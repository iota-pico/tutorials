/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./getNodeInfo.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../iota-pico-lib-browser/node_modules/big-integer/BigInteger.js":
/*!****************************************************************************************!*\
  !*** D:/Workarea/iotaeco/iota-pico-lib-browser/node_modules/big-integer/BigInteger.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var bigInt = (function (undefined) {
    "use strict";

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        LOG_MAX_INT = Math.log(MAX_INT);

    function Integer(v, radix) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 ? parseValue(v) : parseBase(v, radix);
        return parseValue(v);
    }

    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7)
            return [n];
        if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) { // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
                case 0: return 0;
                case 1: return arr[0];
                case 2: return arr[0] + arr[1] * BASE;
                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }

    function trim(v) {
        var i = v.length;
        while (v[--i] === 0);
        v.length = i + 1;
    }

    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;
        while (++i < length) {
            x[i] = 0;
        }
        return x;
    }

    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }

    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum, i;
        for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }

    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }

    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum, i;
        for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    BigInteger.prototype.add = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    function subtract(a, b) { // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i, difference;
        for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for (; i < a_l; i++) {
            r[i] = a[i];
        }
        trim(r);
        return r;
    }

    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a,b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i, difference;
        for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        } return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };

    BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
    };

    function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product, carry, i, a_i, b_j;
        for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product, i;
        for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);

        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);

        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);

        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value, b = n.value,
            sign = this.sign !== n.sign,
            abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) { // a >= 0
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
            if (isPrecise(a.value * this.value)) {
                return new SmallInteger(a.value * this.value);
            }
            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
            if (a.value === 0) return Integer[0];
            if (a.value === 1) return this;
            if (a.value === -1) return this.negate();
            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    function square(a) {
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product, carry, i, a_i, a_j;
        for (i = 0; i < l; i++) {
            a_i = a[i];
            for (var j = 0; j < l; j++) {
                a_j = a[j];
                product = a_i * a_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i = 0; i < l; i++) {
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess, xlen, highx, highy, check;
        while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i, q, remainder, divisor;
        remainder = 0;
        for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
        var value, n = parseValue(v);
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
        }
        if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200)
            value = divMod1(a, b);
        else value = divMod2(a, b);

        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;

    BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
                return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);
        while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };

    BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
    };
    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
    };
    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
    };
    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
    };
    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
    };
    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
    };
    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
    };

    BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
    };

    BigInteger.prototype.isPositive = function () {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
    };

    BigInteger.prototype.isNegative = function () {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
    };

    BigInteger.prototype.isUnit = function () {
        return false;
    };
    SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
    };

    BigInteger.prototype.isZero = function () {
        return false;
    };
    SmallInteger.prototype.isZero = function () {
        return this.value === 0;
    };
    BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        var value = n.value;
        if (value === 0) return false;
        if (value === 1) return true;
        if (value === 2) return this.isEven();
        return this.mod(n).equals(Integer[0]);
    };
    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(25)) return true;
        // we don't know if it's prime: let the other functions figure it out
    }

    BigInteger.prototype.isPrime = function () {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs(),
            nPrev = n.prev();
        var a = [2, 3, 5, 7, 11, 13, 17, 19],
            b = nPrev,
            d, t, i, x;
        while (b.isEven()) b = b.divide(2);
        for (i = 0; i < a.length; i++) {
            x = bigInt(a[i]).modPow(b, n);
            if (x.equals(Integer[1]) || x.equals(nPrev)) continue;
            for (t = true, d = b; t && d.lesser(nPrev) ; d = d.multiply(2)) {
                x = x.square().mod(n);
                if (x.equals(nPrev)) t = false;
            }
            if (t) return false;
        }
        return true;
    };
    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined) return isPrime;
        var n = this.abs();
        var t = iterations === undefined ? 5 : iterations;
        // use the Fermat primality test
        for (var i = 0; i < t; i++) {
            var a = bigInt.randBetween(2, n.minus(2));
            if (!a.modPow(n.prev(), n).isUnit()) return false; // definitely composite
        }
        return true; // large chance of being prime
    };
    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.equals(bigInt.zero)) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.equals(1)) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };

    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };

    BigInteger.prototype.prev = function () {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };

    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
        return ((typeof n === "number" || typeof n === "string") && +Math.abs(n) <= BASE) ||
            (n instanceof BigInteger && n.value.length <= 1);
    }

    BigInteger.prototype.shiftLeft = function (n) {
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        n = +n;
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (n) {
        var remQuo;
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        n = +n;
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
            if (result.isZero()) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }

    BigInteger.prototype.not = function () {
        return this.negate().prev();
    };
    SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) { return a & b; });
    };
    SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) { return a | b; });
    };
    SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) { return a ^ b; });
    };
    SmallInteger.prototype.xor = BigInteger.prototype.xor;

    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) { // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }

    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
            d = Math.min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while (a.isEven()) {
            a = a.divide(roughLOB(a));
        }
        do {
            while (b.isEven()) {
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b; b = a; a = t;
            }
            b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(Math.random() * range));
        var length = range.value.length - 1;
        var result = [], restricted = true;
        for (var i = length; i >= 0; i--) {
            var top = restricted ? range.value[i] : BASE;
            var digit = truncate(Math.random() * top);
            result.unshift(digit);
            if (digit < top) restricted = false;
        }
        result = arrayToSmall(result);
        return low.add(typeof result === "number" ? new SmallInteger(result) : new BigInteger(result, false));
    }
    var parseBase = function (text, base) {
        var length = text.length;
		var i;
		var absBase = Math.abs(base);
		for(var i = 0; i < length; i++) {
			var c = text[i].toLowerCase();
			if(c === "-") continue;
			if(/[a-z0-9]/.test(c)) {
			    if(/[0-9]/.test(c) && +c >= absBase) {
					if(c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
				} else if(c.charCodeAt(0) - 87 >= absBase) {
					throw new Error(c + " is not a valid digit in base " + base + ".");
				}
			}
		}
        if (2 <= base && base <= 36) {
            if (length <= LOG_MAX_INT / Math.log(base)) {
				var result = parseInt(text, base);
				if(isNaN(result)) {
					throw new Error(c + " is not a valid digit in base " + base + ".");
				}
                return new SmallInteger(parseInt(text, base));
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i].toLowerCase(),
                charCode = c.charCodeAt(0);
            if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));
            else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));
            else if (c === "<") {
                var start = i;
                do { i++; } while (text[i] !== ">");
                digits.push(parseValue(text.slice(start + 1, i)));
            }
            else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }

    function stringify(digit) {
        var v = digit.value;
        if (typeof v === "number") v = [v];
        if (v.length === 1 && v[0] <= 35) {
            return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(v[0]);
        }
        return "<" + v + ">";
    }
    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return "0";
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return "0";
            if (n.isNegative()) return new Array(1 - n).join("10");
            return "1" + new Array(+n).join("01");
        }
        var minusSign = "";
        if (n.isNegative() && base.isPositive()) {
            minusSign = "-";
            n = n.abs();
        }
        if (base.equals(1)) {
            if (n.isZero()) return "0";
            return minusSign + new Array(+n + 1).join(1);
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(stringify(digit));
        }
        out.push(stringify(left));
        return minusSign + out.reverse().join("");
    }

    BigInteger.prototype.toString = function (radix) {
        if (radix === undefined) radix = 10;
        if (radix !== 10) return toBase(this, radix);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };

    SmallInteger.prototype.toString = function (radix) {
        if (radix === undefined) radix = 10;
        if (radix != 10) return toBase(this, radix);
        return String(this.value);
    };
    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() { return this.toString(); }

    BigInteger.prototype.valueOf = function () {
        return +this.toString();
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;

    function parseStringValue(v) {
            if (isPrecise(+v)) {
                var x = +v;
                if (x === truncate(x))
                    return new SmallInteger(x);
                throw "Invalid integer: " + v;
            }
            var sign = v[0] === "-";
            if (sign) v = v.slice(1);
            var split = v.split(/e/i);
            if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
            if (split.length === 2) {
                var exp = split[1];
                if (exp[0] === "+") exp = exp.slice(1);
                exp = +exp;
                if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
                var text = split[0];
                var decimalPlace = text.indexOf(".");
                if (decimalPlace >= 0) {
                    exp -= text.length - decimalPlace - 1;
                    text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
                }
                if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
                text += (new Array(exp + 1)).join("0");
                v = text;
            }
            var isValid = /^([0-9][0-9]*)$/.test(v);
            if (!isValid) throw new Error("Invalid integer: " + v);
            var r = [], max = v.length, l = LOG_BASE, min = max - l;
            while (max > 0) {
                r.push(+v.slice(min, max));
                min -= l;
                if (min < 0) min = 0;
                max -= l;
            }
            trim(r);
            return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }

    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
        Integer[i] = new SmallInteger(i);
        if (i > 0) Integer[-i] = new SmallInteger(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger; };
    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
})();

// Node.js check
if (typeof module !== "undefined" && module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}

//amd check
if ( true ) {
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
    return bigInt;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../iota-pico-tutorials/using-library/browser/getNodeInfoWebpack/node_modules/webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../../../../iota-pico-lib-browser/pkg/iota-pico-lib-browser.js":
/*!******************************************************************************!*\
  !*** D:/Workarea/iotaeco/iota-pico-lib-browser/pkg/iota-pico-lib-browser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! big-integer */ "../../../../iota-pico-lib-browser/node_modules/big-integer/BigInteger.js"));
	else {}
})(window, function(__WEBPACK_EXTERNAL_MODULE_big_integer__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./pkg/bootstrap.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../iota-pico-api/dist/client/apiClient.js":
/*!*************************************************!*\
  !*** ../iota-pico-api/dist/client/apiClient.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-api/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar apiError_1 = __webpack_require__(/*! ../error/apiError */ \"../iota-pico-api/dist/error/apiError.js\");\n/**\r\n * Default implementation of an api client.\r\n */\n\n\nvar ApiClient =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create an instance of ApiClient.\r\n   * @param networkClient The network client to communicate through.\r\n   * @param apiVersion The API version to send with the requests\r\n   * @param additionalHeaders Extra headers to send with the requests.\r\n   */\n  function ApiClient(networkClient) {\n    var apiVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"1\";\n    var additionalHeaders = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ApiClient);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(networkClient)) {\n      throw new apiError_1.ApiError(\"The networkClient must be defined\");\n    }\n\n    if (stringHelper_1.StringHelper.isEmpty(apiVersion)) {\n      throw new apiError_1.ApiError(\"The apiVersion must not be empty\");\n    }\n\n    this._networkClient = networkClient;\n    this._apiVersion = apiVersion;\n    this._additionalHeaders = additionalHeaders;\n  }\n  /**\r\n   * Returns information about your node.\r\n   * @returns Promise which resolves to the getNodeInfo response object or rejects with error.\r\n   */\n\n\n  _createClass(ApiClient, [{\n    key: \"getNodeInfo\",\n    value: function () {\n      var _getNodeInfo = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.sendCommand(\"getNodeInfo\", {}));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function getNodeInfo() {\n        return _getNodeInfo.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Returns the set of neighbors you are connected with, as well as their activity count.\r\n     * The activity counter is reset after restarting IRI.\r\n     * @returns Promise which resolves to the getNeighbors response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getNeighbors\",\n    value: function () {\n      var _getNeighbors = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.sendCommand(\"getNeighbors\", {}));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function getNeighbors() {\n        return _getNeighbors.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Add a list of neighbors to your node. It should be noted that this is only temporary,\r\n     * and the added neighbors will be removed from your set of neighbors after you relaunch IRI.\r\n     * @returns Promise which resolves to the addNeighbors response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"addNeighbors\",\n    value: function () {\n      var _addNeighbors = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(request) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.uris)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.uris must not be empty\");\n\n              case 4:\n                return _context3.abrupt(\"return\", this.sendCommand(\"addNeighbors\", request));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function addNeighbors(_x) {\n        return _addNeighbors.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Removes a list of neighbors from your node. This is only temporary, and if you have your\r\n     * neighbors added via the command line, they will be retained after you restart your node.\r\n     * @returns Promise which resolves to the removeNeighbors response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"removeNeighbors\",\n    value: function () {\n      var _removeNeighbors = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(request) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.uris)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.uris must not be empty\");\n\n              case 4:\n                return _context4.abrupt(\"return\", this.sendCommand(\"removeNeighbors\", request));\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function removeNeighbors(_x2) {\n        return _removeNeighbors.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Returns the list of tips.\r\n     * @returns Promise which resolves to the getTips response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getTips\",\n    value: function () {\n      var _getTips = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.sendCommand(\"getTips\", {}));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      return function getTips() {\n        return _getTips.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Find the transactions which match the specified input and return. All input values are lists,\r\n     * for which a list of return values (transaction hashes), in the same order, is returned for all\r\n     * individual elements. The input fields can either be bundles, addresses, tags or approvees.\r\n     * Using multiple of these input fields returns the intersection of the values.\r\n     * @returns Promise which resolves to the findTransactions response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"findTransactions\",\n    value: function () {\n      var _findTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(request) {\n        var bundlesEmpty, addressesEmpty, tagsEmpty, approveesEmpty;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                bundlesEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.bundles);\n                addressesEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.addresses);\n                tagsEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.tags);\n                approveesEmpty = arrayHelper_1.ArrayHelper.isEmpty(request.approvees);\n\n                if (!(bundlesEmpty && addressesEmpty && tagsEmpty && approveesEmpty)) {\n                  _context6.next = 8;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"One of the bundle, addresses, tags or approvees must not be empty\");\n\n              case 8:\n                return _context6.abrupt(\"return\", this.sendCommand(\"findTransactions\", request));\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      return function findTransactions(_x3) {\n        return _findTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Returns the raw transaction data (trytes) of a specific transaction.\r\n     * These trytes can then be easily converted into the actual transaction object.\r\n     * @returns Promise which resolves to the findTransactions response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getTrytes\",\n    value: function () {\n      var _getTrytes = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(request) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.hashes)) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.hashes must not be empty\");\n\n              case 4:\n                return _context7.abrupt(\"return\", this.sendCommand(\"getTrytes\", request));\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      return function getTrytes(_x4) {\n        return _getTrytes.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get the inclusion states of a set of transactions. This is for determining if a transaction\r\n     * was accepted and confirmed by the network or not. You can search for multiple tips (and thus,\r\n     * milestones) to get past inclusion states of transactions.\r\n     * @returns Promise which resolves to the getInclusionStates response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getInclusionStates\",\n    value: function () {\n      var _getInclusionStates = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(request) {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.transactions)) {\n                  _context8.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.transactions must not be empty\");\n\n              case 4:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.tips)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.tips must not be empty\");\n\n              case 6:\n                return _context8.abrupt(\"return\", this.sendCommand(\"getInclusionStates\", request));\n\n              case 7:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      return function getInclusionStates(_x5) {\n        return _getInclusionStates.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Returns the confirmed balance which a list of addresses have at the latest confirmed milestone.\r\n     * In addition to the balances, it also returns the milestone as well as the index with which the\r\n     * confirmed balance was determined. The balances is returned as a list in the same order as the\r\n     * addresses were provided as input.\r\n     * @param request The getBalances request object.\r\n     * @returns Promise which resolves to the getBalances response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getBalances\",\n    value: function () {\n      var _getBalances = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9(request) {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.addresses)) {\n                  _context9.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.addresses must not be empty\");\n\n              case 4:\n                if (numberHelper_1.NumberHelper.isInteger(request.threshold)) {\n                  _context9.next = 6;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.threshold must be a valid number\");\n\n              case 6:\n                return _context9.abrupt(\"return\", this.sendCommand(\"getBalances\", request));\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      return function getBalances(_x6) {\n        return _getBalances.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Tip selection which returns trunkTransaction and branchTransaction. The input value is depth,\r\n     * which basically determines how many bundles to go back to for finding the transactions to approve.\r\n     * The higher your depth value, the more \"babysitting\" you do for the network (as you have to confirm more transactions).\r\n     * @param request The getTransactionsToApprove request object.\r\n     * @returns Promise which resolves to the getTransactionsToApprove response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getTransactionsToApprove\",\n    value: function () {\n      var _getTransactionsToApprove = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(request) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (numberHelper_1.NumberHelper.isInteger(request.depth)) {\n                  _context10.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.depth must be a valid number\");\n\n              case 4:\n                if (!(!objectHelper_1.ObjectHelper.isEmpty(request.reference) && stringHelper_1.StringHelper.isEmpty(request.reference))) {\n                  _context10.next = 6;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.reference must be a non empty string\");\n\n              case 6:\n                if (!(!objectHelper_1.ObjectHelper.isEmpty(request.numWalks) && !numberHelper_1.NumberHelper.isInteger(request.numWalks))) {\n                  _context10.next = 8;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.numWalks must be a valid number\");\n\n              case 8:\n                return _context10.abrupt(\"return\", this.sendCommand(\"getTransactionsToApprove\", request));\n\n              case 9:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      return function getTransactionsToApprove(_x7) {\n        return _getTransactionsToApprove.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Attaches the specified transactions (trytes) to the Tangle by doing Proof of Work. You need to supply\r\n     * branchTransaction as well as trunkTransaction (basically the tips which you're going to validate and\r\n     * reference with this transaction) - both of which you'll get through the getTransactionsToApprove API call.\r\n     * @param request The attachToTangle request object.\r\n     * @returns Promise which resolves to the attachToTangle response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"attachToTangle\",\n    value: function () {\n      var _attachToTangle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(request) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!stringHelper_1.StringHelper.isEmpty(request.trunkTransaction)) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.trunkTransaction must not be empty\");\n\n              case 4:\n                if (!stringHelper_1.StringHelper.isEmpty(request.branchTransaction)) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.branchTransaction must not be empty\");\n\n              case 6:\n                if (numberHelper_1.NumberHelper.isInteger(request.minWeightMagnitude)) {\n                  _context11.next = 8;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.minWeightMagnitude must be a valid number\");\n\n              case 8:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.trytes)) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.trytes must not be empty\");\n\n              case 10:\n                return _context11.abrupt(\"return\", this.sendCommand(\"attachToTangle\", request));\n\n              case 11:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      return function attachToTangle(_x8) {\n        return _attachToTangle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Interrupts and completely aborts the attachToTangle process\r\n     * @returns Promise which resolves with empty response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"interruptAttachingToTangle\",\n    value: function () {\n      var _interruptAttachingToTangle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee12() {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                return _context12.abrupt(\"return\", this.sendCommand(\"interruptAttachingToTangle\", {}));\n\n              case 1:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      return function interruptAttachingToTangle() {\n        return _interruptAttachingToTangle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Broadcast a list of transactions to all neighbors. The input trytes for this call are provided by attachToTangle.\r\n     * @param request The broadcastTransactions request object.\r\n     * @returns Promise which resolves with empty response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"broadcastTransactions\",\n    value: function () {\n      var _broadcastTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee13(request) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context13.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.trytes)) {\n                  _context13.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.trytes must not be empty\");\n\n              case 4:\n                return _context13.abrupt(\"return\", this.sendCommand(\"broadcastTransactions\", request));\n\n              case 5:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      return function broadcastTransactions(_x9) {\n        return _broadcastTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Store transactions into the local storage. The trytes to be used for this call are returned by attachToTangle.\r\n     * @param request The storeTransactions request object.\r\n     * @returns Promise which resolves with empty response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"storeTransactions\",\n    value: function () {\n      var _storeTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee14(request) {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context14.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.trytes)) {\n                  _context14.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.trytes must not be empty\");\n\n              case 4:\n                return _context14.abrupt(\"return\", this.sendCommand(\"storeTransactions\", request));\n\n              case 5:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      return function storeTransactions(_x10) {\n        return _storeTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get transactions with missing references.\r\n     * @param request The getMissingTransactions request object.\r\n     * @returns Promise which resolves to the getMissingTransactions response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"getMissingTransactions\",\n    value: function () {\n      var _getMissingTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee15() {\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                return _context15.abrupt(\"return\", this.sendCommand(\"getMissingTransactions\", {}));\n\n              case 1:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      return function getMissingTransactions() {\n        return _getMissingTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Check the consistency of tail hashes.\r\n     * @param request The checkConsistency request object.\r\n     * @returns Promise which resolves to the checkConsistency response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"checkConsistency\",\n    value: function () {\n      var _checkConsistency = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee16(request) {\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context16.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.tails)) {\n                  _context16.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.tails must not be empty\");\n\n              case 4:\n                return _context16.abrupt(\"return\", this.sendCommand(\"checkConsistency\", request));\n\n              case 5:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      return function checkConsistency(_x11) {\n        return _checkConsistency.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Have the requested addresses been spent from already.\r\n     * @param request The wereAddressesSpentFrom request object.\r\n     * @returns Promise which resolves to the wereAddressesSpentFrom response object or rejects with error.\r\n     */\n\n  }, {\n    key: \"wereAddressesSpentFrom\",\n    value: function () {\n      var _wereAddressesSpentFrom = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee17(request) {\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (!objectHelper_1.ObjectHelper.isEmpty(request)) {\n                  _context17.next = 2;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request must be defined\");\n\n              case 2:\n                if (!arrayHelper_1.ArrayHelper.isEmpty(request.addresses)) {\n                  _context17.next = 4;\n                  break;\n                }\n\n                throw new apiError_1.ApiError(\"The request.addresses must not be empty\");\n\n              case 4:\n                return _context17.abrupt(\"return\", this.sendCommand(\"wereAddressesSpentFrom\", request));\n\n              case 5:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      return function wereAddressesSpentFrom(_x12) {\n        return _wereAddressesSpentFrom.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"sendCommand\",\n    value: function () {\n      var _sendCommand = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee18(command, request) {\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                Object.defineProperty(request, \"command\", {\n                  value: command,\n                  enumerable: true\n                });\n                return _context18.abrupt(\"return\", this._networkClient.postJson(request, undefined, this.createHeaders()).catch(function (err) {\n                  if (err.additional && err.additional.errorResponse) {\n                    try {\n                      var apiError = JSON.parse(err.additional.errorResponse);\n\n                      if (apiError.error) {\n                        delete err.additional.errorResponse;\n                        err.additional.apiError = apiError.error;\n                      } else if (apiError.exception) {\n                        delete err.additional.errorResponse;\n                        err.additional.apiError = apiError.exception;\n                      }\n                    } catch (e) {}\n                  }\n\n                  throw err;\n                }));\n\n              case 2:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      return function sendCommand(_x13, _x14) {\n        return _sendCommand.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"createHeaders\",\n    value: function createHeaders() {\n      var headers = this._additionalHeaders || {};\n      headers[\"X-IOTA-API-Version\"] = this._apiVersion;\n      return headers;\n    }\n  }]);\n\n  return ApiClient;\n}();\n\nexports.ApiClient = ApiClient;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/dist/client/apiClient.js?");

/***/ }),

/***/ "../iota-pico-api/dist/error/apiError.js":
/*!***********************************************!*\
  !*** ../iota-pico-api/dist/error/apiError.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n/**\r\n * An api implementation of an error.\r\n */\n\n\nvar ApiError =\n/*#__PURE__*/\nfunction (_coreError_1$CoreErro) {\n  _inherits(ApiError, _coreError_1$CoreErro);\n\n  function ApiError() {\n    _classCallCheck(this, ApiError);\n\n    return _possibleConstructorReturn(this, (ApiError.__proto__ || Object.getPrototypeOf(ApiError)).apply(this, arguments));\n  }\n\n  return ApiError;\n}(coreError_1.CoreError);\n\nexports.ApiError = ApiError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/dist/error/apiError.js?");

/***/ }),

/***/ "../iota-pico-api/dist/index.js":
/*!**************************************!*\
  !*** ../iota-pico-api/dist/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./client/apiClient */ \"../iota-pico-api/dist/client/apiClient.js\"));\n\n__export(__webpack_require__(/*! ./error/apiError */ \"../iota-pico-api/dist/error/apiError.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/dist/index.js?");

/***/ }),

/***/ "../iota-pico-api/node_modules/@babel/runtime/regenerator/index.js":
/*!*************************************************************************!*\
  !*** ../iota-pico-api/node_modules/@babel/runtime/regenerator/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-api/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-api/node_modules/regenerator-runtime/runtime-module.js":
/*!***************************************************************************!*\
  !*** ../iota-pico-api/node_modules/regenerator-runtime/runtime-module.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-api/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-api/node_modules/regenerator-runtime/runtime.js":
/*!********************************************************************!*\
  !*** ../iota-pico-api/node_modules/regenerator-runtime/runtime.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-api/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-business/dist/error/businessError.js":
/*!*********************************************************!*\
  !*** ../iota-pico-business/dist/error/businessError.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n/**\r\n * A business implementation of an error.\r\n */\n\n\nvar BusinessError =\n/*#__PURE__*/\nfunction (_coreError_1$CoreErro) {\n  _inherits(BusinessError, _coreError_1$CoreErro);\n\n  function BusinessError() {\n    _classCallCheck(this, BusinessError);\n\n    return _possibleConstructorReturn(this, (BusinessError.__proto__ || Object.getPrototypeOf(BusinessError)).apply(this, arguments));\n  }\n\n  return BusinessError;\n}(coreError_1.CoreError);\n\nexports.BusinessError = BusinessError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/error/businessError.js?");

/***/ }),

/***/ "../iota-pico-business/dist/helpers/bundleHelper.js":
/*!**********************************************************!*\
  !*** ../iota-pico-business/dist/helpers/bundleHelper.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar bundle_1 = __webpack_require__(/*! @iota-pico/data/dist/data/bundle */ \"../iota-pico-data/dist/data/bundle.js\");\n\nvar hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ \"../iota-pico-data/dist/data/transaction.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar tryteNumber_1 = __webpack_require__(/*! ../../../iota-pico-data/dist/data/tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\");\n\nvar hmacCurl_1 = __webpack_require__(/*! ../sign/hmacCurl */ \"../iota-pico-business/dist/sign/hmacCurl.js\");\n\nvar signing_1 = __webpack_require__(/*! ../sign/signing */ \"../iota-pico-business/dist/sign/signing.js\");\n/**\r\n * Helper class for signing bundles.\r\n * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js\r\n */\n\n\nvar BundleHelper =\n/*#__PURE__*/\nfunction () {\n  function BundleHelper() {\n    _classCallCheck(this, BundleHelper);\n  }\n\n  _createClass(BundleHelper, null, [{\n    key: \"isValid\",\n\n    /**\r\n     * Is the bundle valid.\r\n     * @param bundle The bundle to check for validity.\r\n     * @returns True if the bundle is valid.\r\n     */\n    value: function isValid(bundle) {\n      var isValid = false;\n\n      if (objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle) && arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {\n        var totalSum = 0;\n        var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n        kerl.initialize(); // Prepare for signature validation\n\n        var signaturesToValidate = [];\n        isValid = true;\n\n        for (var t = 0; t < bundle.transactions.length && isValid; t++) {\n          var bundleTx = bundle.transactions[t];\n          totalSum += bundleTx.value.toNumber(); // currentIndex has to be equal to the index in the array\n\n          if (bundleTx.currentIndex.toNumber() !== t) {\n            isValid = false;\n          } else {\n            // Get the transaction trytes\n            var thisTxTrytes = bundleTx.toTrytes(); // Absorb bundle hash + value + timestamp + lastIndex + currentIndex trytes.\n\n            var thisTxTrits = trits_1.Trits.fromTrytes(thisTxTrytes.sub(signatureMessageFragment_1.SignatureMessageFragment.LENGTH, 162)).toArray();\n            kerl.absorb(thisTxTrits, 0, thisTxTrits.length); // Check if input transaction\n\n            if (bundleTx.value.toNumber() < 0) {\n              var newSignatureToValidate = {\n                address: bundleTx.address,\n                signatureMessageFragments: [bundleTx.signatureMessageFragment]\n              }; // Find the subsequent txs with the remaining signature fragment\n\n              for (var i = t; i < bundle.transactions.length - 1; i++) {\n                var newBundleTx = bundle.transactions[i + 1]; // Check if new tx is part of the signature fragment\n\n                if (newBundleTx.address.toTrytes().toString() === bundleTx.address.toTrytes().toString() && newBundleTx.value.toNumber() === 0) {\n                  newSignatureToValidate.signatureMessageFragments.push(newBundleTx.signatureMessageFragment);\n                }\n              }\n\n              signaturesToValidate.push(newSignatureToValidate);\n            }\n          }\n        } // Check for total sum, if not equal 0 return error\n\n\n        if (totalSum !== 0) {\n          isValid = false;\n        } else {\n          // get the bundle hash from the bundle transactions\n          var bundleFromTxs = new Int8Array(kerl.getConstants().HASH_LENGTH);\n          kerl.squeeze(bundleFromTxs, 0, bundleFromTxs.length);\n          var bundleFromTxsTrytes = trits_1.Trits.fromArray(bundleFromTxs).toTrytes().toString(); // Check if bundle hash is the same as returned by tx object\n\n          var bundleHash = bundle.transactions[0].bundle;\n\n          if (bundleFromTxsTrytes !== bundleHash.toTrytes().toString()) {\n            isValid = false;\n          } else {\n            // Last tx in the bundle should have currentIndex === lastIndex\n            if (bundle.transactions[bundle.transactions.length - 1].currentIndex.toNumber() !== bundle.transactions[bundle.transactions.length - 1].lastIndex.toNumber()) {\n              isValid = false;\n            } else {\n              // Validate the signatures\n              for (var _i = 0; _i < signaturesToValidate.length && isValid; _i++) {\n                var isValidSignature = signing_1.Signing.validateSignatures(signaturesToValidate[_i].address, signaturesToValidate[_i].signatureMessageFragments, bundleHash);\n\n                if (!isValidSignature) {\n                  isValid = false;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return isValid;\n    }\n    /**\r\n     * Validate signatures for each of the co-signers in the multi-signature to independently verify that a generated\r\n     * transaction with the corresponding signatures of the co-signers is valid.\r\n     * @param signedBundle The signed bundle to check the signatures.\r\n     * @param inputAddress The address used to initiate the transfer.\r\n     * @returns True is the signatures are valid.\r\n     */\n\n  }, {\n    key: \"validateSignatures\",\n    value: function validateSignatures(signedBundle, inputAddress) {\n      var isValid = false;\n\n      if (objectHelper_1.ObjectHelper.isType(signedBundle, bundle_1.Bundle) && arrayHelper_1.ArrayHelper.isTyped(signedBundle.transactions, transaction_1.Transaction) && objectHelper_1.ObjectHelper.isType(inputAddress, address_1.Address)) {\n        var bundleHash;\n        var signatureFragments = [];\n        var inputAddressTrytes = inputAddress.toTrytes().toString();\n\n        for (var i = 0; i < signedBundle.transactions.length; i++) {\n          if (signedBundle.transactions[i].address.toTrytes().toString() === inputAddressTrytes) {\n            bundleHash = signedBundle.transactions[i].bundle; // if we reached remainder bundle\n\n            if (signedBundle.transactions[i].signatureMessageFragment.toTrytes().toString() === signatureMessageFragment_1.SignatureMessageFragment.EMPTY.toTrytes().toString()) {\n              break;\n            }\n\n            signatureFragments.push(signedBundle.transactions[i].signatureMessageFragment);\n          }\n        }\n\n        if (bundleHash) {\n          isValid = signing_1.Signing.validateSignatures(inputAddress, signatureFragments, bundleHash);\n        }\n      }\n\n      return isValid;\n    }\n  }, {\n    key: \"prepareBundle\",\n    value: function prepareBundle(timeService, transfers) {\n      var bundle = new bundle_1.Bundle();\n      var lastTag;\n      var totalValue = 0;\n      var signatureMessageFragments = []; //  Iterate over all transfers, get totalValue\n      //  and prepare the Messages, message and tag\n\n      for (var i = 0; i < transfers.length; i++) {\n        var signatureMessageLength = 1; // If message longer than 2187 trytes, increase signatureMessageLength (add 2nd transaction)\n\n        var messageString = transfers[i].message.toString();\n\n        if (messageString.length > signatureMessageFragment_1.SignatureMessageFragment.LENGTH) {\n          // Get total length, message / maxLength (2187 trytes)\n          signatureMessageLength += Math.floor(messageString.length / signatureMessageFragment_1.SignatureMessageFragment.LENGTH);\n          var msgCopy = messageString; // While there is still a message, copy it\n\n          while (msgCopy) {\n            var fragment = msgCopy.slice(0, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);\n            msgCopy = msgCopy.slice(signatureMessageFragment_1.SignatureMessageFragment.LENGTH, msgCopy.length); // Pad remainder of fragment\n\n            for (var j = 0; fragment.length < signatureMessageFragment_1.SignatureMessageFragment.LENGTH; j++) {\n              fragment += \"9\";\n            }\n\n            signatureMessageFragments.push(signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(fragment)));\n          }\n        } else {\n          // Else, get single fragment with 2187 of 9's trytes\n          var _fragment = \"\";\n\n          if (messageString) {\n            _fragment = messageString.slice(0, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);\n          }\n\n          for (var _j = 0; _fragment.length < signatureMessageFragment_1.SignatureMessageFragment.LENGTH; _j++) {\n            _fragment += \"9\";\n          }\n\n          signatureMessageFragments.push(signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(_fragment)));\n        } // get current timestamp in seconds\n\n\n        var timestamp = Math.floor(timeService.msSinceEpoch() / 1000);\n        lastTag = transfers[i].tag; // Add first entries to the bundle\n\n        bundle.addTransactions(signatureMessageLength, transfers[i].address, transfers[i].value, transfers[i].tag, timestamp); // Sum up total value\n\n        totalValue += transfers[i].value;\n      }\n\n      return {\n        bundle: bundle,\n        totalValue: totalValue,\n        lastTag: lastTag,\n        signatureMessageFragments: signatureMessageFragments\n      };\n    }\n    /* @internal */\n\n  }, {\n    key: \"signInputs\",\n    value: function signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC) {\n      BundleHelper.finalizeBundle(bundle);\n      bundle.addSignatureMessageFragments(signatureMessageFragments); //  Here we do the actual signing of the inputs\n      //  Iterate over all bundle transactions, find the inputs\n      //  Get the corresponding private key and calculate the signatureMessageFragment\n\n      for (var i = 0; i < bundle.transactions.length; i++) {\n        if (bundle.transactions[i].value.toNumber() < 0) {\n          var addressTrytes = bundle.transactions[i].address.toTrytes().toString(); // Get the corresponding keyIndex and security of the address\n\n          var keyIndex = void 0;\n          var keySecurity = void 0;\n\n          for (var k = 0; k < inputs.length; k++) {\n            if (inputs[k].address.toTrytes().toString() === addressTrytes) {\n              keyIndex = inputs[k].keyIndex;\n              keySecurity = inputs[k].security ? inputs[k].security : transferOptions.security;\n              break;\n            }\n          } // Get corresponding private key of address\n\n\n          var key = signing_1.Signing.key(seed, keyIndex, keySecurity);\n          BundleHelper.signTransactions(bundle, i, 0, key, addressTrytes, keySecurity);\n        }\n      }\n\n      if (addedHMAC) {\n        var hmac = new hmacCurl_1.HmacCurl(transferOptions.hmacKey);\n        hmac.addHMAC(bundle);\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"signTransactions\",\n    value: function signTransactions(bundle, index, firstUnsignedIndex, keyTrits, addressTrytes, security) {\n      var bundleHash = bundle.transactions[index].bundle; //  Get the normalized bundle hash\n\n      var normalizedBundleHash = BundleHelper.normalizedHash(bundleHash);\n      var normalizedBundleFragments = []; // Split hash into 3 fragments\n\n      for (var l = 0; l < 3; l++) {\n        normalizedBundleFragments[l] = normalizedBundleHash.slice(l * 27, (l + 1) * 27);\n      } //  First 6561 trits for the firstFragment\n\n\n      var firstFragment = keyTrits.slice(0, 6561); //  First bundle fragment uses the first 27 trytes\n\n      var firstBundleFragment = normalizedBundleFragments[firstUnsignedIndex]; //  Calculate the new signatureMessageFragment with the first bundle fragment\n\n      var firstSignedFragment = BundleHelper.signatureMessageFragment(firstBundleFragment, firstFragment); //  Convert signature to trytes and assign the new signatureMessageFragment\n\n      bundle.transactions[index].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trits_1.Trits.fromArray(firstSignedFragment).toTrytes()); // if user chooses higher than 27-tryte security\n      // for each security level, add an additional signature\n\n      for (var j = 1; j < security; j++) {\n        //  Because the signature is > 2187 trytes, we need to\n        //  find the subsequent transaction to add the remainder of the signature\n        //  Same address as well as value = 0 (as we already spent the input)\n        if (bundle.transactions[index + j].address.toTrytes().toString() === addressTrytes && bundle.transactions[index + j].value.toNumber() === 0) {\n          // Use the next 6561 trits\n          var nextFragment = keyTrits.slice(6561 * j, (j + 1) * 6561);\n          var nextBundleFragment = normalizedBundleFragments[j]; //  Calculate the new signature\n\n          var nextSignedFragment = BundleHelper.signatureMessageFragment(nextBundleFragment, nextFragment); //  Convert signature to trytes and assign it again to this bundle entry\n\n          bundle.transactions[index + j].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trits_1.Trits.fromArray(nextSignedFragment).toTrytes());\n        }\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"finalizeBundle\",\n    value: function finalizeBundle(bundle) {\n      if (bundle.transactions.length > 0) {\n        var validBundle = false;\n\n        while (!validBundle) {\n          var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n          kerl.initialize();\n\n          for (var i = 0; i < bundle.transactions.length; i++) {\n            bundle.transactions[i].currentIndex = tryteNumber_1.TryteNumber.fromNumber(i);\n            bundle.transactions[i].lastIndex = tryteNumber_1.TryteNumber.fromNumber(bundle.transactions.length - 1);\n            var bundleEssence = trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(bundle.transactions[i].address.toTrytes().toString() + bundle.transactions[i].value.toTrytes().toString() + transaction_1.Transaction.CHECK_VALUE + bundle.transactions[i].obsoleteTag.toTrytes().toString() + bundle.transactions[i].timestamp.toTrytes().toString() + bundle.transactions[i].currentIndex.toTrytes().toString() + bundle.transactions[i].lastIndex.toTrytes().toString())).toArray();\n            kerl.absorb(bundleEssence, 0, bundleEssence.length);\n          }\n\n          var hashTrits = new Int8Array(kerl.getConstants().HASH_LENGTH);\n          kerl.squeeze(hashTrits, 0, hashTrits.length);\n          var hash = hash_1.Hash.fromTrytes(trits_1.Trits.fromArray(hashTrits).toTrytes());\n\n          for (var _i2 = 0; _i2 < bundle.transactions.length; _i2++) {\n            bundle.transactions[_i2].bundle = hash;\n          }\n\n          var normalizedHash = this.normalizedHash(hash);\n\n          if (normalizedHash.indexOf(13\n          /* = M */\n          ) !== -1) {\n            // Insecure bundle. Increment Tag and recompute bundle hash.\n            var increasedTag = trits_1.Trits.add(trits_1.Trits.fromTrytes(bundle.transactions[0].obsoleteTag.toTrytes()), trits_1.Trits.fromNumberArray([1]));\n            bundle.transactions[0].obsoleteTag = tag_1.Tag.fromTrytes(increasedTag.toTrytes());\n          } else {\n            validBundle = true;\n          }\n        }\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"normalizedHash\",\n    value: function normalizedHash(bundleHash) {\n      var normalizedBundle = new Int8Array(4 * 27);\n      var hashString = bundleHash.toTrytes().toString();\n\n      for (var i = 0; i < 3; i++) {\n        var sum = 0;\n\n        for (var j = 0; j < 27; j++) {\n          var hashChar = hashString.charAt(i * 27 + j);\n          var val = trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(hashChar)).toNumber();\n          normalizedBundle[i * 27 + j] = val;\n          sum += val;\n        }\n\n        if (sum >= 0) {\n          while (sum-- > 0) {\n            for (var _j2 = 0; _j2 < 27; _j2++) {\n              if (normalizedBundle[i * 27 + _j2] > -13) {\n                normalizedBundle[i * 27 + _j2]--;\n                break;\n              }\n            }\n          }\n        } else {\n          while (sum++ < 0) {\n            for (var _j3 = 0; _j3 < 27; _j3++) {\n              if (normalizedBundle[i * 27 + _j3] < 13) {\n                normalizedBundle[i * 27 + _j3]++;\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      return normalizedBundle;\n    }\n    /* @internal */\n\n  }, {\n    key: \"digest\",\n    value: function digest(normalizedBundleFragment, signatureMessageFragmentTrits) {\n      var buffer;\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n\n      for (var i = 0; i < 27; i++) {\n        buffer = new Int8Array(signatureMessageFragmentTrits.slice(i * 243, (i + 1) * 243));\n\n        for (var j = normalizedBundleFragment[i] + 13; j-- > 0;) {\n          var jKerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n          jKerl.initialize();\n          jKerl.absorb(buffer, 0, buffer.length);\n          jKerl.squeeze(buffer, 0, jKerl.getConstants().HASH_LENGTH);\n        }\n\n        kerl.absorb(buffer, 0, buffer.length);\n      }\n\n      kerl.squeeze(buffer, 0, kerl.getConstants().HASH_LENGTH);\n      return buffer;\n    }\n    /* @internal */\n\n  }, {\n    key: \"address\",\n    value: function address(digests) {\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n      kerl.absorb(digests, 0, digests.length);\n      var addressTrits = new Int8Array(kerl.getConstants().HASH_LENGTH);\n      kerl.squeeze(addressTrits, 0, addressTrits.length);\n      return addressTrits;\n    }\n    /* @internal */\n\n  }, {\n    key: \"transactionHash\",\n    value: function transactionHash(transaction) {\n      var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\");\n      var transactionTrits = trits_1.Trits.fromTrytes(transaction.toTrytes()).toArray();\n      curl.initialize();\n      curl.absorb(transactionTrits, 0, transactionTrits.length);\n      var hashTrits = new Int8Array(curl.getConstants().HASH_LENGTH);\n      curl.squeeze(hashTrits, 0, hashTrits.length);\n      return hash_1.Hash.fromTrytes(trits_1.Trits.fromArray(hashTrits).toTrytes());\n    }\n    /* @internal */\n\n  }, {\n    key: \"signatureMessageFragment\",\n    value: function signatureMessageFragment(normalizedBundleFragment, keyFragment) {\n      var signatureMessageFragment = keyFragment.slice();\n      var hash;\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      var hashLength = kerl.getConstants().HASH_LENGTH;\n\n      for (var i = 0; i < 27; i++) {\n        hash = signatureMessageFragment.slice(i * hashLength, (i + 1) * hashLength);\n\n        for (var j = 0; j < 13 - normalizedBundleFragment[i]; j++) {\n          kerl.initialize();\n          kerl.reset();\n          kerl.absorb(hash, 0, hashLength);\n          kerl.squeeze(hash, 0, hashLength);\n        }\n\n        for (var _j4 = 0; _j4 < hashLength; _j4++) {\n          signatureMessageFragment[i * hashLength + _j4] = hash[_j4];\n        }\n      }\n\n      return signatureMessageFragment;\n    }\n  }]);\n\n  return BundleHelper;\n}();\n\nexports.BundleHelper = BundleHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/helpers/bundleHelper.js?");

/***/ }),

/***/ "../iota-pico-business/dist/index.js":
/*!*******************************************!*\
  !*** ../iota-pico-business/dist/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./error/businessError */ \"../iota-pico-business/dist/error/businessError.js\"));\n\n__export(__webpack_require__(/*! ./helpers/bundleHelper */ \"../iota-pico-business/dist/helpers/bundleHelper.js\"));\n\n__export(__webpack_require__(/*! ./multiSig/multiSigAddress */ \"../iota-pico-business/dist/multiSig/multiSigAddress.js\"));\n\n__export(__webpack_require__(/*! ./multiSig/multiSigClient */ \"../iota-pico-business/dist/multiSig/multiSigClient.js\"));\n\n__export(__webpack_require__(/*! ./sign/signing */ \"../iota-pico-business/dist/sign/signing.js\"));\n\n__export(__webpack_require__(/*! ./sign/hmacCurl */ \"../iota-pico-business/dist/sign/hmacCurl.js\"));\n\n__export(__webpack_require__(/*! ./transactions/transactionClient */ \"../iota-pico-business/dist/transactions/transactionClient.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/index.js?");

/***/ }),

/***/ "../iota-pico-business/dist/multiSig/multiSigAddress.js":
/*!**************************************************************!*\
  !*** ../iota-pico-business/dist/multiSig/multiSigAddress.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar businessError_1 = __webpack_require__(/*! ../error/businessError */ \"../iota-pico-business/dist/error/businessError.js\");\n/**\r\n * Address using multiple signatures.\r\n */\n\n\nvar MultiSigAddress =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of the MultiSigAddress.\r\n   */\n  function MultiSigAddress() {\n    _classCallCheck(this, MultiSigAddress);\n\n    this._kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n    this._hashLength = this._kerl.getConstants().HASH_LENGTH;\n\n    this._kerl.initialize();\n  }\n  /**\r\n   * Absorb key digests.\r\n   * @param digests The digests hashes to absorb.\r\n   */\n\n\n  _createClass(MultiSigAddress, [{\n    key: \"absorb\",\n    value: function absorb(digests) {\n      if (!arrayHelper_1.ArrayHelper.isTyped(digests, trytes_1.Trytes)) {\n        throw new businessError_1.BusinessError(\"The digests should be an array of type Trytes\");\n      }\n\n      for (var i = 0; i < digests.length; i++) {\n        var digestTrits = trits_1.Trits.fromTrytes(digests[i]).toArray();\n\n        this._kerl.absorb(digestTrits, 0, digestTrits.length);\n      }\n    }\n    /**\r\n     * Finalizes and returns the multisig address in trytes.\r\n     * @param digests The final digests hashes to absorb.\r\n     * @returns The multi signature address.\r\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize(digests) {\n      if (!objectHelper_1.ObjectHelper.isEmpty(digests)) {\n        this.absorb(digests);\n      }\n\n      var addressTrits = new Int8Array(this._hashLength);\n\n      this._kerl.squeeze(addressTrits, 0, addressTrits.length);\n\n      return address_1.Address.fromTrytes(trits_1.Trits.fromArray(addressTrits).toTrytes());\n    }\n  }]);\n\n  return MultiSigAddress;\n}();\n\nexports.MultiSigAddress = MultiSigAddress;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/multiSig/multiSigAddress.js?");

/***/ }),

/***/ "../iota-pico-business/dist/multiSig/multiSigClient.js":
/*!*************************************************************!*\
  !*** ../iota-pico-business/dist/multiSig/multiSigClient.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar timeService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/timeService */ \"../iota-pico-core/dist/services/timeService.js\");\n\nvar address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar bundle_1 = __webpack_require__(/*! @iota-pico/data/dist/data/bundle */ \"../iota-pico-data/dist/data/bundle.js\");\n\nvar hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ \"../iota-pico-data/dist/data/transaction.js\");\n\nvar transfer_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transfer */ \"../iota-pico-data/dist/data/transfer.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar businessError_1 = __webpack_require__(/*! ../error/businessError */ \"../iota-pico-business/dist/error/businessError.js\");\n\nvar bundleHelper_1 = __webpack_require__(/*! ../helpers/bundleHelper */ \"../iota-pico-business/dist/helpers/bundleHelper.js\");\n\nvar signing_1 = __webpack_require__(/*! ../sign/signing */ \"../iota-pico-business/dist/sign/signing.js\");\n\nvar multiSigAddress_1 = __webpack_require__(/*! ./multiSigAddress */ \"../iota-pico-business/dist/multiSig/multiSigAddress.js\");\n/**\r\n * Multiple signatures.\r\n * Converted https://github.com/iotaledger/iota.lib.js/blob/master/lib/multisig/multisig.js\r\n */\n\n\nvar MultiSigClient =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of the MultiSigClient.\r\n   * @param apiClient An API Client to communicate through.\r\n   * @param timeService A class which can provide the time.\r\n   */\n  function MultiSigClient(apiClient) {\n    var timeService = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new timeService_1.TimeService();\n\n    _classCallCheck(this, MultiSigClient);\n\n    this._apiClient = apiClient;\n    this._timeService = timeService;\n  }\n  /**\r\n   * Get the key value of a seed.\r\n   * @param seed The seed to get the key for.\r\n   * @param index The address index to use.\r\n   * @param security The security level to use.\r\n   * @returns The trytes for the key.\r\n   */\n\n\n  _createClass(MultiSigClient, [{\n    key: \"prepareTransfer\",\n\n    /**\r\n     * Initiates the creation of a new transfer by generating an empty bundle with the correct number\r\n     * of bundle entries to be later used for the signing process.\r\n     * @param address Address which has sufficient balance and is controlled by the co-signers.\r\n     * @param securitySum the sum of the security levels from all cosigners chosen during the private key generation (getKey / getDigest)\r\n     * @param balance The balance available for the transfer, if 0 will call getBalances to lookup available.\r\n     * @param transfers The transfers to perform.\r\n     * @param remainderAddress If there is a remainder after the transfer then send the amount to this address.\r\n     */\n    value: function () {\n      var _prepareTransfer = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(address, securitySum, balance, transfers, remainderAddress) {\n        var emptyTrytes, prepared, totalBalance, request, response, timestamp;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The address should be an object of type Address\");\n\n              case 2:\n                if (!(!numberHelper_1.NumberHelper.isInteger(securitySum) || securitySum < 0)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The securitySum should be a number >= 0\");\n\n              case 4:\n                if (!(!numberHelper_1.NumberHelper.isInteger(balance) || balance < 0)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The balance should be a number >= 0\");\n\n              case 6:\n                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transfers should be an array of type Transfer\");\n\n              case 8:\n                if (!(!objectHelper_1.ObjectHelper.isEmpty(remainderAddress) && !objectHelper_1.ObjectHelper.isType(remainderAddress, address_1.Address))) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The remainderAddress should be an object of type Address\");\n\n              case 10:\n                emptyTrytes = trytes_1.Trytes.fromString(\"\"); // If message or tag is not supplied, provide it\n\n                transfers.forEach(function (transfer) {\n                  transfer.message = transfer.message ? transfer.message : emptyTrytes;\n                  transfer.tag = transfer.tag || tag_1.Tag.EMPTY;\n                });\n                prepared = bundleHelper_1.BundleHelper.prepareBundle(this._timeService, transfers);\n\n                if (!(prepared.totalValue === 0)) {\n                  _context.next = 17;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The total transfer value is 0, the transfer does not require a signature\");\n\n              case 17:\n                totalBalance = balance;\n\n                if (!(totalBalance === 0)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                request = {\n                  addresses: [address.toTrytes().toString()],\n                  threshold: 100\n                };\n                _context.next = 22;\n                return this._apiClient.getBalances(request);\n\n              case 22:\n                response = _context.sent;\n                totalBalance = parseInt(response.balances[0], 10);\n\n              case 24:\n                if (!(prepared.totalValue > totalBalance)) {\n                  _context.next = 26;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Not enough balance to satisfy the value\", {\n                  totalValue: prepared.totalValue,\n                  totalBalance: totalBalance\n                });\n\n              case 26:\n                timestamp = Math.floor(this._timeService.msSinceEpoch() / 1000); // Add input as bundle entry\n                // Only a single entry, signatures will be added later\n\n                prepared.bundle.addTransactions(securitySum, address, -totalBalance, prepared.lastTag, timestamp); // If there is a remainder value\n                // Add extra output to send remaining funds to\n\n                if (!(totalBalance > prepared.totalValue)) {\n                  _context.next = 32;\n                  break;\n                }\n\n                if (!objectHelper_1.ObjectHelper.isEmpty(remainderAddress)) {\n                  _context.next = 31;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Transfer has remainder but no remainder address was provided\");\n\n              case 31:\n                prepared.bundle.addTransactions(1, remainderAddress, totalBalance - prepared.totalValue, prepared.lastTag, timestamp);\n\n              case 32:\n                bundleHelper_1.BundleHelper.finalizeBundle(prepared.bundle);\n                prepared.bundle.addSignatureMessageFragments(prepared.signatureMessageFragments);\n\n              case 34:\n                return _context.abrupt(\"return\", prepared.bundle);\n\n              case 35:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function prepareTransfer(_x, _x2, _x3, _x4, _x5) {\n        return _prepareTransfer.apply(this, arguments);\n      };\n    }()\n  }], [{\n    key: \"getKey\",\n    value: function getKey(seed, index, security) {\n      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n        throw new businessError_1.BusinessError(\"The seed should be an object of type Hash\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {\n        throw new businessError_1.BusinessError(\"The index should be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3) {\n        throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n          security: security\n        });\n      }\n\n      return trits_1.Trits.fromArray(signing_1.Signing.key(seed, index, security)).toTrytes();\n    }\n    /**\r\n     * Get the digest value of a seed.\r\n     * @param seed The seed to get the digest for.\r\n     * @param index The address index to use.\r\n     * @param security The security level to use.\r\n     * @returns The trytes for the digest.\r\n     */\n\n  }, {\n    key: \"getDigest\",\n    value: function getDigest(seed, index, security) {\n      if (!objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n        throw new businessError_1.BusinessError(\"The seed should be an object of type Hash\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(index) || index < 0) {\n        throw new businessError_1.BusinessError(\"The index should be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3) {\n        throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n          security: security\n        });\n      }\n\n      var key = signing_1.Signing.key(seed, index, security);\n      return trits_1.Trits.fromArray(signing_1.Signing.digests(key)).toTrytes();\n    }\n    /**\r\n     * Validate address.\r\n     * @param address The address to validate against the digests.\r\n     * @param digests The digests to use to validate the address.\r\n     * @returns True if the address matches the digests.\r\n     */\n\n  }, {\n    key: \"validateAddress\",\n    value: function validateAddress(address, digests) {\n      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n        throw new businessError_1.BusinessError(\"The address should be an object of type Address\");\n      }\n\n      if (!arrayHelper_1.ArrayHelper.isTyped(digests, trytes_1.Trytes)) {\n        throw new businessError_1.BusinessError(\"The digests should be an array of type Trytes\");\n      }\n\n      return address.toTrytes().toString() === new multiSigAddress_1.MultiSigAddress().finalize(digests).toTrytes().toString();\n    }\n    /**\r\n     * Adds the cosigner signatures to the corresponding bundle transactions.\r\n     * @param bundle The bundle to sign.\r\n     * @param address The address to match the transactions.\r\n     * @param key The key to sign the transactions with.\r\n     */\n\n  }, {\n    key: \"addSignature\",\n    value: function addSignature(bundle, address, key) {\n      if (!objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle)) {\n        throw new businessError_1.BusinessError(\"The bundle should be an object of type Bundle\");\n      }\n\n      if (!arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {\n        throw new businessError_1.BusinessError(\"The bundle.transactions should be an array of type Transaction\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n        throw new businessError_1.BusinessError(\"The address should be an object of type Address\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(key, trytes_1.Trytes)) {\n        throw new businessError_1.BusinessError(\"The key should be an object of type Trytes\");\n      }\n\n      var keyTrits = trits_1.Trits.fromTrytes(key).toArray(); // Get the security used for the private key\n      // 1 security level = 2187 trytes\n\n      var security = keyTrits.length / 3 / 2187; // First get the total number of already signed transactions\n      // use that for the bundle hash calculation as well as knowing\n      // where to add the signature\n\n      var numSignedTxs = 0;\n      var addressTrytes = address.toTrytes().toString();\n\n      for (var i = 0; i < bundle.transactions.length; i++) {\n        if (bundle.transactions[i].address.toTrytes().toString() === addressTrytes) {\n          if (bundle.transactions[i].signatureMessageFragment.toTrytes().toString() !== signatureMessageFragment_1.SignatureMessageFragment.EMPTY.toTrytes().toString()) {\n            // If transaction is already signed, increase counter\n            numSignedTxs++;\n          } else {\n            bundleHelper_1.BundleHelper.signTransactions(bundle, i, numSignedTxs % 3, keyTrits, addressTrytes, security);\n            break;\n          }\n        }\n      }\n    }\n  }]);\n\n  return MultiSigClient;\n}();\n\nexports.MultiSigClient = MultiSigClient;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/multiSig/multiSigClient.js?");

/***/ }),

/***/ "../iota-pico-business/dist/sign/hmacCurl.js":
/*!***************************************************!*\
  !*** ../iota-pico-business/dist/sign/hmacCurl.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! @iota-pico/data/dist/data/signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * Hashed Message Authentication Code using Curl.\r\n */\n\n\nvar HmacCurl =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of the HmacCurl.\r\n   * @param key The key to seed with.\r\n   */\n  function HmacCurl(key) {\n    _classCallCheck(this, HmacCurl);\n\n    this._keyTrits = trits_1.Trits.fromTrytes(key).toArray();\n  }\n  /**\r\n   * Add bundle to the HMAC.\r\n   */\n\n\n  _createClass(HmacCurl, [{\n    key: \"addHMAC\",\n    value: function addHMAC(bundle) {\n      var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\", HmacCurl.HMAC_ROUNDS);\n      var hashLength = curl.getConstants().HASH_LENGTH;\n      var key = this._keyTrits;\n\n      for (var i = 0; i < bundle.transactions.length; i++) {\n        if (bundle.transactions[i].value.toNumber() > 0) {\n          var bundleHashTrits = trits_1.Trits.fromTrytes(bundle.transactions[i].bundle.toTrytes()).toArray();\n          var hmac = new Int8Array(hashLength);\n          curl.initialize();\n          curl.absorb(key, 0, key.length);\n          curl.absorb(bundleHashTrits, 0, bundleHashTrits.length);\n          curl.squeeze(hmac, 0, hmac.length);\n          var hmacTrytes = trits_1.Trits.fromArray(hmac).toTrytes().toString();\n          var rest = bundle.transactions[i].signatureMessageFragment.toTrytes().toString().substring(81, signatureMessageFragment_1.SignatureMessageFragment.LENGTH);\n          bundle.transactions[i].signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(hmacTrytes + rest));\n        }\n      }\n    }\n  }]);\n\n  return HmacCurl;\n}();\n/* @internal */\n\n\nHmacCurl.HMAC_ROUNDS = 27;\nexports.HmacCurl = HmacCurl;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/sign/hmacCurl.js?");

/***/ }),

/***/ "../iota-pico-business/dist/sign/signing.js":
/*!**************************************************!*\
  !*** ../iota-pico-business/dist/sign/signing.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar bundleHelper_1 = __webpack_require__(/*! ../helpers/bundleHelper */ \"../iota-pico-business/dist/helpers/bundleHelper.js\");\n/**\r\n * Helper class for signing transactions.\r\n * Original https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/signing/signing.js\r\n * @internal\r\n */\n\n\nvar Signing =\n/*#__PURE__*/\nfunction () {\n  function Signing() {\n    _classCallCheck(this, Signing);\n  }\n\n  _createClass(Signing, null, [{\n    key: \"key\",\n\n    /* @internal */\n    value: function key(seed, index, length) {\n      var seedTrits = trits_1.Trits.fromTrytes(seed.toTrytes());\n      var indexTrits = trits_1.Trits.fromNumber(index);\n      var subseed = trits_1.Trits.add(seedTrits, indexTrits).toArray();\n      var subseedLength = subseed.length;\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n      kerl.absorb(subseed, 0, subseedLength);\n      kerl.squeeze(subseed, 0, subseedLength);\n      kerl.reset();\n      kerl.absorb(subseed, 0, subseedLength);\n      var key = new Int8Array(27 * 243 * length);\n      var offset = 0;\n      var buffer = new Int8Array(subseedLength);\n      var localLength = length;\n\n      while (localLength-- > 0) {\n        for (var i = 0; i < 27; i++) {\n          kerl.squeeze(buffer, 0, subseedLength);\n\n          for (var j = 0; j < 243; j++) {\n            key[offset++] = buffer[j];\n          }\n        }\n      }\n\n      return key;\n    }\n    /* @internal */\n\n  }, {\n    key: \"digests\",\n    value: function digests(key) {\n      var keyLenDiv = Math.floor(key.length / 6561);\n      var digests = new Int8Array(keyLenDiv * 243);\n      var buffer;\n\n      for (var i = 0; i < keyLenDiv; i++) {\n        var iMul = i * 6561;\n        var keyFragment = key.slice(iMul, iMul + 6561);\n\n        for (var j = 0; j < 27; j++) {\n          var jMul = j * 243;\n          buffer = keyFragment.slice(jMul, jMul + 243);\n\n          for (var k = 0; k < 26; k++) {\n            var kKerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n            kKerl.initialize();\n            kKerl.absorb(buffer, 0, buffer.length);\n            kKerl.squeeze(buffer, 0, kKerl.getConstants().HASH_LENGTH);\n          }\n\n          for (var _k = 0; _k < 243; _k++) {\n            keyFragment[jMul + _k] = buffer[_k];\n          }\n        }\n\n        var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n        kerl.initialize();\n        kerl.absorb(keyFragment, 0, keyFragment.length);\n        kerl.squeeze(buffer, 0, kerl.getConstants().HASH_LENGTH);\n        var iMul2 = i * 243;\n\n        for (var _j = 0; _j < 243; _j++) {\n          digests[iMul2 + _j] = buffer[_j];\n        }\n      }\n\n      return digests;\n    }\n    /* @internal */\n\n  }, {\n    key: \"address\",\n    value: function address(digests) {\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n      kerl.absorb(digests, 0, digests.length);\n      var addressTrits = new Int8Array(kerl.getConstants().HASH_LENGTH);\n      kerl.squeeze(addressTrits, 0, addressTrits.length);\n      return addressTrits;\n    }\n    /* @internal */\n\n  }, {\n    key: \"createChecksum\",\n    value: function createChecksum(trits, checksumLength) {\n      var kerl = spongeFactory_1.SpongeFactory.instance().create(\"kerl\");\n      kerl.initialize();\n      kerl.absorb(trits, 0, trits.length);\n      var checksumTrits = new Int8Array(kerl.getConstants().HASH_LENGTH);\n      kerl.squeeze(checksumTrits, 0, checksumTrits.length);\n      return trits_1.Trits.fromArray(checksumTrits).toTrytes().toString().substring(81 - checksumLength, 81);\n    }\n    /* @internal */\n\n  }, {\n    key: \"validateSignatures\",\n    value: function validateSignatures(expectedAddress, signatureMessageFragments, bundleHash) {\n      var normalizedBundleFragments = [];\n      var normalizedBundleHash = bundleHelper_1.BundleHelper.normalizedHash(bundleHash); // Split hash into 3 fragments\n\n      for (var f = 0; f < 3; f++) {\n        normalizedBundleFragments[f] = normalizedBundleHash.slice(f * 27, (f + 1) * 27);\n      } // Get digests\n\n\n      var digests = new Int8Array(signatureMessageFragments.length * 243);\n\n      for (var i = 0; i < signatureMessageFragments.length; i++) {\n        var digestBuffer = bundleHelper_1.BundleHelper.digest(normalizedBundleFragments[i % 3], trits_1.Trits.fromTrytes(signatureMessageFragments[i].toTrytes()).toArray());\n\n        for (var j = 0; j < 243; j++) {\n          digests[i * 243 + j] = digestBuffer[j];\n        }\n      }\n\n      return expectedAddress.toTrytes().toString() === trits_1.Trits.fromArray(bundleHelper_1.BundleHelper.address(digests)).toTrytes().toString();\n    }\n  }]);\n\n  return Signing;\n}();\n\nexports.Signing = Signing;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/sign/signing.js?");

/***/ }),

/***/ "../iota-pico-business/dist/transactions/transactionClient.js":
/*!********************************************************************!*\
  !*** ../iota-pico-business/dist/transactions/transactionClient.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar backgroundTaskService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/backgroundTaskService */ \"../iota-pico-core/dist/services/backgroundTaskService.js\");\n\nvar timeService_1 = __webpack_require__(/*! @iota-pico/core/dist/services/timeService */ \"../iota-pico-core/dist/services/timeService.js\");\n\nvar address_1 = __webpack_require__(/*! @iota-pico/data/dist/data/address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar addressSecurity_1 = __webpack_require__(/*! @iota-pico/data/dist/data/addressSecurity */ \"../iota-pico-data/dist/data/addressSecurity.js\");\n\nvar bundle_1 = __webpack_require__(/*! @iota-pico/data/dist/data/bundle */ \"../iota-pico-data/dist/data/bundle.js\");\n\nvar hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar input_1 = __webpack_require__(/*! @iota-pico/data/dist/data/input */ \"../iota-pico-data/dist/data/input.js\");\n\nvar tag_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar transaction_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transaction */ \"../iota-pico-data/dist/data/transaction.js\");\n\nvar transfer_1 = __webpack_require__(/*! @iota-pico/data/dist/data/transfer */ \"../iota-pico-data/dist/data/transfer.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar tryteNumber_1 = __webpack_require__(/*! @iota-pico/data/dist/data/tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar businessError_1 = __webpack_require__(/*! ../error/businessError */ \"../iota-pico-business/dist/error/businessError.js\");\n\nvar bundleHelper_1 = __webpack_require__(/*! ../helpers/bundleHelper */ \"../iota-pico-business/dist/helpers/bundleHelper.js\");\n\nvar signing_1 = __webpack_require__(/*! ../sign/signing */ \"../iota-pico-business/dist/sign/signing.js\");\n/**\r\n * Default implementation of the ITransactionClient.\r\n */\n\n\nvar TransactionClient =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of the TransactionClient.\r\n   * @param apiClient An API Client to communicate through.\r\n   * @param proofOfWork Proof of work module to use, if undefined will use remote.\r\n   * @param timeService A class which can provide the time.\r\n   * @param backgroundTaskService A class which can provide background tasks.\r\n   */\n  function TransactionClient(apiClient, proofOfWork) {\n    var timeService = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new timeService_1.TimeService();\n    var backgroundTaskService = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new backgroundTaskService_1.BackgroundTaskService();\n\n    _classCallCheck(this, TransactionClient);\n\n    this._apiClient = apiClient;\n    this._proofOfWork = proofOfWork;\n    this._timeService = timeService;\n    this._backgroundTaskService = backgroundTaskService;\n  }\n  /**\r\n   * Returns the list of transaction in progress.\r\n   * @returns Promise which resolves to a list of hashes or rejects with error.\r\n   */\n\n\n  _createClass(TransactionClient, [{\n    key: \"getTransactionsInProgress\",\n    value: function () {\n      var _getTransactionsInProgress = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._apiClient.getTips();\n\n              case 2:\n                response = _context.sent;\n\n                if (!(response && response.hashes)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", response.hashes.map(function (hash) {\n                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));\n                }));\n\n              case 7:\n                return _context.abrupt(\"return\", []);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function getTransactionsInProgress() {\n        return _getTransactionsInProgress.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Find the transactions which match the specified input and return. All input values are lists,\r\n     * for which a list of return values (transaction hashes), in the same order, is returned for all\r\n     * individual elements. Using multiple of these input fields returns the intersection of the values.\r\n     * @param bundles Bundles to lookup transaction hashes for.\r\n     * @param addresses Addresses to lookup transaction hashes for.\r\n     * @param tags Tags to lookup transaction hashes for.\r\n     * @param approvees Approvees to lookup transaction hashes for.\r\n     * @returns Promise which resolves with a list of hashes or rejects with error.\r\n     */\n\n  }, {\n    key: \"findTransactions\",\n    value: function () {\n      var _findTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(bundles, addresses, tags, approvees) {\n        var hasBundle, hasAddresses, hasTags, hasApprovees, request, response;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                hasBundle = bundles !== undefined && bundles !== null && bundles.length > 0;\n                hasAddresses = addresses !== undefined && addresses !== null && addresses.length > 0;\n                hasTags = tags !== undefined && tags !== null && tags.length > 0;\n                hasApprovees = approvees !== undefined && approvees !== null && approvees.length > 0;\n\n                if (!(hasBundle && !arrayHelper_1.ArrayHelper.isTyped(bundles, hash_1.Hash))) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The bundles must be an array of type Hash\");\n\n              case 6:\n                if (!(hasAddresses && !arrayHelper_1.ArrayHelper.isTyped(addresses, address_1.Address))) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The addresses must be an array of type Address\");\n\n              case 8:\n                if (!(hasTags && !arrayHelper_1.ArrayHelper.isTyped(tags, tag_1.Tag))) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The tags must be an array of type Tag\");\n\n              case 10:\n                if (!(hasApprovees && !arrayHelper_1.ArrayHelper.isTyped(approvees, hash_1.Hash))) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The approvees must be an array of type Hash\");\n\n              case 12:\n                if (!(!hasBundle && !hasAddresses && !hasTags && !hasApprovees)) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"You must provide bundles, addresses, tags or approvees\");\n\n              case 14:\n                request = {\n                  bundles: hasBundle ? bundles.map(function (bundle) {\n                    return bundle.toTrytes().toString();\n                  }) : undefined,\n                  addresses: hasAddresses ? addresses.map(function (address) {\n                    return address.toTrytes().toString();\n                  }) : undefined,\n                  tags: hasTags ? tags.map(function (tag) {\n                    return tag.toTrytes().toString();\n                  }) : undefined,\n                  approvees: hasApprovees ? approvees.map(function (approvee) {\n                    return approvee.toTrytes().toString();\n                  }) : undefined\n                };\n                _context2.next = 17;\n                return this._apiClient.findTransactions(request);\n\n              case 17:\n                response = _context2.sent;\n\n                if (!(response && response.hashes)) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", response.hashes.map(function (hash) {\n                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));\n                }));\n\n              case 22:\n                return _context2.abrupt(\"return\", []);\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function findTransactions(_x, _x2, _x3, _x4) {\n        return _findTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get the transaction details of specific transactions.\r\n     * @returns Promise which resolves to the list of transactions or rejects with error.\r\n     */\n\n  }, {\n    key: \"getTransactionsObjects\",\n    value: function () {\n      var _getTransactionsObjects = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(transactionHashes) {\n        var request, response;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (arrayHelper_1.ArrayHelper.isTyped(transactionHashes, hash_1.Hash)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionHashes must be an array of type Hash\");\n\n              case 2:\n                request = {\n                  hashes: transactionHashes.map(function (hash) {\n                    return hash.toTrytes().toString();\n                  })\n                };\n                _context3.next = 5;\n                return this._apiClient.getTrytes(request);\n\n              case 5:\n                response = _context3.sent;\n\n                if (!(response && response.trytes)) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", response.trytes.map(function (trytes) {\n                  return transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(trytes));\n                }));\n\n              case 10:\n                return _context3.abrupt(\"return\", []);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function getTransactionsObjects(_x5) {\n        return _getTransactionsObjects.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get the inclusion states of a list of transaction hashes.\r\n     * @returns Promise which resolves to the list of inclusion states or rejects with error.\r\n     */\n\n  }, {\n    key: \"getLatestInclusion\",\n    value: function () {\n      var _getLatestInclusion = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(transactionHashes) {\n        var nodeInfo, request, response;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (arrayHelper_1.ArrayHelper.isTyped(transactionHashes, hash_1.Hash)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionHashes must be an array of type Hash\");\n\n              case 2:\n                _context4.next = 4;\n                return this._apiClient.getNodeInfo();\n\n              case 4:\n                nodeInfo = _context4.sent;\n\n                if (!(nodeInfo && numberHelper_1.NumberHelper.isInteger(nodeInfo.latestSolidSubtangleMilestone))) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                request = {\n                  transactions: transactionHashes.map(function (hash) {\n                    return hash.toTrytes().toString();\n                  }),\n                  tips: [nodeInfo.latestSolidSubtangleMilestone]\n                };\n                _context4.next = 9;\n                return this._apiClient.getInclusionStates(request);\n\n              case 9:\n                response = _context4.sent;\n\n                if (!(response && response.states)) {\n                  _context4.next = 14;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", response.states);\n\n              case 14:\n                return _context4.abrupt(\"return\", []);\n\n              case 15:\n                _context4.next = 18;\n                break;\n\n              case 17:\n                throw new businessError_1.BusinessError(\"The node could not provide the latestSolidSubtangleMilestone\");\n\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function getLatestInclusion(_x6) {\n        return _getLatestInclusion.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Generates addresses with index-based or using apis.\r\n     * @param seed The seed to generate the addresses from.\r\n     * @param startIndex The start index to generate addresses.\r\n     * @param endIndex The end index to generate addresses.\r\n     * @param includeChecksum Includes the checksum on addresses.\r\n     * @param security The security level at which to create the addresses.\r\n     * @returns Promise which resolves to the list of addresses or rejects with error.\r\n     */\n\n  }, {\n    key: \"getNewAddress\",\n    value: function () {\n      var _getNewAddress = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(seed, startIndex, endIndex, includeChecksum, security) {\n        var localStartIndex, hasEndIndex, localSecurity, addresses, total;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 2:\n                if (!(!objectHelper_1.ObjectHelper.isEmpty(startIndex) && !objectHelper_1.ObjectHelper.isType(startIndex, Number))) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be an integer\", {\n                  startIndex: startIndex\n                });\n\n              case 4:\n                localStartIndex = startIndex || 0;\n\n                if (!(localStartIndex < 0)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be >= 0\", {\n                  localStartIndex: localStartIndex\n                });\n\n              case 7:\n                hasEndIndex = numberHelper_1.NumberHelper.isInteger(endIndex);\n                localSecurity = security || addressSecurity_1.AddressSecurity.medium;\n\n                if (!hasEndIndex) {\n                  _context5.next = 18;\n                  break;\n                }\n\n                total = endIndex - startIndex + 1;\n\n                if (!(total <= 0 || total > TransactionClient.MAX_INPUTS)) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The total must be > 0 and <= \".concat(TransactionClient.MAX_INPUTS), {\n                  total: total\n                });\n\n              case 13:\n                _context5.next = 15;\n                return this.getAddressesByIndex(seed, startIndex, endIndex, includeChecksum, localSecurity);\n\n              case 15:\n                addresses = _context5.sent;\n                _context5.next = 21;\n                break;\n\n              case 18:\n                _context5.next = 20;\n                return this.getAddressesToUnused(seed, startIndex, includeChecksum, localSecurity);\n\n              case 20:\n                addresses = _context5.sent;\n\n              case 21:\n                return _context5.abrupt(\"return\", addresses);\n\n              case 22:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      return function getNewAddress(_x7, _x8, _x9, _x10, _x11) {\n        return _getNewAddress.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Generates new addresses index-based.\r\n     * @param seed The seed to generate the addresses from.\r\n     * @param startIndex The start index to generate addresses.\r\n     * @param endIndex The end index to generate addresses.\r\n     * @param includeChecksum Includes the checksum on addresses.\r\n     * @param security The security level at which to create the addresses.\r\n     * @returns Promise which resolves to the list of addresses or rejects with error.\r\n     */\n\n  }, {\n    key: \"getAddressesByIndex\",\n    value: function () {\n      var _getAddressesByIndex = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(seed, startIndex, endIndex, includeChecksum, security) {\n        var total, addresses, i;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 2:\n                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be a number >= 0\", {\n                  startIndex: startIndex\n                });\n\n              case 4:\n                if (!(!numberHelper_1.NumberHelper.isInteger(endIndex) || endIndex <= 0)) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The endIndex must be a number > 0\", {\n                  endIndex: endIndex\n                });\n\n              case 6:\n                total = endIndex - startIndex + 1;\n\n                if (!(total <= 0 || total > TransactionClient.MAX_INPUTS)) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The total must be > 0 and <= \".concat(TransactionClient.MAX_INPUTS), {\n                  total: total\n                });\n\n              case 9:\n                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {\n                  _context6.next = 11;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n                  security: security\n                });\n\n              case 11:\n                addresses = [];\n\n                for (i = 0; i < total; i++) {\n                  addresses.push(this.generateAddress(seed, startIndex + i, security, includeChecksum));\n                }\n\n                return _context6.abrupt(\"return\", Promise.resolve(addresses));\n\n              case 14:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      return function getAddressesByIndex(_x12, _x13, _x14, _x15, _x16) {\n        return _getAddressesByIndex.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Generates new address which havent been used using apis.\r\n     * @param seed The seed to generate the addresses from.\r\n     * @param startIndex The start index to generate addresses.\r\n     * @param includeChecksum Includes the checksum on addresses.\r\n     * @param security The security level at which to create the addresses.\r\n     * @returns Promise which resolves to an addresses list, the first unused address is the last in the list or rejects with error.\r\n     */\n\n  }, {\n    key: \"getAddressesToUnused\",\n    value: function () {\n      var _getAddressesToUnused = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(seed, startIndex, includeChecksum, security) {\n        var localStartIndex, isUsed, addresses, address, addressNoChecksum, spentFromRequest, spentFromResponse, findTransactionsRequest, findResponse;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 2:\n                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be a number >= 0\", {\n                  startIndex: startIndex\n                });\n\n              case 4:\n                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n                  security: security\n                });\n\n              case 6:\n                localStartIndex = startIndex;\n                addresses = [];\n\n              case 8:\n                address = this.generateAddress(seed, localStartIndex++, security, includeChecksum);\n                addresses.push(address);\n                addressNoChecksum = address.toTrytes().toString();\n                spentFromRequest = {\n                  addresses: [addressNoChecksum]\n                };\n                _context7.next = 14;\n                return this._apiClient.wereAddressesSpentFrom(spentFromRequest);\n\n              case 14:\n                spentFromResponse = _context7.sent;\n                isUsed = spentFromResponse && spentFromResponse.states && spentFromResponse.states.length > 0 ? spentFromResponse.states[0] : false;\n\n                if (isUsed) {\n                  _context7.next = 22;\n                  break;\n                }\n\n                findTransactionsRequest = {\n                  addresses: [addressNoChecksum]\n                };\n                _context7.next = 20;\n                return this._apiClient.findTransactions(findTransactionsRequest);\n\n              case 20:\n                findResponse = _context7.sent;\n                isUsed = findResponse && findResponse.hashes && findResponse.hashes.length > 0;\n\n              case 22:\n                if (isUsed) {\n                  _context7.next = 8;\n                  break;\n                }\n\n              case 23:\n                return _context7.abrupt(\"return\", Promise.resolve(addresses));\n\n              case 24:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      return function getAddressesToUnused(_x17, _x18, _x19, _x20) {\n        return _getAddressesToUnused.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get the input data for a range of addresses.\r\n     * @param seed The seed to get the input data for.\r\n     * @param startIndex The start index to get the addresses.\r\n     * @param endIndex The end index to get the addresses.\r\n     * @param security The security level used to create the addresses.\r\n     * @param totalRequired The threshold at which total balance to stop gathering addresses.\r\n     * @returns Promise which resolves to the inputs for each address or rejects with error.\r\n     */\n\n  }, {\n    key: \"getInputs\",\n    value: function () {\n      var _getInputs = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(seed, startIndex, endIndex, security, totalRequired) {\n        var addresses, request, response, inputs, totalBalance, i, balance;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context8.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 2:\n                if (!(!numberHelper_1.NumberHelper.isInteger(startIndex) || startIndex < 0)) {\n                  _context8.next = 4;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The startIndex must be a number >= 0\", {\n                  startIndex: startIndex\n                });\n\n              case 4:\n                if (!(!numberHelper_1.NumberHelper.isInteger(security) || security < 1 || security > 3)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The security must be between 1 and 3\", {\n                  security: security\n                });\n\n              case 6:\n                if (!(!numberHelper_1.NumberHelper.isInteger(totalRequired) || totalRequired < 0)) {\n                  _context8.next = 8;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The totalRequired must be >= 0\", {\n                  totalRequired: totalRequired\n                });\n\n              case 8:\n                _context8.next = 10;\n                return this.getNewAddress(seed, startIndex, endIndex, false, security);\n\n              case 10:\n                addresses = _context8.sent;\n                request = {\n                  addresses: addresses.map(function (add) {\n                    return add.toTrytes().toString();\n                  }),\n                  threshold: 100\n                };\n                _context8.next = 14;\n                return this._apiClient.getBalances(request);\n\n              case 14:\n                response = _context8.sent;\n                inputs = [];\n                totalBalance = 0;\n\n                if (!response) {\n                  _context8.next = 29;\n                  break;\n                }\n\n                i = 0;\n\n              case 19:\n                if (!(i < addresses.length)) {\n                  _context8.next = 29;\n                  break;\n                }\n\n                balance = parseInt(response.balances[i], 10);\n\n                if (!(balance > 0)) {\n                  _context8.next = 26;\n                  break;\n                }\n\n                inputs.push(input_1.Input.fromParams(addresses[i], security, startIndex + i, balance));\n                totalBalance += balance;\n\n                if (!(totalRequired > 0 && totalBalance >= totalRequired)) {\n                  _context8.next = 26;\n                  break;\n                }\n\n                return _context8.abrupt(\"break\", 29);\n\n              case 26:\n                i++;\n                _context8.next = 19;\n                break;\n\n              case 29:\n                if (!(totalRequired > 0 && totalBalance < totalRequired)) {\n                  _context8.next = 31;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Not enough combined balance in the addresses to satisfy the total required\", {\n                  totalRequired: totalRequired,\n                  totalBalance: totalBalance\n                });\n\n              case 31:\n                return _context8.abrupt(\"return\", {\n                  inputs: inputs,\n                  totalBalance: totalBalance\n                });\n\n              case 32:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      return function getInputs(_x21, _x22, _x23, _x24, _x25) {\n        return _getInputs.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Prepares transfer by generating bundle, finding and signing inputs.\r\n     * @param seed The seed to prepare the transfer for.\r\n     * @param transfers The transfers to prepare.\r\n     * @param transferOptions\r\n     *      @property inputs List of inputs used for funding the transfer.\r\n     *      @property security Security level to be used for the private key / addresses.\r\n     *      @property remainderAddress If defined, this address will be used for sending the remainder value (of the inputs) to.\r\n     *      @property hmacKey Hmac key to sign the bundle.\r\n     *      @property reference The transaction to reference.\r\n     * @returns Promise which resolves to the array of Trytes for the transfer or rejects with error.\r\n     */\n\n  }, {\n    key: \"prepareTransfers\",\n    value: function () {\n      var _prepareTransfers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9(seed, transfers, transferOptions) {\n        var localTransferOptions, emptyTrytes, addHMAC, addedHMAC, prepared, bundle, lastTag, totalValue, signatureMessageFragments, request, balances, confirmedInputs, totalBalance, i, balance, inputsResponse;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 2:\n                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {\n                  _context9.next = 4;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transfers must be an array of Transfer objects\");\n\n              case 4:\n                localTransferOptions = transferOptions || {};\n                localTransferOptions.security = localTransferOptions.security || addressSecurity_1.AddressSecurity.medium;\n                emptyTrytes = trytes_1.Trytes.fromString(\"\");\n                addHMAC = !objectHelper_1.ObjectHelper.isEmpty(localTransferOptions.hmacKey);\n                addedHMAC = false; // If message or tag is not supplied, provide it\n\n                transfers.forEach(function (transfer) {\n                  transfer.message = transfer.message ? transfer.message : emptyTrytes;\n                  transfer.tag = transfer.tag || tag_1.Tag.EMPTY;\n\n                  if (addHMAC && transfer.value > 0) {\n                    transfer.message = trytes_1.Trytes.fromString(TransactionClient.NULL_HASH_TRYTES + transfer.message.toString());\n                    addedHMAC = true;\n                  }\n                }); // Create a new bundle\n\n                prepared = bundleHelper_1.BundleHelper.prepareBundle(this._timeService, transfers);\n                bundle = prepared.bundle;\n                lastTag = prepared.lastTag;\n                totalValue = prepared.totalValue;\n                signatureMessageFragments = prepared.signatureMessageFragments; // Get inputs if we are sending tokens\n\n                if (!totalValue) {\n                  _context9.next = 48;\n                  break;\n                }\n\n                if (!localTransferOptions.inputs) {\n                  _context9.next = 41;\n                  break;\n                }\n\n                request = {\n                  addresses: localTransferOptions.inputs.map(function (input) {\n                    return input.address.toTrytes().toString();\n                  }),\n                  threshold: 100\n                };\n                _context9.next = 20;\n                return this._apiClient.getBalances(request);\n\n              case 20:\n                balances = _context9.sent;\n                confirmedInputs = [];\n                totalBalance = 0;\n                i = 0;\n\n              case 24:\n                if (!(i < balances.balances.length)) {\n                  _context9.next = 35;\n                  break;\n                }\n\n                balance = parseInt(balances.balances[i], 10); // If input has balance, add it to confirmedInputs\n\n                if (!(balance > 0)) {\n                  _context9.next = 32;\n                  break;\n                }\n\n                totalBalance += balance;\n                localTransferOptions.inputs[i].balance = balance;\n                confirmedInputs.push(localTransferOptions.inputs[i]); // if we've already reached the intended input value, break out of loop\n\n                if (!(totalBalance >= totalValue)) {\n                  _context9.next = 32;\n                  break;\n                }\n\n                return _context9.abrupt(\"break\", 35);\n\n              case 32:\n                i++;\n                _context9.next = 24;\n                break;\n\n              case 35:\n                if (!(totalValue > totalBalance)) {\n                  _context9.next = 37;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Not enough balance in the input addresses to satisfy the total for the transfer\");\n\n              case 37:\n                _context9.next = 39;\n                return this.addRemainder(seed, bundle, localTransferOptions, confirmedInputs, signatureMessageFragments, totalValue, lastTag, addedHMAC);\n\n              case 39:\n                _context9.next = 46;\n                break;\n\n              case 41:\n                _context9.next = 43;\n                return this.getInputs(seed, 0, undefined, localTransferOptions.security, totalValue);\n\n              case 43:\n                inputsResponse = _context9.sent;\n                _context9.next = 46;\n                return this.addRemainder(seed, bundle, localTransferOptions, inputsResponse.inputs, signatureMessageFragments, totalValue, lastTag, addedHMAC);\n\n              case 46:\n                _context9.next = 50;\n                break;\n\n              case 48:\n                // If no input required, don't sign and simply finalize the bundle\n                bundleHelper_1.BundleHelper.finalizeBundle(bundle);\n                bundle.addSignatureMessageFragments(signatureMessageFragments);\n\n              case 50:\n                bundle.transactions = bundle.transactions.reverse();\n                return _context9.abrupt(\"return\", bundle);\n\n              case 52:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      return function prepareTransfers(_x26, _x27, _x28) {\n        return _prepareTransfers.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Attach the transactions to the tangle by doing proof of work.\r\n     * @param bundle The bundle of transactions to attach.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @param reference The reference to send with the transactions.\r\n     * @returns Promise which resolves to the bundle of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"attachToTangle\",\n    value: function () {\n      var _attachToTangle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(bundle, depth, minWeightMagnitude, reference) {\n        var transactionsToApproveRequest, transactionsToApprove, powTransactions, allTrytes, attachToTangleRequest, attachToTangleResponse, newBundle;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(bundle, bundle_1.Bundle)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The bundle must be an array of type Bundle\");\n\n              case 2:\n                if (arrayHelper_1.ArrayHelper.isTyped(bundle.transactions, transaction_1.Transaction)) {\n                  _context10.next = 4;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The bundle.transactions must be an array of type Transaction\");\n\n              case 4:\n                if (!(!numberHelper_1.NumberHelper.isInteger(depth) || depth <= 0)) {\n                  _context10.next = 6;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The depth must be a number > 0\", {\n                  depth: depth\n                });\n\n              case 6:\n                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {\n                  _context10.next = 8;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The minWeightMagnitude must be a number > 0\", {\n                  minWeightMagnitude: minWeightMagnitude\n                });\n\n              case 8:\n                transactionsToApproveRequest = {\n                  depth: depth,\n                  reference: reference ? reference.toTrytes().toString() : undefined\n                };\n                _context10.next = 11;\n                return this._apiClient.getTransactionsToApprove(transactionsToApproveRequest);\n\n              case 11:\n                transactionsToApprove = _context10.sent;\n\n                if (!this._proofOfWork) {\n                  _context10.next = 25;\n                  break;\n                }\n\n                if (!this._proofOfWork.performsSingle()) {\n                  _context10.next = 19;\n                  break;\n                }\n\n                _context10.next = 16;\n                return this.proofOfWorkIterate(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.trunkTransaction)), hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.branchTransaction)), bundle.transactions, minWeightMagnitude);\n\n              case 16:\n                powTransactions = _context10.sent;\n                _context10.next = 23;\n                break;\n\n              case 19:\n                _context10.next = 21;\n                return this._proofOfWork.pow(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.trunkTransaction)), hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(transactionsToApprove.branchTransaction)), bundle.transactions.map(function (t) {\n                  return t.toTrytes();\n                }), minWeightMagnitude);\n\n              case 21:\n                allTrytes = _context10.sent;\n                powTransactions = allTrytes.map(function (returnTrytes) {\n                  return transaction_1.Transaction.fromTrytes(returnTrytes);\n                });\n\n              case 23:\n                _context10.next = 30;\n                break;\n\n              case 25:\n                attachToTangleRequest = {\n                  trunkTransaction: transactionsToApprove.trunkTransaction,\n                  branchTransaction: transactionsToApprove.branchTransaction,\n                  minWeightMagnitude: minWeightMagnitude,\n                  trytes: bundle.transactions.map(function (t) {\n                    return t.toTrytes().toString();\n                  })\n                };\n                _context10.next = 28;\n                return this._apiClient.attachToTangle(attachToTangleRequest);\n\n              case 28:\n                attachToTangleResponse = _context10.sent;\n                powTransactions = attachToTangleResponse.trytes.map(function (returnTrytes) {\n                  return transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(returnTrytes));\n                });\n\n              case 30:\n                newBundle = new bundle_1.Bundle();\n                newBundle.transactions = powTransactions;\n                return _context10.abrupt(\"return\", newBundle);\n\n              case 33:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      return function attachToTangle(_x29, _x30, _x31, _x32) {\n        return _attachToTangle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Wrapper function that does attachToTangle and then stores and broadcasts the transactions.\r\n     * @param bundle The bundle of transactions to send.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @param reference The reference to send with the transactions.\r\n     * @returns Promise which resolves to the bundle of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"sendTransactions\",\n    value: function () {\n      var _sendTransactions = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(bundle, depth, minWeightMagnitude, reference) {\n        var attachedTransactionsBundle, storeTransactionsRequest, broadcastTransactionsRequest;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.attachToTangle(bundle, depth, minWeightMagnitude, reference);\n\n              case 2:\n                attachedTransactionsBundle = _context11.sent;\n                storeTransactionsRequest = {\n                  trytes: attachedTransactionsBundle.transactions.map(function (t) {\n                    return t.toTrytes().toString();\n                  })\n                };\n                _context11.next = 6;\n                return this._apiClient.storeTransactions(storeTransactionsRequest);\n\n              case 6:\n                broadcastTransactionsRequest = {\n                  trytes: storeTransactionsRequest.trytes\n                };\n                _context11.next = 9;\n                return this._apiClient.broadcastTransactions(broadcastTransactionsRequest);\n\n              case 9:\n                return _context11.abrupt(\"return\", attachedTransactionsBundle);\n\n              case 10:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      return function sendTransactions(_x33, _x34, _x35, _x36) {\n        return _sendTransactions.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Wrapper function that does prepareTransfers and then sendTransactions.\r\n     * @param seed The seed to send the transfer for.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @param transfers The transfers to send.\r\n     * @param transferOptions Additional options for the transfer.\r\n     *      @property inputs List of inputs used for funding the transfer.\r\n     *      @property security Security level to be used for the private key / addresses.\r\n     *      @property remainderAddress If defined, this address will be used for sending the remainder value (of the inputs) to.\r\n     *      @property hmacKey Hmac key to sign the bundle.\r\n     * @param reference The reference to send with the transactions.\r\n     * @returns Promise which resolves to the list of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"sendTransfer\",\n    value: function () {\n      var _sendTransfer = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee12(seed, depth, minWeightMagnitude, transfers, transferOptions, reference) {\n        var transferTrytes;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this.prepareTransfers(seed, transfers, transferOptions);\n\n              case 2:\n                transferTrytes = _context12.sent;\n                return _context12.abrupt(\"return\", this.sendTransactions(transferTrytes, depth, minWeightMagnitude, reference));\n\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      return function sendTransfer(_x37, _x38, _x39, _x40, _x41, _x42) {\n        return _sendTransfer.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Find out if a transaction is promotable.\r\n     * @param transactionTail The hash of the transaction to be promoted.\r\n     * @returns Promise which resolves to true if the transaction is promotable rejects with an error.\r\n     */\n\n  }, {\n    key: \"isPromotable\",\n    value: function () {\n      var _isPromotable = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee13(transactionTail) {\n        var checkConsistencyRequest, checkConsistencyResponse;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(transactionTail, hash_1.Hash)) {\n                  _context13.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionTail must be an object of type Hash\");\n\n              case 2:\n                checkConsistencyRequest = {\n                  tails: [transactionTail.toTrytes().toString()]\n                };\n                _context13.next = 5;\n                return this._apiClient.checkConsistency(checkConsistencyRequest);\n\n              case 5:\n                checkConsistencyResponse = _context13.sent;\n                return _context13.abrupt(\"return\", checkConsistencyResponse.state);\n\n              case 7:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      return function isPromotable(_x43) {\n        return _isPromotable.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Determines whether you should replay a transaction or make a new one (either with the same input, or a different one).\r\n     * @param addresses Input address you want to have tested.\r\n     * @returns Promise which resolves to true if the addresses are reattachable or rejects with an error.\r\n     */\n\n  }, {\n    key: \"isReattachable\",\n    value: function () {\n      var _isReattachable = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee14(addresses) {\n        var addrsTxsMap, i, addressString, transactions, valueTransactions, results, inclusionStates, _i2;\n\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (arrayHelper_1.ArrayHelper.isTyped(addresses, address_1.Address)) {\n                  _context14.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The addresses must be an object of type Address\");\n\n              case 2:\n                addrsTxsMap = {};\n\n                for (i = 0; i < addresses.length; i++) {\n                  addressString = addresses[i].toTrytes().toString();\n                  addrsTxsMap[addressString] = [];\n                }\n\n                _context14.next = 6;\n                return this.findTransactionObjects(undefined, addresses);\n\n              case 6:\n                transactions = _context14.sent;\n                valueTransactions = [];\n                transactions.forEach(function (transaction) {\n                  if (transaction.value.toNumber() < 0) {\n                    var txAddress = transaction.address;\n                    var txHash = bundleHelper_1.BundleHelper.transactionHash(transaction);\n                    addrsTxsMap[txAddress.toTrytes().toString()].push(txHash);\n                    valueTransactions.push(txHash);\n                  }\n                });\n\n                if (!(valueTransactions.length > 0)) {\n                  _context14.next = 16;\n                  break;\n                }\n\n                _context14.next = 12;\n                return this.getLatestInclusion(valueTransactions);\n\n              case 12:\n                inclusionStates = _context14.sent;\n                results = addresses.map(function (address) {\n                  var shouldReattach = true;\n                  var txs = addrsTxsMap[address.toTrytes().toString()];\n\n                  for (var _i = 0; _i < txs.length; _i++) {\n                    var txIndex = valueTransactions.indexOf(txs[_i]);\n                    shouldReattach = !inclusionStates[txIndex];\n\n                    if (!shouldReattach) {\n                      break;\n                    }\n                  }\n\n                  return shouldReattach;\n                });\n                _context14.next = 18;\n                break;\n\n              case 16:\n                results = [];\n\n                for (_i2 = 0; _i2 < addresses.length; _i2++) {\n                  results.push(true);\n                }\n\n              case 18:\n                return _context14.abrupt(\"return\", results);\n\n              case 19:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      return function isReattachable(_x44) {\n        return _isReattachable.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Promotes a transaction by adding spam on top of it, as long as it is promotable.\r\n     * Will promote by adding transfers on top of the current one with delay interval.\r\n     * Use promoteOptions.interrupt to terminate the promotion.\r\n     * If promoteOptions.delay is set to 0 only one promotion transfer will be sent.\r\n     * @param transactionTail The hash of the transaction to be promoted.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @param transfers The transfers to send.\r\n     * @param promoteOptions Additional options for the promote.\r\n     *      @property delay Delay between promotion transfers\r\n     *      @property interrupt Flag or method to terminate promotion.\r\n     * @returns Promise which resolves to the list of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"promoteTransaction\",\n    value: function () {\n      var _promoteTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee16(transactionTail, depth, minWeightMagnitude, transfers, promoteOptions) {\n        var _this = this;\n\n        var localPromoteOptions, isPromotable, sendTransferResponse;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(transactionTail, hash_1.Hash)) {\n                  _context16.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionTail must be an object of type Hash\");\n\n              case 2:\n                if (!(!numberHelper_1.NumberHelper.isInteger(depth) || depth <= 0)) {\n                  _context16.next = 4;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The depth must be a number > 0\", {\n                  depth: depth\n                });\n\n              case 4:\n                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {\n                  _context16.next = 6;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The minWeightMagnitude must be a number > 0\", {\n                  minWeightMagnitude: minWeightMagnitude\n                });\n\n              case 6:\n                if (arrayHelper_1.ArrayHelper.isTyped(transfers, transfer_1.Transfer)) {\n                  _context16.next = 8;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transfers must an array of Transfer objects\");\n\n              case 8:\n                localPromoteOptions = promoteOptions || {};\n\n                if (objectHelper_1.ObjectHelper.isEmpty(localPromoteOptions.interrupt)) {\n                  localPromoteOptions.interrupt = false;\n                }\n\n                if (!(localPromoteOptions.interrupt === false || typeof localPromoteOptions.interrupt === \"function\" && !localPromoteOptions.interrupt())) {\n                  _context16.next = 28;\n                  break;\n                }\n\n                _context16.next = 13;\n                return this.isPromotable(transactionTail);\n\n              case 13:\n                isPromotable = _context16.sent;\n\n                if (!isPromotable) {\n                  _context16.next = 25;\n                  break;\n                }\n\n                _context16.next = 17;\n                return this.sendTransfer(hash_1.Hash.fromTrytes(transfers[0].address.toTrytes()), depth, minWeightMagnitude, transfers, undefined, transactionTail);\n\n              case 17:\n                sendTransferResponse = _context16.sent;\n\n                if (!numberHelper_1.NumberHelper.isInteger(localPromoteOptions.delay)) {\n                  _context16.next = 22;\n                  break;\n                }\n\n                return _context16.abrupt(\"return\", this._backgroundTaskService.create(\n                /*#__PURE__*/\n                _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee15() {\n                  return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n                    while (1) {\n                      switch (_context15.prev = _context15.next) {\n                        case 0:\n                          return _context15.abrupt(\"return\", _this.promoteTransaction(transactionTail, depth, minWeightMagnitude, transfers, localPromoteOptions));\n\n                        case 1:\n                        case \"end\":\n                          return _context15.stop();\n                      }\n                    }\n                  }, _callee15, this);\n                })), localPromoteOptions.delay));\n\n              case 22:\n                return _context16.abrupt(\"return\", sendTransferResponse);\n\n              case 23:\n                _context16.next = 26;\n                break;\n\n              case 25:\n                throw new businessError_1.BusinessError(\"Transaction is not promotable\");\n\n              case 26:\n                _context16.next = 29;\n                break;\n\n              case 28:\n                return _context16.abrupt(\"return\", undefined);\n\n              case 29:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      return function promoteTransaction(_x45, _x46, _x47, _x48, _x49) {\n        return _promoteTransaction.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Gets the associated bundle transactions of a single transaction.\r\n     * Does validation of signatures, total sum as well as bundle order.\r\n     * @param transactionHash Hash of a trunk or a tail transaction of a bundle.\r\n     * @returns Promise which resolves to the bundle transactions or rejects with an error.\r\n     */\n\n  }, {\n    key: \"getBundle\",\n    value: function () {\n      var _getBundle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee17(transactionHash) {\n        var transactions, bundle, isValid;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(transactionHash, hash_1.Hash)) {\n                  _context17.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The transactionHash must be an object of type Hash\");\n\n              case 2:\n                _context17.next = 4;\n                return this.traverseBundle(transactionHash);\n\n              case 4:\n                transactions = _context17.sent;\n                bundle = new bundle_1.Bundle();\n                bundle.transactions = transactions;\n                isValid = bundleHelper_1.BundleHelper.isValid(bundle);\n\n                if (isValid) {\n                  _context17.next = 10;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Invalid bundle provided\");\n\n              case 10:\n                return _context17.abrupt(\"return\", bundle);\n\n              case 11:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      return function getBundle(_x50) {\n        return _getBundle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Traverse the Bundle by going down the trunkTransactions until\r\n     * the bundle hash of the transaction is no longer the same.\r\n     * @param trunkTransaction Hash of a trunk or a tail transaction of a bundle.\r\n     * @param bundleHash The bundle hash to match.\r\n     * @returns Promise which resolves to the bundle transactions or rejects with an error.\r\n     */\n\n  }, {\n    key: \"traverseBundle\",\n    value: function () {\n      var _traverseBundle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee18(trunkTransaction, bundleHash) {\n        var allBundleTransactions, newTrunkTransaction, newBundleHash, getTrytesRequest, getTrytesResponse, trytes, transactionObject, hasHash, localBundleHash;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(trunkTransaction, hash_1.Hash)) {\n                  _context18.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The trunkTransaction must be an object of type Hash\");\n\n              case 2:\n                allBundleTransactions = [];\n                newTrunkTransaction = trunkTransaction;\n                newBundleHash = bundleHash;\n\n              case 5:\n                getTrytesRequest = {\n                  hashes: [newTrunkTransaction.toTrytes().toString()]\n                };\n                _context18.next = 8;\n                return this._apiClient.getTrytes(getTrytesRequest);\n\n              case 8:\n                getTrytesResponse = _context18.sent;\n                trytes = !objectHelper_1.ObjectHelper.isEmpty(getTrytesResponse) && !objectHelper_1.ObjectHelper.isEmpty(getTrytesResponse.trytes) && getTrytesResponse.trytes.length > 0 ? getTrytesResponse.trytes[0] : undefined;\n\n                if (!objectHelper_1.ObjectHelper.isEmpty(trytes)) {\n                  _context18.next = 14;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Bundle transactions not visible\");\n\n              case 14:\n                transactionObject = transaction_1.Transaction.fromTrytes(trytes_1.Trytes.fromString(trytes)); // If first transaction to search is not a tail, return error\n\n                hasHash = !objectHelper_1.ObjectHelper.isEmpty(newBundleHash);\n\n                if (!(!hasHash && transactionObject.currentIndex.toNumber() !== 0)) {\n                  _context18.next = 18;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Invalid tail transaction supplied\");\n\n              case 18:\n                // If no bundle hash, define it\n                localBundleHash = hasHash ? newBundleHash : transactionObject.bundle;\n                newTrunkTransaction = undefined;\n                newBundleHash = undefined; // If same bundle hash continue\n\n                if (localBundleHash.toTrytes().toString() === transactionObject.bundle.toTrytes().toString()) {\n                  // Add transaction object to bundle\n                  allBundleTransactions.push(transactionObject); // If more than one element then continue\n\n                  if (transactionObject.lastIndex.toNumber() !== 0 || transactionObject.currentIndex.toNumber() !== 0) {\n                    newTrunkTransaction = transactionObject.trunkTransaction;\n                    newBundleHash = localBundleHash;\n                  }\n                }\n\n              case 22:\n                if (newTrunkTransaction !== undefined) {\n                  _context18.next = 5;\n                  break;\n                }\n\n              case 23:\n                return _context18.abrupt(\"return\", allBundleTransactions);\n\n              case 24:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      return function traverseBundle(_x51, _x52) {\n        return _traverseBundle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Wrapper which gets a bundle and then replays a transfer by doing Proof of Work again.\r\n     * @param transactionHash The hash of the transaction to be promoted.\r\n     * @param depth Value that determines how far to go for tip selection.\r\n     * @param minWeightMagnitude The minimum weight magnitude for the proof of work.\r\n     * @returns Promise which resolves to the list of transactions created or rejects with an error.\r\n     */\n\n  }, {\n    key: \"reattachBundle\",\n    value: function () {\n      var _reattachBundle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee19(transactionHash, depth, minWeightMagnitude) {\n        var bundle;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return this.getBundle(transactionHash);\n\n              case 2:\n                bundle = _context19.sent;\n                bundle.transactions = bundle.transactions.reverse();\n                return _context19.abrupt(\"return\", this.sendTransactions(bundle, depth, minWeightMagnitude));\n\n              case 5:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      return function reattachBundle(_x53, _x54, _x55) {\n        return _reattachBundle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Wrapper which gets a bundle and then broadcasts it.\r\n     * @param transactionHash The hash of the transaction to be re-broadcast.\r\n     * @returns Promise which resolves or rejects with an error.\r\n     */\n\n  }, {\n    key: \"rebroadcastBundle\",\n    value: function () {\n      var _rebroadcastBundle = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee20(transactionHash) {\n        var bundle, broadcastTransactionsRequest;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return this.getBundle(transactionHash);\n\n              case 2:\n                bundle = _context20.sent;\n                broadcastTransactionsRequest = {\n                  trytes: bundle.transactions.reverse().map(function (bt) {\n                    return bt.toTrytes().toString();\n                  })\n                };\n                _context20.next = 6;\n                return this._apiClient.broadcastTransactions(broadcastTransactionsRequest);\n\n              case 6:\n                return _context20.abrupt(\"return\", bundle);\n\n              case 7:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      return function rebroadcastBundle(_x56) {\n        return _rebroadcastBundle.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get transaction objects by fist performing a findTransactions call.\r\n     * @param addresses The addresses to get the transaction objects for.\r\n     * @param bundles Bundles to lookup transactions for.\r\n     * @param addresses Addresses to lookup transactions for.\r\n     * @param tags Tags to lookup transactions for.\r\n     * @param approvees Approvees to lookup transactions for.\r\n     * @returns Promise which resolves to the list of transactions or rejects with an error.\r\n     */\n\n  }, {\n    key: \"findTransactionObjects\",\n    value: function () {\n      var _findTransactionObjects = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee21(bundles, addresses, tags, approvees) {\n        var transactions;\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this.findTransactions(bundles, addresses, tags, approvees);\n\n              case 2:\n                transactions = _context21.sent;\n\n                if (!(transactions.length > 0)) {\n                  _context21.next = 7;\n                  break;\n                }\n\n                return _context21.abrupt(\"return\", this.getTransactionsObjects(transactions));\n\n              case 7:\n                return _context21.abrupt(\"return\", []);\n\n              case 8:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      return function findTransactionObjects(_x57, _x58, _x59, _x60) {\n        return _findTransactionObjects.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * The transfers which are associated with a seed. The transfers are determined by either calculating\r\n     * deterministically which addresses were already used, or by providing a list of indexes to get the\r\n     * addresses and the associated transfers from. The transfers are sorted by their timestamp.\r\n     * @param seed The seed to get the transfers for\r\n     * @param startIndex The start index to get the transfers for.\r\n     * @param endIndex The end index to get the transfers for.\r\n     * @param security The security level for the transfers.\r\n     * @param inclusionStates Do you want inclusion states in the bundles.\r\n     * @returns Promise which resolves to the requested bundles or rejects with an error.\r\n     */\n\n  }, {\n    key: \"getTransfers\",\n    value: function () {\n      var _getTransfers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee22(seed, startIndex, endIndex, security, inclusionStates) {\n        var localStartIndex, addresses;\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context22.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 2:\n                localStartIndex = startIndex;\n\n                if (!numberHelper_1.NumberHelper.isInteger(localStartIndex)) {\n                  localStartIndex = 0;\n                }\n\n                _context22.next = 6;\n                return this.getNewAddress(seed, localStartIndex, endIndex, false, security);\n\n              case 6:\n                addresses = _context22.sent;\n                return _context22.abrupt(\"return\", this.bundlesFromAddresses(addresses, inclusionStates));\n\n              case 8:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      return function getTransfers(_x61, _x62, _x63, _x64, _x65) {\n        return _getTransfers.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Similar to getTransfers, just that it returns additional account data.\r\n     * @param seed The seed to get the transfers for\r\n     * @param startIndex The start index to get the transfers for.\r\n     * @param endIndex The end index to get the transfers for.\r\n     * @param security The security level for the transfers.\r\n     * @returns Promise which resolves to the account data or rejects with an error.\r\n     */\n\n  }, {\n    key: \"getAccountData\",\n    value: function () {\n      var _getAccountData = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee23(seed, startIndex, endIndex, security) {\n        var localStartIndex, addresses, bundles, accountData, balanceRequest, balanceResponse, i, balance;\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(seed, hash_1.Hash)) {\n                  _context23.next = 2;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"The seed must be of type Hash\");\n\n              case 2:\n                localStartIndex = startIndex;\n\n                if (!numberHelper_1.NumberHelper.isInteger(localStartIndex)) {\n                  localStartIndex = 0;\n                }\n\n                _context23.next = 6;\n                return this.getNewAddress(seed, localStartIndex, endIndex, false, security || addressSecurity_1.AddressSecurity.medium);\n\n              case 6:\n                addresses = _context23.sent;\n                _context23.next = 9;\n                return this.bundlesFromAddresses(addresses, true);\n\n              case 9:\n                bundles = _context23.sent;\n                accountData = {\n                  latestAddress: addresses.pop(),\n                  addresses: addresses,\n                  transfers: bundles,\n                  inputs: [],\n                  balance: 0\n                };\n                balanceRequest = {\n                  addresses: accountData.addresses.map(function (add) {\n                    return add.toTrytes().toString();\n                  }),\n                  threshold: 100\n                };\n                _context23.next = 14;\n                return this._apiClient.getBalances(balanceRequest);\n\n              case 14:\n                balanceResponse = _context23.sent;\n\n                for (i = 0; i < balanceResponse.balances.length; i++) {\n                  balance = parseInt(balanceResponse.balances[i], 10);\n\n                  if (balance > 0) {\n                    accountData.inputs.push(input_1.Input.fromParams(accountData.addresses[i], security || addressSecurity_1.AddressSecurity.medium, localStartIndex + i, balance));\n                    accountData.balance += balance;\n                  }\n                }\n\n                return _context23.abrupt(\"return\", accountData);\n\n              case 17:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      return function getAccountData(_x66, _x67, _x68, _x69) {\n        return _getAccountData.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"bundlesFromAddresses\",\n    value: function () {\n      var _bundlesFromAddresses = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee24(addresses, inclusionStates) {\n        var transactionObjects, tailTransactions, nonTailBundleHashes, nonTailBundleTransactions, finalBundles, tailTxArray, tailTxStates, i, bundle;\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                _context24.next = 2;\n                return this.findTransactionObjects(undefined, addresses, undefined, undefined);\n\n              case 2:\n                transactionObjects = _context24.sent;\n                // set of tail transactions\n                tailTransactions = new Set();\n                nonTailBundleHashes = new Set();\n                transactionObjects.forEach(function (transaction) {\n                  // Sort tail and nonTails\n                  if (transaction.currentIndex.toNumber() === 0) {\n                    tailTransactions.add(bundleHelper_1.BundleHelper.transactionHash(transaction).toTrytes().toString());\n                  } else {\n                    nonTailBundleHashes.add(transaction.bundle.toTrytes().toString());\n                  }\n                });\n\n                if (!(nonTailBundleHashes.size > 0)) {\n                  _context24.next = 11;\n                  break;\n                }\n\n                _context24.next = 9;\n                return this.findTransactionObjects(Array.from(nonTailBundleHashes).map(function (hash) {\n                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(hash));\n                }));\n\n              case 9:\n                nonTailBundleTransactions = _context24.sent;\n                nonTailBundleTransactions.forEach(function (transaction) {\n                  if (transaction.currentIndex.toNumber() === 0) {\n                    tailTransactions.add(bundleHelper_1.BundleHelper.transactionHash(transaction).toTrytes().toString());\n                  }\n                });\n\n              case 11:\n                finalBundles = [];\n                tailTxArray = Array.from(tailTransactions); // If inclusionStates, get the confirmation status\n                // of the tail transactions, and thus the bundles\n\n                if (!inclusionStates) {\n                  _context24.next = 17;\n                  break;\n                }\n\n                _context24.next = 16;\n                return this.getLatestInclusion(tailTxArray.map(function (tail) {\n                  return hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(tail));\n                }));\n\n              case 16:\n                tailTxStates = _context24.sent;\n\n              case 17:\n                i = 0;\n\n              case 18:\n                if (!(i < tailTxArray.length)) {\n                  _context24.next = 27;\n                  break;\n                }\n\n                _context24.next = 21;\n                return this.getBundle(hash_1.Hash.fromTrytes(trytes_1.Trytes.fromString(tailTxArray[i])));\n\n              case 21:\n                bundle = _context24.sent;\n                bundle.inclusionState = tailTxStates ? tailTxStates[i] : undefined;\n                finalBundles.push(bundle);\n\n              case 24:\n                i++;\n                _context24.next = 18;\n                break;\n\n              case 27:\n                // Sort bundles by timestamp\n                finalBundles.sort(function (a, b) {\n                  var x = a.transactions[0].attachmentTimestamp.toNumber();\n                  var y = b.transactions[0].attachmentTimestamp.toNumber();\n                  return x < y ? -1 : x > y ? 1 : 0;\n                });\n                return _context24.abrupt(\"return\", finalBundles);\n\n              case 29:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      return function bundlesFromAddresses(_x70, _x71) {\n        return _bundlesFromAddresses.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"generateAddress\",\n    value: function generateAddress(seed, index, security, includeChecksum) {\n      var key = signing_1.Signing.key(seed, index, security);\n      var digests = signing_1.Signing.digests(key);\n      var addressTrits = signing_1.Signing.address(digests);\n      var addressTrytesString = trits_1.Trits.fromArray(addressTrits).toTrytes().toString();\n\n      if (includeChecksum) {\n        addressTrytesString += signing_1.Signing.createChecksum(addressTrits, 9);\n      }\n\n      return address_1.Address.fromTrytes(trytes_1.Trytes.fromString(addressTrytesString));\n    }\n    /* @internal */\n\n  }, {\n    key: \"addRemainder\",\n    value: function () {\n      var _addRemainder = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee25(seed, bundle, transferOptions, inputs, signatureMessageFragments, totalValue, tag, addedHMAC) {\n        var totalTransferValue, i, timestamp, remainder, startIndex, k, addresses, ts;\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                totalTransferValue = totalValue;\n                i = 0;\n\n              case 2:\n                if (!(i < inputs.length)) {\n                  _context25.next = 31;\n                  break;\n                }\n\n                timestamp = Math.floor(this._timeService.msSinceEpoch() / 1000); // Add input as bundle entry\n\n                bundle.addTransactions(inputs[i].security, inputs[i].address, -inputs[i].balance, tag, timestamp); // If there is a remainder value\n                // Add extra output to send remaining funds to\n\n                if (!(inputs[i].balance >= totalTransferValue)) {\n                  _context25.next = 27;\n                  break;\n                }\n\n                remainder = inputs[i].balance - totalTransferValue; // If user has provided remainder address use it to send remaining funds to\n\n                if (!(remainder > 0 && !objectHelper_1.ObjectHelper.isEmpty(transferOptions) && objectHelper_1.ObjectHelper.isType(transferOptions.remainderAddress, address_1.Address))) {\n                  _context25.next = 12;\n                  break;\n                }\n\n                // Remainder bundle entry\n                bundle.addTransactions(1, transferOptions.remainderAddress, remainder, tag, timestamp); // Final function for signing inputs\n\n                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);\n                _context25.next = 25;\n                break;\n\n              case 12:\n                if (!(remainder > 0)) {\n                  _context25.next = 24;\n                  break;\n                }\n\n                startIndex = 0;\n\n                for (k = 0; k < inputs.length; k++) {\n                  startIndex = Math.max(inputs[k].keyIndex, startIndex);\n                }\n\n                startIndex++;\n                _context25.next = 18;\n                return this.getAddressesToUnused(seed, startIndex, false, transferOptions.security);\n\n              case 18:\n                addresses = _context25.sent;\n                ts = Math.floor(this._timeService.msSinceEpoch() / 1000); // Remainder bundle entry\n\n                bundle.addTransactions(1, addresses[addresses.length - 1], remainder, tag, ts); // Final function for signing inputs\n\n                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);\n                _context25.next = 25;\n                break;\n\n              case 24:\n                // If there is no remainder, do not add transaction to bundle\n                // simply sign and return\n                bundleHelper_1.BundleHelper.signInputs(seed, bundle, transferOptions, signatureMessageFragments, inputs, addedHMAC);\n\n              case 25:\n                _context25.next = 28;\n                break;\n\n              case 27:\n                // If multiple inputs provided, subtract the totalTransferValue by\n                // the inputs balance\n                totalTransferValue -= inputs[i].balance;\n\n              case 28:\n                i++;\n                _context25.next = 2;\n                break;\n\n              case 31:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      return function addRemainder(_x72, _x73, _x74, _x75, _x76, _x77, _x78, _x79) {\n        return _addRemainder.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"proofOfWorkIterate\",\n    value: function () {\n      var _proofOfWorkIterate = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee26(trunkTransaction, branchTransaction, transactions, minWeightMagnitude) {\n        var finalTransactions, previousTransactionHash, i, newTrytes, returnedTrytes, returnTransaction;\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                finalTransactions = [];\n                i = 0;\n\n              case 2:\n                if (!(i < transactions.length)) {\n                  _context26.next = 26;\n                  break;\n                }\n\n                // Start with last index transaction\n                // Assign it the trunk / branch which the user has supplied\n                // If there is a bundle, chain the bundle transactions via\n                // trunkTransaction together\n                transactions[i].attachmentTimestamp = tryteNumber_1.TryteNumber.fromNumber(this._timeService.msSinceEpoch());\n                transactions[i].attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromNumber(0);\n                transactions[i].attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromNumber(TransactionClient.MAX_TIMESTAMP_VALUE); // If this is the first transaction, to be processed\n                // Make sure that it's the last in the bundle and then\n                // assign it the supplied trunk and branch transactions\n\n                if (!objectHelper_1.ObjectHelper.isEmpty(previousTransactionHash)) {\n                  _context26.next = 13;\n                  break;\n                }\n\n                if (!(transactions[i].lastIndex.toNumber() !== transactions[i].currentIndex.toNumber())) {\n                  _context26.next = 9;\n                  break;\n                }\n\n                throw new businessError_1.BusinessError(\"Wrong bundle order. The bundle should be ordered in descending order from currentIndex\");\n\n              case 9:\n                transactions[i].trunkTransaction = trunkTransaction;\n                transactions[i].branchTransaction = branchTransaction;\n                _context26.next = 15;\n                break;\n\n              case 13:\n                transactions[i].trunkTransaction = previousTransactionHash;\n                transactions[i].branchTransaction = trunkTransaction;\n\n              case 15:\n                newTrytes = transactions[i].toTrytes();\n                _context26.next = 18;\n                return this._proofOfWork.pow(trunkTransaction, branchTransaction, [newTrytes], minWeightMagnitude);\n\n              case 18:\n                returnedTrytes = _context26.sent;\n                transactions[i].nonce = tag_1.Tag.fromTrytes(returnedTrytes[0].sub(transaction_1.Transaction.LENGTH - tag_1.Tag.LENGTH, tag_1.Tag.LENGTH)); // Calculate the hash of the new transaction with nonce and use that as the previous hash for next entry\n\n                returnTransaction = transaction_1.Transaction.fromTrytes(returnedTrytes[0]);\n                previousTransactionHash = bundleHelper_1.BundleHelper.transactionHash(returnTransaction);\n                finalTransactions.push(returnTransaction);\n\n              case 23:\n                i++;\n                _context26.next = 2;\n                break;\n\n              case 26:\n                return _context26.abrupt(\"return\", Promise.resolve(finalTransactions.reverse()));\n\n              case 27:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      return function proofOfWorkIterate(_x80, _x81, _x82, _x83) {\n        return _proofOfWorkIterate.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return TransactionClient;\n}();\n/* @internal */\n\n\nTransactionClient.NULL_HASH_TRYTES = \"9\".repeat(243);\n/* @internal */\n\nTransactionClient.MAX_TIMESTAMP_VALUE = (Math.pow(3, 27) - 1) / 2;\n/* @internal */\n\nTransactionClient.MAX_INPUTS = 500;\nexports.TransactionClient = TransactionClient;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/dist/transactions/transactionClient.js?");

/***/ }),

/***/ "../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js":
/*!******************************************************************************!*\
  !*** ../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-business/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-business/node_modules/regenerator-runtime/runtime-module.js":
/*!********************************************************************************!*\
  !*** ../iota-pico-business/node_modules/regenerator-runtime/runtime-module.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-business/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-business/node_modules/regenerator-runtime/runtime.js":
/*!*************************************************************************!*\
  !*** ../iota-pico-business/node_modules/regenerator-runtime/runtime.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-business/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-core/dist/error/coreError.js":
/*!*************************************************!*\
  !*** ../iota-pico-core/dist/error/coreError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _extendableBuiltin(cls) {\n  function ExtendableBuiltin() {\n    var instance = Reflect.construct(cls, Array.from(arguments));\n    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n    return instance;\n  }\n\n  ExtendableBuiltin.prototype = Object.create(cls.prototype, {\n    constructor: {\n      value: cls,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(ExtendableBuiltin, cls);\n  } else {\n    ExtendableBuiltin.__proto__ = cls;\n  }\n\n  return ExtendableBuiltin;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar jsonHelper_1 = __webpack_require__(/*! ../helpers/jsonHelper */ \"../iota-pico-core/dist/helpers/jsonHelper.js\");\n/**\r\n * A core implementation of an error.\r\n */\n\n\nvar CoreError =\n/*#__PURE__*/\nfunction (_extendableBuiltin2) {\n  _inherits(CoreError, _extendableBuiltin2);\n\n  /**\r\n   * Create an instance of CoreError.\r\n   * @param message The message for the error.\r\n   * @param additional Additional details about the error.\r\n   * @param innerError Add information from inner error if there was one.\r\n   */\n  function CoreError(message, additional, innerError) {\n    var _this;\n\n    _classCallCheck(this, CoreError);\n\n    _this = _possibleConstructorReturn(this, (CoreError.__proto__ || Object.getPrototypeOf(CoreError)).call(this, message));\n    _this.additional = additional ? additional : {};\n    _this.innerError = innerError;\n    return _this;\n  }\n  /**\r\n   * Check if an object could be a CoreError.\r\n   * @param obj The object to check if it is a CoreError.\r\n   * @returns true If the tested object is a CoreError.\r\n   */\n\n\n  _createClass(CoreError, [{\n    key: \"format\",\n\n    /**\r\n     * Format the error to a readable version.\r\n     */\n    value: function format() {\n      var _this2 = this;\n\n      var out = this.message || \"\";\n      var keys = Object.keys(this.additional);\n\n      if (keys.length > 0) {\n        if (out.length > 0) {\n          out += \"\\n\";\n        }\n\n        keys.forEach(function (key) {\n          out += \"\\t\".concat(key, \": \").concat(jsonHelper_1.JsonHelper.stringify(_this2.additional[key]), \"\\n\");\n        });\n      }\n\n      return out;\n    }\n  }], [{\n    key: \"isError\",\n    value: function isError(obj) {\n      return obj !== undefined && obj !== null && _typeof(obj) === \"object\" && \"message\" in obj && \"additional\" in obj;\n    }\n  }]);\n\n  return CoreError;\n}(_extendableBuiltin(Error));\n\nexports.CoreError = CoreError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/error/coreError.js?");

/***/ }),

/***/ "../iota-pico-core/dist/factories/factoryBase.js":
/*!*******************************************************!*\
  !*** ../iota-pico-core/dist/factories/factoryBase.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Factory to generate types.\r\n * @typeparam T The generic type for the object types in the factory.\r\n */\n\nvar FactoryBase =\n/*#__PURE__*/\nfunction () {\n  function FactoryBase() {\n    _classCallCheck(this, FactoryBase);\n\n    /* @internal */\n    this._types = {};\n  }\n  /**\r\n   * Register a new type with the factory.\r\n   * @param name The name of the type to register.\r\n   * @param typeConstructor The constructor for the type.\r\n   */\n\n\n  _createClass(FactoryBase, [{\n    key: \"register\",\n    value: function register(name, typeConstructor) {\n      this.getInstance()._types[name] = typeConstructor;\n    }\n    /**\r\n     * Unregister a type from the factory.\r\n     * @param name The name of the type to unregister.\r\n     */\n\n  }, {\n    key: \"unregister\",\n    value: function unregister(name) {\n      delete this.getInstance()._types[name];\n    }\n    /**\r\n     * Does the factory contain a specific type.\r\n     * @param name The name of the type to look for.\r\n     * @returns True if the type exists.\r\n     */\n\n  }, {\n    key: \"exists\",\n    value: function exists(name) {\n      return this.getInstance()._types[name] !== undefined;\n    }\n    /**\r\n     * Create an instance of an object from the factory.\r\n     * @param name The name of the type to create.\r\n     * @param args Any parameters to pass to the constructor.\r\n     * @returns A new instance of the type if it exists, or undefined if it does not.\r\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(name) {\n      var instance = this.getInstance();\n\n      if (instance._types[name]) {\n        var _instance$_types;\n\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        return (_instance$_types = instance._types)[name].apply(_instance$_types, args);\n      } else {\n        return undefined;\n      }\n    }\n  }]);\n\n  return FactoryBase;\n}();\n\nexports.FactoryBase = FactoryBase;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/factories/factoryBase.js?");

/***/ }),

/***/ "../iota-pico-core/dist/factories/networkClientFactory.js":
/*!****************************************************************!*\
  !*** ../iota-pico-core/dist/factories/networkClientFactory.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar factoryBase_1 = __webpack_require__(/*! ./factoryBase */ \"../iota-pico-core/dist/factories/factoryBase.js\");\n/**\r\n * Factory to generate network clients.\r\n */\n\n\nvar NetworkClientFactory =\n/*#__PURE__*/\nfunction (_factoryBase_1$Factor) {\n  _inherits(NetworkClientFactory, _factoryBase_1$Factor);\n\n  /**\r\n   * Don't allow manual construction of the factory.\r\n   * @internal\r\n   */\n  function NetworkClientFactory() {\n    _classCallCheck(this, NetworkClientFactory);\n\n    return _possibleConstructorReturn(this, (NetworkClientFactory.__proto__ || Object.getPrototypeOf(NetworkClientFactory)).call(this));\n  }\n  /**\r\n   * Get the instance of the factory.\r\n   * @returns The factory instance.\r\n   */\n\n\n  _createClass(NetworkClientFactory, [{\n    key: \"getInstance\",\n\n    /* @internal */\n    value: function getInstance() {\n      return NetworkClientFactory.instance();\n    }\n  }], [{\n    key: \"instance\",\n    value: function instance() {\n      if (!NetworkClientFactory._instance) {\n        NetworkClientFactory._instance = new NetworkClientFactory();\n      }\n\n      return NetworkClientFactory._instance;\n    }\n  }]);\n\n  return NetworkClientFactory;\n}(factoryBase_1.FactoryBase);\n\nexports.NetworkClientFactory = NetworkClientFactory;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/factories/networkClientFactory.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/arrayHelper.js":
/*!*****************************************************!*\
  !*** ../iota-pico-core/dist/helpers/arrayHelper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! ./objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n/**\r\n * Array helper methods.\r\n */\n\n\nvar ArrayHelper =\n/*#__PURE__*/\nfunction () {\n  function ArrayHelper() {\n    _classCallCheck(this, ArrayHelper);\n  }\n\n  _createClass(ArrayHelper, null, [{\n    key: \"isArray\",\n\n    /**\r\n     * Is the value an array.\r\n     * @param value Object to test.\r\n     * @returns True if the value is an array.\r\n     */\n    value: function isArray(value) {\n      return value === null || value === undefined ? false : Array.isArray(value);\n    }\n    /**\r\n     * Is the value a empty array.\r\n     * @param value Object to test.\r\n     * @returns True if the value is a empty array.\r\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty(value) {\n      return !ArrayHelper.isArray(value) || value.length === 0;\n    }\n    /**\r\n     * Is the value a non empty array of specific type.\r\n     * @param value Object to test.\r\n     * @param type The type of the object\r\n     * @returns True if the value is a non empty array of a specific type.\r\n     */\n\n  }, {\n    key: \"isTyped\",\n    value: function isTyped(value, type) {\n      return !ArrayHelper.isEmpty(value) && !value.includes(undefined) && !value.includes(null) && value.every(function (a) {\n        return objectHelper_1.ObjectHelper.isType(a, type);\n      });\n    }\n  }]);\n\n  return ArrayHelper;\n}();\n\nexports.ArrayHelper = ArrayHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/arrayHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/errorHelper.js":
/*!*****************************************************!*\
  !*** ../iota-pico-core/dist/helpers/errorHelper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! ../error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n\nvar jsonHelper_1 = __webpack_require__(/*! ./jsonHelper */ \"../iota-pico-core/dist/helpers/jsonHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! ./stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n/**\r\n * Handle errors as gracefully as possible.\r\n */\n\n\nvar ErrorHelper =\n/*#__PURE__*/\nfunction () {\n  function ErrorHelper() {\n    _classCallCheck(this, ErrorHelper);\n  }\n\n  _createClass(ErrorHelper, null, [{\n    key: \"format\",\n\n    /**\r\n     * Format an error object into something readable.\r\n     * @param err The object to format.\r\n     * @param includeStack Include the stack trace if there is one.\r\n     * @returns Formatted version of the error object.\r\n     */\n    value: function format(err, includeStack) {\n      if (err === null || err === undefined) {\n        return \"unknown error\";\n      } else if (coreError_1.CoreError.isError(err)) {\n        var ret = err.format();\n\n        if (includeStack && err.stack) {\n          ret += \"\\nStack Trace\";\n          var parts = err.stack.split(\"\\n\");\n          parts.shift();\n          ret += \"\\n\".concat(parts.join(\"\\n\"));\n        }\n\n        if (err.innerError) {\n          if (includeStack && err.innerError.stack) {\n            ret += \"\\n\\n-----------------------------------------------\";\n            ret += \"\\nInner Stack Trace\\n\";\n            ret += err.innerError.stack;\n          } else {\n            ret += \"\\nInner Error: \".concat(err.innerError.message, \"\\n\");\n          }\n        }\n\n        return ret;\n      } else if (err instanceof Error) {\n        var _ret = \"\";\n\n        if (includeStack && err.stack) {\n          _ret += err.stack;\n        } else {\n          _ret += err.message;\n        }\n\n        return _ret;\n      } else {\n        if (stringHelper_1.StringHelper.isString(err)) {\n          return err;\n        } else {\n          return jsonHelper_1.JsonHelper.stringify(err, undefined, \"\\t\");\n        }\n      }\n    }\n  }]);\n\n  return ErrorHelper;\n}();\n\nexports.ErrorHelper = ErrorHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/errorHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/jsonHelper.js":
/*!****************************************************!*\
  !*** ../iota-pico-core/dist/helpers/jsonHelper.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Json helper methods.\r\n */\n\nvar JsonHelper =\n/*#__PURE__*/\nfunction () {\n  function JsonHelper() {\n    _classCallCheck(this, JsonHelper);\n  }\n\n  _createClass(JsonHelper, null, [{\n    key: \"stringify\",\n\n    /**\r\n     * Stringify an object with recursion breaking.\r\n     * @param value A JavaScript value, usually an object or array, to be converted.\r\n     * @param replacer A function that transforms the results.\r\n     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\r\n     * @returns String version of the object.\r\n     */\n    value: function stringify(value, replacer, space) {\n      // eliminates any recursion in the stringify\n      var cache = [];\n\n      var recusionReplacer = function recusionReplacer(key, replaceValue) {\n        if (_typeof(replaceValue) === \"object\" && value !== null && replaceValue !== undefined) {\n          if (cache.indexOf(replaceValue) !== -1) {\n            // circular reference found, discard key\n            return;\n          } else {\n            cache.push(replaceValue);\n          }\n        }\n\n        return replacer ? replacer(key, replaceValue) : replaceValue;\n      };\n\n      return JSON.stringify(value, recusionReplacer, space);\n    }\n  }]);\n\n  return JsonHelper;\n}();\n\nexports.JsonHelper = JsonHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/jsonHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/numberHelper.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/helpers/numberHelper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Number helper methods.\r\n */\n\nvar NumberHelper =\n/*#__PURE__*/\nfunction () {\n  function NumberHelper() {\n    _classCallCheck(this, NumberHelper);\n  }\n\n  _createClass(NumberHelper, null, [{\n    key: \"isInteger\",\n\n    /**\r\n     * Is the value a number.\r\n     * @param value Object to test for its numberyness.\r\n     * @returns True if the object is a number.\r\n     */\n    value: function isInteger(value) {\n      return Number.isInteger(value) && !Number.isNaN(value) && Number.isFinite(value);\n    }\n  }]);\n\n  return NumberHelper;\n}();\n\nexports.NumberHelper = NumberHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/numberHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/objectHelper.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/helpers/objectHelper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Object helper methods.\r\n */\n\nvar ObjectHelper =\n/*#__PURE__*/\nfunction () {\n  function ObjectHelper() {\n    _classCallCheck(this, ObjectHelper);\n  }\n\n  _createClass(ObjectHelper, null, [{\n    key: \"isEmpty\",\n\n    /**\r\n     * Is the value empty.\r\n     * @param value Object to test.\r\n     * @returns True if the value is empty.\r\n     */\n    value: function isEmpty(value) {\n      return value === null || value === undefined;\n    }\n    /**\r\n     * Is the value an object.\r\n     * @param value Object to test.\r\n     * @returns True if the value is an object.\r\n     */\n\n  }, {\n    key: \"isObject\",\n    value: function isObject(value) {\n      return value === null || value === undefined ? false : _typeof(value) === \"object\" && !Array.isArray(value);\n    }\n    /**\r\n     * Is the value an object if given type.\r\n     * @param value Object to test.\r\n     * @param type The type of the object\r\n     * @returns True if the value is an object of the specified type.\r\n     */\n\n  }, {\n    key: \"isType\",\n    value: function isType(value, typeConstructor) {\n      var valueClassName = ObjectHelper.getClassName(value);\n      return valueClassName !== undefined && valueClassName === ObjectHelper.getClassName(typeConstructor);\n    }\n    /**\r\n     * Get the class name of an object if it has one.\r\n     * @param object The object to get the class name for.\r\n     * @returns The class name if it has one or undefined if not.\r\n     */\n\n  }, {\n    key: \"getClassName\",\n    value: function getClassName(object) {\n      if (object === null || object === undefined) {\n        return undefined;\n      } else {\n        var _constructor = typeof object === \"function\" ? object.toString() : object.constructor.toString();\n\n        var results = _constructor.match(/\\w+/g);\n\n        return results && results.length > 1 ? results[1] : undefined;\n      }\n    }\n  }]);\n\n  return ObjectHelper;\n}();\n\nexports.ObjectHelper = ObjectHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/objectHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/helpers/stringHelper.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/helpers/stringHelper.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * String helper methods.\r\n */\n\nvar StringHelper =\n/*#__PURE__*/\nfunction () {\n  function StringHelper() {\n    _classCallCheck(this, StringHelper);\n  }\n\n  _createClass(StringHelper, null, [{\n    key: \"isString\",\n\n    /**\r\n     * Is the value a string.\r\n     * @param value Object to test for its stringyness.\r\n     * @returns True if the object is a string.\r\n     */\n    value: function isString(value) {\n      return value === null || value === undefined ? false : Object.prototype.toString.call(value) === \"[object String]\";\n    }\n    /**\r\n     * Is the value a string that is empty.\r\n     * @param value Object to test for its no emptyness.\r\n     * @returns True if the object is an empty string.\r\n     */\n\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty(value) {\n      return !StringHelper.isString(value) || value.length === 0;\n    }\n    /**\r\n     * Is the string all ASCII characters.\r\n     * @param value string to test if is is ASCII.\r\n     * @returns True if the object is all ASCII.\r\n     */\n\n  }, {\n    key: \"isAscii\",\n    value: function isAscii(value) {\n      return value === null || value === undefined ? false : /^[\\x00-\\xFF]*$/.test(value);\n    }\n    /**\r\n     * Encode non ASCII characters with control characters.\r\n     * @param value The string value to escape.\r\n     * @returns The escaped version of the string.\r\n     */\n\n  }, {\n    key: \"encodeNonASCII\",\n    value: function encodeNonASCII(value) {\n      return StringHelper.isString(value) ? value.replace(/[\\u007F-\\uFFFF]/g, function (chr) {\n        return \"\\\\u\".concat(\"0000\".concat(chr.charCodeAt(0).toString(16)).substr(-4));\n      }) : undefined;\n    }\n    /**\r\n     * Decode control characters to ASCII.\r\n     * @param value The encoded string to convert back to ASCII.\r\n     * @returns The decoded version of the string.\r\n     */\n\n  }, {\n    key: \"decodeNonASCII\",\n    value: function decodeNonASCII(value) {\n      return StringHelper.isString(value) ? value.replace(/\\\\u([\\d\\w]{4})/gi, function (match, grp) {\n        return String.fromCharCode(parseInt(grp, 16));\n      }) : undefined;\n    }\n  }]);\n\n  return StringHelper;\n}();\n\nexports.StringHelper = StringHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/helpers/stringHelper.js?");

/***/ }),

/***/ "../iota-pico-core/dist/index.js":
/*!***************************************!*\
  !*** ../iota-pico-core/dist/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./error/coreError */ \"../iota-pico-core/dist/error/coreError.js\"));\n\n__export(__webpack_require__(/*! ./factories/factoryBase */ \"../iota-pico-core/dist/factories/factoryBase.js\"));\n\n__export(__webpack_require__(/*! ./factories/networkClientFactory */ \"../iota-pico-core/dist/factories/networkClientFactory.js\"));\n\n__export(__webpack_require__(/*! ./helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/errorHelper */ \"../iota-pico-core/dist/helpers/errorHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/jsonHelper */ \"../iota-pico-core/dist/helpers/jsonHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\"));\n\n__export(__webpack_require__(/*! ./helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\"));\n\n__export(__webpack_require__(/*! ./loggers/consoleLogger */ \"../iota-pico-core/dist/loggers/consoleLogger.js\"));\n\n__export(__webpack_require__(/*! ./loggers/nullLogger */ \"../iota-pico-core/dist/loggers/nullLogger.js\"));\n\n__export(__webpack_require__(/*! ./network/networkEndPoint */ \"../iota-pico-core/dist/network/networkEndPoint.js\"));\n\n__export(__webpack_require__(/*! ./services/backgroundTaskService */ \"../iota-pico-core/dist/services/backgroundTaskService.js\"));\n\n__export(__webpack_require__(/*! ./services/timeService */ \"../iota-pico-core/dist/services/timeService.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/index.js?");

/***/ }),

/***/ "../iota-pico-core/dist/loggers/consoleLogger.js":
/*!*******************************************************!*\
  !*** ../iota-pico-core/dist/loggers/consoleLogger.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! ../helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar errorHelper_1 = __webpack_require__(/*! ../helpers/errorHelper */ \"../iota-pico-core/dist/helpers/errorHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! ../helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! ../helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n/**\r\n * Implementation of ILogger which sends to the this._loggingObject.\r\n */\n// tslint:disable:no-console\n\n\nvar ConsoleLogger =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create and instance of the console logger.\r\n   */\n  function ConsoleLogger(loggingObject) {\n    _classCallCheck(this, ConsoleLogger);\n\n    this._loggingObject = loggingObject || console;\n  }\n  /**\r\n   * Send banner to the logger.\r\n   * @param message The message to log.\r\n   * @param args Additional parameters to log.\r\n   */\n\n\n  _createClass(ConsoleLogger, [{\n    key: \"banner\",\n    value: function banner(message) {\n      this._loggingObject.log(\"=\".repeat(80));\n\n      this._loggingObject.log(message);\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      this.logArgs(this._loggingObject.log, args);\n\n      this._loggingObject.log(\"=\".repeat(80));\n    }\n    /**\r\n     * Send log to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(message) {\n      this._loggingObject.log(message);\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      this.logArgs(this._loggingObject.log, args);\n    }\n    /**\r\n     * Send information to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"info\",\n    value: function info(message) {\n      this._loggingObject.info(message);\n\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      this.logArgs(this._loggingObject.info, args);\n    }\n    /**\r\n     * Send warning to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"warning\",\n    value: function warning(message) {\n      this._loggingObject.warn(message);\n\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        args[_key4 - 1] = arguments[_key4];\n      }\n\n      this.logArgs(this._loggingObject.warn, args);\n    }\n    /**\r\n     * Send error to the logger.\r\n     * @param message The message to log.\r\n     * @param err An error object to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(message, err) {\n      var _this = this;\n\n      this._loggingObject.error(message);\n\n      if (!objectHelper_1.ObjectHelper.isEmpty(err)) {\n        var lines = errorHelper_1.ErrorHelper.format(err, true).split(\"\\n\");\n        lines.forEach(function (line) {\n          _this._loggingObject.error(\"\\t\".concat(line));\n        });\n      }\n\n      for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n        args[_key5 - 2] = arguments[_key5];\n      }\n\n      this.logArgs(this._loggingObject.error, args);\n    }\n    /* @internal */\n\n  }, {\n    key: \"logArgs\",\n    value: function logArgs(logMethod, args) {\n      var _this2 = this;\n\n      if (!arrayHelper_1.ArrayHelper.isEmpty(args)) {\n        var indent = \"\\t\";\n\n        if (args.length === 1) {\n          if (!objectHelper_1.ObjectHelper.isEmpty(args[0])) {\n            this.logItem(indent, \"\", args[0], logMethod);\n          }\n        } else {\n          args.forEach(function (arg, index) {\n            _this2.logItem(indent, index.toString(), arg, logMethod);\n          });\n        }\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"logItem\",\n    value: function logItem(indent, key, item, logMethod) {\n      var _this3 = this;\n\n      if (arrayHelper_1.ArrayHelper.isArray(item)) {\n        var newIndent = \"\".concat(indent, \"\\t\");\n\n        if (stringHelper_1.StringHelper.isEmpty(key)) {\n          logMethod(\"\".concat(indent, \" [\"));\n        } else {\n          logMethod(\"\".concat(indent).concat(key, \": [\"));\n        }\n\n        item.forEach(function (element, index) {\n          _this3.logItem(newIndent, \"\", element, logMethod);\n        });\n        logMethod(\"\".concat(indent, \"]\"));\n      } else if (objectHelper_1.ObjectHelper.isObject(item)) {\n        var _newIndent = \"\".concat(indent, \"\\t\");\n\n        if (stringHelper_1.StringHelper.isEmpty(key)) {\n          logMethod(\"\".concat(indent, \" {\"));\n        } else {\n          logMethod(\"\".concat(indent).concat(key, \": {\"));\n        }\n\n        for (var key2 in item) {\n          this.logItem(_newIndent, key2, item[key2], logMethod);\n        }\n\n        logMethod(\"\".concat(indent, \"}\"));\n      } else {\n        if (stringHelper_1.StringHelper.isEmpty(key)) {\n          logMethod(\"\".concat(indent).concat(item));\n        } else {\n          logMethod(\"\".concat(indent).concat(key, \": \").concat(item));\n        }\n      }\n    }\n  }]);\n\n  return ConsoleLogger;\n}();\n\nexports.ConsoleLogger = ConsoleLogger;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/loggers/consoleLogger.js?");

/***/ }),

/***/ "../iota-pico-core/dist/loggers/nullLogger.js":
/*!****************************************************!*\
  !*** ../iota-pico-core/dist/loggers/nullLogger.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Implementation of ILogger which is silent.\r\n */\n\nvar NullLogger =\n/*#__PURE__*/\nfunction () {\n  function NullLogger() {\n    _classCallCheck(this, NullLogger);\n  }\n\n  _createClass(NullLogger, [{\n    key: \"banner\",\n\n    /**\r\n     * Send banner to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n    value: function banner(message) {}\n    /**\r\n     * Send log to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(message) {}\n    /**\r\n     * Send information to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"info\",\n    value: function info(message) {}\n    /**\r\n     * Send warning to the logger.\r\n     * @param message The message to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"warning\",\n    value: function warning(message) {}\n    /**\r\n     * Send error to the logger.\r\n     * @param message The message to log.\r\n     * @param err An error object to log.\r\n     * @param args Additional parameters to log.\r\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(message, err) {}\n  }]);\n\n  return NullLogger;\n}();\n\nexports.NullLogger = NullLogger;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/loggers/nullLogger.js?");

/***/ }),

/***/ "../iota-pico-core/dist/network/networkEndPoint.js":
/*!*********************************************************!*\
  !*** ../iota-pico-core/dist/network/networkEndPoint.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! ../error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! ../helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! ../helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! ../helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n/**\r\n * Default implementation of a network endpoint.\r\n */\n\n\nvar NetworkEndPoint =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create an instance of NetworkEndPoint.\r\n   * @param protocol The protocol to access the endpoint with.\r\n   * @param host The host name or ip of the endpoint.\r\n   * @param port The port of the endpoint.\r\n   * @param rootPath The path to the endpoint.\r\n   */\n  function NetworkEndPoint(protocol, host, port, rootPath) {\n    _classCallCheck(this, NetworkEndPoint);\n\n    if (!stringHelper_1.StringHelper.isString(protocol) || !/http|https/.test(protocol)) {\n      throw new coreError_1.CoreError(\"The protocol must be defined as http or https\");\n    }\n\n    if (!stringHelper_1.StringHelper.isString(host)) {\n      throw new coreError_1.CoreError(\"The host must be defined\");\n    }\n\n    if (!numberHelper_1.NumberHelper.isInteger(port) || port <= 0) {\n      throw new coreError_1.CoreError(\"The port must be a number greater than zero\");\n    }\n\n    if (!objectHelper_1.ObjectHelper.isEmpty(rootPath) && !stringHelper_1.StringHelper.isString(rootPath)) {\n      throw new coreError_1.CoreError(\"The rootPath must be a valid string\");\n    }\n\n    this._protocol = protocol;\n    this._host = host.replace(/^\\/*/, \"\").replace(/\\/*$/, \"\");\n    this._port = port;\n    this._rootPath = (rootPath || \"\").replace(/^\\/*/, \"\").replace(/\\/*$/, \"\");\n  }\n  /**\r\n   * The protocol to access the endpoint with.\r\n   * @return The protocol.\r\n   */\n\n\n  _createClass(NetworkEndPoint, [{\n    key: \"getProtocol\",\n    value: function getProtocol() {\n      return this._protocol;\n    }\n    /**\r\n     * The host name or ip of the endpoint.\r\n     * @returns The host.\r\n     */\n\n  }, {\n    key: \"getHost\",\n    value: function getHost() {\n      return this._host;\n    }\n    /**\r\n     * The path to the endpoint.\r\n     * @returns The path.\r\n     */\n\n  }, {\n    key: \"getRootPath\",\n    value: function getRootPath() {\n      return this._rootPath;\n    }\n    /**\r\n     * The port of the endpoint.\r\n     * @returns The port.\r\n     */\n\n  }, {\n    key: \"getPort\",\n    value: function getPort() {\n      return this._port;\n    }\n    /**\r\n     * The complete uri.\r\n     * @returns The uri.\r\n     */\n\n  }, {\n    key: \"getUri\",\n    value: function getUri() {\n      return \"\".concat(this._protocol, \"://\").concat(this._host, \":\").concat(this._port, \"/\").concat(this._rootPath);\n    }\n  }]);\n\n  return NetworkEndPoint;\n}();\n\nexports.NetworkEndPoint = NetworkEndPoint;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/network/networkEndPoint.js?");

/***/ }),

/***/ "../iota-pico-core/dist/services/backgroundTaskService.js":
/*!****************************************************************!*\
  !*** ../iota-pico-core/dist/services/backgroundTaskService.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Default implementation of background task service.\r\n */\n\nvar BackgroundTaskService =\n/*#__PURE__*/\nfunction () {\n  function BackgroundTaskService() {\n    _classCallCheck(this, BackgroundTaskService);\n  }\n\n  _createClass(BackgroundTaskService, [{\n    key: \"create\",\n\n    /**\r\n     * Create a background task.\r\n     * @param task The task to run in the background.\r\n     * @param delay The delay before running the task.\r\n     */\n    value: function () {\n      var _create = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(task, delay) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  setTimeout(function () {\n                    try {\n                      resolve(task());\n                    } catch (err) {\n                      reject(err);\n                    }\n                  }, delay);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function create(_x, _x2) {\n        return _create.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return BackgroundTaskService;\n}();\n\nexports.BackgroundTaskService = BackgroundTaskService;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/services/backgroundTaskService.js?");

/***/ }),

/***/ "../iota-pico-core/dist/services/timeService.js":
/*!******************************************************!*\
  !*** ../iota-pico-core/dist/services/timeService.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Represents a class which can provide the time.\r\n */\n\nvar TimeService =\n/*#__PURE__*/\nfunction () {\n  function TimeService() {\n    _classCallCheck(this, TimeService);\n  }\n\n  _createClass(TimeService, [{\n    key: \"msSinceEpoch\",\n\n    /**\r\n     * Returns the number of milliseconds since 1970/01/01.\r\n     * @returns Number of milliseconds.\r\n     */\n    value: function msSinceEpoch() {\n      return Date.now();\n    }\n  }]);\n\n  return TimeService;\n}();\n\nexports.TimeService = TimeService;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/dist/services/timeService.js?");

/***/ }),

/***/ "../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js":
/*!**************************************************************************!*\
  !*** ../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js":
/*!****************************************************************************!*\
  !*** ../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-core/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-core/node_modules/regenerator-runtime/runtime.js":
/*!*********************************************************************!*\
  !*** ../iota-pico-core/node_modules/regenerator-runtime/runtime.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-core/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/digests/sha3.js":
/*!************************************************!*\
  !*** ../iota-pico-crypto/dist/digests/sha3.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n/**\r\n * Sha3 implementation.\r\n */\n\n\nvar Sha3 =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of SHA3.\r\n   * @param bits The number of input bits.\r\n   * @param padding The padding to use.\r\n   * @param outputBits The number of output bits.\r\n   */\n  function Sha3(bits, padding, outputBits) {\n    _classCallCheck(this, Sha3);\n\n    this._padding = padding;\n    this._outputBits = outputBits;\n    this._blockCount = 1600 - (bits << 1) >> 5;\n    this._byteCount = this._blockCount << 2;\n    this._outputBlocks = outputBits >> 5;\n    this._extraBytes = (outputBits & 31) >> 3;\n    this.reset();\n  }\n  /**\r\n   * Reset the digest.\r\n   */\n\n\n  _createClass(Sha3, [{\n    key: \"reset\",\n    value: function reset() {\n      this._reset = true;\n      this._block = 0;\n      this._start = 0;\n      this._blocks = new Uint32Array(this._blockCount + 1);\n      this._state = new Uint32Array(50);\n    }\n    /**\r\n     * Update the digest.\r\n     * @param input Array of data to use in the update.\r\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(input) {\n      if (!objectHelper_1.ObjectHelper.isType(input, ArrayBuffer)) {\n        throw new cryptoError_1.CryptoError(\"Input is not of type ArrayBuffer\");\n      }\n\n      var message = new Uint8Array(input);\n      var length = message.length;\n      var index = 0;\n      var i;\n\n      while (index < length) {\n        if (this._reset) {\n          this._reset = false;\n          this._blocks[0] = this._block;\n\n          for (i = 1; i < this._blockCount + 1; ++i) {\n            this._blocks[i] = 0;\n          }\n        }\n\n        for (i = this._start; index < length && i < this._byteCount; ++index) {\n          this._blocks[i >> 2] |= message[index] << Sha3.SHIFT[i++ & 3];\n        }\n\n        this._lastByteIndex = i;\n\n        if (i >= this._byteCount) {\n          this._start = i - this._byteCount;\n          this._block = this._blocks[this._blockCount];\n\n          for (i = 0; i < this._blockCount; ++i) {\n            this._state[i] ^= this._blocks[i];\n          }\n\n          this.keccakPermutation(this._state);\n          this._reset = true;\n        } else {\n          this._start = i;\n        }\n      }\n    }\n    /**\r\n     * Finalize and return the hash for the digest, will also reset the state.\r\n     * @return Array buffer containing the digest.\r\n     */\n\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      this.finalize();\n      var i = 0;\n      var j = 0;\n      var bytes = this._outputBits >> 3;\n      var buffer;\n\n      if (this._extraBytes) {\n        buffer = new ArrayBuffer(this._outputBlocks + 1 << 2);\n      } else {\n        buffer = new ArrayBuffer(bytes);\n      }\n\n      var array = new Uint32Array(buffer);\n\n      while (j < this._outputBlocks) {\n        for (i = 0; i < this._blockCount && j < this._outputBlocks; ++i, ++j) {\n          array[j] = this._state[i];\n        }\n      }\n\n      if (this._extraBytes) {\n        array[i] = this._state[i];\n        buffer = buffer.slice(0, bytes);\n      }\n\n      this.reset();\n      return buffer;\n    }\n    /* @internal */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      var i = this._lastByteIndex;\n      this._blocks[i >> 2] |= this._padding[i & 3];\n\n      if (this._lastByteIndex === this._byteCount) {\n        this._blocks[0] = this._blocks[this._blockCount];\n\n        for (i = 1; i < this._blockCount + 1; ++i) {\n          this._blocks[i] = 0;\n        }\n      }\n\n      this._blocks[this._blockCount - 1] |= 0x80000000;\n\n      for (i = 0; i < this._blockCount; ++i) {\n        this._state[i] ^= this._blocks[i];\n      }\n\n      this.keccakPermutation(this._state);\n    }\n    /* @internal */\n\n  }, {\n    key: \"keccakPermutation\",\n    value: function keccakPermutation(s) {\n      // tslint:disable-next-line:one-variable-per-declaration\n      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n\n      for (n = 0; n < 48; n += 2) {\n        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n        h = c8 ^ (c2 << 1 | c3 >>> 31);\n        l = c9 ^ (c3 << 1 | c2 >>> 31);\n        s[0] ^= h;\n        s[1] ^= l;\n        s[10] ^= h;\n        s[11] ^= l;\n        s[20] ^= h;\n        s[21] ^= l;\n        s[30] ^= h;\n        s[31] ^= l;\n        s[40] ^= h;\n        s[41] ^= l;\n        h = c0 ^ (c4 << 1 | c5 >>> 31);\n        l = c1 ^ (c5 << 1 | c4 >>> 31);\n        s[2] ^= h;\n        s[3] ^= l;\n        s[12] ^= h;\n        s[13] ^= l;\n        s[22] ^= h;\n        s[23] ^= l;\n        s[32] ^= h;\n        s[33] ^= l;\n        s[42] ^= h;\n        s[43] ^= l;\n        h = c2 ^ (c6 << 1 | c7 >>> 31);\n        l = c3 ^ (c7 << 1 | c6 >>> 31);\n        s[4] ^= h;\n        s[5] ^= l;\n        s[14] ^= h;\n        s[15] ^= l;\n        s[24] ^= h;\n        s[25] ^= l;\n        s[34] ^= h;\n        s[35] ^= l;\n        s[44] ^= h;\n        s[45] ^= l;\n        h = c4 ^ (c8 << 1 | c9 >>> 31);\n        l = c5 ^ (c9 << 1 | c8 >>> 31);\n        s[6] ^= h;\n        s[7] ^= l;\n        s[16] ^= h;\n        s[17] ^= l;\n        s[26] ^= h;\n        s[27] ^= l;\n        s[36] ^= h;\n        s[37] ^= l;\n        s[46] ^= h;\n        s[47] ^= l;\n        h = c6 ^ (c0 << 1 | c1 >>> 31);\n        l = c7 ^ (c1 << 1 | c0 >>> 31);\n        s[8] ^= h;\n        s[9] ^= l;\n        s[18] ^= h;\n        s[19] ^= l;\n        s[28] ^= h;\n        s[29] ^= l;\n        s[38] ^= h;\n        s[39] ^= l;\n        s[48] ^= h;\n        s[49] ^= l;\n        b0 = s[0];\n        b1 = s[1];\n        b32 = s[11] << 4 | s[10] >>> 28;\n        b33 = s[10] << 4 | s[11] >>> 28;\n        b14 = s[20] << 3 | s[21] >>> 29;\n        b15 = s[21] << 3 | s[20] >>> 29;\n        b46 = s[31] << 9 | s[30] >>> 23;\n        b47 = s[30] << 9 | s[31] >>> 23;\n        b28 = s[40] << 18 | s[41] >>> 14;\n        b29 = s[41] << 18 | s[40] >>> 14;\n        b20 = s[2] << 1 | s[3] >>> 31;\n        b21 = s[3] << 1 | s[2] >>> 31;\n        b2 = s[13] << 12 | s[12] >>> 20;\n        b3 = s[12] << 12 | s[13] >>> 20;\n        b34 = s[22] << 10 | s[23] >>> 22;\n        b35 = s[23] << 10 | s[22] >>> 22;\n        b16 = s[33] << 13 | s[32] >>> 19;\n        b17 = s[32] << 13 | s[33] >>> 19;\n        b48 = s[42] << 2 | s[43] >>> 30;\n        b49 = s[43] << 2 | s[42] >>> 30;\n        b40 = s[5] << 30 | s[4] >>> 2;\n        b41 = s[4] << 30 | s[5] >>> 2;\n        b22 = s[14] << 6 | s[15] >>> 26;\n        b23 = s[15] << 6 | s[14] >>> 26;\n        b4 = s[25] << 11 | s[24] >>> 21;\n        b5 = s[24] << 11 | s[25] >>> 21;\n        b36 = s[34] << 15 | s[35] >>> 17;\n        b37 = s[35] << 15 | s[34] >>> 17;\n        b18 = s[45] << 29 | s[44] >>> 3;\n        b19 = s[44] << 29 | s[45] >>> 3;\n        b10 = s[6] << 28 | s[7] >>> 4;\n        b11 = s[7] << 28 | s[6] >>> 4;\n        b42 = s[17] << 23 | s[16] >>> 9;\n        b43 = s[16] << 23 | s[17] >>> 9;\n        b24 = s[26] << 25 | s[27] >>> 7;\n        b25 = s[27] << 25 | s[26] >>> 7;\n        b6 = s[36] << 21 | s[37] >>> 11;\n        b7 = s[37] << 21 | s[36] >>> 11;\n        b38 = s[47] << 24 | s[46] >>> 8;\n        b39 = s[46] << 24 | s[47] >>> 8;\n        b30 = s[8] << 27 | s[9] >>> 5;\n        b31 = s[9] << 27 | s[8] >>> 5;\n        b12 = s[18] << 20 | s[19] >>> 12;\n        b13 = s[19] << 20 | s[18] >>> 12;\n        b44 = s[29] << 7 | s[28] >>> 25;\n        b45 = s[28] << 7 | s[29] >>> 25;\n        b26 = s[38] << 8 | s[39] >>> 24;\n        b27 = s[39] << 8 | s[38] >>> 24;\n        b8 = s[48] << 14 | s[49] >>> 18;\n        b9 = s[49] << 14 | s[48] >>> 18;\n        s[0] = b0 ^ ~b2 & b4;\n        s[1] = b1 ^ ~b3 & b5;\n        s[10] = b10 ^ ~b12 & b14;\n        s[11] = b11 ^ ~b13 & b15;\n        s[20] = b20 ^ ~b22 & b24;\n        s[21] = b21 ^ ~b23 & b25;\n        s[30] = b30 ^ ~b32 & b34;\n        s[31] = b31 ^ ~b33 & b35;\n        s[40] = b40 ^ ~b42 & b44;\n        s[41] = b41 ^ ~b43 & b45;\n        s[2] = b2 ^ ~b4 & b6;\n        s[3] = b3 ^ ~b5 & b7;\n        s[12] = b12 ^ ~b14 & b16;\n        s[13] = b13 ^ ~b15 & b17;\n        s[22] = b22 ^ ~b24 & b26;\n        s[23] = b23 ^ ~b25 & b27;\n        s[32] = b32 ^ ~b34 & b36;\n        s[33] = b33 ^ ~b35 & b37;\n        s[42] = b42 ^ ~b44 & b46;\n        s[43] = b43 ^ ~b45 & b47;\n        s[4] = b4 ^ ~b6 & b8;\n        s[5] = b5 ^ ~b7 & b9;\n        s[14] = b14 ^ ~b16 & b18;\n        s[15] = b15 ^ ~b17 & b19;\n        s[24] = b24 ^ ~b26 & b28;\n        s[25] = b25 ^ ~b27 & b29;\n        s[34] = b34 ^ ~b36 & b38;\n        s[35] = b35 ^ ~b37 & b39;\n        s[44] = b44 ^ ~b46 & b48;\n        s[45] = b45 ^ ~b47 & b49;\n        s[6] = b6 ^ ~b8 & b0;\n        s[7] = b7 ^ ~b9 & b1;\n        s[16] = b16 ^ ~b18 & b10;\n        s[17] = b17 ^ ~b19 & b11;\n        s[26] = b26 ^ ~b28 & b20;\n        s[27] = b27 ^ ~b29 & b21;\n        s[36] = b36 ^ ~b38 & b30;\n        s[37] = b37 ^ ~b39 & b31;\n        s[46] = b46 ^ ~b48 & b40;\n        s[47] = b47 ^ ~b49 & b41;\n        s[8] = b8 ^ ~b0 & b2;\n        s[9] = b9 ^ ~b1 & b3;\n        s[18] = b18 ^ ~b10 & b12;\n        s[19] = b19 ^ ~b11 & b13;\n        s[28] = b28 ^ ~b20 & b22;\n        s[29] = b29 ^ ~b21 & b23;\n        s[38] = b38 ^ ~b30 & b32;\n        s[39] = b39 ^ ~b31 & b33;\n        s[48] = b48 ^ ~b40 & b42;\n        s[49] = b49 ^ ~b41 & b43;\n        s[0] ^= Sha3.ROUND_CONSTANTS[n];\n        s[1] ^= Sha3.ROUND_CONSTANTS[n + 1];\n      }\n    }\n  }]);\n\n  return Sha3;\n}();\n/* Padding to use for Keccak */\n\n\nSha3.KECCAK_PADDING = new Uint32Array([1, 256, 65536, 16777216]);\n/* @internal */\n\nSha3.SHIFT = new Uint8Array([0, 8, 16, 24]);\n/* @internal */\n\nSha3.ROUND_CONSTANTS = new Uint32Array([1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]);\nexports.Sha3 = Sha3;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/digests/sha3.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/error/cryptoError.js":
/*!*****************************************************!*\
  !*** ../iota-pico-crypto/dist/error/cryptoError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n/**\r\n * A crypto implementation of an error.\r\n */\n\n\nvar CryptoError =\n/*#__PURE__*/\nfunction (_coreError_1$CoreErro) {\n  _inherits(CryptoError, _coreError_1$CoreErro);\n\n  function CryptoError() {\n    _classCallCheck(this, CryptoError);\n\n    return _possibleConstructorReturn(this, (CryptoError.__proto__ || Object.getPrototypeOf(CryptoError)).apply(this, arguments));\n  }\n\n  return CryptoError;\n}(coreError_1.CoreError);\n\nexports.CryptoError = CryptoError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/error/cryptoError.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/factories/spongeFactory.js":
/*!***********************************************************!*\
  !*** ../iota-pico-crypto/dist/factories/spongeFactory.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar factoryBase_1 = __webpack_require__(/*! @iota-pico/core/dist/factories/factoryBase */ \"../iota-pico-core/dist/factories/factoryBase.js\");\n\nvar curl_1 = __webpack_require__(/*! ../sponges/curl */ \"../iota-pico-crypto/dist/sponges/curl.js\");\n\nvar kerl_1 = __webpack_require__(/*! ../sponges/kerl */ \"../iota-pico-crypto/dist/sponges/kerl.js\");\n/**\r\n * Factory to generate sponges.\r\n */\n\n\nvar SpongeFactory =\n/*#__PURE__*/\nfunction (_factoryBase_1$Factor) {\n  _inherits(SpongeFactory, _factoryBase_1$Factor);\n\n  /**\r\n   * Don't allow manual construction of the factory.\r\n   * @internal\r\n   */\n  function SpongeFactory() {\n    _classCallCheck(this, SpongeFactory);\n\n    return _possibleConstructorReturn(this, (SpongeFactory.__proto__ || Object.getPrototypeOf(SpongeFactory)).call(this));\n  }\n  /**\r\n   * Get the instance of the factory.\r\n   * @returns The factory instance.\r\n   */\n\n\n  _createClass(SpongeFactory, [{\n    key: \"getInstance\",\n\n    /* @internal */\n    value: function getInstance() {\n      return SpongeFactory.instance();\n    }\n  }], [{\n    key: \"instance\",\n    value: function instance() {\n      if (!SpongeFactory._instance) {\n        SpongeFactory._instance = new SpongeFactory();\n\n        SpongeFactory._instance.register(\"curl\", function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return new (Function.prototype.bind.apply(curl_1.Curl, [null].concat(args)))();\n        });\n\n        SpongeFactory._instance.register(\"kerl\", function () {\n          return new kerl_1.Kerl();\n        });\n      }\n\n      return SpongeFactory._instance;\n    }\n  }]);\n\n  return SpongeFactory;\n}(factoryBase_1.FactoryBase);\n\nexports.SpongeFactory = SpongeFactory;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/factories/spongeFactory.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/helpers/bigIntegerHelper.js":
/*!************************************************************!*\
  !*** ../iota-pico-crypto/dist/helpers/bigIntegerHelper.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\"); // tslint:disable-next-line:import-name\n\n\nvar big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ \"big-integer\"));\n\nvar cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n/**\r\n * Helper class to convert between BigInteger and other types.\r\n * Converted from https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java\r\n */\n\n\nvar BigIntegerHelper =\n/*#__PURE__*/\nfunction () {\n  function BigIntegerHelper() {\n    _classCallCheck(this, BigIntegerHelper);\n  }\n\n  _createClass(BigIntegerHelper, null, [{\n    key: \"tritsToBigInteger\",\n\n    /**\r\n     * Convert trits to a bigInteger.\r\n     * @param trits The trits to convert.\r\n     * @param offset Offset within the array to start.\r\n     * @param length The length of the trits array to convert.\r\n     */\n    value: function tritsToBigInteger(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"The trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"The offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new cryptoError_1.CryptoError(\"The length must be a number > 0\");\n      }\n\n      if (offset + length > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the array\");\n      }\n\n      var value = big_integer_1.default.zero;\n\n      for (var i = length - 1; i >= 0; i--) {\n        value = value.multiply(BigIntegerHelper.RADIX).add(big_integer_1.default(trits[offset + i]));\n      }\n\n      return value;\n    }\n    /**\r\n     * Convert bigInteger to trits.\r\n     * @param value The bigInteger to convert to trits.\r\n     * @param trits The array to receive the trits.\r\n     * @param offset The offset to place the trits in the array.\r\n     * @param length The length of the array.\r\n     */\n\n  }, {\n    key: \"bigIntegerToTrits\",\n    value: function bigIntegerToTrits(value, trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {\n        throw new cryptoError_1.CryptoError(\"The value must be a bigInteger type\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array)) {\n        throw new cryptoError_1.CryptoError(\"The trits must be an Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"The offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new cryptoError_1.CryptoError(\"The length must be a number > 0\");\n      }\n\n      if (offset + length > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the array\");\n      }\n\n      var absoluteValue = value.compareTo(big_integer_1.default.zero) < 0 ? value.negate() : value;\n\n      for (var i = 0; i < length; i++) {\n        var divRemainder = absoluteValue.divmod(BigIntegerHelper.RADIX);\n        absoluteValue = divRemainder.quotient;\n        var remainder = divRemainder.remainder;\n\n        if (remainder > BigIntegerHelper.MAX_TRIT_VALUE) {\n          remainder = BigIntegerHelper.MIN_TRIT_VALUE;\n          absoluteValue = absoluteValue.add(big_integer_1.default[\"1\"]);\n        }\n\n        trits[offset + i] = remainder.toJSNumber();\n      }\n\n      if (value.compareTo(big_integer_1.default.zero) < 0) {\n        for (var _i = 0; _i < length; _i++) {\n          // Avoid negative zero\n          trits[offset + _i] = trits[offset + _i] === 0 ? 0 : -trits[offset + _i];\n        }\n      }\n    }\n    /**\r\n     * Convert the bigInteger into bytes.\r\n     * @param value The value to convert.\r\n     * @param destination The destination array to store the bytes.\r\n     * @param offset The offset within the array to store the bytes.\r\n     */\n\n  }, {\n    key: \"bigIntegerToBytes\",\n    value: function bigIntegerToBytes(value, destination, offset) {\n      if (!objectHelper_1.ObjectHelper.isType(value, big_integer_1.default)) {\n        throw new cryptoError_1.CryptoError(\"The value must be a bigInteger type\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(destination, ArrayBuffer) || destination.byteLength === 0) {\n        throw new cryptoError_1.CryptoError(\"The destination must be an array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"The offset must be a number >= 0\");\n      }\n\n      if (destination.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {\n        throw new cryptoError_1.CryptoError(\"Destination array has invalid size, it must be at least \".concat(BigIntegerHelper.BYTE_HASH_LENGTH));\n      } // Remember if it is negative for later\n\n\n      var isNeg = value.isNegative() ? -1 : 0;\n      var hexString = value.toString(16);\n\n      if (isNeg === -1) {\n        // But remove it for now\n        hexString = hexString.slice(1);\n      } // Now make sure the hex string is an even length so the regex works\n\n\n      if (hexString.length % 2 === 1) {\n        hexString = \"0\".concat(hexString);\n      }\n\n      var matches = hexString.match(/[0-9a-f]{2}/g); // Convert the hex to numbers\n\n      var signedBytes = new Int8Array(matches.map(function (hex) {\n        return parseInt(\"0x\".concat(hex), 16);\n      }));\n\n      if (isNeg === -1) {\n        BigIntegerHelper.twosComplement(signedBytes);\n      }\n\n      var dataView = new DataView(destination); // Pad the start of the buffer with the neg value\n\n      var i = offset;\n\n      while (i + signedBytes.length < BigIntegerHelper.BYTE_HASH_LENGTH) {\n        dataView.setInt8(i++, isNeg);\n      } // And copy in the actual bytes\n\n\n      for (var j = signedBytes.length; j-- > 0;) {\n        dataView.setInt8(i++, signedBytes[signedBytes.length - 1 - j]);\n      }\n    }\n    /**\r\n     * Convert bytes to a bigInteger.\r\n     * @param source The source bytes.\r\n     * @param offset The offset within the bytes to start conversion.\r\n     * @param length The length of the bytes to use for conversion.\r\n     */\n\n  }, {\n    key: \"bytesToBigInteger\",\n    value: function bytesToBigInteger(source, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(source, ArrayBuffer) || source.byteLength === 0) {\n        throw new cryptoError_1.CryptoError(\"The source must be a non empty number array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"The offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new cryptoError_1.CryptoError(\"The length must be a number > 0\");\n      }\n\n      if (source.byteLength - offset < BigIntegerHelper.BYTE_HASH_LENGTH) {\n        throw new cryptoError_1.CryptoError(\"Source array has invalid size, it must be at least \".concat(BigIntegerHelper.BYTE_HASH_LENGTH));\n      }\n\n      var dataView = new DataView(source);\n      var signedBytes = new Int8Array(dataView.byteLength);\n\n      for (var b = 0; b < dataView.byteLength; b++) {\n        signedBytes[b] = dataView.getInt8(b + offset);\n      } // Remove the initial padding leaving at least one byte\n\n\n      var paddingOffset = 0;\n      var firstByte = signedBytes[0];\n      var isNeg = firstByte < 0; // If the first padding character is negative then reverse the 2s complement\n      // but first strip of the leading padding\n\n      if (firstByte === 0 || firstByte === -1) {\n        while (signedBytes[paddingOffset] === firstByte && paddingOffset < signedBytes.length - 1) {\n          paddingOffset++;\n        } // Strip any padding\n\n\n        signedBytes = signedBytes.slice(paddingOffset);\n      }\n\n      if (isNeg) {\n        BigIntegerHelper.twosComplement(signedBytes);\n      }\n\n      var hexString = isNeg ? \"-\" : \"\";\n      var dv = new DataView(signedBytes.buffer);\n\n      for (var h = 0; h < dv.byteLength; h++) {\n        hexString += \"00\".concat(dv.getUint8(h).toString(16)).slice(-2);\n      }\n\n      return big_integer_1.default(hexString, 16);\n    }\n    /* @internal */\n\n  }, {\n    key: \"twosComplement\",\n    value: function twosComplement(signedBytes) {\n      // if the whole number is negative then\n      // change to 2's complements by noting all the numbers\n      // and adding 1 to the last i.e. ~bignum+1\n      for (var b = 0; b < signedBytes.length; b++) {\n        signedBytes[b] = ~signedBytes[b];\n      } // Add 1 to last number, if the number is 0xFF continue to carry\n\n\n      var c = signedBytes.length - 1;\n\n      do {\n        signedBytes[c]++;\n      } while (signedBytes[c--] === 0 && c > 0);\n    }\n  }]);\n\n  return BigIntegerHelper;\n}();\n/* @internal */\n\n\nBigIntegerHelper.RADIX = big_integer_1.default(3);\n/* @internal */\n\nBigIntegerHelper.MAX_TRIT_VALUE = BigIntegerHelper.RADIX.minus(1).divide(2);\n/* @internal */\n\nBigIntegerHelper.MIN_TRIT_VALUE = BigIntegerHelper.MAX_TRIT_VALUE.negate();\n/* @internal */\n\nBigIntegerHelper.BIT_HASH_LENGTH = 384;\n/* @internal */\n\nBigIntegerHelper.BYTE_HASH_LENGTH = BigIntegerHelper.BIT_HASH_LENGTH / 8;\nexports.BigIntegerHelper = BigIntegerHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/helpers/bigIntegerHelper.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/index.js":
/*!*****************************************!*\
  !*** ../iota-pico-crypto/dist/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./digests/sha3 */ \"../iota-pico-crypto/dist/digests/sha3.js\"));\n\n__export(__webpack_require__(/*! ./error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\"));\n\n__export(__webpack_require__(/*! ./factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\"));\n\n__export(__webpack_require__(/*! ./helpers/bigIntegerHelper */ \"../iota-pico-crypto/dist/helpers/bigIntegerHelper.js\"));\n\n__export(__webpack_require__(/*! ./sponges/curl */ \"../iota-pico-crypto/dist/sponges/curl.js\"));\n\n__export(__webpack_require__(/*! ./sponges/kerl */ \"../iota-pico-crypto/dist/sponges/kerl.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/index.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/sponges/curl.js":
/*!************************************************!*\
  !*** ../iota-pico-crypto/dist/sponges/curl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n/**\r\n * Implementation of ISponge using Curl algorithm.\r\n * https://github.com/iotaledger/iota.lib.js/blob/master/lib/crypto/curl/curl.js\r\n */\n\n\nvar Curl =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of Curl.\r\n   * @param rounds The number of rounds to use.\r\n   */\n  function Curl() {\n    var rounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Curl.NUMBER_OF_ROUNDS;\n\n    _classCallCheck(this, Curl);\n\n    this._numberOfRounds = rounds;\n  }\n  /**\r\n   * Get the constant for the hasher.\r\n   * @returns The constants.\r\n   */\n\n\n  _createClass(Curl, [{\n    key: \"getConstants\",\n    value: function getConstants() {\n      return {\n        HASH_LENGTH: Curl.HASH_LENGTH,\n        STATE_LENGTH: Curl.STATE_LENGTH,\n        NUMBER_OF_ROUNDS: this._numberOfRounds\n      };\n    }\n    /**\r\n     * Get the state.\r\n     * @returns The state.\r\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this._state;\n    }\n    /**\r\n     * Initialise the hasher.\r\n     * @param state The initial state for the hasher.\r\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize(state) {\n      if (state) {\n        this._state = state;\n      } else {\n        this._state = new Int8Array(Curl.STATE_LENGTH);\n      }\n    }\n    /**\r\n     * Reset the hasher.\r\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.initialize();\n    }\n    /**\r\n     * Absorb trits into the hash.\r\n     * @param trits The trits to absorb.\r\n     * @param offset The offset into the trits to absorb from.\r\n     * @param length The number of trits to absorb.\r\n     */\n\n  }, {\n    key: \"absorb\",\n    value: function absorb(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"Trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"Offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a number >= 0\");\n      }\n\n      if (length + offset > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the trits\");\n      }\n\n      var localOffset = offset;\n      var localLength = length;\n\n      do {\n        var i = 0;\n        var limit = localLength < Curl.HASH_LENGTH ? localLength : Curl.HASH_LENGTH;\n\n        while (i < limit) {\n          this._state[i++] = trits[localOffset++];\n        }\n\n        this.transform();\n        localLength -= Curl.HASH_LENGTH;\n      } while (localLength > 0);\n    }\n    /**\r\n     * Squeeze trits into the hash.\r\n     * @param trits The trits to squeeze.\r\n     * @param offset The offset into the trits to squeeze from.\r\n     * @param length The number of trits to squeeze.\r\n     */\n\n  }, {\n    key: \"squeeze\",\n    value: function squeeze(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"Trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"Offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a number >= 0\");\n      }\n\n      if (length + offset > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the trits\");\n      }\n\n      var localOffset = offset;\n      var localLength = length;\n\n      do {\n        var i = 0;\n        var limit = localLength < Curl.HASH_LENGTH ? length : Curl.HASH_LENGTH;\n\n        while (i < limit) {\n          trits[localOffset++] = this._state[i++];\n        }\n\n        this.transform();\n        localLength -= Curl.HASH_LENGTH;\n      } while (localLength > 0);\n    }\n    /**\r\n     * Transform the hash.\r\n     * @internal\r\n     */\n\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      var stateCopy;\n      var index = 0;\n\n      for (var round = 0; round < this._numberOfRounds; round++) {\n        stateCopy = new Int8Array(this._state.slice());\n\n        for (var i = 0; i < Curl.STATE_LENGTH; i++) {\n          this._state[i] = Curl.TRUTH_TABLE[stateCopy[index] + (stateCopy[index += index < 365 ? 364 : -365] << 2) + 5];\n        }\n      }\n    }\n  }]);\n\n  return Curl;\n}();\n\nCurl.HASH_LENGTH = 243;\nCurl.NUMBER_OF_ROUNDS = 81;\nCurl.STATE_LENGTH = Curl.HASH_LENGTH * 3;\n/* @internal */\n\nCurl.TRUTH_TABLE = new Int8Array([1, 0, -1, 2, 1, -1, 0, 2, -1, 1, 0]);\nexports.Curl = Curl;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/sponges/curl.js?");

/***/ }),

/***/ "../iota-pico-crypto/dist/sponges/kerl.js":
/*!************************************************!*\
  !*** ../iota-pico-crypto/dist/sponges/kerl.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar sha3_1 = __webpack_require__(/*! ../digests/sha3 */ \"../iota-pico-crypto/dist/digests/sha3.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! ../error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar bigIntegerHelper_1 = __webpack_require__(/*! ../helpers/bigIntegerHelper */ \"../iota-pico-crypto/dist/helpers/bigIntegerHelper.js\");\n/**\r\n * Implementation of ISponge using Kerl algorithm.\r\n * https://github.com/iotaledger/iri/blob/dev/src/main/java/com/iota/iri/hash/Kerl.java\r\n */\n\n\nvar Kerl =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of Kerl.\r\n   */\n  function Kerl() {\n    _classCallCheck(this, Kerl);\n\n    this._keccak = new sha3_1.Sha3(384, sha3_1.Sha3.KECCAK_PADDING, 384);\n  }\n  /**\r\n   * Get the constant for the hasher.\r\n   * @returns The constants.\r\n   */\n\n\n  _createClass(Kerl, [{\n    key: \"getConstants\",\n    value: function getConstants() {\n      return {\n        HASH_LENGTH: Kerl.HASH_LENGTH,\n        BIT_HASH_LENGTH: Kerl.BIT_HASH_LENGTH,\n        BYTE_HASH_LENGTH: Kerl.BYTE_HASH_LENGTH\n      };\n    }\n    /**\r\n     * Get the state.\r\n     * @returns The state.\r\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return undefined;\n    }\n    /**\r\n     * Initialise the hasher.\r\n     * @param state The initial state for the hasher.\r\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize(state) {}\n    /**\r\n     * Reset the hasher.\r\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._keccak.reset();\n    }\n    /**\r\n     * Absorb trits into the hash.\r\n     * @param trits The trits to absorb.\r\n     * @param offset The offset into the trits to absorb from.\r\n     * @param length The number of trits to absorb.\r\n     */\n\n  }, {\n    key: \"absorb\",\n    value: function absorb(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"Trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"Offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a number >= 0\");\n      }\n\n      if (length + offset > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the trits\");\n      }\n\n      if (length % 243 !== 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a multiple of \".concat(Kerl.HASH_LENGTH), {\n          length: length\n        });\n      }\n\n      var localOffset = offset;\n      var localLength = length;\n\n      do {\n        var tritState = trits.slice(localOffset, localOffset + Kerl.HASH_LENGTH);\n        tritState[Kerl.HASH_LENGTH - 1] = 0;\n        var bigInt = bigIntegerHelper_1.BigIntegerHelper.tritsToBigInteger(tritState, 0, tritState.length);\n        var byteState = new ArrayBuffer(Kerl.BYTE_HASH_LENGTH);\n        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToBytes(bigInt, byteState, 0);\n\n        this._keccak.update(byteState);\n\n        localOffset += Kerl.HASH_LENGTH;\n        localLength -= Kerl.HASH_LENGTH;\n      } while (localLength > 0);\n    }\n    /**\r\n     * Squeeze trits into the hash.\r\n     * @param trits The trits to squeeze.\r\n     * @param offset The offset into the trits to squeeze from.\r\n     * @param length The number of trits to squeeze.\r\n     */\n\n  }, {\n    key: \"squeeze\",\n    value: function squeeze(trits, offset, length) {\n      if (!objectHelper_1.ObjectHelper.isType(trits, Int8Array) || trits.length === 0) {\n        throw new cryptoError_1.CryptoError(\"Trits must be a non empty Int8Array\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(offset) || offset < 0) {\n        throw new cryptoError_1.CryptoError(\"Offset must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a number >= 0\");\n      }\n\n      if (length + offset > trits.length) {\n        throw new cryptoError_1.CryptoError(\"The offset + length is beyond the length of the trits\");\n      }\n\n      if (length % 243 !== 0) {\n        throw new cryptoError_1.CryptoError(\"Length must be a multiple of \".concat(Kerl.HASH_LENGTH), {\n          length: length\n        });\n      }\n\n      var localOffset = offset;\n      var localLength = length;\n\n      do {\n        var byteStateBuffer = this._keccak.digest();\n\n        var bigInt = bigIntegerHelper_1.BigIntegerHelper.bytesToBigInteger(byteStateBuffer, 0, Kerl.BYTE_HASH_LENGTH);\n        var tritState = new Int8Array(Kerl.HASH_LENGTH);\n        bigIntegerHelper_1.BigIntegerHelper.bigIntegerToTrits(bigInt, tritState, 0, Kerl.HASH_LENGTH);\n        tritState[Kerl.HASH_LENGTH - 1] = 0;\n        var i = 0;\n\n        while (i < Kerl.HASH_LENGTH) {\n          trits[localOffset++] = tritState[i++];\n        }\n\n        var dv = new DataView(byteStateBuffer);\n\n        for (i = 0; i < dv.byteLength; i++) {\n          dv.setUint8(i, dv.getUint8(i) ^ 0xFF);\n        }\n\n        this._keccak.update(byteStateBuffer);\n\n        localLength -= Kerl.HASH_LENGTH;\n      } while (localLength > 0);\n    }\n  }]);\n\n  return Kerl;\n}();\n/* @internal */\n\n\nKerl.HASH_LENGTH = 243;\n/* @internal */\n\nKerl.BIT_HASH_LENGTH = 384;\n/* @internal */\n\nKerl.BYTE_HASH_LENGTH = Kerl.BIT_HASH_LENGTH / 8;\nexports.Kerl = Kerl;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-crypto/dist/sponges/kerl.js?");

/***/ }),

/***/ "../iota-pico-data/dist/converters/asciiTrytesConverter.js":
/*!*****************************************************************!*\
  !*** ../iota-pico-data/dist/converters/asciiTrytesConverter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar trytes_1 = __webpack_require__(/*! ../data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n/**\r\n * Trytes converter that converts to and from a string.\r\n */\n\n\nvar AsciiTrytesConverter =\n/*#__PURE__*/\nfunction () {\n  function AsciiTrytesConverter() {\n    _classCallCheck(this, AsciiTrytesConverter);\n  }\n\n  _createClass(AsciiTrytesConverter, [{\n    key: \"to\",\n\n    /**\r\n     * Convert a string value into trytes.\r\n     * @param string value to convert into trytes.\r\n     * @returns The trytes representation of the value.\r\n     */\n    value: function to(value) {\n      if (!stringHelper_1.StringHelper.isString(value)) {\n        throw new dataError_1.DataError(\"The value must not be string\", {\n          value: value\n        });\n      }\n\n      if (!stringHelper_1.StringHelper.isAscii(value)) {\n        throw new dataError_1.DataError(\"The value contains non ASCII characters\", {\n          value: value\n        });\n      }\n\n      var trytes = \"\";\n\n      for (var i = 0; i < value.length; i++) {\n        var asciiValue = value.charCodeAt(i);\n        var firstValue = asciiValue % 27;\n        var secondValue = (asciiValue - firstValue) / 27;\n        trytes += trytes_1.Trytes.ALPHABET[firstValue] + trytes_1.Trytes.ALPHABET[secondValue];\n      }\n\n      return trytes_1.Trytes.fromString(trytes);\n    }\n    /**\r\n     * Convert trytes into a string value.\r\n     * @param trytes to convert into a string value.\r\n     * @returns The string value converted from the trytes.\r\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(trytes) {\n      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The trytes parameter is empty or not the correct type\");\n      }\n\n      var trytesString = trytes.toString();\n\n      if (trytesString.length % 2 === 1) {\n        throw new dataError_1.DataError(\"The trytes length must be an even number\");\n      }\n\n      var ascii = \"\";\n\n      for (var i = 0; i < trytesString.length; i += 2) {\n        var trytesPair = trytesString[i] + trytesString[i + 1];\n        var firstValue = trytes_1.Trytes.ALPHABET.indexOf(trytesPair[0]);\n        var secondValue = trytes_1.Trytes.ALPHABET.indexOf(trytesPair[1]);\n        var decimalValue = firstValue + secondValue * 27;\n        ascii += String.fromCharCode(decimalValue);\n      }\n\n      return ascii;\n    }\n  }]);\n\n  return AsciiTrytesConverter;\n}();\n\nexports.AsciiTrytesConverter = AsciiTrytesConverter;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/converters/asciiTrytesConverter.js?");

/***/ }),

/***/ "../iota-pico-data/dist/converters/objectTrytesConverter.js":
/*!******************************************************************!*\
  !*** ../iota-pico-data/dist/converters/objectTrytesConverter.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar jsonHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/jsonHelper */ \"../iota-pico-core/dist/helpers/jsonHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar trytes_1 = __webpack_require__(/*! ../data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar asciiTrytesConverter_1 = __webpack_require__(/*! ./asciiTrytesConverter */ \"../iota-pico-data/dist/converters/asciiTrytesConverter.js\");\n/**\r\n * Trytes converter that converts to and from an object.\r\n * @typeparam T The generic type for the conversion methods.\r\n */\n\n\nvar ObjectTrytesConverter =\n/*#__PURE__*/\nfunction () {\n  function ObjectTrytesConverter() {\n    _classCallCheck(this, ObjectTrytesConverter);\n  }\n\n  _createClass(ObjectTrytesConverter, [{\n    key: \"to\",\n\n    /**\r\n     * Convert an object value into trytes.\r\n     * @param object to convert into trytes.\r\n     * @returns The trytes representation of the object.\r\n     */\n    value: function to(value) {\n      if (objectHelper_1.ObjectHelper.isEmpty(value)) {\n        throw new dataError_1.DataError(\"The value can not be empty\");\n      }\n\n      var json;\n\n      try {\n        json = jsonHelper_1.JsonHelper.stringify(value);\n      } catch (err) {\n        throw new dataError_1.DataError(\"There was a problem converting the object to JSON\", {\n          err: err\n        });\n      }\n\n      return new asciiTrytesConverter_1.AsciiTrytesConverter().to(stringHelper_1.StringHelper.encodeNonASCII(json));\n    }\n    /**\r\n     * Convert trytes into a string value.\r\n     * @param trytes to convert into a string value.\r\n     * @returns The string value converted from the trytes.\r\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(trytes) {\n      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The trytes parameter is empty or not the correct type\");\n      }\n\n      var ascii = new asciiTrytesConverter_1.AsciiTrytesConverter().from(trytes); // Must have a a start and closing pairs\n\n      if (ascii.length < 2) {\n        throw new dataError_1.DataError(\"The trytes do not represent an object\");\n      } // The start and end must be either {} or \"\" to represent a JSON object\n\n\n      if (!(ascii[0] === \"{\" && ascii[ascii.length - 1] === \"}\" || ascii[0] === \"\\\"\" && ascii[ascii.length - 1] === \"\\\"\")) {\n        throw new dataError_1.DataError(\"The trytes do not represent an object\");\n      }\n\n      var decoded = stringHelper_1.StringHelper.decodeNonASCII(ascii);\n      var obj;\n\n      try {\n        obj = JSON.parse(decoded);\n      } catch (err) {\n        throw new dataError_1.DataError(\"There was a problem converting the object from JSON\", {\n          err: err\n        });\n      }\n\n      return obj;\n    }\n  }]);\n\n  return ObjectTrytesConverter;\n}();\n\nexports.ObjectTrytesConverter = ObjectTrytesConverter;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/converters/objectTrytesConverter.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/address.js":
/*!**********************************************!*\
  !*** ../iota-pico-data/dist/data/address.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling addresses.\r\n */\n\n\nvar Address =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Address(addressTrytes, checksumTrytes) {\n    _classCallCheck(this, Address);\n\n    this._addressTrytes = addressTrytes;\n    this._checksumTrytes = checksumTrytes;\n  }\n  /**\r\n   * Create address from trytes.\r\n   * @param address The trytes to create the address from.\r\n   * @returns An instance of Address.\r\n   */\n\n\n  _createClass(Address, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the address to trytes with no checksum.\r\n     * @returns Trytes version of the address with no checksum.\r\n     */\n    value: function toTrytes() {\n      return trytes_1.Trytes.fromString(this._addressTrytes);\n    }\n    /**\r\n     * Convert the address to trytes with a checksum, creating a blank one if needed.\r\n     * @returns Trytes version of the address with checksu,.\r\n     */\n\n  }, {\n    key: \"toTrytesWithChecksum\",\n    value: function toTrytesWithChecksum() {\n      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {\n        return trytes_1.Trytes.fromString(this._addressTrytes + this._checksumTrytes);\n      } else {\n        throw new dataError_1.DataError(\"This address has no checksum calculated for it\");\n      }\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!objectHelper_1.ObjectHelper.isEmpty(this._checksumTrytes)) {\n        return this._addressTrytes + this._checksumTrytes;\n      } else {\n        return this._addressTrytes;\n      }\n    }\n  }], [{\n    key: \"fromTrytes\",\n    value: function fromTrytes(address) {\n      if (!objectHelper_1.ObjectHelper.isType(address, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The address should be a valid Trytes object\");\n      }\n\n      var trytesString = address.toString();\n\n      if (trytesString.length !== Address.LENGTH && trytesString.length !== Address.LENGTH_WITH_CHECKSUM) {\n        throw new dataError_1.DataError(\"The address should either be \".concat(Address.LENGTH, \" or \").concat(Address.LENGTH_WITH_CHECKSUM, \" characters in length\"), {\n          length: trytesString.length\n        });\n      }\n\n      var addressTrytes = trytesString.substr(0, Address.LENGTH);\n      var checksumTrytes;\n\n      if (trytesString.length === Address.LENGTH_WITH_CHECKSUM) {\n        checksumTrytes = trytesString.substr(Address.LENGTH);\n      }\n\n      return new Address(addressTrytes, checksumTrytes);\n    }\n  }]);\n\n  return Address;\n}();\n/**\r\n * The length for a valid address without checksum (81).\r\n */\n\n\nAddress.LENGTH = 81;\n/**\r\n * The length for an address checksum (9).\r\n */\n\nAddress.LENGTH_CHECKSUM = 9;\n/**\r\n * The length for valid address with checksum (90).\r\n */\n\nAddress.LENGTH_WITH_CHECKSUM = Address.LENGTH + Address.LENGTH_CHECKSUM;\nexports.Address = Address;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/address.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/addressSecurity.js":
/*!******************************************************!*\
  !*** ../iota-pico-data/dist/data/addressSecurity.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Represents an enum for the address security values.\r\n */\n\nvar AddressSecurity;\n\n(function (AddressSecurity) {\n  AddressSecurity[AddressSecurity[\"low\"] = 1] = \"low\";\n  AddressSecurity[AddressSecurity[\"medium\"] = 2] = \"medium\";\n  AddressSecurity[AddressSecurity[\"high\"] = 3] = \"high\";\n})(AddressSecurity = exports.AddressSecurity || (exports.AddressSecurity = {}));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/addressSecurity.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/bundle.js":
/*!*********************************************!*\
  !*** ../iota-pico-data/dist/data/bundle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar hash_1 = __webpack_require__(/*! ./hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! ./signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar tag_1 = __webpack_require__(/*! ./tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar transaction_1 = __webpack_require__(/*! ./transaction */ \"../iota-pico-data/dist/data/transaction.js\");\n\nvar tryteNumber_1 = __webpack_require__(/*! ./tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\");\n/**\r\n * A class for handling bundles.\r\n */\n\n\nvar Bundle =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of Bundle.\r\n   */\n  function Bundle() {\n    _classCallCheck(this, Bundle);\n\n    this.transactions = [];\n  }\n  /**\r\n   * Add new transactions to the bundle.\r\n   * @param signatureMessageLength The number of transactions to add.\r\n   * @param address The address for the transactions.\r\n   * @param value The value for the first of the transactions.\r\n   * @param tag The tag to include in the transactions.\r\n   * @param timestamp The timestamp for the transactions.\r\n   */\n\n\n  _createClass(Bundle, [{\n    key: \"addTransactions\",\n    value: function addTransactions(signatureMessageLength, address, value, tag, timestamp) {\n      for (var i = 0; i < signatureMessageLength; i++) {\n        this.transactions.push(transaction_1.Transaction.fromParams(undefined, address, i === 0 ? value : 0, tag, timestamp, undefined, undefined, undefined, undefined, undefined, tag, undefined, undefined, undefined, undefined));\n      }\n    }\n    /**\r\n     * Add signature fragments to the bundle.\r\n     * @param signatureMessageFragments The signature fragments to add to the bundle transactions.\r\n     */\n\n  }, {\n    key: \"addSignatureMessageFragments\",\n    value: function addSignatureMessageFragments(signatureMessageFragments) {\n      if (objectHelper_1.ObjectHelper.isEmpty(signatureMessageFragments)) {\n        throw new dataError_1.DataError(\"The signatureMessageFragments should be an array of SignatureMessageFragments\");\n      }\n\n      for (var i = 0; i < this.transactions.length; i++) {\n        this.transactions[i].signatureMessageFragment = signatureMessageFragments[i] || signatureMessageFragment_1.SignatureMessageFragment.EMPTY;\n        this.transactions[i].trunkTransaction = hash_1.Hash.EMPTY;\n        this.transactions[i].branchTransaction = hash_1.Hash.EMPTY;\n        this.transactions[i].attachmentTimestamp = tryteNumber_1.TryteNumber.EMPTY_9;\n        this.transactions[i].attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.EMPTY_9;\n        this.transactions[i].attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.EMPTY_9;\n        this.transactions[i].nonce = tag_1.Tag.EMPTY;\n      }\n    }\n  }]);\n\n  return Bundle;\n}();\n\nexports.Bundle = Bundle;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/bundle.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/hash.js":
/*!*******************************************!*\
  !*** ../iota-pico-data/dist/data/hash.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling hashes.\r\n */\n\n\nvar Hash =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Hash(trytes) {\n    _classCallCheck(this, Hash);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create hash from trytes.\r\n   * @param hash The trytes to create the hash from.\r\n   * @returns An instance of Hash.\r\n   */\n\n\n  _createClass(Hash, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the hash to trytes.\r\n     * @returns Trytes version of the hash.\r\n     */\n    value: function toTrytes() {\n      return this._trytes;\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._trytes.toString();\n    }\n  }], [{\n    key: \"fromTrytes\",\n    value: function fromTrytes(hash) {\n      if (!objectHelper_1.ObjectHelper.isType(hash, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The hash should be a valid Trytes object\");\n      }\n\n      var length = hash.length();\n\n      if (length !== Hash.LENGTH) {\n        throw new dataError_1.DataError(\"The hash should be \".concat(Hash.LENGTH, \" characters in length\"), {\n          length: length\n        });\n      }\n\n      return new Hash(hash);\n    }\n  }]);\n\n  return Hash;\n}();\n/**\r\n * The length for a valid hash (81).\r\n */\n\n\nHash.LENGTH = 81;\n/**\r\n * An empty hash all 9s.\r\n */\n\nHash.EMPTY = Hash.fromTrytes(trytes_1.Trytes.fromString(\"9\".repeat(Hash.LENGTH)));\nexports.Hash = Hash;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/hash.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/input.js":
/*!********************************************!*\
  !*** ../iota-pico-data/dist/data/input.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar address_1 = __webpack_require__(/*! ./address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar addressSecurity_1 = __webpack_require__(/*! ./addressSecurity */ \"../iota-pico-data/dist/data/addressSecurity.js\");\n/**\r\n * A class for handling inputs.\r\n */\n\n\nvar Input =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Input() {\n    _classCallCheck(this, Input);\n  }\n  /**\r\n   * Create instance of input from parameters.\r\n   * @param address The address.\r\n   * @param security The address security.\r\n   * @param keyIndex The key index.\r\n   * @param balance The balance of the address.\r\n   * @return New instance of Input.\r\n   */\n\n\n  _createClass(Input, null, [{\n    key: \"fromParams\",\n    value: function fromParams(address, security, keyIndex, balance) {\n      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n        throw new dataError_1.DataError(\"The address should be a valid Address object\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(security) || security < addressSecurity_1.AddressSecurity.low || security > addressSecurity_1.AddressSecurity.high) {\n        throw new dataError_1.DataError(\"The security should be a number between \".concat(addressSecurity_1.AddressSecurity.low, \" and \").concat(addressSecurity_1.AddressSecurity.high));\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(keyIndex) || keyIndex < 0) {\n        throw new dataError_1.DataError(\"The keyIndex should be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(balance) || balance < 0) {\n        throw new dataError_1.DataError(\"The balance should be a number >= 0\");\n      }\n\n      var input = new Input();\n      input.address = address;\n      input.security = security;\n      input.keyIndex = keyIndex;\n      input.balance = balance;\n      return input;\n    }\n  }]);\n\n  return Input;\n}();\n\nexports.Input = Input;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/input.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/signatureMessageFragment.js":
/*!***************************************************************!*\
  !*** ../iota-pico-data/dist/data/signatureMessageFragment.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling signature message fragments.\r\n */\n\n\nvar SignatureMessageFragment =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function SignatureMessageFragment(trytes) {\n    _classCallCheck(this, SignatureMessageFragment);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create signature fragment from trytes.\r\n   * @param signatureMessageFragment The trytes to create the signature fragment from.\r\n   * @returns An instance of SignatureMessageFragment.\r\n   */\n\n\n  _createClass(SignatureMessageFragment, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the signature fragment to trytes.\r\n     * @returns Trytes version of the signature fragment.\r\n     */\n    value: function toTrytes() {\n      return this._trytes;\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._trytes.toString();\n    }\n  }], [{\n    key: \"fromTrytes\",\n    value: function fromTrytes(signatureMessageFragment) {\n      if (!objectHelper_1.ObjectHelper.isType(signatureMessageFragment, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The signatureMessageFragment should be a valid Trytes object\");\n      }\n\n      var length = signatureMessageFragment.length();\n\n      if (length !== SignatureMessageFragment.LENGTH) {\n        throw new dataError_1.DataError(\"The signatureMessageFragment should be \".concat(SignatureMessageFragment.LENGTH, \" characters in length\"), {\n          length: length\n        });\n      }\n\n      return new SignatureMessageFragment(signatureMessageFragment);\n    }\n  }]);\n\n  return SignatureMessageFragment;\n}();\n/**\r\n * The length of a valid signature message fragment (2187)\r\n */\n\n\nSignatureMessageFragment.LENGTH = 2187;\n/**\r\n * An empty signature message fragment all 9s.\r\n */\n\nSignatureMessageFragment.EMPTY = SignatureMessageFragment.fromTrytes(trytes_1.Trytes.fromString(\"9\".repeat(SignatureMessageFragment.LENGTH)));\nexports.SignatureMessageFragment = SignatureMessageFragment;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/signatureMessageFragment.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/tag.js":
/*!******************************************!*\
  !*** ../iota-pico-data/dist/data/tag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling tags.\r\n */\n\n\nvar Tag =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Tag(trytes) {\n    _classCallCheck(this, Tag);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create tag from trytes.\r\n   * @param tag The trytes to create the tag from.\r\n   * @returns An instance of Tag.\r\n   */\n\n\n  _createClass(Tag, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the tag to trytes.\r\n     * @returns Trytes version of the tag.\r\n     */\n    value: function toTrytes() {\n      return trytes_1.Trytes.fromString(this._trytes);\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._trytes;\n    }\n  }], [{\n    key: \"fromTrytes\",\n    value: function fromTrytes(tag) {\n      if (!objectHelper_1.ObjectHelper.isType(tag, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The tag should be a valid Trytes object\");\n      }\n\n      var trytesString = tag.toString();\n\n      if (trytesString.length > Tag.LENGTH) {\n        throw new dataError_1.DataError(\"The tag should be at most \".concat(Tag.LENGTH, \" characters in length\"), {\n          length: trytesString.length\n        });\n      }\n\n      while (trytesString.length < Tag.LENGTH) {\n        trytesString += \"9\";\n      }\n\n      return new Tag(trytesString);\n    }\n  }]);\n\n  return Tag;\n}();\n/**\r\n * The length of a valid tag (27).\r\n */\n\n\nTag.LENGTH = 27;\n/**\r\n * An empty tag all 9s.\r\n */\n\nTag.EMPTY = Tag.fromTrytes(trytes_1.Trytes.fromString(\"9\".repeat(Tag.LENGTH)));\nexports.Tag = Tag;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/tag.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/transaction.js":
/*!**************************************************!*\
  !*** ../iota-pico-data/dist/data/transaction.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar address_1 = __webpack_require__(/*! ./address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar hash_1 = __webpack_require__(/*! ./hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar signatureMessageFragment_1 = __webpack_require__(/*! ./signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\");\n\nvar tag_1 = __webpack_require__(/*! ./tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar tryteNumber_1 = __webpack_require__(/*! ./tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling transactions.\r\n */\n\n\nvar Transaction =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Transaction() {\n    _classCallCheck(this, Transaction);\n  }\n  /**\r\n   * Create instance of transaction from parameters.\r\n   * @param signatureMessageFragment The signature message fragment.\r\n   * @param address The address.\r\n   * @param value The value.\r\n   * @param obsoleteTag Obsolete transaction tag.\r\n   * @param timestamp The timestamp.\r\n   * @param currentIndex The current index.\r\n   * @param lastIndex The last index.\r\n   * @param bundle The bundle.\r\n   * @param trunkTransaction The trunk transaction.\r\n   * @param branchTransaction The branch transaction.\r\n   * @param tag The tag.\r\n   * @param attachmentTimestamp The attachment timestamp.\r\n   * @param attachmentTimestampLowerBound The attachment timestamp lower bound.\r\n   * @param attachmentTimestampUpperBound  The attachment timestamp upper bound.\r\n   * @param nonce The nonce.\r\n   * @return New instance of transaction.\r\n   */\n\n\n  _createClass(Transaction, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the transaction to trytes.\r\n     * @return The transaction as trytes.\r\n     */\n    value: function toTrytes() {\n      return trytes_1.Trytes.fromString(this.toString());\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!objectHelper_1.ObjectHelper.isType(this.signatureMessageFragment, signatureMessageFragment_1.SignatureMessageFragment)) {\n        throw new dataError_1.DataError(\"The signatureMessageFragment must be set to create transaction trytes\", {\n          signatureMessageFragment: this.signatureMessageFragment\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.address, address_1.Address)) {\n        throw new dataError_1.DataError(\"The address must be set to create transaction trytes\", {\n          address: this.address\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.obsoleteTag, tag_1.Tag)) {\n        throw new dataError_1.DataError(\"The obsoleteTag must be set to create transaction trytes\", {\n          obsoleteTag: this.obsoleteTag\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.bundle, hash_1.Hash)) {\n        throw new dataError_1.DataError(\"The bundle must be set to create transaction trytes\", {\n          bundle: this.bundle\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.trunkTransaction, hash_1.Hash)) {\n        throw new dataError_1.DataError(\"The trunkTransaction must be set to create transaction trytes\", {\n          trunkTransaction: this.trunkTransaction\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.branchTransaction, hash_1.Hash)) {\n        throw new dataError_1.DataError(\"The branchTransaction must be set to create transaction trytes\", {\n          branchTransaction: this.branchTransaction\n        });\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(this.nonce, tag_1.Tag)) {\n        throw new dataError_1.DataError(\"The nonce must be set to create transaction trytes\", {\n          nonce: this.nonce\n        });\n      }\n\n      var trytes = this.signatureMessageFragment.toTrytes().toString() + this.address.toTrytes().toString() + (this.value || Transaction.EMPTY_11).toTrytes().toString() + Transaction.CHECK_VALUE + this.obsoleteTag.toTrytes().toString() + (this.timestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.currentIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.lastIndex || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.bundle.toTrytes().toString() + this.trunkTransaction.toTrytes().toString() + this.branchTransaction.toTrytes().toString() + (this.tag || this.obsoleteTag).toTrytes().toString() + (this.attachmentTimestamp || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampLowerBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + (this.attachmentTimestampUpperBound || tryteNumber_1.TryteNumber.EMPTY_9).toTrytes().toString() + this.nonce.toTrytes().toString();\n      var length = trytes.length;\n\n      if (length !== Transaction.LENGTH) {\n        throw new dataError_1.DataError(\"The trytes must be \".concat(Transaction.LENGTH, \" in length \").concat(length), {\n          length: length\n        });\n      }\n\n      return trytes;\n    }\n  }], [{\n    key: \"fromParams\",\n    value: function fromParams(signatureMessageFragment, address, value, obsoleteTag, timestamp, currentIndex, lastIndex, bundle, trunkTransaction, branchTransaction, tag, attachmentTimestamp, attachmentTimestampLowerBound, attachmentTimestampUpperBound, nonce) {\n      var tx = new Transaction();\n      tx.signatureMessageFragment = signatureMessageFragment;\n      tx.address = address;\n      tx.value = tryteNumber_1.TryteNumber.fromNumber(value, 11);\n      tx.obsoleteTag = obsoleteTag;\n      tx.timestamp = tryteNumber_1.TryteNumber.fromNumber(timestamp);\n      tx.currentIndex = tryteNumber_1.TryteNumber.fromNumber(currentIndex);\n      tx.lastIndex = tryteNumber_1.TryteNumber.fromNumber(lastIndex);\n      tx.bundle = bundle;\n      tx.trunkTransaction = trunkTransaction;\n      tx.branchTransaction = branchTransaction;\n      tx.tag = tag;\n      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestamp);\n      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampLowerBound);\n      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromNumber(attachmentTimestampUpperBound);\n      tx.nonce = nonce;\n      return tx;\n    }\n    /**\r\n     * Create instance of transaction from trytes.\r\n     * @param trytes The trytes for the this.\r\n     * @returns An instance of this.\r\n     */\n\n  }, {\n    key: \"fromTrytes\",\n    value: function fromTrytes(trytes) {\n      if (!objectHelper_1.ObjectHelper.isType(trytes, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The trytes should be a valid Trytes object\");\n      }\n\n      var length = trytes.length();\n\n      if (length !== Transaction.LENGTH) {\n        throw new dataError_1.DataError(\"The trytes must be \".concat(Transaction.LENGTH, \" in length\"), {\n          length: length\n        });\n      }\n\n      var checkIndexStart = 2279;\n      var checkIndexLength = 16;\n      var check = trytes.sub(checkIndexStart, checkIndexLength).toString();\n\n      if (check !== Transaction.CHECK_VALUE) {\n        throw new dataError_1.DataError(\"The trytes between \".concat(checkIndexStart, \" and \").concat(checkIndexStart + checkIndexLength, \" should be all 9s\"), {\n          check: check\n        });\n      }\n\n      var tx = new Transaction();\n      var startPos = 0;\n      tx.signatureMessageFragment = signatureMessageFragment_1.SignatureMessageFragment.fromTrytes(trytes.sub(startPos, signatureMessageFragment_1.SignatureMessageFragment.LENGTH));\n      startPos += signatureMessageFragment_1.SignatureMessageFragment.LENGTH;\n      tx.address = address_1.Address.fromTrytes(trytes.sub(startPos, address_1.Address.LENGTH));\n      startPos += address_1.Address.LENGTH;\n      tx.value = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, 11), 11);\n      startPos += 11;\n      startPos += Transaction.CHECK_VALUE_LENGTH;\n      tx.obsoleteTag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));\n      startPos += tag_1.Tag.LENGTH;\n      tx.timestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.currentIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.lastIndex = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.bundle = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));\n      startPos += hash_1.Hash.LENGTH;\n      tx.trunkTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));\n      startPos += hash_1.Hash.LENGTH;\n      tx.branchTransaction = hash_1.Hash.fromTrytes(trytes.sub(startPos, hash_1.Hash.LENGTH));\n      startPos += hash_1.Hash.LENGTH;\n      tx.tag = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));\n      startPos += tag_1.Tag.LENGTH;\n      tx.attachmentTimestamp = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.attachmentTimestampLowerBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.attachmentTimestampUpperBound = tryteNumber_1.TryteNumber.fromTrytes(trytes.sub(startPos, tryteNumber_1.TryteNumber.LENGTH_9));\n      startPos += tryteNumber_1.TryteNumber.LENGTH_9;\n      tx.nonce = tag_1.Tag.fromTrytes(trytes.sub(startPos, tag_1.Tag.LENGTH));\n      return tx;\n    }\n  }]);\n\n  return Transaction;\n}();\n/**\r\n * The length of a valid transaction (2673).\r\n */\n\n\nTransaction.LENGTH = 2673;\n/**\r\n * The length of a valid check value (16).\r\n */\n\nTransaction.CHECK_VALUE_LENGTH = 16;\n/**\r\n * The check value for bundles all 9s.\r\n */\n\nTransaction.CHECK_VALUE = \"9\".repeat(Transaction.CHECK_VALUE_LENGTH);\n/* @internal */\n\nTransaction.EMPTY_11 = tryteNumber_1.TryteNumber.fromNumber(0, 11);\nexports.Transaction = Transaction;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/transaction.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/transfer.js":
/*!***********************************************!*\
  !*** ../iota-pico-data/dist/data/transfer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar address_1 = __webpack_require__(/*! ./address */ \"../iota-pico-data/dist/data/address.js\");\n\nvar tag_1 = __webpack_require__(/*! ./tag */ \"../iota-pico-data/dist/data/tag.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling transfers.\r\n */\n\n\nvar Transfer =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Transfer() {\n    _classCallCheck(this, Transfer);\n  }\n  /**\r\n   * Create instance of transfer from parameters.\r\n   * @param address The address.\r\n   * @param value The value.\r\n   * @param messsage The message for the transfer.\r\n   * @param tag The tag.\r\n   * @return New instance of Transfer.\r\n   */\n\n\n  _createClass(Transfer, null, [{\n    key: \"fromParams\",\n    value: function fromParams(address, value, message, tag) {\n      if (!objectHelper_1.ObjectHelper.isType(address, address_1.Address)) {\n        throw new dataError_1.DataError(\"The address should be a valid Address object\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(value) || value < 0) {\n        throw new dataError_1.DataError(\"The value should be a number >= 0\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isEmpty(message) && !objectHelper_1.ObjectHelper.isType(message, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The message should be a valid Trytes object\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isEmpty(tag) && !objectHelper_1.ObjectHelper.isType(tag, tag_1.Tag)) {\n        throw new dataError_1.DataError(\"The tag should be a valid Tag object\");\n      }\n\n      var transfer = new Transfer();\n      transfer.address = address;\n      transfer.value = value;\n      transfer.message = message;\n      transfer.tag = tag;\n      return transfer;\n    }\n  }]);\n\n  return Transfer;\n}();\n\nexports.Transfer = Transfer;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/transfer.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/trits.js":
/*!********************************************!*\
  !*** ../iota-pico-data/dist/data/trits.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling trits.\r\n */\n\n\nvar Trits =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Trits(trits) {\n    _classCallCheck(this, Trits);\n\n    this._trits = trits;\n  }\n  /**\r\n   * Create instance of trits from Int8Array array.\r\n   * @param value Trytes used to create trits.\r\n   * @returns An instance of Trits.\r\n   */\n\n\n  _createClass(Trits, [{\n    key: \"toArray\",\n\n    /**\r\n     * Get the value of the trits array.\r\n     * @returns Array representation of the trits.\r\n     */\n    value: function toArray() {\n      return this._trits;\n    }\n    /**\r\n     * Get the value of the trits array as a number array.\r\n     * @returns Array representation of the trits.\r\n     */\n\n  }, {\n    key: \"toNumberArray\",\n    value: function toNumberArray() {\n      return Array.from(this._trits);\n    }\n    /**\r\n     * Get the trits as trytes.\r\n     * @returns Instance of Trytes.\r\n     */\n\n  }, {\n    key: \"toTrytes\",\n    value: function toTrytes() {\n      var trytes = \"\";\n\n      for (var i = 0; i < this._trits.length; i += 3) {\n        // Iterate over all possible tryte values to find correct trit representation\n        for (var j = 0; j < trytes_1.Trytes.ALPHABET.length; j++) {\n          if (Trits.TRYTES_TRITS[j][0] === this._trits[i] && Trits.TRYTES_TRITS[j][1] === this._trits[i + 1] && Trits.TRYTES_TRITS[j][2] === this._trits[i + 2]) {\n            trytes += trytes_1.Trytes.ALPHABET.charAt(j);\n            break;\n          }\n        }\n      }\n\n      return trytes_1.Trytes.fromString(trytes);\n    }\n    /**\r\n     * Get the trits as a number.\r\n     * @returns The trits converted to a number.\r\n     */\n\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      var returnValue = 0;\n\n      for (var i = this._trits.length - 1; i >= 0; i--) {\n        returnValue = returnValue * 3 + this._trits[i];\n      }\n\n      return returnValue;\n    }\n    /**\r\n     * What is the length of the trits.\r\n     * @returns Length of the trits.\r\n     */\n\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this._trits.length;\n    }\n    /**\r\n     * Get a sub of the trits.\r\n     * @param start The start position to get the sub.\r\n     * @param length The length of the sub.\r\n     * @returns The trits sub.\r\n     */\n\n  }, {\n    key: \"sub\",\n    value: function sub(start, length) {\n      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {\n        throw new dataError_1.DataError(\"The start must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trits.length) {\n        throw new dataError_1.DataError(\"The start + length must <= \".concat(this._trits.length));\n      }\n\n      return Trits.fromArray(this._trits.slice(start, start + length));\n    }\n  }], [{\n    key: \"fromArray\",\n    value: function fromArray(value) {\n      if (!objectHelper_1.ObjectHelper.isType(value, Int8Array)) {\n        throw new dataError_1.DataError(\"The value does not contain valid trits\");\n      }\n\n      return new Trits(value);\n    }\n    /**\r\n     * Create instance of trits from number array.\r\n     * @param value Trytes used to create trits.\r\n     * @returns An instance of Trits.\r\n     */\n\n  }, {\n    key: \"fromNumberArray\",\n    value: function fromNumberArray(value) {\n      if (!arrayHelper_1.ArrayHelper.isTyped(value, Number)) {\n        throw new dataError_1.DataError(\"The value does not contain valid trits\");\n      }\n\n      return new Trits(new Int8Array(value));\n    }\n    /**\r\n     * Create instance of trits from trytes.\r\n     * @param value Trytes used to create trits.\r\n     * @returns An instance of Trits.\r\n     */\n\n  }, {\n    key: \"fromTrytes\",\n    value: function fromTrytes(value) {\n      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The value should be a valid Trytes object\");\n      }\n\n      var trytesString = value.toString();\n      var trits = new Int8Array(trytesString.length * 3);\n\n      for (var i = 0; i < trytesString.length; i++) {\n        var idx = trytes_1.Trytes.ALPHABET.indexOf(trytesString.charAt(i));\n        trits[i * 3] = Trits.TRYTES_TRITS[idx][0];\n        trits[i * 3 + 1] = Trits.TRYTES_TRITS[idx][1];\n        trits[i * 3 + 2] = Trits.TRYTES_TRITS[idx][2];\n      }\n\n      return new Trits(trits);\n    }\n    /**\r\n     * Create instance of trits from number\r\n     * @param value Number used to create trits.\r\n     * @returns An instance of Trits.\r\n     */\n\n  }, {\n    key: \"fromNumber\",\n    value: function fromNumber(value) {\n      if (!numberHelper_1.NumberHelper.isInteger(value)) {\n        throw new dataError_1.DataError(\"The value is not an integer\");\n      }\n\n      var trits = [];\n      var absoluteValue = value < 0 ? -value : value;\n\n      while (absoluteValue > 0) {\n        var remainder = absoluteValue % 3;\n        absoluteValue = Math.floor(absoluteValue / 3);\n\n        if (remainder > 1) {\n          remainder = -1;\n          absoluteValue++;\n        }\n\n        trits[trits.length] = remainder;\n      }\n\n      if (value < 0) {\n        for (var i = 0; i < trits.length; i++) {\n          trits[i] = -trits[i];\n        }\n      }\n\n      return new Trits(new Int8Array(trits));\n    }\n    /**\r\n     * Add two trits together.\r\n     * @param first The first trit.\r\n     * @param second The second trit.\r\n     * @return New trit which is the addition of the a + b.\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(first, second) {\n      if (!objectHelper_1.ObjectHelper.isType(first, Trits)) {\n        throw new dataError_1.DataError(\"The first should be a valid Trits object\");\n      }\n\n      if (!objectHelper_1.ObjectHelper.isType(second, Trits)) {\n        throw new dataError_1.DataError(\"The seconds should be a valid Trits object\");\n      }\n\n      var out = new Int8Array(Math.max(first._trits.length, second._trits.length));\n      var carry = 0;\n      var iA;\n      var iB;\n\n      for (var i = 0; i < out.length; i++) {\n        iA = i < first._trits.length ? first._trits[i] : 0;\n        iB = i < second._trits.length ? second._trits[i] : 0;\n        var fA = Trits.fullAdd(iA, iB, carry);\n        out[i] = fA[0];\n        carry = fA[1];\n      }\n\n      return Trits.fromArray(out);\n    }\n    /* @internal */\n\n  }, {\n    key: \"fullAdd\",\n    value: function fullAdd(a, b, c) {\n      var sA = Trits.sum(a, b);\n      var cA = Trits.cons(a, b);\n      var cB = Trits.cons(sA, c);\n      var cOut = Trits.any(cA, cB);\n      var sOUt = Trits.sum(sA, c);\n      return new Int8Array([sOUt, cOut]);\n    }\n    /* @internal */\n\n  }, {\n    key: \"sum\",\n    value: function sum(a, b) {\n      var s = a + b;\n\n      switch (s) {\n        case 2:\n          return -1;\n\n        case -2:\n          return 1;\n\n        default:\n          return s;\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"cons\",\n    value: function cons(a, b) {\n      if (a === b) {\n        return a;\n      }\n\n      return 0;\n    }\n    /* @internal */\n\n  }, {\n    key: \"any\",\n    value: function any(a, b) {\n      var s = a + b;\n\n      if (s > 0) {\n        return 1;\n      } else if (s < 0) {\n        return -1;\n      }\n\n      return 0;\n    }\n  }]);\n\n  return Trits;\n}();\n/* @internal */\n\n\nTrits.TRYTES_TRITS = [new Int8Array([0, 0, 0]), new Int8Array([1, 0, 0]), new Int8Array([-1, 1, 0]), new Int8Array([0, 1, 0]), new Int8Array([1, 1, 0]), new Int8Array([-1, -1, 1]), new Int8Array([0, -1, 1]), new Int8Array([1, -1, 1]), new Int8Array([-1, 0, 1]), new Int8Array([0, 0, 1]), new Int8Array([1, 0, 1]), new Int8Array([-1, 1, 1]), new Int8Array([0, 1, 1]), new Int8Array([1, 1, 1]), new Int8Array([-1, -1, -1]), new Int8Array([0, -1, -1]), new Int8Array([1, -1, -1]), new Int8Array([-1, 0, -1]), new Int8Array([0, 0, -1]), new Int8Array([1, 0, -1]), new Int8Array([-1, 1, -1]), new Int8Array([0, 1, -1]), new Int8Array([1, 1, -1]), new Int8Array([-1, -1, 0]), new Int8Array([0, -1, 0]), new Int8Array([1, -1, 0]), new Int8Array([-1, 0, 0])];\nexports.Trits = Trits;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/trits.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/tryteNumber.js":
/*!**************************************************!*\
  !*** ../iota-pico-data/dist/data/tryteNumber.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n\nvar trits_1 = __webpack_require__(/*! ./trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar trytes_1 = __webpack_require__(/*! ./trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * A class for handling tryte number.\r\n */\n\n\nvar TryteNumber =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function TryteNumber(trytes) {\n    _classCallCheck(this, TryteNumber);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create tryte number from number.\r\n   * @param value The number value to create the object from.\r\n   * @param length The tryte length to pad the number with.\r\n   * @returns An instance of TryteNumber.\r\n   */\n\n\n  _createClass(TryteNumber, [{\n    key: \"toTrytes\",\n\n    /**\r\n     * Convert the tryte number to trytes.\r\n     * @returns Trytes version of the tryte number.\r\n     */\n    value: function toTrytes() {\n      return trytes_1.Trytes.fromString(this._trytes);\n    }\n    /**\r\n     * Convert the tryte number to number.\r\n     * @returns number value of the tryte number.\r\n     */\n\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return trits_1.Trits.fromTrytes(trytes_1.Trytes.fromString(this._trytes)).toNumber();\n    }\n    /**\r\n     * Get the string view of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toNumber().toString();\n    }\n    /**\r\n     * Get the value of the object.\r\n     * @returns string of the trytes.\r\n     */\n\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toNumber();\n    }\n  }], [{\n    key: \"fromNumber\",\n    value: function fromNumber(value) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;\n      var trytes;\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new dataError_1.DataError(\"The length should be a number > 0\", {\n          length: length\n        });\n      }\n\n      if (objectHelper_1.ObjectHelper.isEmpty(value)) {\n        trytes = \"9\".repeat(length);\n      } else {\n        if (!numberHelper_1.NumberHelper.isInteger(value)) {\n          throw new dataError_1.DataError(\"The value is not an integer\", {\n            value: value\n          });\n        }\n\n        var trits = trits_1.Trits.fromNumber(value).toNumberArray();\n\n        while (trits.length < length * 3) {\n          trits.push(0);\n        }\n\n        trytes = trits_1.Trits.fromNumberArray(trits).toTrytes().toString();\n      }\n\n      return new TryteNumber(trytes);\n    }\n    /**\r\n     * Create tryte number from trytes.\r\n     * @param value The number value to create the object from.\r\n     * @param length The tryte length to pad the number with.\r\n     * @returns An instance of TryteNumber.\r\n     */\n\n  }, {\n    key: \"fromTrytes\",\n    value: function fromTrytes(value) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TryteNumber.LENGTH_9;\n\n      if (!objectHelper_1.ObjectHelper.isType(value, trytes_1.Trytes)) {\n        throw new dataError_1.DataError(\"The value should be a valid Trytes object\");\n      }\n\n      var tryteString = value.toString();\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length <= 0) {\n        throw new dataError_1.DataError(\"The length should be a number > 0\", {\n          length: length\n        });\n      }\n\n      if (tryteString.length > length) {\n        throw new dataError_1.DataError(\"The value contains too many characters\", {\n          length: tryteString.length\n        });\n      }\n\n      while (tryteString.length < length) {\n        tryteString += \"9\";\n      }\n\n      return new TryteNumber(tryteString);\n    }\n  }]);\n\n  return TryteNumber;\n}();\n/**\r\n * Length of a number that uses 9 trytes.\r\n */\n\n\nTryteNumber.LENGTH_9 = 9;\n/**\r\n * An emnpty 9 length tryte number.\r\n */\n\nTryteNumber.EMPTY_9 = TryteNumber.fromNumber(0, TryteNumber.LENGTH_9);\nexports.TryteNumber = TryteNumber;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/tryteNumber.js?");

/***/ }),

/***/ "../iota-pico-data/dist/data/trytes.js":
/*!*********************************************!*\
  !*** ../iota-pico-data/dist/data/trytes.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar dataError_1 = __webpack_require__(/*! ../error/dataError */ \"../iota-pico-data/dist/error/dataError.js\");\n/**\r\n * A class for handling trytes.\r\n */\n\n\nvar Trytes =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function Trytes(trytes) {\n    _classCallCheck(this, Trytes);\n\n    this._trytes = trytes;\n  }\n  /**\r\n   * Create trytes from a string.\r\n   * @param value A string to create the trytes from.\r\n   * @param length An optional validation length for the trytes, 0 means ignore length.\r\n   * @returns An instance of Trytes.\r\n   */\n\n\n  _createClass(Trytes, [{\n    key: \"toString\",\n\n    /**\r\n     * Convert the trytes to a string.\r\n     * @returns String representation of the trytes.\r\n     */\n    value: function toString() {\n      return this._trytes;\n    }\n    /**\r\n     * Get the length of the trytes.\r\n     * @returns The length of the trytes.\r\n     */\n\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this._trytes.length;\n    }\n    /**\r\n     * Get a sub of the trytes.\r\n     * @param start The start position to get the sub.\r\n     * @param length The length of the sub.\r\n     * @returns The trytes sub.\r\n     */\n\n  }, {\n    key: \"sub\",\n    value: function sub(start, length) {\n      if (!numberHelper_1.NumberHelper.isInteger(start) || start < 0) {\n        throw new dataError_1.DataError(\"The start must be a number >= 0\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || start + length > this._trytes.length) {\n        throw new dataError_1.DataError(\"The start + length must <= \".concat(this._trytes.length));\n      }\n\n      return Trytes.fromString(this._trytes.substr(start, length));\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(value) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (!stringHelper_1.StringHelper.isString(value)) {\n        throw new dataError_1.DataError(\"The value must be a non empty string\");\n      }\n\n      if (!numberHelper_1.NumberHelper.isInteger(length) || length < 0) {\n        throw new dataError_1.DataError(\"The length must be >= 0\");\n      }\n\n      if (!Trytes.isValid(value, length)) {\n        throw new dataError_1.DataError(\"The value and length do not contain valid trytes\", {\n          value: value,\n          length: length\n        });\n      }\n\n      return new Trytes(value);\n    }\n    /**\r\n     * Does the value contain valid trytes.\r\n     * @param value A string to validate as trytes.\r\n     * @param length An optional validation length for the trytes, 0 means ignore length.\r\n     * @returns True if the input was valid trytes.\r\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid(value) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (!stringHelper_1.StringHelper.isString(value)) {\n        return false;\n      } else {\n        return new RegExp(\"^[9A-Z]{\".concat(length ? length : \"0,\", \"}$\")).test(value);\n      }\n    }\n  }]);\n\n  return Trytes;\n}();\n/**\r\n * All the characters that can be used in trytes.\r\n */\n\n\nTrytes.ALPHABET = \"9ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nexports.Trytes = Trytes;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/data/trytes.js?");

/***/ }),

/***/ "../iota-pico-data/dist/error/dataError.js":
/*!*************************************************!*\
  !*** ../iota-pico-data/dist/error/dataError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n/**\r\n * A data implementation of an error.\r\n */\n\n\nvar DataError =\n/*#__PURE__*/\nfunction (_coreError_1$CoreErro) {\n  _inherits(DataError, _coreError_1$CoreErro);\n\n  function DataError() {\n    _classCallCheck(this, DataError);\n\n    return _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).apply(this, arguments));\n  }\n\n  return DataError;\n}(coreError_1.CoreError);\n\nexports.DataError = DataError;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/error/dataError.js?");

/***/ }),

/***/ "../iota-pico-data/dist/index.js":
/*!***************************************!*\
  !*** ../iota-pico-data/dist/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./converters/asciiTrytesConverter */ \"../iota-pico-data/dist/converters/asciiTrytesConverter.js\"));\n\n__export(__webpack_require__(/*! ./converters/objectTrytesConverter */ \"../iota-pico-data/dist/converters/objectTrytesConverter.js\"));\n\n__export(__webpack_require__(/*! ./data/address */ \"../iota-pico-data/dist/data/address.js\"));\n\n__export(__webpack_require__(/*! ./data/addressSecurity */ \"../iota-pico-data/dist/data/addressSecurity.js\"));\n\n__export(__webpack_require__(/*! ./data/bundle */ \"../iota-pico-data/dist/data/bundle.js\"));\n\n__export(__webpack_require__(/*! ./data/hash */ \"../iota-pico-data/dist/data/hash.js\"));\n\n__export(__webpack_require__(/*! ./data/input */ \"../iota-pico-data/dist/data/input.js\"));\n\n__export(__webpack_require__(/*! ./data/signatureMessageFragment */ \"../iota-pico-data/dist/data/signatureMessageFragment.js\"));\n\n__export(__webpack_require__(/*! ./data/tag */ \"../iota-pico-data/dist/data/tag.js\"));\n\n__export(__webpack_require__(/*! ./data/transaction */ \"../iota-pico-data/dist/data/transaction.js\"));\n\n__export(__webpack_require__(/*! ./data/transfer */ \"../iota-pico-data/dist/data/transfer.js\"));\n\n__export(__webpack_require__(/*! ./data/trits */ \"../iota-pico-data/dist/data/trits.js\"));\n\n__export(__webpack_require__(/*! ./data/tryteNumber */ \"../iota-pico-data/dist/data/tryteNumber.js\"));\n\n__export(__webpack_require__(/*! ./data/trytes */ \"../iota-pico-data/dist/data/trytes.js\"));\n\n__export(__webpack_require__(/*! ./error/dataError */ \"../iota-pico-data/dist/error/dataError.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-data/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pal-browser/dist/index.js":
/*!**********************************************!*\
  !*** ../iota-pico-pal-browser/dist/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./pal */ \"../iota-pico-pal-browser/dist/pal.js\"));\n\n__export(__webpack_require__(/*! ./network/networkClient */ \"../iota-pico-pal-browser/dist/network/networkClient.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-browser/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pal-browser/dist/network/networkClient.js":
/*!**************************************************************!*\
  !*** ../iota-pico-pal-browser/dist/network/networkClient.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pal-browser/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar coreError_1 = __webpack_require__(/*! @iota-pico/core/dist/error/coreError */ \"../iota-pico-core/dist/error/coreError.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar nullLogger_1 = __webpack_require__(/*! @iota-pico/core/dist/loggers/nullLogger */ \"../iota-pico-core/dist/loggers/nullLogger.js\");\n/**\r\n * Implementation of a node client for use in the browser.\r\n */\n\n\nvar NetworkClient =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create an instance of NetworkClient.\r\n   * @param networkEndPoint The endpoint to use for the client.\r\n   * @param logger Logger to send communication info to.\r\n   * @param timeoutMs The timeout in ms before aborting.\r\n   */\n  function NetworkClient(networkEndPoint, logger) {\n    var timeoutMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, NetworkClient);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(networkEndPoint)) {\n      throw new coreError_1.CoreError(\"The networkEndPoint must be defined\");\n    }\n\n    if (!numberHelper_1.NumberHelper.isInteger(timeoutMs) || timeoutMs < 0) {\n      throw new coreError_1.CoreError(\"The timeoutMs must be >= 0\");\n    }\n\n    this._networkEndPoint = networkEndPoint;\n    this._timeoutMs = timeoutMs;\n    this._logger = logger || new nullLogger_1.NullLogger();\n\n    this._logger.banner(\"Network Client\", {\n      endPoint: this._networkEndPoint\n    });\n  }\n  /**\r\n   * Get data asynchronously.\r\n   * @param additionalPath An additional path append to the endpoint path.\r\n   * @param additionalHeaders Extra headers to send with the request.\r\n   * @returns Promise which resolves to the object returned or rejects with error.\r\n   */\n\n\n  _createClass(NetworkClient, [{\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(additionalPath, additionalHeaders) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.doRequest(\"GET\", undefined, additionalPath, additionalHeaders));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function get(_x, _x2) {\n        return _get.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Post data asynchronously.\r\n     * @param additionalPath An additional path append to the endpoint path.\r\n     * @param data The data to send.\r\n     * @param additionalHeaders Extra headers to send with the request.\r\n     * @returns Promise which resolves to the object returned or rejects with error.\r\n     */\n\n  }, {\n    key: \"post\",\n    value: function () {\n      var _post = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(data, additionalPath, additionalHeaders) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.doRequest(\"POST\", data, additionalPath, additionalHeaders));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function post(_x3, _x4, _x5) {\n        return _post.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Get data as JSON asynchronously.\r\n     * @typeparam U The generic type for the returned object.\r\n     * @param additionalPath An additional path append to the endpoint path.\r\n     * @param additionalHeaders Extra headers to send with the request.\r\n     * @returns Promise which resolves to the object returned or rejects with error.\r\n     */\n\n  }, {\n    key: \"getJson\",\n    value: function () {\n      var _getJson = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(additionalPath, additionalHeaders) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.doRequest(\"GET\", undefined, additionalPath, additionalHeaders).then(function (responseData) {\n                  try {\n                    var response = JSON.parse(responseData);\n                    return response;\n                  } catch (err) {\n                    throw new coreError_1.CoreError(\"Failed GET request, unable to parse response\", {\n                      endPoint: _this._networkEndPoint.getUri(),\n                      response: responseData\n                    });\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      return function getJson(_x6, _x7) {\n        return _getJson.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Post data as JSON asynchronously.\r\n     * @typeparam T The generic type for the object to send.\r\n     * @typeparam U The generic type for the returned object.\r\n     * @param data The data to send.\r\n     * @param additionalPath An additional path append to the endpoint path.\r\n     * @param additionalHeaders Extra headers to send with the request.\r\n     * @returns Promise which resolves to the object returned or rejects with error.\r\n     */\n\n  }, {\n    key: \"postJson\",\n    value: function () {\n      var _postJson = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(data, additionalPath, additionalHeaders) {\n        var _this2 = this;\n\n        var headers;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                headers = additionalHeaders || {};\n                headers[\"Content-Type\"] = \"application/json\";\n                return _context4.abrupt(\"return\", this.doRequest(\"POST\", JSON.stringify(data), additionalPath, headers).then(function (responseData) {\n                  try {\n                    var response = JSON.parse(responseData);\n                    return response;\n                  } catch (err) {\n                    throw new coreError_1.CoreError(\"Failed POST request, unable to parse response\", {\n                      endPoint: _this2._networkEndPoint.getUri(),\n                      response: responseData\n                    });\n                  }\n                }));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function postJson(_x8, _x9, _x10) {\n        return _postJson.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"doRequest\",\n    value: function () {\n      var _doRequest = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(method, data, additionalPath, additionalHeaders) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var headers = additionalHeaders || {};\n\n                  var uri = _this3._networkEndPoint.getUri();\n\n                  if (!stringHelper_1.StringHelper.isEmpty(additionalPath)) {\n                    var stripped = \"/\".concat(additionalPath.replace(/^\\/*/, \"\"));\n                    uri += stripped;\n                  }\n\n                  var req = new XMLHttpRequest();\n\n                  if (_this3._timeoutMs > 0) {\n                    req.timeout = _this3._timeoutMs;\n                  }\n\n                  req.ontimeout = function () {\n                    _this3._logger.error(\"<=== Timed Out\");\n\n                    reject(new coreError_1.CoreError(\"Failed \".concat(method, \" request, timed out\"), {\n                      endPoint: uri,\n                      errorResponseCode: req.status,\n                      errorResponse: req.responseText || req.statusText\n                    }));\n                  };\n\n                  req.onerror = function (err) {\n                    _this3._logger.error(\"<=== Errored\");\n\n                    reject(new coreError_1.CoreError(\"Failed \".concat(method, \" request\"), {\n                      endPoint: uri,\n                      errorResponseCode: req.status,\n                      errorResponse: req.responseText || req.statusText\n                    }));\n                  };\n\n                  req.onload = function () {\n                    if (req.status === 200) {\n                      _this3._logger.info(\"<=== Received\", {\n                        data: req.responseText\n                      });\n\n                      resolve(req.responseText);\n                    } else {\n                      _this3._logger.info(\"<=== Received Fail\", {\n                        code: req.status,\n                        data: req.responseText\n                      });\n\n                      reject(new coreError_1.CoreError(\"Failed \".concat(method, \" request\"), {\n                        endPoint: uri,\n                        errorResponseCode: req.status,\n                        errorResponse: req.responseText || req.statusText\n                      }));\n                    }\n                  };\n\n                  req.open(method, uri, true);\n\n                  for (var key in headers) {\n                    req.setRequestHeader(key, headers[key]);\n                  }\n\n                  _this3._logger.info(\"===> Send\", {\n                    data: data\n                  });\n\n                  req.send(data);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      return function doRequest(_x11, _x12, _x13, _x14) {\n        return _doRequest.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return NetworkClient;\n}();\n\nexports.NetworkClient = NetworkClient;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-browser/dist/network/networkClient.js?");

/***/ }),

/***/ "../iota-pico-pal-browser/dist/pal.js":
/*!********************************************!*\
  !*** ../iota-pico-pal-browser/dist/pal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pal-browser/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar networkClientFactory_1 = __webpack_require__(/*! @iota-pico/core/dist/factories/networkClientFactory */ \"../iota-pico-core/dist/factories/networkClientFactory.js\");\n\nvar networkClient_1 = __webpack_require__(/*! ./network/networkClient */ \"../iota-pico-pal-browser/dist/network/networkClient.js\");\n/**\r\n * Platform abstraction layer for Browser.\r\n */\n\n\nvar PAL =\n/*#__PURE__*/\nfunction () {\n  function PAL() {\n    _classCallCheck(this, PAL);\n  }\n\n  _createClass(PAL, null, [{\n    key: \"initialize\",\n\n    /**\r\n     * Perform any initialization for the PAL.\r\n     */\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!PAL._isInitialized) {\n                  PAL._isInitialized = true;\n                  networkClientFactory_1.NetworkClientFactory.instance().register(\"default\", function (networkEndpoint) {\n                    return new networkClient_1.NetworkClient(networkEndpoint);\n                  });\n                }\n\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return PAL;\n}();\n/* @internal */\n\n\nPAL._isInitialized = false;\nexports.PAL = PAL;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-browser/dist/pal.js?");

/***/ }),

/***/ "../iota-pico-pal-browser/node_modules/@babel/runtime/regenerator/index.js":
/*!*********************************************************************************!*\
  !*** ../iota-pico-pal-browser/node_modules/@babel/runtime/regenerator/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pal-browser/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-browser/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pal-browser/node_modules/regenerator-runtime/runtime-module.js":
/*!***********************************************************************************!*\
  !*** ../iota-pico-pal-browser/node_modules/regenerator-runtime/runtime-module.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pal-browser/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-browser/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pal-browser/node_modules/regenerator-runtime/runtime.js":
/*!****************************************************************************!*\
  !*** ../iota-pico-pal-browser/node_modules/regenerator-runtime/runtime.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pal-browser/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-pow-box/dist/index.js":
/*!******************************************!*\
  !*** ../iota-pico-pow-box/dist/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./proofOfWorkBox */ \"../iota-pico-pow-box/dist/proofOfWorkBox.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pow-box/dist/proofOfWorkBox.js":
/*!***************************************************!*\
  !*** ../iota-pico-pow-box/dist/proofOfWorkBox.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pow-box/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar stringHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/stringHelper */ \"../iota-pico-core/dist/helpers/stringHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar hash_1 = __webpack_require__(/*! @iota-pico/data/dist/data/hash */ \"../iota-pico-data/dist/data/hash.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n/**\r\n * ProofOfWork implementation using Remote PowBox.\r\n */\n\n\nvar ProofOfWorkBox =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create an instance of ProofOfWork.\r\n   * @param networkClient The network client to communicate through.\r\n   * @param apiKey The API key to access the pow box.\r\n   */\n  function ProofOfWorkBox(networkClient, apiKey) {\n    var pollIntervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n\n    _classCallCheck(this, ProofOfWorkBox);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(networkClient)) {\n      throw new cryptoError_1.CryptoError(\"The networkClient must be defined\");\n    }\n\n    if (stringHelper_1.StringHelper.isEmpty(apiKey)) {\n      throw new cryptoError_1.CryptoError(\"The apiKey must not be empty\");\n    }\n\n    if (!numberHelper_1.NumberHelper.isInteger(pollIntervalMs) || pollIntervalMs <= 0) {\n      throw new cryptoError_1.CryptoError(\"The pollIntervalMs must be > 0\");\n    }\n\n    this._networkClient = networkClient;\n    this._apiKey = apiKey;\n    this._pollIntervalMs = pollIntervalMs;\n  }\n  /**\r\n   * Allow the proof of work to perform any initialization.\r\n   * Will throw an exception if the implementation is not supported.\r\n   */\n\n\n  _createClass(ProofOfWorkBox, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Performs single conversion per pow call.\r\n     * @returns True if pow only does one conversion.\r\n     */\n\n  }, {\n    key: \"performsSingle\",\n    value: function performsSingle() {\n      return false;\n    }\n    /**\r\n     * Perform a proof of work on the data.\r\n     * @param trunkTransaction The trunkTransaction to use for the pow.\r\n     * @param branchTransaction The branchTransaction to use for the pow.\r\n     * @param trytes The trytes to perform the pow on.\r\n     * @param minWeightMagnitude The minimum weight magnitude.\r\n     * @returns The trytes produced by the proof of work.\r\n     */\n\n  }, {\n    key: \"pow\",\n    value: function () {\n      var _pow = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {\n        var attachToTangleRequest, additionalHeaders, attachToTangleResponse;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (objectHelper_1.ObjectHelper.isType(trunkTransaction, hash_1.Hash)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The trunkTransaction must be an object of type Hash\");\n\n              case 2:\n                if (objectHelper_1.ObjectHelper.isType(branchTransaction, hash_1.Hash)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The branchTransaction must be an object of type Hash\");\n\n              case 4:\n                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The trytes must be an array of type Trytes\");\n\n              case 6:\n                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The minWeightMagnitude must be > 0\");\n\n              case 8:\n                attachToTangleRequest = {\n                  command: \"attachToTangle\",\n                  trunkTransaction: trunkTransaction.toTrytes().toString(),\n                  branchTransaction: branchTransaction.toTrytes().toString(),\n                  minWeightMagnitude: minWeightMagnitude,\n                  trytes: trytes.map(function (t) {\n                    return t.toString();\n                  })\n                };\n                additionalHeaders = {\n                  Authorization: this._apiKey\n                };\n                _context2.next = 12;\n                return this._networkClient.postJson(attachToTangleRequest, \"commands\", additionalHeaders);\n\n              case 12:\n                attachToTangleResponse = _context2.sent;\n\n                if (!(objectHelper_1.ObjectHelper.isEmpty(attachToTangleResponse) || stringHelper_1.StringHelper.isEmpty(attachToTangleResponse.jobId))) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The attachToTangleRequest did not return a jobId\");\n\n              case 17:\n                return _context2.abrupt(\"return\", this.waitForJobCompletion(attachToTangleResponse.jobId, trytes));\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function pow(_x, _x2, _x3, _x4) {\n        return _pow.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"waitForJobCompletion\",\n    value: function () {\n      var _waitForJobCompletion = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(jobId, sourceTrytes) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var intervalId = setInterval(\n                  /*#__PURE__*/\n                  _asyncToGenerator(\n                  /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee3() {\n                    var jobResponse;\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.prev = 0;\n                            _context3.next = 3;\n                            return _this._networkClient.getJson(\"jobs/\".concat(jobId));\n\n                          case 3:\n                            jobResponse = _context3.sent;\n\n                            if (jobResponse.error) {\n                              reject(new cryptoError_1.CryptoError(jobResponse.errorMessage));\n                            } else if (jobResponse.progress === \"100\") {\n                              clearInterval(intervalId);\n\n                              if (jobResponse && jobResponse.response && jobResponse.response.trytes && jobResponse.response.trytes.length === sourceTrytes.length) {\n                                resolve(jobResponse.response.trytes.map(function (t) {\n                                  return trytes_1.Trytes.fromString(t);\n                                }));\n                              } else {\n                                reject(new cryptoError_1.CryptoError(\"The response did not contain enough trytes\"));\n                              }\n                            }\n\n                            _context3.next = 11;\n                            break;\n\n                          case 7:\n                            _context3.prev = 7;\n                            _context3.t0 = _context3[\"catch\"](0);\n                            clearInterval(intervalId);\n                            reject(_context3.t0);\n\n                          case 11:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, this, [[0, 7]]);\n                  })), _this._pollIntervalMs);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      return function waitForJobCompletion(_x5, _x6) {\n        return _waitForJobCompletion.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return ProofOfWorkBox;\n}();\n\nexports.ProofOfWorkBox = ProofOfWorkBox;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/dist/proofOfWorkBox.js?");

/***/ }),

/***/ "../iota-pico-pow-box/node_modules/@babel/runtime/regenerator/index.js":
/*!*****************************************************************************!*\
  !*** ../iota-pico-pow-box/node_modules/@babel/runtime/regenerator/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pow-box/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pow-box/node_modules/regenerator-runtime/runtime-module.js":
/*!*******************************************************************************!*\
  !*** ../iota-pico-pow-box/node_modules/regenerator-runtime/runtime-module.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pow-box/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pow-box/node_modules/regenerator-runtime/runtime.js":
/*!************************************************************************!*\
  !*** ../iota-pico-pow-box/node_modules/regenerator-runtime/runtime.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-box/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-pow-js/dist/index.js":
/*!*****************************************!*\
  !*** ../iota-pico-pow-js/dist/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./proofOfWorkJs */ \"../iota-pico-pow-js/dist/proofOfWorkJs.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pow-js/dist/pearlDiver/pearlDiver.js":
/*!*********************************************************!*\
  !*** ../iota-pico-pow-js/dist/pearlDiver/pearlDiver.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\"); // tslint:disable-next-line:import-name\n\n\nvar big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ \"big-integer\"));\n/**\r\n * PearlDiver implementation in plain JavaScript.\r\n */\n\n\nvar PearlDiver =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of PearlDiver.\r\n   */\n  function PearlDiver() {\n    _classCallCheck(this, PearlDiver);\n\n    var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\");\n    var curlConstants = curl.getConstants();\n    this._hashLength = curlConstants.HASH_LENGTH;\n    this._stateLength = curlConstants.STATE_LENGTH;\n    this._numberRounds = curlConstants.NUMBER_OF_ROUNDS;\n    this._transactionLength = this._hashLength * 33;\n    this._nonceLength = this._hashLength / 3;\n    this._nonceStart = this._hashLength - this._nonceLength;\n    var OFFSET_LENGTH = 4;\n    this._nonceInitStart = this._nonceStart + OFFSET_LENGTH;\n    var INT_LENGTH = this._nonceLength / 3;\n    this._nonceIncrementStart = this._nonceInitStart + INT_LENGTH;\n  }\n  /**\r\n   * Perform a proof of work on the data.\r\n   * @param trytes The trytes to perform the pow on.\r\n   * @param minWeightMagnitude The minimum weight magnitude.\r\n   * @returns The trytes produced by the proof of work.\r\n   */\n\n\n  _createClass(PearlDiver, [{\n    key: \"searchWithTrytes\",\n    value: function searchWithTrytes(trytes, minWeightMagnitude) {\n      var curlState = this.prepare(trytes);\n      var searchStates = this.searchInit(curlState);\n      return this.search(searchStates, minWeightMagnitude);\n    }\n  }, {\n    key: \"search\",\n    value: function search(searchStates, minWeightMagnitude) {\n      var searching = true;\n      var trits = new Int8Array(this._hashLength);\n      var midStateCopy = {\n        low: searchStates.low.slice(),\n        high: searchStates.high.slice()\n      };\n\n      while (searching) {\n        this.increment(midStateCopy, this._nonceIncrementStart, this._hashLength);\n        var state = {\n          low: midStateCopy.low.slice(),\n          high: midStateCopy.high.slice()\n        };\n        this.transform(state);\n        var nonceProbe = this.isFoundFast(state, minWeightMagnitude);\n\n        if (nonceProbe.toJSNumber() === 0) {\n          continue;\n        }\n\n        var nonceOutput = big_integer_1.default(1); // Bit scan forward\n\n        while (nonceOutput.and(nonceProbe).toJSNumber() === 0) {\n          nonceOutput = nonceOutput.shiftLeft(1);\n        }\n\n        searching = false;\n\n        for (var i = 0; i < this._hashLength; i++) {\n          trits[i] = midStateCopy.low[i].and(nonceOutput).toJSNumber() === 0 ? 1 : midStateCopy.high[i].and(nonceOutput).toJSNumber() === 0 ? -1 : 0;\n        }\n      }\n\n      return trits_1.Trits.fromArray(trits).toTrytes();\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(searchStates) {\n      var curlScratchpadIndex = 0;\n\n      for (var round = 0; round < this._numberRounds; round++) {\n        var curlScratchpad = {\n          low: searchStates.low.slice(),\n          high: searchStates.high.slice()\n        };\n\n        for (var stateIndex = 0; stateIndex < this._stateLength; stateIndex++) {\n          var alpha = curlScratchpad.low[curlScratchpadIndex];\n          var beta = curlScratchpad.high[curlScratchpadIndex];\n\n          if (curlScratchpadIndex < 365) {\n            curlScratchpadIndex += 364;\n          } else {\n            curlScratchpadIndex += -365;\n          }\n\n          var gamma = curlScratchpad.high[curlScratchpadIndex];\n          var lowXorBeta = curlScratchpad.low[curlScratchpadIndex].xor(beta);\n          var notGamma = gamma.not();\n          var alphaOrNotGamma = alpha.or(notGamma);\n          var delta = alphaOrNotGamma.and(lowXorBeta);\n          searchStates.low[stateIndex] = delta.not();\n          var alphaXorGamma = alpha.xor(gamma);\n          searchStates.high[stateIndex] = alphaXorGamma.or(delta);\n        }\n      }\n    }\n  }, {\n    key: \"increment\",\n    value: function increment(searchStates, fromIndex, toIndex) {\n      for (var i = fromIndex; i < toIndex; i++) {\n        if (searchStates.low[i].toJSNumber() === PearlDiver.LOW_BITS) {\n          searchStates.low[i] = big_integer_1.default(PearlDiver.HIGH_BITS);\n          searchStates.high[i] = big_integer_1.default(PearlDiver.LOW_BITS);\n        } else {\n          if (searchStates.high[i].toJSNumber() === PearlDiver.LOW_BITS) {\n            searchStates.high[i] = big_integer_1.default(PearlDiver.HIGH_BITS);\n          } else {\n            searchStates.low[i] = big_integer_1.default(PearlDiver.LOW_BITS);\n          }\n\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"prepare\",\n    value: function prepare(transactionTrytes) {\n      var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\");\n      curl.initialize();\n      var transactionTrits = trits_1.Trits.fromTrytes(transactionTrytes).toArray();\n      curl.absorb(transactionTrits, 0, this._transactionLength - this._hashLength);\n      var curlState = curl.getState();\n      transactionTrits.slice(this._transactionLength - this._hashLength, this._transactionLength).forEach(function (value, index) {\n        curlState[index] = value;\n      });\n      return curlState;\n    }\n  }, {\n    key: \"searchInit\",\n    value: function searchInit(curlState) {\n      var states = {\n        low: [],\n        high: []\n      };\n      curlState.forEach(function (trit, index) {\n        switch (trit) {\n          case 0:\n            states.low[index] = big_integer_1.default(PearlDiver.HIGH_BITS);\n            states.high[index] = big_integer_1.default(PearlDiver.HIGH_BITS);\n            break;\n\n          case 1:\n            states.low[index] = big_integer_1.default(PearlDiver.LOW_BITS);\n            states.high[index] = big_integer_1.default(PearlDiver.HIGH_BITS);\n            break;\n\n          default:\n            states.low[index] = big_integer_1.default(PearlDiver.HIGH_BITS);\n            states.high[index] = big_integer_1.default(PearlDiver.LOW_BITS);\n        }\n      });\n      this.searchOffset(states, this._nonceStart);\n      return states;\n    }\n  }, {\n    key: \"searchOffset\",\n    value: function searchOffset(states, offset) {\n      states.low[offset + 0] = big_integer_1.default(\"-2635249153387078803\", 10);\n      states.high[offset + 0] = big_integer_1.default(\"-5270498306774157605\", 10);\n      states.low[offset + 1] = big_integer_1.default(\"-1010780497189564473\", 10);\n      states.high[offset + 1] = big_integer_1.default(\"-8086243977516515777\", 10);\n      states.low[offset + 2] = big_integer_1.default(\"9223336921201902079\", 10);\n      states.high[offset + 2] = big_integer_1.default(\"-17979214271348737\", 10);\n      states.low[offset + 3] = big_integer_1.default(\"-18014398375264257\", 10);\n      states.high[offset + 3] = big_integer_1.default(\"18014398509481983\", 10);\n    }\n  }, {\n    key: \"isFoundFast\",\n    value: function isFoundFast(searchStates, minWeightMagnitude) {\n      var lastMeasurement = big_integer_1.default(PearlDiver.HIGH_BITS);\n\n      for (var i = minWeightMagnitude - 1; i >= 0; i--) {\n        var low = searchStates.low[this._hashLength - 1 - i];\n        var high = searchStates.high[this._hashLength - 1 - i];\n        var lowXorHigh = low.xor(high);\n        var notLowXorHigh = lowXorHigh.not();\n        lastMeasurement = lastMeasurement.and(notLowXorHigh);\n\n        if (lastMeasurement.toJSNumber() === 0) {\n          break;\n        }\n      }\n\n      return lastMeasurement;\n    }\n  }]);\n\n  return PearlDiver;\n}();\n/* @internal */\n\n\nPearlDiver.HIGH_BITS = -1;\n/* @internal */\n\nPearlDiver.LOW_BITS = 0;\nexports.PearlDiver = PearlDiver;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/dist/pearlDiver/pearlDiver.js?");

/***/ }),

/***/ "../iota-pico-pow-js/dist/proofOfWorkJs.js":
/*!*************************************************!*\
  !*** ../iota-pico-pow-js/dist/proofOfWorkJs.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pow-js/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar pearlDiver_1 = __webpack_require__(/*! ./pearlDiver/pearlDiver */ \"../iota-pico-pow-js/dist/pearlDiver/pearlDiver.js\");\n/**\r\n * ProofOfWork implementation using JavaScript.\r\n */\n\n\nvar ProofOfWorkJs =\n/*#__PURE__*/\nfunction () {\n  function ProofOfWorkJs() {\n    _classCallCheck(this, ProofOfWorkJs);\n  }\n\n  _createClass(ProofOfWorkJs, [{\n    key: \"initialize\",\n\n    /**\r\n     * Allow the proof of work to perform any initialization.\r\n     * Will throw an exception if the implementation is not supported.\r\n     */\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Performs single conversion per pow call.\r\n     * @returns True if pow only does one conversion.\r\n     */\n\n  }, {\n    key: \"performsSingle\",\n    value: function performsSingle() {\n      return true;\n    }\n    /**\r\n     * Perform a proof of work on the data.\r\n     * @param trunkTransaction The trunkTransaction to use for the pow.\r\n     * @param branchTransaction The branchTransaction to use for the pow.\r\n     * @param trytes The trytes to perform the pow on.\r\n     * @param minWeightMagnitude The minimum weight magnitude.\r\n     * @returns The trytes produced by the proof of work.\r\n     */\n\n  }, {\n    key: \"pow\",\n    value: function () {\n      var _pow = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {\n        var nonce, nonceString, trytesString;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The trytes must be an array of type Trytes\");\n\n              case 2:\n                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The minWeightMagnitude must be > 0\");\n\n              case 4:\n                nonce = new pearlDiver_1.PearlDiver().searchWithTrytes(trytes[0], minWeightMagnitude);\n                nonceString = nonce.toString();\n                trytesString = trytes.toString();\n                return _context2.abrupt(\"return\", [trytes_1.Trytes.fromString(trytesString.substr(0, trytesString.length - nonceString.length) + nonceString)]);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function pow(_x, _x2, _x3, _x4) {\n        return _pow.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return ProofOfWorkJs;\n}();\n\nexports.ProofOfWorkJs = ProofOfWorkJs;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/dist/proofOfWorkJs.js?");

/***/ }),

/***/ "../iota-pico-pow-js/node_modules/@babel/runtime/regenerator/index.js":
/*!****************************************************************************!*\
  !*** ../iota-pico-pow-js/node_modules/@babel/runtime/regenerator/index.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pow-js/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pow-js/node_modules/regenerator-runtime/runtime-module.js":
/*!******************************************************************************!*\
  !*** ../iota-pico-pow-js/node_modules/regenerator-runtime/runtime-module.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pow-js/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pow-js/node_modules/regenerator-runtime/runtime.js":
/*!***********************************************************************!*\
  !*** ../iota-pico-pow-js/node_modules/regenerator-runtime/runtime.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-js/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/dist/index.js":
/*!*******************************************!*\
  !*** ../iota-pico-pow-wasm/dist/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./proofOfWorkWasm */ \"../iota-pico-pow-wasm/dist/proofOfWorkWasm.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/dist/proofOfWorkWasm.js":
/*!*****************************************************!*\
  !*** ../iota-pico-pow-wasm/dist/proofOfWorkWasm.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pow-wasm/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); /// <reference types=\"emscripten\" />\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\"); // @ts-ignore\n\n\nvar iota_pico_pow_wasm_1 = __importDefault(__webpack_require__(/*! ../wasm/iota-pico-pow-wasm */ \"../iota-pico-pow-wasm/wasm/iota-pico-pow-wasm.js\"));\n/**\r\n * ProofOfWork implementation using WebAssembly.\r\n */\n\n\nvar ProofOfWorkWasm =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of ProofOfWork.\r\n   * @param webPlatform Provides platform specific functions, optional mostly used for testing.\r\n   */\n  function ProofOfWorkWasm(webPlatform) {\n    _classCallCheck(this, ProofOfWorkWasm);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(webPlatform)) {\n      this._webPlatform = {\n        webAssemblyType: typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly),\n        wasmModuleLoader: iota_pico_pow_wasm_1.default\n      };\n    } else {\n      this._webPlatform = webPlatform;\n    }\n  }\n  /**\r\n   * Allow the proof of work to perform any initialization.\r\n   * Will throw an exception if the implementation is not supported.\r\n   */\n\n\n  _createClass(ProofOfWorkWasm, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (objectHelper_1.ObjectHelper.isEmpty(_this._webPlatform.webAssemblyType) || _this._webPlatform.webAssemblyType === \"undefined\") {\n                    reject(new cryptoError_1.CryptoError(\"No WebAssembly support detected\"));\n                  }\n\n                  var module = {};\n\n                  module.onRuntimeInitialized = function () {\n                    _this._ccurlPow = module.cwrap(\"ccurl_pow\", \"string\", [\"string\", \"number\"]);\n                    resolve();\n                  };\n\n                  try {\n                    _this._webPlatform.wasmModuleLoader(module);\n                  } catch (err) {\n                    reject(new cryptoError_1.CryptoError(\"There was a problem intializing the WebAssembly Module\", undefined, err));\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Performs single conversion per pow call.\r\n     * @returns True if pow only does one conversion.\r\n     */\n\n  }, {\n    key: \"performsSingle\",\n    value: function performsSingle() {\n      return true;\n    }\n    /**\r\n     * Perform a proof of work on the data.\r\n     * @param trunkTransaction The trunkTransaction to use for the pow.\r\n     * @param branchTransaction The branchTransaction to use for the pow.\r\n     * @param trytes The trytes to perform the pow on.\r\n     * @param minWeightMagnitude The minimum weight magnitude.\r\n     * @returns The trytes produced by the proof of work.\r\n     */\n\n  }, {\n    key: \"pow\",\n    value: function () {\n      var _pow = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (objectHelper_1.ObjectHelper.isEmpty(_this2._ccurlPow)) {\n                    throw new cryptoError_1.CryptoError(\"WebAssembly not loaded, have you called initialize\");\n                  }\n\n                  if (!arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {\n                    throw new cryptoError_1.CryptoError(\"The trytes must be an array of type Trytes\");\n                  }\n\n                  if (!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0) {\n                    throw new cryptoError_1.CryptoError(\"The minWeightMagnitude must be > 0\");\n                  }\n\n                  try {\n                    var result = _this2._ccurlPow(trytes[0].toString(), minWeightMagnitude);\n\n                    resolve([trytes_1.Trytes.fromString(result)]);\n                  } catch (err) {\n                    reject(err);\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function pow(_x, _x2, _x3, _x4) {\n        return _pow.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return ProofOfWorkWasm;\n}();\n\nexports.ProofOfWorkWasm = ProofOfWorkWasm;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/dist/proofOfWorkWasm.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/node_modules/@babel/runtime/regenerator/index.js":
/*!******************************************************************************!*\
  !*** ../iota-pico-pow-wasm/node_modules/@babel/runtime/regenerator/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime-module.js":
/*!********************************************************************************!*\
  !*** ../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime-module.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime.js":
/*!*************************************************************************!*\
  !*** ../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "../iota-pico-pow-wasm/wasm/iota-pico-pow-wasm.js":
/*!********************************************************!*\
  !*** ../iota-pico-pow-wasm/wasm/iota-pico-pow-wasm.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Module = function Module(_Module) {\n  _Module = _Module || {}; // The Module object: Our interface to the outside world. We import\n  // and export values on it. There are various ways Module can be used:\n  // 1. Not defined. We create it here\n  // 2. A function parameter, function(Module) { ..generated code.. }\n  // 3. pre-run appended it, var Module = {}; ..generated code..\n  // 4. External script tag defines var Module.\n  // We need to check if Module already exists (e.g. case 3 above).\n  // Substitution will be replaced with actual code on later stage of the build,\n  // this way Closure Compiler will not mangle it (e.g. case 4. above).\n  // Note that if you want to run closure, and also to use Module\n  // after the generated code, you will need to define   var Module = {};\n  // before the code. Then that object will be used in the code, and you\n  // can continue to use Module afterwards as well.\n\n  var _Module = typeof _Module !== 'undefined' ? _Module : {}; // --pre-jses are emitted after the Module integration code, so that they can\n  // refer to Module (if they choose; they can also define Module)\n  // {{PRE_JSES}}\n  // Sometimes an existing Module object exists with properties\n  // meant to overwrite the default module functionality. Here\n  // we collect those properties and reapply _after_ we configure\n  // the current environment's defaults to avoid having to be so\n  // defensive during initialization.\n\n\n  var moduleOverrides = {};\n  var key;\n\n  for (key in _Module) {\n    if (_Module.hasOwnProperty(key)) {\n      moduleOverrides[key] = _Module[key];\n    }\n  }\n\n  _Module['arguments'] = [];\n  _Module['thisProgram'] = './this.program';\n\n  _Module['quit'] = function (status, toThrow) {\n    throw toThrow;\n  };\n\n  _Module['preRun'] = [];\n  _Module['postRun'] = []; // The environment setup code below is customized to use Module.\n  // *** Environment setup code ***\n\n  var ENVIRONMENT_IS_WEB = false;\n  var ENVIRONMENT_IS_WORKER = false;\n  var ENVIRONMENT_IS_NODE = false;\n  var ENVIRONMENT_IS_SHELL = false; // Three configurations we can be running in:\n  // 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)\n  // 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)\n  // 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)\n\n  if (_Module['ENVIRONMENT']) {\n    if (_Module['ENVIRONMENT'] === 'WEB') {\n      ENVIRONMENT_IS_WEB = true;\n    } else if (_Module['ENVIRONMENT'] === 'WORKER') {\n      ENVIRONMENT_IS_WORKER = true;\n    } else if (_Module['ENVIRONMENT'] === 'NODE') {\n      ENVIRONMENT_IS_NODE = true;\n    } else if (_Module['ENVIRONMENT'] === 'SHELL') {\n      ENVIRONMENT_IS_SHELL = true;\n    } else {\n      throw new Error('Module[\\'ENVIRONMENT\\'] value is not valid. must be one of: WEB|WORKER|NODE|SHELL.');\n    }\n  } else {\n    ENVIRONMENT_IS_WEB = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object';\n    ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n    ENVIRONMENT_IS_NODE = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && \"function\" === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;\n    ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n  }\n\n  if (ENVIRONMENT_IS_NODE) {\n    // Expose functionality in the same simple way that the shells work\n    // Note that we pollute the global namespace here, otherwise we break in node\n    var nodeFS;\n    var nodePath;\n\n    _Module['read'] = function shell_read(filename, binary) {\n      var ret;\n      ret = tryParseAsDataURI(filename);\n\n      if (!ret) {\n        if (!nodeFS) nodeFS = __webpack_require__(/*! fs */ \"./node_modules/node-libs-browser/mock/empty.js\");\n        if (!nodePath) nodePath = __webpack_require__(/*! path */ \"./node_modules/node-libs-browser/mock/empty.js\");\n        filename = nodePath['normalize'](filename);\n        ret = nodeFS['readFileSync'](filename);\n      }\n\n      return binary ? ret : ret.toString();\n    };\n\n    _Module['readBinary'] = function readBinary(filename) {\n      var ret = _Module['read'](filename, true);\n\n      if (!ret.buffer) {\n        ret = new Uint8Array(ret);\n      }\n\n      assert(ret.buffer);\n      return ret;\n    };\n\n    if (process['argv'].length > 1) {\n      _Module['thisProgram'] = process['argv'][1].replace(/\\\\/g, '/');\n    }\n\n    _Module['arguments'] = process['argv'].slice(2); // MODULARIZE will export the module in the proper place outside, we don't need to export here\n\n    process['on']('uncaughtException', function (ex) {\n      // suppress ExitStatus exceptions from showing an error\n      if (!(ex instanceof ExitStatus)) {\n        throw ex;\n      }\n    }); // Currently node will swallow unhandled rejections, but this behavior is\n    // deprecated, and in the future it will exit with error status.\n\n    process['on']('unhandledRejection', function (reason, p) {\n      _Module['printErr']('node.js exiting due to unhandled promise rejection');\n\n      process['exit'](1);\n    });\n\n    _Module['inspect'] = function () {\n      return '[Emscripten Module object]';\n    };\n  } else if (ENVIRONMENT_IS_SHELL) {\n    if (typeof read != 'undefined') {\n      _Module['read'] = function shell_read(f) {\n        var data = tryParseAsDataURI(f);\n\n        if (data) {\n          return intArrayToString(data);\n        }\n\n        return read(f);\n      };\n    }\n\n    _Module['readBinary'] = function readBinary(f) {\n      var data;\n      data = tryParseAsDataURI(f);\n\n      if (data) {\n        return data;\n      }\n\n      if (typeof readbuffer === 'function') {\n        return new Uint8Array(readbuffer(f));\n      }\n\n      data = read(f, 'binary');\n      assert(_typeof(data) === 'object');\n      return data;\n    };\n\n    if (typeof scriptArgs != 'undefined') {\n      _Module['arguments'] = scriptArgs;\n    } else if (typeof arguments != 'undefined') {\n      _Module['arguments'] = arguments;\n    }\n\n    if (typeof quit === 'function') {\n      _Module['quit'] = function (status, toThrow) {\n        quit(status);\n      };\n    }\n  } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    _Module['read'] = function shell_read(url) {\n      try {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, false);\n        xhr.send(null);\n        return xhr.responseText;\n      } catch (err) {\n        var data = tryParseAsDataURI(url);\n\n        if (data) {\n          return intArrayToString(data);\n        }\n\n        throw err;\n      }\n    };\n\n    if (ENVIRONMENT_IS_WORKER) {\n      _Module['readBinary'] = function readBinary(url) {\n        try {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.responseType = 'arraybuffer';\n          xhr.send(null);\n          return new Uint8Array(xhr.response);\n        } catch (err) {\n          var data = tryParseAsDataURI(url);\n\n          if (data) {\n            return data;\n          }\n\n          throw err;\n        }\n      };\n    }\n\n    _Module['readAsync'] = function readAsync(url, onload, onerror) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'arraybuffer';\n\n      xhr.onload = function xhr_onload() {\n        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n          // file URLs can return 0\n          onload(xhr.response);\n          return;\n        }\n\n        var data = tryParseAsDataURI(url);\n\n        if (data) {\n          onload(data.buffer);\n          return;\n        }\n\n        onerror();\n      };\n\n      xhr.onerror = onerror;\n      xhr.send(null);\n    };\n\n    if (typeof arguments != 'undefined') {\n      _Module['arguments'] = arguments;\n    }\n\n    _Module['setWindowTitle'] = function (title) {\n      document.title = title;\n    };\n  } else {\n    // Unreachable because SHELL is dependent on the others\n    throw new Error('unknown runtime environment');\n  } // console.log is checked first, as 'print' on the web will open a print dialogue\n  // printErr is preferable to console.warn (works better in shells)\n\n\n  _Module['print'] = typeof console !== 'undefined' ? console.log : typeof print !== 'undefined' ? print : null;\n  _Module['printErr'] = typeof printErr !== 'undefined' ? printErr : typeof console !== 'undefined' && console.warn || _Module['print']; // *** Environment setup code ***\n  // Closure helpers\n\n  _Module.print = _Module['print'];\n  _Module.printErr = _Module['printErr']; // Merge back in the overrides\n\n  for (key in moduleOverrides) {\n    if (moduleOverrides.hasOwnProperty(key)) {\n      _Module[key] = moduleOverrides[key];\n    }\n  } // Free the object hierarchy contained in the overrides, this lets the GC\n  // reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.\n\n\n  moduleOverrides = undefined; // {{PREAMBLE_ADDITIONS}}\n\n  var STACK_ALIGN = 16; // stack management, and other functionality that is provided by the compiled code,\n  // should not be used before it is ready\n\n  _stackSave = _stackRestore = stackAlloc = setTempRet0 = getTempRet0 = function getTempRet0() {\n    abort('cannot use the stack before compiled code is ready to run, and has provided stack access');\n  };\n\n  function staticAlloc(size) {\n    assert(!staticSealed);\n    var ret = STATICTOP;\n    STATICTOP = STATICTOP + size + 15 & -16;\n    return ret;\n  }\n\n  function dynamicAlloc(size) {\n    assert(DYNAMICTOP_PTR);\n    var ret = HEAP32[DYNAMICTOP_PTR >> 2];\n    var end = ret + size + 15 & -16;\n    HEAP32[DYNAMICTOP_PTR >> 2] = end;\n\n    if (end >= TOTAL_MEMORY) {\n      var success = enlargeMemory();\n\n      if (!success) {\n        HEAP32[DYNAMICTOP_PTR >> 2] = ret;\n        return 0;\n      }\n    }\n\n    return ret;\n  }\n\n  function alignMemory(size, factor) {\n    if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default\n\n    var ret = size = Math.ceil(size / factor) * factor;\n    return ret;\n  }\n\n  function getNativeTypeSize(type) {\n    switch (type) {\n      case 'i1':\n      case 'i8':\n        return 1;\n\n      case 'i16':\n        return 2;\n\n      case 'i32':\n        return 4;\n\n      case 'i64':\n        return 8;\n\n      case 'float':\n        return 4;\n\n      case 'double':\n        return 8;\n\n      default:\n        {\n          if (type[type.length - 1] === '*') {\n            return 4; // A pointer\n          } else if (type[0] === 'i') {\n            var bits = parseInt(type.substr(1));\n            assert(bits % 8 === 0);\n            return bits / 8;\n          } else {\n            return 0;\n          }\n        }\n    }\n  }\n\n  function warnOnce(text) {\n    if (!warnOnce.shown) warnOnce.shown = {};\n\n    if (!warnOnce.shown[text]) {\n      warnOnce.shown[text] = 1;\n\n      _Module.printErr(text);\n    }\n  }\n\n  var functionPointers = new Array(0);\n\n  function addFunction(func) {\n    for (var i = 0; i < functionPointers.length; i++) {\n      if (!functionPointers[i]) {\n        functionPointers[i] = func;\n        return 1 + i;\n      }\n    }\n\n    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';\n  }\n\n  function removeFunction(index) {\n    functionPointers[index - 1] = null;\n  }\n\n  var funcWrappers = {};\n\n  function getFuncWrapper(func, sig) {\n    if (!func) return; // on null pointer, return undefined\n\n    assert(sig);\n\n    if (!funcWrappers[sig]) {\n      funcWrappers[sig] = {};\n    }\n\n    var sigCache = funcWrappers[sig];\n\n    if (!sigCache[func]) {\n      // optimize away arguments usage in common cases\n      if (sig.length === 1) {\n        sigCache[func] = function dynCall_wrapper() {\n          return dynCall(sig, func);\n        };\n      } else if (sig.length === 2) {\n        sigCache[func] = function dynCall_wrapper(arg) {\n          return dynCall(sig, func, [arg]);\n        };\n      } else {\n        // general case\n        sigCache[func] = function dynCall_wrapper() {\n          return dynCall(sig, func, Array.prototype.slice.call(arguments));\n        };\n      }\n    }\n\n    return sigCache[func];\n  }\n\n  function makeBigInt(low, high, unsigned) {\n    return unsigned ? +(low >>> 0) + +(high >>> 0) * 4294967296.0 : +(low >>> 0) + +(high | 0) * 4294967296.0;\n  }\n\n  function dynCall(sig, ptr, args) {\n    if (args && args.length) {\n      assert(args.length == sig.length - 1);\n      assert('dynCall_' + sig in _Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n      return _Module['dynCall_' + sig].apply(null, [ptr].concat(args));\n    } else {\n      assert(sig.length == 1);\n      assert('dynCall_' + sig in _Module, 'bad function pointer type - no table for sig \\'' + sig + '\\'');\n      return _Module['dynCall_' + sig].call(null, ptr);\n    }\n  }\n\n  function getCompilerSetting(name) {\n    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';\n  }\n\n  var Runtime = {\n    // FIXME backwards compatibility layer for ports. Support some Runtime.*\n    //       for now, fix it there, then remove it from here. That way we\n    //       can minimize any period of breakage.\n    dynCall: dynCall,\n    // for SDL2 port\n    // helpful errors\n    getTempRet0: function getTempRet0() {\n      abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n    },\n    staticAlloc: function staticAlloc() {\n      abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n    },\n    stackAlloc: function stackAlloc() {\n      abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove \"Runtime.\"');\n    }\n  }; // The address globals begin at. Very low in memory, for code size and optimization opportunities.\n  // Above 0 is static memory, starting with globals.\n  // Then the stack.\n  // Then 'dynamic' memory for sbrk.\n\n  var GLOBAL_BASE = 1024; // === Preamble library stuff ===\n  // Documentation for the public APIs defined in this file must be updated in:\n  //    site/source/docs/api_reference/preamble.js.rst\n  // A prebuilt local version of the documentation is available at:\n  //    site/build/text/docs/api_reference/preamble.js.txt\n  // You can also build docs locally as HTML or other formats in site/\n  // An online HTML version (which may be of a different version of Emscripten)\n  //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n  //========================================\n  // Runtime essentials\n  //========================================\n\n  var ABORT = 0; // whether we are quitting the application. no code should run after this. set in exit() and abort()\n\n  var EXITSTATUS = 0;\n  /** @type {function(*, string=)} */\n\n  function assert(condition, text) {\n    if (!condition) {\n      abort('Assertion failed: ' + text);\n    }\n  }\n\n  var globalScope = this; // Returns the C function with a specified identifier (for C++, you need to do manual name mangling)\n\n  function getCFunc(ident) {\n    var func = _Module['_' + ident]; // closure exported function\n\n    assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n    return func;\n  }\n\n  var JSfuncs = {\n    // Helpers for cwrap -- it can't refer to Runtime directly because it might\n    // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find\n    // out what the minified function name is.\n    'stackSave': function stackSave() {\n      _stackSave();\n    },\n    'stackRestore': function stackRestore() {\n      _stackRestore();\n    },\n    // type conversion from js to c\n    'arrayToC': function arrayToC(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    },\n    'stringToC': function stringToC(str) {\n      var ret = 0;\n\n      if (str !== null && str !== undefined && str !== 0) {\n        // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        var len = (str.length << 2) + 1;\n        ret = stackAlloc(len);\n        stringToUTF8(str, ret, len);\n      }\n\n      return ret;\n    }\n  }; // For fast lookup of conversion functions\n\n  var toC = {\n    'string': JSfuncs['stringToC'],\n    'array': JSfuncs['arrayToC']\n  }; // C calling interface.\n\n  function ccall(ident, returnType, argTypes, args, opts) {\n    var func = getCFunc(ident);\n    var cArgs = [];\n    var stack = 0;\n    assert(returnType !== 'array', 'Return type should not be \"array\".');\n\n    if (args) {\n      for (var i = 0; i < args.length; i++) {\n        var converter = toC[argTypes[i]];\n\n        if (converter) {\n          if (stack === 0) stack = _stackSave();\n          cArgs[i] = converter(args[i]);\n        } else {\n          cArgs[i] = args[i];\n        }\n      }\n    }\n\n    var ret = func.apply(null, cArgs);\n    if (returnType === 'string') ret = Pointer_stringify(ret);\n\n    if (stack !== 0) {\n      _stackRestore(stack);\n    }\n\n    return ret;\n  }\n\n  function cwrap(ident, returnType, argTypes) {\n    argTypes = argTypes || [];\n    var cfunc = getCFunc(ident); // When the function takes numbers and returns a number, we can just return\n    // the original function\n\n    var numericArgs = argTypes.every(function (type) {\n      return type === 'number';\n    });\n    var numericRet = returnType !== 'string';\n\n    if (numericRet && numericArgs) {\n      return cfunc;\n    }\n\n    return function () {\n      return ccall(ident, returnType, argTypes, arguments);\n    };\n  }\n  /** @type {function(number, number, string, boolean=)} */\n\n\n  function setValue(ptr, value, type, noSafe) {\n    type = type || 'i8';\n    if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n    switch (type) {\n      case 'i1':\n        HEAP8[ptr >> 0] = value;\n        break;\n\n      case 'i8':\n        HEAP8[ptr >> 0] = value;\n        break;\n\n      case 'i16':\n        HEAP16[ptr >> 1] = value;\n        break;\n\n      case 'i32':\n        HEAP32[ptr >> 2] = value;\n        break;\n\n      case 'i64':\n        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? (Math_min(+Math_floor(tempDouble / 4294967296.0), 4294967295.0) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];\n        break;\n\n      case 'float':\n        HEAPF32[ptr >> 2] = value;\n        break;\n\n      case 'double':\n        HEAPF64[ptr >> 3] = value;\n        break;\n\n      default:\n        abort('invalid type for setValue: ' + type);\n    }\n  }\n  /** @type {function(number, string, boolean=)} */\n\n\n  function getValue(ptr, type, noSafe) {\n    type = type || 'i8';\n    if (type.charAt(type.length - 1) === '*') type = 'i32'; // pointers are 32-bit\n\n    switch (type) {\n      case 'i1':\n        return HEAP8[ptr >> 0];\n\n      case 'i8':\n        return HEAP8[ptr >> 0];\n\n      case 'i16':\n        return HEAP16[ptr >> 1];\n\n      case 'i32':\n        return HEAP32[ptr >> 2];\n\n      case 'i64':\n        return HEAP32[ptr >> 2];\n\n      case 'float':\n        return HEAPF32[ptr >> 2];\n\n      case 'double':\n        return HEAPF64[ptr >> 3];\n\n      default:\n        abort('invalid type for getValue: ' + type);\n    }\n\n    return null;\n  }\n\n  var ALLOC_NORMAL = 0; // Tries to use _malloc()\n\n  var ALLOC_STACK = 1; // Lives for the duration of the current function call\n\n  var ALLOC_STATIC = 2; // Cannot be freed\n\n  var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk\n\n  var ALLOC_NONE = 4; // Do not allocate\n  // allocate(): This is for internal use. You can use it yourself as well, but the interface\n  //             is a little tricky (see docs right below). The reason is that it is optimized\n  //             for multiple syntaxes to save space in generated code. So you should\n  //             normally not use allocate(), and instead allocate memory using _malloc(),\n  //             initialize it with setValue(), and so forth.\n  // @slab: An array of data, or a number. If a number, then the size of the block to allocate,\n  //        in *bytes* (note that this is sometimes confusing: the next parameter does not\n  //        affect this!)\n  // @types: Either an array of types, one for each byte (or 0 if no type at that position),\n  //         or a single type which is used for the entire block. This only matters if there\n  //         is initial data - if @slab is a number, then this does not matter at all and is\n  //         ignored.\n  // @allocator: How to allocate memory, see ALLOC_*\n\n  /** @type {function((TypedArray|Array<number>|number), string, number, number=)} */\n\n  function allocate(slab, types, allocator, ptr) {\n    var zeroinit, size;\n\n    if (typeof slab === 'number') {\n      zeroinit = true;\n      size = slab;\n    } else {\n      zeroinit = false;\n      size = slab.length;\n    }\n\n    var singleType = typeof types === 'string' ? types : null;\n    var ret;\n\n    if (allocator == ALLOC_NONE) {\n      ret = ptr;\n    } else {\n      ret = [typeof _malloc === 'function' ? _malloc : staticAlloc, stackAlloc, staticAlloc, dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));\n    }\n\n    if (zeroinit) {\n      var stop;\n      ptr = ret;\n      assert((ret & 3) == 0);\n      stop = ret + (size & ~3);\n\n      for (; ptr < stop; ptr += 4) {\n        HEAP32[ptr >> 2] = 0;\n      }\n\n      stop = ret + size;\n\n      while (ptr < stop) {\n        HEAP8[ptr++ >> 0] = 0;\n      }\n\n      return ret;\n    }\n\n    if (singleType === 'i8') {\n      if (slab.subarray || slab.slice) {\n        HEAPU8.set(\n        /** @type {!Uint8Array} */\n        slab, ret);\n      } else {\n        HEAPU8.set(new Uint8Array(slab), ret);\n      }\n\n      return ret;\n    }\n\n    var i = 0,\n        type,\n        typeSize,\n        previousType;\n\n    while (i < size) {\n      var curr = slab[i];\n      type = singleType || types[i];\n\n      if (type === 0) {\n        i++;\n        continue;\n      }\n\n      assert(type, 'Must know what type to store in allocate!');\n      if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later\n\n      setValue(ret + i, curr, type); // no need to look up size unless type changes, so cache it\n\n      if (previousType !== type) {\n        typeSize = getNativeTypeSize(type);\n        previousType = type;\n      }\n\n      i += typeSize;\n    }\n\n    return ret;\n  } // Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready\n\n\n  function getMemory(size) {\n    if (!staticSealed) return staticAlloc(size);\n    if (!runtimeInitialized) return dynamicAlloc(size);\n    return _malloc(size);\n  }\n  /** @type {function(number, number=)} */\n\n\n  function Pointer_stringify(ptr, length) {\n    if (length === 0 || !ptr) return ''; // TODO: use TextDecoder\n    // Find the length, and check for UTF while doing so\n\n    var hasUtf = 0;\n    var t;\n    var i = 0;\n\n    while (1) {\n      assert(ptr + i < TOTAL_MEMORY);\n      t = HEAPU8[ptr + i >> 0];\n      hasUtf |= t;\n      if (t == 0 && !length) break;\n      i++;\n      if (length && i == length) break;\n    }\n\n    if (!length) length = i;\n    var ret = '';\n\n    if (hasUtf < 128) {\n      var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack\n\n      var curr;\n\n      while (length > 0) {\n        curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));\n        ret = ret ? ret + curr : curr;\n        ptr += MAX_CHUNK;\n        length -= MAX_CHUNK;\n      }\n\n      return ret;\n    }\n\n    return UTF8ToString(ptr);\n  } // Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns\n  // a copy of that string as a Javascript String object.\n\n\n  function AsciiToString(ptr) {\n    var str = '';\n\n    while (1) {\n      var ch = HEAP8[ptr++ >> 0];\n      if (!ch) return str;\n      str += String.fromCharCode(ch);\n    }\n  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n  // null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.\n\n\n  function stringToAscii(str, outPtr) {\n    return writeAsciiToMemory(str, outPtr, false);\n  } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns\n  // a copy of that string as a Javascript String object.\n\n\n  var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;\n\n  function UTF8ArrayToString(u8Array, idx) {\n    var endPtr = idx; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n    while (u8Array[endPtr]) {\n      ++endPtr;\n    }\n\n    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {\n      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));\n    } else {\n      var u0, u1, u2, u3, u4, u5;\n      var str = '';\n\n      while (1) {\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n        u0 = u8Array[idx++];\n        if (!u0) return str;\n\n        if (!(u0 & 0x80)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n\n        u1 = u8Array[idx++] & 63;\n\n        if ((u0 & 0xE0) == 0xC0) {\n          str += String.fromCharCode((u0 & 31) << 6 | u1);\n          continue;\n        }\n\n        u2 = u8Array[idx++] & 63;\n\n        if ((u0 & 0xF0) == 0xE0) {\n          u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n        } else {\n          u3 = u8Array[idx++] & 63;\n\n          if ((u0 & 0xF8) == 0xF0) {\n            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;\n          } else {\n            u4 = u8Array[idx++] & 63;\n\n            if ((u0 & 0xFC) == 0xF8) {\n              u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;\n            } else {\n              u5 = u8Array[idx++] & 63;\n              u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;\n            }\n          }\n        }\n\n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n        }\n      }\n    }\n  } // Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns\n  // a copy of that string as a Javascript String object.\n\n\n  function UTF8ToString(ptr) {\n    return UTF8ArrayToString(HEAPU8, ptr);\n  } // Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',\n  // encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n  // Parameters:\n  //   str: the Javascript string to copy.\n  //   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.\n  //   outIdx: The starting offset in the array to begin the copying.\n  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n  //                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.\n  //                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.\n  // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {\n    if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.\n      return 0;\n    var startIdx = outIdx;\n    var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n\n    for (var i = 0; i < str.length; ++i) {\n      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n      // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\n      var u = str.charCodeAt(i); // possibly a lead surrogate\n\n      if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n\n      if (u <= 0x7F) {\n        if (outIdx >= endIdx) break;\n        outU8Array[outIdx++] = u;\n      } else if (u <= 0x7FF) {\n        if (outIdx + 1 >= endIdx) break;\n        outU8Array[outIdx++] = 0xC0 | u >> 6;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      } else if (u <= 0xFFFF) {\n        if (outIdx + 2 >= endIdx) break;\n        outU8Array[outIdx++] = 0xE0 | u >> 12;\n        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      } else if (u <= 0x1FFFFF) {\n        if (outIdx + 3 >= endIdx) break;\n        outU8Array[outIdx++] = 0xF0 | u >> 18;\n        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      } else if (u <= 0x3FFFFFF) {\n        if (outIdx + 4 >= endIdx) break;\n        outU8Array[outIdx++] = 0xF8 | u >> 24;\n        outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      } else {\n        if (outIdx + 5 >= endIdx) break;\n        outU8Array[outIdx++] = 0xFC | u >> 30;\n        outU8Array[outIdx++] = 0x80 | u >> 24 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 18 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 12 & 63;\n        outU8Array[outIdx++] = 0x80 | u >> 6 & 63;\n        outU8Array[outIdx++] = 0x80 | u & 63;\n      }\n    } // Null-terminate the pointer to the buffer.\n\n\n    outU8Array[outIdx] = 0;\n    return outIdx - startIdx;\n  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n  // null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.\n  // Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.\n  // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n  function stringToUTF8(str, outPtr, maxBytesToWrite) {\n    assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.\n\n\n  function lengthBytesUTF8(str) {\n    var len = 0;\n\n    for (var i = 0; i < str.length; ++i) {\n      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n      var u = str.charCodeAt(i); // possibly a lead surrogate\n\n      if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\n\n      if (u <= 0x7F) {\n        ++len;\n      } else if (u <= 0x7FF) {\n        len += 2;\n      } else if (u <= 0xFFFF) {\n        len += 3;\n      } else if (u <= 0x1FFFFF) {\n        len += 4;\n      } else if (u <= 0x3FFFFFF) {\n        len += 5;\n      } else {\n        len += 6;\n      }\n    }\n\n    return len;\n  } // Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns\n  // a copy of that string as a Javascript String object.\n\n\n  var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;\n\n  function UTF16ToString(ptr) {\n    assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\n    var endPtr = ptr; // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.\n    // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.\n\n    var idx = endPtr >> 1;\n\n    while (HEAP16[idx]) {\n      ++idx;\n    }\n\n    endPtr = idx << 1;\n\n    if (endPtr - ptr > 32 && UTF16Decoder) {\n      return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n    } else {\n      var i = 0;\n      var str = '';\n\n      while (1) {\n        var codeUnit = HEAP16[ptr + i * 2 >> 1];\n        if (codeUnit == 0) return str;\n        ++i; // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.\n\n        str += String.fromCharCode(codeUnit);\n      }\n    }\n  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n  // null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.\n  // Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.\n  // Parameters:\n  //   str: the Javascript string to copy.\n  //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n  //                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.\n  //                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.\n  // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n  function stringToUTF16(str, outPtr, maxBytesToWrite) {\n    assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\n    assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 0x7FFFFFFF;\n    }\n\n    if (maxBytesToWrite < 2) return 0;\n    maxBytesToWrite -= 2; // Null terminator.\n\n    var startPtr = outPtr;\n    var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n\n    for (var i = 0; i < numCharsToWrite; ++i) {\n      // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\n      var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n      HEAP16[outPtr >> 1] = codeUnit;\n      outPtr += 2;\n    } // Null-terminate the pointer to the HEAP.\n\n\n    HEAP16[outPtr >> 1] = 0;\n    return outPtr - startPtr;\n  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n  function lengthBytesUTF16(str) {\n    return str.length * 2;\n  }\n\n  function UTF32ToString(ptr) {\n    assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\n    var i = 0;\n    var str = '';\n\n    while (1) {\n      var utf32 = HEAP32[ptr + i * 4 >> 2];\n      if (utf32 == 0) return str;\n      ++i; // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n\n      if (utf32 >= 0x10000) {\n        var ch = utf32 - 0x10000;\n        str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n      } else {\n        str += String.fromCharCode(utf32);\n      }\n    }\n  } // Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',\n  // null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.\n  // Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.\n  // Parameters:\n  //   str: the Javascript string to copy.\n  //   outPtr: Byte address in Emscripten HEAP where to write the string to.\n  //   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null\n  //                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.\n  //                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.\n  // Returns the number of bytes written, EXCLUDING the null terminator.\n\n\n  function stringToUTF32(str, outPtr, maxBytesToWrite) {\n    assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\n    assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!'); // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\n\n    if (maxBytesToWrite === undefined) {\n      maxBytesToWrite = 0x7FFFFFFF;\n    }\n\n    if (maxBytesToWrite < 4) return 0;\n    var startPtr = outPtr;\n    var endPtr = startPtr + maxBytesToWrite - 4;\n\n    for (var i = 0; i < str.length; ++i) {\n      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n      var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\n\n      if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\n        var trailSurrogate = str.charCodeAt(++i);\n        codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | trailSurrogate & 0x3FF;\n      }\n\n      HEAP32[outPtr >> 2] = codeUnit;\n      outPtr += 4;\n      if (outPtr + 4 > endPtr) break;\n    } // Null-terminate the pointer to the HEAP.\n\n\n    HEAP32[outPtr >> 2] = 0;\n    return outPtr - startPtr;\n  } // Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.\n\n\n  function lengthBytesUTF32(str) {\n    var len = 0;\n\n    for (var i = 0; i < str.length; ++i) {\n      // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\n      // See http://unicode.org/faq/utf_bom.html#utf16-3\n      var codeUnit = str.charCodeAt(i);\n      if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\n\n      len += 4;\n    }\n\n    return len;\n  } // Allocate heap space for a JS string, and write it there.\n  // It is the responsibility of the caller to free() that memory.\n\n\n  function allocateUTF8(str) {\n    var size = lengthBytesUTF8(str) + 1;\n\n    var ret = _malloc(size);\n\n    if (ret) stringToUTF8Array(str, HEAP8, ret, size);\n    return ret;\n  } // Allocate stack space for a JS string, and write it there.\n\n\n  function allocateUTF8OnStack(str) {\n    var size = lengthBytesUTF8(str) + 1;\n    var ret = stackAlloc(size);\n    stringToUTF8Array(str, HEAP8, ret, size);\n    return ret;\n  }\n\n  function demangle(func) {\n    warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');\n    return func;\n  }\n\n  function demangleAll(text) {\n    var regex = /__Z[\\w\\d_]+/g;\n    return text.replace(regex, function (x) {\n      var y = demangle(x);\n      return x === y ? x : x + ' [' + y + ']';\n    });\n  }\n\n  function jsStackTrace() {\n    var err = new Error();\n\n    if (!err.stack) {\n      // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,\n      // so try that as a special-case.\n      try {\n        throw new Error(0);\n      } catch (e) {\n        err = e;\n      }\n\n      if (!err.stack) {\n        return '(no stack trace available)';\n      }\n    }\n\n    return err.stack.toString();\n  }\n\n  function stackTrace() {\n    var js = jsStackTrace();\n    if (_Module['extraStackTrace']) js += '\\n' + _Module['extraStackTrace']();\n    return demangleAll(js);\n  } // Memory management\n\n\n  var PAGE_SIZE = 16384;\n  var WASM_PAGE_SIZE = 65536;\n  var ASMJS_PAGE_SIZE = 16777216;\n  var MIN_TOTAL_MEMORY = 16777216;\n\n  function alignUp(x, multiple) {\n    if (x % multiple > 0) {\n      x += multiple - x % multiple;\n    }\n\n    return x;\n  }\n\n  var HEAP,\n  /** @type {ArrayBuffer} */\n  buffer,\n  /** @type {Int8Array} */\n  HEAP8,\n  /** @type {Uint8Array} */\n  HEAPU8,\n  /** @type {Int16Array} */\n  HEAP16,\n  /** @type {Uint16Array} */\n  HEAPU16,\n  /** @type {Int32Array} */\n  HEAP32,\n  /** @type {Uint32Array} */\n  HEAPU32,\n  /** @type {Float32Array} */\n  HEAPF32,\n  /** @type {Float64Array} */\n  HEAPF64;\n\n  function updateGlobalBuffer(buf) {\n    _Module['buffer'] = buffer = buf;\n  }\n\n  function updateGlobalBufferViews() {\n    _Module['HEAP8'] = HEAP8 = new Int8Array(buffer);\n    _Module['HEAP16'] = HEAP16 = new Int16Array(buffer);\n    _Module['HEAP32'] = HEAP32 = new Int32Array(buffer);\n    _Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);\n    _Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);\n    _Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);\n    _Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);\n    _Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);\n  }\n\n  var STATIC_BASE, STATICTOP, staticSealed; // static area\n\n  var STACK_BASE, STACKTOP, STACK_MAX; // stack area\n\n  var DYNAMIC_BASE, DYNAMICTOP_PTR; // dynamic area handled by sbrk\n\n  STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;\n  staticSealed = false; // Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\n\n  function writeStackCookie() {\n    assert((STACK_MAX & 3) == 0);\n    HEAPU32[(STACK_MAX >> 2) - 1] = 0x02135467;\n    HEAPU32[(STACK_MAX >> 2) - 2] = 0x89BACDFE;\n  }\n\n  function checkStackCookie() {\n    if (HEAPU32[(STACK_MAX >> 2) - 1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2) - 2] != 0x89BACDFE) {\n      abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2) - 2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2) - 1].toString(16));\n    } // Also test the global address 0 for integrity. This check is not compatible with SAFE_SPLIT_MEMORY though, since that mode already tests all address 0 accesses on its own.\n\n\n    if (HEAP32[0] !== 0x63736d65\n    /* 'emsc' */\n    ) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';\n  }\n\n  function abortStackOverflow(allocSize) {\n    abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - _stackSave() + allocSize) + ' bytes available!');\n  }\n\n  function abortOnCannotGrowMemory() {\n    abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');\n  }\n\n  function enlargeMemory() {\n    abortOnCannotGrowMemory();\n  }\n\n  var TOTAL_STACK = _Module['TOTAL_STACK'] || 5242880;\n  var TOTAL_MEMORY = _Module['TOTAL_MEMORY'] || 16777216;\n  if (TOTAL_MEMORY < TOTAL_STACK) _Module.printErr('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')'); // Initialize the runtime's memory\n  // check for full engine support (use string 'subarray' to avoid closure compiler confusion)\n\n  assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined, 'JS engine does not provide full typed array support'); // Use a provided buffer, if there is one, or else allocate a new one\n\n  if (_Module['buffer']) {\n    buffer = _Module['buffer'];\n    assert(buffer.byteLength === TOTAL_MEMORY, 'provided buffer should be ' + TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);\n  } else {\n    // Use a WebAssembly memory where available\n    if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Memory === 'function') {\n      assert(TOTAL_MEMORY % WASM_PAGE_SIZE === 0);\n      _Module['wasmMemory'] = new WebAssembly.Memory({\n        'initial': TOTAL_MEMORY / WASM_PAGE_SIZE,\n        'maximum': TOTAL_MEMORY / WASM_PAGE_SIZE\n      });\n      buffer = _Module['wasmMemory'].buffer;\n    } else {\n      buffer = new ArrayBuffer(TOTAL_MEMORY);\n    }\n\n    assert(buffer.byteLength === TOTAL_MEMORY);\n    _Module['buffer'] = buffer;\n  }\n\n  updateGlobalBufferViews();\n\n  function getTotalMemory() {\n    return TOTAL_MEMORY;\n  } // Endianness check (note: assumes compiler arch was little-endian)\n\n\n  HEAP32[0] = 0x63736d65;\n  /* 'emsc' */\n\n  HEAP16[1] = 0x6373;\n  if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';\n\n  function callRuntimeCallbacks(callbacks) {\n    while (callbacks.length > 0) {\n      var callback = callbacks.shift();\n\n      if (typeof callback == 'function') {\n        callback();\n        continue;\n      }\n\n      var func = callback.func;\n\n      if (typeof func === 'number') {\n        if (callback.arg === undefined) {\n          _Module['dynCall_v'](func);\n        } else {\n          _Module['dynCall_vi'](func, callback.arg);\n        }\n      } else {\n        func(callback.arg === undefined ? null : callback.arg);\n      }\n    }\n  }\n\n  var __ATPRERUN__ = []; // functions called before the runtime is initialized\n\n  var __ATINIT__ = []; // functions called during startup\n\n  var __ATMAIN__ = []; // functions called when main() is to be run\n\n  var __ATEXIT__ = []; // functions called during shutdown\n\n  var __ATPOSTRUN__ = []; // functions called after the runtime has exited\n\n  var runtimeInitialized = false;\n  var runtimeExited = false;\n\n  function preRun() {\n    // compatibility - merge in anything from Module['preRun'] at this time\n    if (_Module['preRun']) {\n      if (typeof _Module['preRun'] == 'function') _Module['preRun'] = [_Module['preRun']];\n\n      while (_Module['preRun'].length) {\n        addOnPreRun(_Module['preRun'].shift());\n      }\n    }\n\n    callRuntimeCallbacks(__ATPRERUN__);\n  }\n\n  function ensureInitRuntime() {\n    checkStackCookie();\n    if (runtimeInitialized) return;\n    runtimeInitialized = true;\n    callRuntimeCallbacks(__ATINIT__);\n  }\n\n  function preMain() {\n    checkStackCookie();\n    callRuntimeCallbacks(__ATMAIN__);\n  }\n\n  function exitRuntime() {\n    checkStackCookie();\n    callRuntimeCallbacks(__ATEXIT__);\n    runtimeExited = true;\n  }\n\n  function postRun() {\n    checkStackCookie(); // compatibility - merge in anything from Module['postRun'] at this time\n\n    if (_Module['postRun']) {\n      if (typeof _Module['postRun'] == 'function') _Module['postRun'] = [_Module['postRun']];\n\n      while (_Module['postRun'].length) {\n        addOnPostRun(_Module['postRun'].shift());\n      }\n    }\n\n    callRuntimeCallbacks(__ATPOSTRUN__);\n  }\n\n  function addOnPreRun(cb) {\n    __ATPRERUN__.unshift(cb);\n  }\n\n  function addOnInit(cb) {\n    __ATINIT__.unshift(cb);\n  }\n\n  function addOnPreMain(cb) {\n    __ATMAIN__.unshift(cb);\n  }\n\n  function addOnExit(cb) {\n    __ATEXIT__.unshift(cb);\n  }\n\n  function addOnPostRun(cb) {\n    __ATPOSTRUN__.unshift(cb);\n  } // Deprecated: This function should not be called because it is unsafe and does not provide\n  // a maximum length limit of how many bytes it is allowed to write. Prefer calling the\n  // function stringToUTF8Array() instead, which takes in a maximum length that can be used\n  // to be secure from out of bounds writes.\n\n  /** @deprecated */\n\n\n  function writeStringToMemory(string, buffer, dontAddNull) {\n    warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');\n    var\n    /** @type {number} */\n    lastChar,\n    /** @type {number} */\n    end;\n\n    if (dontAddNull) {\n      // stringToUTF8Array always appends null. If we don't want to do that, remember the\n      // character that existed at the location where the null will be placed, and restore\n      // that after the write (below).\n      end = buffer + lengthBytesUTF8(string);\n      lastChar = HEAP8[end];\n    }\n\n    stringToUTF8(string, buffer, Infinity);\n    if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.\n  }\n\n  function writeArrayToMemory(array, buffer) {\n    assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n    HEAP8.set(array, buffer);\n  }\n\n  function writeAsciiToMemory(str, buffer, dontAddNull) {\n    for (var i = 0; i < str.length; ++i) {\n      assert(str.charCodeAt(i) === str.charCodeAt(i) & 0xff);\n      HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n    } // Null-terminate the pointer to the HEAP.\n\n\n    if (!dontAddNull) HEAP8[buffer >> 0] = 0;\n  }\n\n  function unSign(value, bits, ignore) {\n    if (value >= 0) {\n      return value;\n    }\n\n    return bits <= 32 ? 2 * Math.abs(1 << bits - 1) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts\n    : Math.pow(2, bits) + value;\n  }\n\n  function reSign(value, bits, ignore) {\n    if (value <= 0) {\n      return value;\n    }\n\n    var half = bits <= 32 ? Math.abs(1 << bits - 1) // abs is needed if bits == 32\n    : Math.pow(2, bits - 1);\n\n    if (value >= half && (bits <= 32 || value > half)) {\n      // for huge values, we can hit the precision limit and always get true here. so don't do that\n      // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors\n      // TODO: In i64 mode 1, resign the two parts separately and safely\n      value = -2 * half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts\n    }\n\n    return value;\n  }\n\n  assert(Math['imul'] && Math['fround'] && Math['clz32'] && Math['trunc'], 'this is a legacy browser, build with LEGACY_VM_SUPPORT');\n  var Math_abs = Math.abs;\n  var Math_cos = Math.cos;\n  var Math_sin = Math.sin;\n  var Math_tan = Math.tan;\n  var Math_acos = Math.acos;\n  var Math_asin = Math.asin;\n  var Math_atan = Math.atan;\n  var Math_atan2 = Math.atan2;\n  var Math_exp = Math.exp;\n  var Math_log = Math.log;\n  var Math_sqrt = Math.sqrt;\n  var Math_ceil = Math.ceil;\n  var Math_floor = Math.floor;\n  var Math_pow = Math.pow;\n  var Math_imul = Math.imul;\n  var Math_fround = Math.fround;\n  var Math_round = Math.round;\n  var Math_min = Math.min;\n  var Math_max = Math.max;\n  var Math_clz32 = Math.clz32;\n  var Math_trunc = Math.trunc; // A counter of dependencies for calling run(). If we need to\n  // do asynchronous work before running, increment this and\n  // decrement it. Incrementing must happen in a place like\n  // PRE_RUN_ADDITIONS (used by emcc to add file preloading).\n  // Note that you can add dependencies in preRun, even though\n  // it happens right before run - run will be postponed until\n  // the dependencies are met.\n\n  var runDependencies = 0;\n  var runDependencyWatcher = null;\n  var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\n  var runDependencyTracking = {};\n\n  function getUniqueRunDependency(id) {\n    var orig = id;\n\n    while (1) {\n      if (!runDependencyTracking[id]) return id;\n      id = orig + Math.random();\n    }\n\n    return id;\n  }\n\n  function addRunDependency(id) {\n    runDependencies++;\n\n    if (_Module['monitorRunDependencies']) {\n      _Module['monitorRunDependencies'](runDependencies);\n    }\n\n    if (id) {\n      assert(!runDependencyTracking[id]);\n      runDependencyTracking[id] = 1;\n\n      if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {\n        // Check for missing dependencies every few seconds\n        runDependencyWatcher = setInterval(function () {\n          if (ABORT) {\n            clearInterval(runDependencyWatcher);\n            runDependencyWatcher = null;\n            return;\n          }\n\n          var shown = false;\n\n          for (var dep in runDependencyTracking) {\n            if (!shown) {\n              shown = true;\n\n              _Module.printErr('still waiting on run dependencies:');\n            }\n\n            _Module.printErr('dependency: ' + dep);\n          }\n\n          if (shown) {\n            _Module.printErr('(end of list)');\n          }\n        }, 10000);\n      }\n    } else {\n      _Module.printErr('warning: run dependency added without ID');\n    }\n  }\n\n  function removeRunDependency(id) {\n    runDependencies--;\n\n    if (_Module['monitorRunDependencies']) {\n      _Module['monitorRunDependencies'](runDependencies);\n    }\n\n    if (id) {\n      assert(runDependencyTracking[id]);\n      delete runDependencyTracking[id];\n    } else {\n      _Module.printErr('warning: run dependency removed without ID');\n    }\n\n    if (runDependencies == 0) {\n      if (runDependencyWatcher !== null) {\n        clearInterval(runDependencyWatcher);\n        runDependencyWatcher = null;\n      }\n\n      if (dependenciesFulfilled) {\n        var callback = dependenciesFulfilled;\n        dependenciesFulfilled = null;\n        callback(); // can add another dependenciesFulfilled\n      }\n    }\n  }\n\n  _Module[\"preloadedImages\"] = {}; // maps url to image data\n\n  _Module[\"preloadedAudios\"] = {}; // maps url to audio data\n\n  var memoryInitializer = null;\n  var\n  /* show errors on likely calls to FS when it was not included */\n  FS = {\n    error: function error() {\n      abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');\n    },\n    init: function init() {\n      FS.error();\n    },\n    createDataFile: function createDataFile() {\n      FS.error();\n    },\n    createPreloadedFile: function createPreloadedFile() {\n      FS.error();\n    },\n    createLazyFile: function createLazyFile() {\n      FS.error();\n    },\n    open: function open() {\n      FS.error();\n    },\n    mkdev: function mkdev() {\n      FS.error();\n    },\n    registerDevice: function registerDevice() {\n      FS.error();\n    },\n    analyzePath: function analyzePath() {\n      FS.error();\n    },\n    loadFilesFromDB: function loadFilesFromDB() {\n      FS.error();\n    },\n    ErrnoError: function ErrnoError() {\n      FS.error();\n    }\n  };\n  _Module['FS_createDataFile'] = FS.createDataFile;\n  _Module['FS_createPreloadedFile'] = FS.createPreloadedFile; // Prefix of data URIs emitted by SINGLE_FILE and related options.\n\n  var dataURIPrefix = 'data:application/octet-stream;base64,'; // Indicates whether filename is a base64 data URI.\n\n  function isDataURI(filename) {\n    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;\n  }\n\n  function integrateWasmJS() {\n    // wasm.js has several methods for creating the compiled code module here:\n    //  * 'native-wasm' : use native WebAssembly support in the browser\n    //  * 'interpret-s-expr': load s-expression code from a .wast and interpret\n    //  * 'interpret-binary': load binary wasm and interpret\n    //  * 'interpret-asm2wasm': load asm.js code, translate to wasm, and interpret\n    //  * 'asmjs': no wasm, just load the asm.js code and use that (good for testing)\n    // The method is set at compile time (BINARYEN_METHOD)\n    // The method can be a comma-separated list, in which case, we will try the\n    // options one by one. Some of them can fail gracefully, and then we can try\n    // the next.\n    // inputs\n    var method = 'native-wasm';\n    var wasmTextFile = '';\n    var wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAABchJgA39/fwF/YAF/AX9gAAF/YAF/AGACf38Bf2AEf39/fwF/YAJ/fwBgA39/fwBgBH9/f38AYAN/f38BfmAAAGAFf39/f38Bf2ADfn9/AX9gAn5/AX9gBX9/f39/AGAGf3x/f39/AX9gAXwBfmACfH8BfAKXBSEDZW52Bm1lbW9yeQIBgAKAAgNlbnYFdGFibGUBcAEQEANlbnYKbWVtb3J5QmFzZQN/AANlbnYJdGFibGVCYXNlA38AA2Vudg5EWU5BTUlDVE9QX1BUUgN/AANlbnYNdGVtcERvdWJsZVB0cgN/AANlbnYFQUJPUlQDfwADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwADZW52B2N0dHpfaTgDfwAGZ2xvYmFsA05hTgN8AAZnbG9iYWwISW5maW5pdHkDfAADZW52DWVubGFyZ2VNZW1vcnkAAgNlbnYOZ2V0VG90YWxNZW1vcnkAAgNlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkAAgNlbnYSYWJvcnRTdGFja092ZXJmbG93AAMDZW52C251bGxGdW5jX2lpAAMDZW52DW51bGxGdW5jX2lpaWkAAwNlbnYHX19fbG9jawADA2VudgtfX19zZXRFcnJObwADA2Vudg1fX19zeXNjYWxsMTQwAAQDZW52DV9fX3N5c2NhbGwxNDYABANlbnYMX19fc3lzY2FsbDU0AAQDZW52C19fX3N5c2NhbGw2AAQDZW52CV9fX3VubG9jawADA2VudiFfZW1zY3JpcHRlbl9oYXNfdGhyZWFkaW5nX3N1cHBvcnQAAgNlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwAAA2VudhJfbGx2bV9zdGFja3Jlc3RvcmUAAwNlbnYPX2xsdm1fc3RhY2tzYXZlAAIDZW52D19wdGhyZWFkX2NyZWF0ZQAFA2Vudg1fcHRocmVhZF9qb2luAAQDZW52E19wdGhyZWFkX211dGV4X2luaXQABANlbnYIX3N5c2NvbmYAAQNSUQECAwYGAwIEAwcDCAcBCAAICQQACgYBAwEAAAECAQAEAAsBAwcBBwwNDQEADgQPEBERAAICAgQEBAAEAAEEAQQEAgoBAQAKAQAAAQEBBAUBAAZyFH8BIwILfwEjAwt/ASMEC38BIwULfwEj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IQQgBA8L9BEDC38EfgV8Iw0hDCAAvSEPIA9CNIghECAQp0H//wNxIQkgCUH/D3EhCgJAAkACQAJAIApBEHRBEHVBAGsOgBAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQILAkAgAEQAAAAAAAAAAGIhBCAEBEAgAEQAAAAAAADwQ6IhFCAUIAEQRiEVIAEoAgAhBSAFQUBqIQYgFSESIAYhCAUgACESQQAhCAsgASAINgIAIBIhEQwDAAsACwJAIAAhEQwCAAsACwJAIBCnIQcgB0H/D3EhAiACQYJ4aiEDIAEgAzYCACAPQv////////+HgH+DIQ0gDUKAgICAgICA8D+EIQ4gDr8hEyATIRELCyARDwvkBAE7fyMNIT0gAEEARiEYAkAgGARAQQEhAwUgAUGAAUkhIyAjBEAgAUH/AXEhLiAAIC46AABBASEDDAILEEghNyA3QbwBaiE4IDgoAgAhOSA5KAIAITogOkEARiEEIAQEQCABQYB/cSEFIAVBgL8DRiEGIAYEQCABQf8BcSEIIAAgCDoAAEEBIQMMAwUQMSEHIAdB1AA2AgBBfyEDDAMLAAsgAUGAEEkhCSAJBEAgAUEGdiEKIApBwAFyIQsgC0H/AXEhDCAAQQFqIQ0gACAMOgAAIAFBP3EhDiAOQYABciEPIA9B/wFxIRAgDSAQOgAAQQIhAwwCCyABQYCwA0khESABQYBAcSESIBJBgMADRiETIBEgE3IhOyA7BEAgAUEMdiEUIBRB4AFyIRUgFUH/AXEhFiAAQQFqIRcgACAWOgAAIAFBBnYhGSAZQT9xIRogGkGAAXIhGyAbQf8BcSEcIABBAmohHSAXIBw6AAAgAUE/cSEeIB5BgAFyIR8gH0H/AXEhICAdICA6AABBAyED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ADYCACAPQQA2AgAgAkEANgIAIAVBADYCACADQQA2AgBBACEBCyABDws3AQR/Iw0hBiMNQRBqJA0jDSMOTgRAQRAQAwsgBiEDIAMgAjYCACAAIAEgAxA1IQQgBiQNIAQPCwMAAQssACAAQf8BcUEYdCAAQQh1Qf8BcUEQdHIgAEEQdUH/AXFBCHRyIABBGHZyDwvkBAEEfyACQYDAAE4EQCAAIAEgAhAODwsgACEDIAAgAmohBiAAQQNxIAFBA3FGBEADQAJAIABBA3FFBEAMAQsCQCACQQBGBEAgAw8LIAAgASwAADoAACAAQQFqIQAgAUEBaiEBIAJBAWshAgsMAQsLIAZBfHEhBCAEQcAAayEFA0ACQCAAIAVMRQRADAELAkAgACABKAIANgIAIABBBGogAUEEaigCADYCACAAQQhqIAFBCGooAgA2AgAgAEEMaiABQQxqKAIANgIAIABBEGogAUEQaigCADYCACAAQRRqIAFBFGooAgA2AgAgAEEYaiABQRhqKAIANgIAIABBHGogAUEcaigCADYCACAAQSBqIAFBIGooAgA2AgAgAEEkaiABQSRqKAIANgIAIABBKGogAUEoaigCADYCACAAQSxqIAFBLGooAgA2AgAgAEEwaiABQTBqKAIANgIAIABBNGogAUE0aigCADYCACAAQThqIAFBOGooAgA2AgAgAEE8aiABQTxqKAIANgIAIABBwABqIQAgAUHAAGohAQsMAQsLA0ACQCAAIARIRQRADAELAkAgACABKAIANgIAIABBBGohACABQQRqIQELDAELCwUgBkEEayEEA0ACQCAAIARIRQRADAELAkAgACABLAAAOgAAIABBAWogAUEBaiwAADoAACAAQQJqIAFBAmosAAA6AAAgAEEDaiABQQNqLAAAOgAAIABBBGohACABQQRqIQELDAELCwsDQAJAIAAgBkhFBEAMAQsCQCAAIAEsAAA6AAAgAEEBaiEAIAFBAWohAQsMAQsLIAMPC/ECAQR/IAAgAmohAyABQf8BcSEBIAJBwwBOBEADQAJAIABBA3FBAEdFBEAMAQsCQCAAIAE6AAAgAEEBaiEACwwBCwsgA0F8cSEEIARBwABrIQUgASABQQh0ciABQRB0ciABQRh0ciEGA0ACQCAAIAVMRQRADAELAkAgACAGNgIAIABBBGogBjYCACAAQQhqIAY2AgAgAEEMaiAGNgIAIABBEGogBjYCACAAQRRqIAY2AgAgAEEYaiAGNgIAIABBHGogBjYCACAAQSBqIAY2AgAgAEEkaiAGNgIAIABBKGogBjYCACAAQSxqIAY2AgAgAEEwaiAGNgIAIABBNGogBjYCACAAQThqIAY2AgAgAEE8aiAGNgIAIABBwABqIQALDAELCwNAAkAgACAESEUEQAwBCwJAIAAgBjYCACAAQQRqIQALDAELCwsDQAJAIAAgA0hFBEAMAQsCQCAAIAE6AAAgAEEBaiEACwwBCwsgAyACaw8LBQBBAA8LBQBBAA8LZgEEfyAAQQ9qQXBxIQAjCigCACEBIAEgAGohAyAAQQBKIAMgAUhxIANBAEhyBEAQAhpBDBAHQX8PCyMKIAM2AgAQASEEIAMgBEoEQBAAQQBGBEAjCiABNgIAQQwQB0F/DwsLIAEPCxAAIAEgAEEHcUEAahEBAA8LFAAgASACIAMgAEEHcUEIahEAAA8LCQBBABAEQQAPCwkAQQEQBUEADwsLwi4BAEGACAu6LgAAAABsAQAA2AIAAGsBAADXAgAAagEAANYCAABpAQAA1QIAAGgBAADUAgAAZwEAANMCAABmAQAA0gIAAGUBAADRAgAAZAEAANACAABjAQAAzwIAAGIBAADOAgAAYQEAAM0CAABgAQAAzAIAAF8BAADLAgAAXgEAAMoCAABdAQAAyQIAAFwBAADIAgAAWwEAAMcCAABaAQAAxgIAAFkBAADFAgAAWAEAAMQCAABXAQAAwwIAAFYBAADCAgAAVQEAAMECAABUAQAAwAIAAFMBAAC/AgAAUgEAAL4CAABRAQAAvQIAAFABAAC8AgAATwEAALsCAABOAQAAugIAAE0BAAC5AgAATAEAALgCAABLAQAAtwIAAEoBAAC2AgAASQEAALUCAABIAQAAtAIAAEcBAACzAgAARgEAALICAABFAQAAsQIAAEQBAACwAgAAQwEAAK8CAABCAQAArgIAAEEBAACtAgAAQAEAAKwCAAA/AQAAqwIAAD4BAACqAgAAPQEAAKkCAAA8AQAAqAIAADsBAACnAgAAOgEAAKYCAAA5AQAApQIAADgBAACkAgAANwEAAKMCAAA2AQAAogIAADUBAAChAgAANAEAAKACAAAzAQAAnwIAADIBAACeAgAAMQEAAJ0CAAAwAQAAnAIAAC8BAACbAgAALgEAAJoCAAAtAQAAmQIAACwBAACYAgAAKwEAAJcCAAAqAQAAlgIAACkBAACVAgAAKAEAAJQCAAAnAQAAkwIAACYBAACSAgAAJQEAAJECAAAkAQAAkAIAACMBAACPAgAAIgEAAI4CAAAhAQAAjQIAACABAACMAgAAHwEAAIsCAAAeAQAAigIAAB0BAACJAgAAHAEAAIgCAAAbAQAAhwIAABoBAACGAgAAGQEAAIUCAAAYAQAAhAIAABcBAACDAgAAFgEAAIICAAAVAQAAgQIAABQBAACAAgAAEwEAAH8CAAASAQAAfgIAABEBAAB9AgAAEAEAAHwCAAAPAQAAewIAAA4BAAB6AgAADQEAAHkCAAAMAQAAeAIAAAsBAAB3AgAACgEAAHYCAAAJAQAAdQIAAAgBAAB0AgAABwEAAHMCAAAGAQAAcgIAAAUBAABxAgAABAEAAHACAAADAQAAbwIAAAIBAABuAgAAAQEAAG0CAAAAAQAAbAIAAP8AAABrAgAA/gAAAGoCAAD9AAAAaQIAAPwAAABoAgAA+wAAAGcCAAD6AAAAZgIAAPkAAABlAgAA+AAAAGQCAAD3AAAAYwIAAPYAAABiAgAA9QAAAGECAAD0AAAAYAIAAPMAAABfAgAA8gAAAF4CAADxAAAAXQIAAPAAAABcAgAA7wAAAFsCAADuAAAAWgIAAO0AAABZAgAA7AAAAFgCAADrAAAAVwIAAOoAAABWAgAA6QAAAFUCAADoAAAAVAIAAOcAAABTAgAA5gAAAFICAADlAAAAUQIAAOQAAABQAgAA4wAAAE8CAADiAAAATgIAAOEAAABNAgAA4AAAAEwCAADfAAAASwIAAN4AAABKAgAA3QAAAEkCAADcAAAASAIAANsAAABHAgAA2gAAAEYCAADZAAAARQIAANgAAABEAgAA1wAAAEMCAADWAAAAQgIAANUAAABBAgAA1AAAAEACAADTAAAAPwIAANIAAAA+AgAA0QAAAD0CAADQAAAAPAIAAM8AAAA7AgAAzgAAADoCAADNAAAAOQIAAMwAAAA4AgAAywAAADcCAADKAAAANgIAAMkAAAA1AgAAyAAAADQCAADHAAAAMwIAAMYAAAAyAgAAxQAAADECAADEAAAAMAIAAMMAAAAvAgAAwgAAAC4CAADBAAAALQIAAMAAAAAsAgAAvwAAACsCAAC+AAAAKgIAAL0AAAApAgAAvAAAACgCAAC7AAAAJwIAALoAAAAmAgAAuQAAACUCAAC4AAAAJAIAALcAAAAjAgAAtgAAACICAAC1AAAAIQIAALQAAAAgAgAAswAAAB8CAACyAAAAHgIAALEAAAAdAgAAsAAAABwCAACvAAAAGwIAAK4AAAAaAgAArQAAABkCAACsAAAAGAIAAKsAAAAXAgAAqgAAABYCAACpAAAAFQIAAKgAAAAUAgAApwAAABMCAACmAAAAEgIAAKUAAAARAgAApAAAABACAACjAAAADwIAAKIAAAAOAgAAoQAAAA0CAACgAAAADAIAAJ8AAAALAgAAngAAAAoCAACdAAAACQIAAJwAAAAIAgAAmwAAAAcCAACaAAAABgIAAJkAAAAFAgAAmAAAAAQCAACXAAAAAwIAAJYAAAACAgAAlQAAAAECAACUAAAAAAIAAJMAAAD/AQAAkgAAAP4BAACRAAAA/QEAAJAAAAD8AQAAjwAAAPsBAACOAAAA+gEAAI0AAAD5AQAAjAAAAPgBAACLAAAA9wEAAIoAAAD2AQAAiQAAAPUBAACIAAAA9AEAAIcAAADzAQAAhgAAAPIBAACFAAAA8QEAAIQAAADwAQAAgwAAAO8BAACCAAAA7gEAAIEAAADtAQAAgAAAAOwBAAB/AAAA6wEAAH4AAADqAQAAfQAAAOkBAAB8AAAA6AEAAHsAAADnAQAAegAAAOYBAAB5AAAA5QEAAHgAAADkAQAAdwAAAOMBAAB2AAAA4gEAAHUAAADhAQAAdAAAAOABAABzAAAA3wEAAHIAAADeAQAAcQAAAN0BAABwAAAA3AEAAG8AAADbAQAAbgAAANoBAABtAAAA2QEAAGwAAADYAQAAawAAANcBAABqAAAA1gEAAGkAAADVAQAAaAAAANQBAABnAAAA0wEAAGYAAADSAQAAZQAAANEBAABkAAAA0AEAAGMAAADPAQAAYgAAAM4BAABhAAAAzQEAAGAAAADMAQAAXwAAAMsBAABeAAAAygEAAF0AAADJAQAAXAAAAMgBAABbAAAAxwEAAFoAAADGAQAAWQAAAMUBAABYAAAAxAEAAFcAAADDAQAAVgAAAMIBAABVAAAAwQEAAFQAAADAAQAAUwAAAL8BAABSAAAAvgEAAFEAAAC9AQAAUAAAALwBAABPAAAAuwEAAE4AAAC6AQAATQAAALkBAABMAAAAuAEAAEsAAAC3AQAASgAAALYBAABJAAAAtQEAAEgAAAC0AQAARwAAALMBAABGAAAAsgEAAEUAAACxAQAARAAAALABAABDAAAArwEAAEIAAACuAQAAQQAAAK0BAABAAAAArAEAAD8AAACrAQAAPgAAAKoBAAA9AAAAqQEAADwAAACoAQAAOwAAAKcBAAA6AAAApgEAADkAAAClAQAAOAAAAKQBAAA3AAAAowEAADYAAACiAQAANQAAAKEBAAA0AAAAoAEAADMAAACfAQAAMgAAAJ4BAAAxAAAAnQEAADAAAACcAQAALwAAAJsBAAAuAAAAmgEAAC0AAACZAQAALAAAAJgBAAArAAAAlwEAACoAAACWAQAAKQAAAJUBAAAoAAAAlAEAACcAAACTAQAAJgAAAJIBAAAlAAAAkQEAACQAAACQAQAAIwAAAI8BAAAiAAAAjgEAACEAAACNAQAAIAAAAIwBAAAfAAAAiwEAAB4AAACKAQAAHQAAAIkBAAAcAAAAiAEAABsAAACHAQAAGgAAAIYBAAAZAAAAhQEAABgAAACEAQAAFwAAAIMBAAAWAAAAggEAABUAAACBAQAAFAAAAIABAAATAAAAfwEAABIAAAB+AQAAEQAAAH0BAAAQAAAAfAEAAA8AAAB7AQAADgAAAHoBAAANAAAAeQEAAAwAAAB4AQAACwAAAHcBAAAKAAAAdgEAAAkAAAB1AQAACAAAAHQBAAAHAAAAcwEAAAYAAAByAQAABQAAAHEBAAAEAAAAcAEAAAMAAABvAQAAAgAAAG4BAAABAAAAbQEAAAAAAAABAAAAAAAAAP////8CAAAAAQAAAP////8AAAAAAgAAAP////8BAAAAAAAAAJgPAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAwAAAJQiAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAD//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAMAAACcIgAAAAQAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACv////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBtaW5XZWlnaHRNYWduaXR1ZGUgJWQAOUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaABEACgAREREAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAEQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERERAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAABEACgoREREACgAAAgAJCwAAAAkACwAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAwAAAAACQwAAAAAAAwAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAADQAAAAQNAAAAAAkOAAAAAAAOAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAA8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAEhISAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAACgAAAAAKAAAAAAkLAAAAAAALAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAADAAAAAAJDAAAAAAADAAADAAALSsgICAwWDB4AChudWxsKQAtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBuYW4ATkFOADAxMjM0NTY3ODlBQkNERUYuAFQhIhkNAQIDEUscDBAECx0SHidobm9wcWIgBQYPExQVGggWBygkFxgJCg4bHyUjg4J9JiorPD0+P0NHSk1YWVpbXF1eX2BhY2RlZmdpamtscnN0eXp7fABJbGxlZ2FsIGJ5dGUgc2VxdWVuY2UARG9tYWluIGVycm9yAFJlc3VsdCBub3QgcmVwcmVzZW50YWJsZQBOb3QgYSB0dHkAUGVybWlzc2lvbiBkZW5pZWQAT3BlcmF0aW9uIG5vdCBwZXJtaXR0ZWQATm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeQBObyBzdWNoIHByb2Nlc3MARmlsZSBleGlzdHMAVmFsdWUgdG9vIGxhcmdlIGZvciBkYXRhIHR5cGUATm8gc3BhY2UgbGVmdCBvbiBkZXZpY2UAT3V0IG9mIG1lbW9yeQBSZXNvdXJjZSBidXN5AEludGVycnVwdGVkIHN5c3RlbSBjYWxsAFJlc291cmNlIHRlbXBvcmFyaWx5IHVuYXZhaWxhYmxlAEludmFsaWQgc2VlawBDcm9zcy1kZXZpY2UgbGluawBSZWFkLW9ubHkgZmlsZSBzeXN0ZW0ARGlyZWN0b3J5IG5vdCBlbXB0eQBDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXIAT3BlcmF0aW9uIHRpbWVkIG91dABDb25uZWN0aW9uIHJlZnVzZWQASG9zdCBpcyBkb3duAEhvc3QgaXMgdW5yZWFjaGFibGUAQWRkcmVzcyBpbiB1c2UAQnJva2VuIHBpcGUASS9PIGVycm9yAE5vIHN1Y2ggZGV2aWNlIG9yIGFkZHJlc3MAQmxvY2sgZGV2aWNlIHJlcXVpcmVkAE5vIHN1Y2ggZGV2aWNlAE5vdCBhIGRpcmVjdG9yeQBJcyBhIGRpcmVjdG9yeQBUZXh0IGZpbGUgYnVzeQBFeGVjIGZvcm1hdCBlcnJvcgBJbnZhbGlkIGFyZ3VtZW50AEFyZ3VtZW50IGxpc3QgdG9vIGxvbmcAU3ltYm9saWMgbGluayBsb29wAEZpbGVuYW1lIHRvbyBsb25nAFRvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtAE5vIGZpbGUgZGVzY3JpcHRvcnMgYXZhaWxhYmxlAEJhZCBmaWxlIGRlc2NyaXB0b3IATm8gY2hpbGQgcHJvY2VzcwBCYWQgYWRkcmVzcwBGaWxlIHRvbyBsYXJnZQBUb28gbWFueSBsaW5rcwBObyBsb2NrcyBhdmFpbGFibGUAUmVzb3VyY2UgZGVhZGxvY2sgd291bGQgb2NjdXIAU3RhdGUgbm90IHJlY292ZXJhYmxlAFByZXZpb3VzIG93bmVyIGRpZWQAT3BlcmF0aW9uIGNhbmNlbGVkAEZ1bmN0aW9uIG5vdCBpbXBsZW1lbnRlZABObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZQBJZGVudGlmaWVyIHJlbW92ZWQARGV2aWNlIG5vdCBhIHN0cmVhbQBObyBkYXRhIGF2YWlsYWJsZQBEZXZpY2UgdGltZW91dABPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMATGluayBoYXMgYmVlbiBzZXZlcmVkAFByb3RvY29sIGVycm9yAEJhZCBtZXNzYWdlAEZpbGUgZGVzY3JpcHRvciBpbiBiYWQgc3RhdGUATm90IGEgc29ja2V0AERlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQATWVzc2FnZSB0b28gbGFyZ2UAUHJvdG9jb2wgd3JvbmcgdHlwZSBmb3Igc29ja2V0AFByb3RvY29sIG5vdCBhdmFpbGFibGUAUHJvdG9jb2wgbm90IHN1cHBvcnRlZABTb2NrZXQgdHlwZSBub3Qgc3VwcG9ydGVkAE5vdCBzdXBwb3J0ZWQAUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQAQWRkcmVzcyBmYW1pbHkgbm90IHN1cHBvcnRlZCBieSBwcm90b2NvbABBZGRyZXNzIG5vdCBhdmFpbGFibGUATmV0d29yayBpcyBkb3duAE5ldHdvcmsgdW5yZWFjaGFibGUAQ29ubmVjdGlvbiByZXNldCBieSBuZXR3b3JrAENvbm5lY3Rpb24gYWJvcnRlZABObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlAFNvY2tldCBpcyBjb25uZWN0ZWQAU29ja2V0IG5vdCBjb25uZWN0ZWQAQ2Fubm90IHNlbmQgYWZ0ZXIgc29ja2V0IHNodXRkb3duAE9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzAE9wZXJhdGlvbiBpbiBwcm9ncmVzcwBTdGFsZSBmaWxlIGhhbmRsZQBSZW1vdGUgSS9PIGVycm9yAFF1b3RhIGV4Y2VlZGVkAE5vIG1lZGl1bSBmb3VuZABXcm9uZyBtZWRpdW0gdHlwZQBObyBlcnJvciBpbmZvcm1hdGlvbg==';\n    var asmjsCodeFile = '';\n\n    if (typeof _Module['locateFile'] === 'function') {\n      if (!isDataURI(wasmTextFile)) {\n        wasmTextFile = _Module['locateFile'](wasmTextFile);\n      }\n\n      if (!isDataURI(wasmBinaryFile)) {\n        wasmBinaryFile = _Module['locateFile'](wasmBinaryFile);\n      }\n\n      if (!isDataURI(asmjsCodeFile)) {\n        asmjsCodeFile = _Module['locateFile'](asmjsCodeFile);\n      }\n    } // utilities\n\n\n    var wasmPageSize = 64 * 1024;\n    var info = {\n      'global': null,\n      'env': null,\n      'asm2wasm': {\n        // special asm2wasm imports\n        \"f64-rem\": function f64Rem(x, y) {\n          return x % y;\n        },\n        \"debugger\": function _debugger() {\n          debugger;\n        }\n      },\n      'parent': _Module // Module inside wasm-js.cpp refers to wasm-js.cpp; this allows access to the outside program.\n\n    };\n    var exports = null;\n\n    function mergeMemory(newBuffer) {\n      // The wasm instance creates its memory. But static init code might have written to\n      // buffer already, including the mem init file, and we must copy it over in a proper merge.\n      // TODO: avoid this copy, by avoiding such static init writes\n      // TODO: in shorter term, just copy up to the last static init write\n      var oldBuffer = _Module['buffer'];\n\n      if (newBuffer.byteLength < oldBuffer.byteLength) {\n        _Module['printErr']('the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here');\n      }\n\n      var oldView = new Int8Array(oldBuffer);\n      var newView = new Int8Array(newBuffer);\n      newView.set(oldView);\n      updateGlobalBuffer(newBuffer);\n      updateGlobalBufferViews();\n    }\n\n    function fixImports(imports) {\n      return imports;\n    }\n\n    function getBinary() {\n      try {\n        if (_Module['wasmBinary']) {\n          return new Uint8Array(_Module['wasmBinary']);\n        }\n\n        var binary = tryParseAsDataURI(wasmBinaryFile);\n\n        if (binary) {\n          return binary;\n        }\n\n        if (_Module['readBinary']) {\n          return _Module['readBinary'](wasmBinaryFile);\n        } else {\n          throw \"on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)\";\n        }\n      } catch (err) {\n        abort(err);\n      }\n    }\n\n    function getBinaryPromise() {\n      // if we don't have the binary yet, and have the Fetch api, use that\n      // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web\n      if (!_Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {\n        return fetch(wasmBinaryFile, {\n          credentials: 'same-origin'\n        }).then(function (response) {\n          if (!response['ok']) {\n            throw \"failed to load wasm binary file at '\" + wasmBinaryFile + \"'\";\n          }\n\n          return response['arrayBuffer']();\n        }).catch(function () {\n          return getBinary();\n        });\n      } // Otherwise, getBinary should be able to get it synchronously\n\n\n      return new Promise(function (resolve, reject) {\n        resolve(getBinary());\n      });\n    } // do-method functions\n\n\n    function doNativeWasm(global, env, providedBuffer) {\n      if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) !== 'object') {\n        _Module['printErr']('no native wasm support detected');\n\n        return false;\n      } // prepare memory import\n\n\n      if (!(_Module['wasmMemory'] instanceof WebAssembly.Memory)) {\n        _Module['printErr']('no native wasm Memory in use');\n\n        return false;\n      }\n\n      env['memory'] = _Module['wasmMemory']; // Load the wasm module and create an instance of using native support in the JS engine.\n\n      info['global'] = {\n        'NaN': NaN,\n        'Infinity': Infinity\n      };\n      info['global.Math'] = Math;\n      info['env'] = env; // handle a generated wasm instance, receiving its exports and\n      // performing other necessary setup\n\n      function receiveInstance(instance, module) {\n        exports = instance.exports;\n        if (exports.memory) mergeMemory(exports.memory);\n        _Module['asm'] = exports;\n        _Module[\"usingWasm\"] = true;\n        removeRunDependency('wasm-instantiate');\n      }\n\n      addRunDependency('wasm-instantiate'); // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n      // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel\n      // to any other async startup actions they are performing.\n\n      if (_Module['instantiateWasm']) {\n        try {\n          return _Module['instantiateWasm'](info, receiveInstance);\n        } catch (e) {\n          _Module['printErr']('Module.instantiateWasm callback failed with error: ' + e);\n\n          return false;\n        }\n      } // Async compilation can be confusing when an error on the page overwrites Module\n      // (for example, if the order of elements is wrong, and the one defining Module is\n      // later), so we save Module and check it later.\n\n\n      var trueModule = _Module;\n\n      function receiveInstantiatedSource(output) {\n        // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.\n        // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n        assert(_Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n        trueModule = null;\n        receiveInstance(output['instance'], output['module']);\n      }\n\n      function instantiateArrayBuffer(receiver) {\n        getBinaryPromise().then(function (binary) {\n          return WebAssembly.instantiate(binary, info);\n        }).then(receiver).catch(function (reason) {\n          _Module['printErr']('failed to asynchronously prepare wasm: ' + reason);\n\n          abort(reason);\n        });\n      } // Prefer streaming instantiation if available.\n\n\n      if (!_Module['wasmBinary'] && typeof WebAssembly.instantiateStreaming === 'function' && !isDataURI(wasmBinaryFile) && typeof fetch === 'function') {\n        WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, {\n          credentials: 'same-origin'\n        }), info).then(receiveInstantiatedSource).catch(function (reason) {\n          // We expect the most common failure cause to be a bad MIME type for the binary,\n          // in which case falling back to ArrayBuffer instantiation should work.\n          _Module['printErr']('wasm streaming compile failed: ' + reason);\n\n          _Module['printErr']('falling back to ArrayBuffer instantiation');\n\n          instantiateArrayBuffer(receiveInstantiatedSource);\n        });\n      } else {\n        instantiateArrayBuffer(receiveInstantiatedSource);\n      }\n\n      return {}; // no exports yet; we'll fill them in later\n    } // We may have a preloaded value in Module.asm, save it\n\n\n    _Module['asmPreload'] = _Module['asm']; // Memory growth integration code\n\n    var asmjsReallocBuffer = _Module['reallocBuffer'];\n\n    var wasmReallocBuffer = function wasmReallocBuffer(size) {\n      var PAGE_MULTIPLE = _Module[\"usingWasm\"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE; // In wasm, heap size must be a multiple of 64KB. In asm.js, they need to be multiples of 16MB.\n\n      size = alignUp(size, PAGE_MULTIPLE); // round up to wasm page size\n\n      var old = _Module['buffer'];\n      var oldSize = old.byteLength;\n\n      if (_Module[\"usingWasm\"]) {\n        // native wasm support\n        try {\n          var result = _Module['wasmMemory'].grow((size - oldSize) / wasmPageSize); // .grow() takes a delta compared to the previous size\n\n\n          if (result !== (-1 | 0)) {\n            // success in native wasm memory growth, get the buffer from the memory\n            return _Module['buffer'] = _Module['wasmMemory'].buffer;\n          } else {\n            return null;\n          }\n        } catch (e) {\n          console.error('Module.reallocBuffer: Attempted to grow from ' + oldSize + ' bytes to ' + size + ' bytes, but got error: ' + e);\n          return null;\n        }\n      }\n    };\n\n    _Module['reallocBuffer'] = function (size) {\n      if (finalMethod === 'asmjs') {\n        return asmjsReallocBuffer(size);\n      } else {\n        return wasmReallocBuffer(size);\n      }\n    }; // we may try more than one; this is the final one, that worked and we are using\n\n\n    var finalMethod = ''; // Provide an \"asm.js function\" for the application, called to \"link\" the asm.js module. We instantiate\n    // the wasm module at that time, and it receives imports and provides exports and so forth, the app\n    // doesn't need to care that it is wasm or olyfilled wasm or asm.js.\n\n    _Module['asm'] = function (global, env, providedBuffer) {\n      env = fixImports(env); // import table\n\n      if (!env['table']) {\n        var TABLE_SIZE = _Module['wasmTableSize'];\n        if (TABLE_SIZE === undefined) TABLE_SIZE = 1024; // works in binaryen interpreter at least\n\n        var MAX_TABLE_SIZE = _Module['wasmMaxTableSize'];\n\n        if ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) === 'object' && typeof WebAssembly.Table === 'function') {\n          if (MAX_TABLE_SIZE !== undefined) {\n            env['table'] = new WebAssembly.Table({\n              'initial': TABLE_SIZE,\n              'maximum': MAX_TABLE_SIZE,\n              'element': 'anyfunc'\n            });\n          } else {\n            env['table'] = new WebAssembly.Table({\n              'initial': TABLE_SIZE,\n              element: 'anyfunc'\n            });\n          }\n        } else {\n          env['table'] = new Array(TABLE_SIZE); // works in binaryen interpreter at least\n        }\n\n        _Module['wasmTable'] = env['table'];\n      }\n\n      if (!env['memoryBase']) {\n        env['memoryBase'] = _Module['STATIC_BASE']; // tell the memory segments where to place themselves\n      }\n\n      if (!env['tableBase']) {\n        env['tableBase'] = 0; // table starts at 0 by default, in dynamic linking this will change\n      } // try the methods. each should return the exports if it succeeded\n\n\n      var exports;\n      exports = doNativeWasm(global, env, providedBuffer);\n      if (!exports) abort('no binaryen method succeeded. consider enabling more options, like interpreting, if you want that: https://github.com/kripken/emscripten/wiki/WebAssembly#binaryen-methods');\n      return exports;\n    };\n\n    var methodHandler = _Module['asm']; // note our method handler, as we may modify Module['asm'] later\n  }\n\n  integrateWasmJS(); // === Body ===\n\n  var ASM_CONSTS = [];\n  STATIC_BASE = GLOBAL_BASE;\n  STATICTOP = STATIC_BASE + 9888;\n  /* global initializers */\n\n  __ATINIT__.push();\n\n  var STATIC_BUMP = 9888;\n  _Module[\"STATIC_BASE\"] = STATIC_BASE;\n  _Module[\"STATIC_BUMP\"] = STATIC_BUMP;\n  /* no memory initializer */\n\n  var tempDoublePtr = STATICTOP;\n  STATICTOP += 16;\n  assert(tempDoublePtr % 8 == 0);\n\n  function copyTempFloat(ptr) {\n    // functions, because inlining this code increases code size too much\n    HEAP8[tempDoublePtr] = HEAP8[ptr];\n    HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n    HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n    HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n  }\n\n  function copyTempDouble(ptr) {\n    HEAP8[tempDoublePtr] = HEAP8[ptr];\n    HEAP8[tempDoublePtr + 1] = HEAP8[ptr + 1];\n    HEAP8[tempDoublePtr + 2] = HEAP8[ptr + 2];\n    HEAP8[tempDoublePtr + 3] = HEAP8[ptr + 3];\n    HEAP8[tempDoublePtr + 4] = HEAP8[ptr + 4];\n    HEAP8[tempDoublePtr + 5] = HEAP8[ptr + 5];\n    HEAP8[tempDoublePtr + 6] = HEAP8[ptr + 6];\n    HEAP8[tempDoublePtr + 7] = HEAP8[ptr + 7];\n  } // {{PRE_LIBRARY}}\n\n\n  function ___lock() {}\n\n  var SYSCALLS = {\n    varargs: 0,\n    get: function get(varargs) {\n      SYSCALLS.varargs += 4;\n      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];\n      return ret;\n    },\n    getStr: function getStr() {\n      var ret = Pointer_stringify(SYSCALLS.get());\n      return ret;\n    },\n    get64: function get64() {\n      var low = SYSCALLS.get(),\n          high = SYSCALLS.get();\n      if (low >= 0) assert(high === 0);else assert(high === -1);\n      return low;\n    },\n    getZero: function getZero() {\n      assert(SYSCALLS.get() === 0);\n    }\n  };\n\n  function ___syscall140(which, varargs) {\n    SYSCALLS.varargs = varargs;\n\n    try {\n      // llseek\n      var stream = SYSCALLS.getStreamFromFD(),\n          offset_high = SYSCALLS.get(),\n          offset_low = SYSCALLS.get(),\n          result = SYSCALLS.get(),\n          whence = SYSCALLS.get(); // NOTE: offset_high is unused - Emscripten's off_t is 32-bit\n\n      var offset = offset_low;\n      FS.llseek(stream, offset, whence);\n      HEAP32[result >> 2] = stream.position;\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n\n      return 0;\n    } catch (e) {\n      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n      return -e.errno;\n    }\n  }\n\n  function flush_NO_FILESYSTEM() {\n    // flush anything remaining in the buffers during shutdown\n    var fflush = _Module[\"_fflush\"];\n    if (fflush) fflush(0);\n    var printChar = ___syscall146.printChar;\n    if (!printChar) return;\n    var buffers = ___syscall146.buffers;\n    if (buffers[1].length) printChar(1, 10);\n    if (buffers[2].length) printChar(2, 10);\n  }\n\n  function ___syscall146(which, varargs) {\n    SYSCALLS.varargs = varargs;\n\n    try {\n      // writev\n      // hack to support printf in NO_FILESYSTEM\n      var stream = SYSCALLS.get(),\n          iov = SYSCALLS.get(),\n          iovcnt = SYSCALLS.get();\n      var ret = 0;\n\n      if (!___syscall146.buffers) {\n        ___syscall146.buffers = [null, [], []]; // 1 => stdout, 2 => stderr\n\n        ___syscall146.printChar = function (stream, curr) {\n          var buffer = ___syscall146.buffers[stream];\n          assert(buffer);\n\n          if (curr === 0 || curr === 10) {\n            (stream === 1 ? _Module['print'] : _Module['printErr'])(UTF8ArrayToString(buffer, 0));\n            buffer.length = 0;\n          } else {\n            buffer.push(curr);\n          }\n        };\n      }\n\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAP32[iov + i * 8 >> 2];\n        var len = HEAP32[iov + (i * 8 + 4) >> 2];\n\n        for (var j = 0; j < len; j++) {\n          ___syscall146.printChar(stream, HEAPU8[ptr + j]);\n        }\n\n        ret += len;\n      }\n\n      return ret;\n    } catch (e) {\n      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n      return -e.errno;\n    }\n  }\n\n  function ___syscall54(which, varargs) {\n    SYSCALLS.varargs = varargs;\n\n    try {\n      // ioctl\n      return 0;\n    } catch (e) {\n      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n      return -e.errno;\n    }\n  }\n\n  function ___syscall6(which, varargs) {\n    SYSCALLS.varargs = varargs;\n\n    try {\n      // close\n      var stream = SYSCALLS.getStreamFromFD();\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n      if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);\n      return -e.errno;\n    }\n  }\n\n  function ___unlock() {}\n\n  function _emscripten_has_threading_support() {\n    return 0;\n  }\n\n  var cttz_i8 = allocate([8, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0], \"i8\", ALLOC_STATIC);\n\n  function _llvm_cttz_i32(x) {\n    x = x | 0;\n    var ret = 0;\n    ret = HEAP8[cttz_i8 + (x & 0xff) >> 0] | 0;\n    if ((ret | 0) < 8) return ret | 0;\n    ret = HEAP8[cttz_i8 + (x >> 8 & 0xff) >> 0] | 0;\n    if ((ret | 0) < 8) return ret + 8 | 0;\n    ret = HEAP8[cttz_i8 + (x >> 16 & 0xff) >> 0] | 0;\n    if ((ret | 0) < 8) return ret + 16 | 0;\n    return (HEAP8[cttz_i8 + (x >>> 24) >> 0] | 0) + 24 | 0;\n  }\n\n  function _llvm_cttz_i64(l, h) {\n    var ret = _llvm_cttz_i32(l);\n\n    if (ret == 32) ret += _llvm_cttz_i32(h);\n    return (setTempRet0(0), ret) | 0;\n  }\n\n  function _llvm_stackrestore(p) {\n    var self = _llvm_stacksave;\n    var ret = self.LLVM_SAVEDSTACKS[p];\n    self.LLVM_SAVEDSTACKS.splice(p, 1);\n\n    _stackRestore(ret);\n  }\n\n  function _llvm_stacksave() {\n    var self = _llvm_stacksave;\n\n    if (!self.LLVM_SAVEDSTACKS) {\n      self.LLVM_SAVEDSTACKS = [];\n    }\n\n    self.LLVM_SAVEDSTACKS.push(_stackSave());\n    return self.LLVM_SAVEDSTACKS.length - 1;\n  }\n\n  function _emscripten_memcpy_big(dest, src, num) {\n    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);\n    return dest;\n  }\n\n  function _pthread_create() {\n    return 11;\n  }\n\n  function _pthread_join() {}\n\n  function _pthread_mutex_init() {}\n\n  function ___setErrNo(value) {\n    if (_Module['___errno_location']) HEAP32[_Module['___errno_location']() >> 2] = value;else _Module.printErr('failed to set errno from JS');\n    return value;\n  }\n\n  var ERRNO_CODES = {\n    EPERM: 1,\n    ENOENT: 2,\n    ESRCH: 3,\n    EINTR: 4,\n    EIO: 5,\n    ENXIO: 6,\n    E2BIG: 7,\n    ENOEXEC: 8,\n    EBADF: 9,\n    ECHILD: 10,\n    EAGAIN: 11,\n    EWOULDBLOCK: 11,\n    ENOMEM: 12,\n    EACCES: 13,\n    EFAULT: 14,\n    ENOTBLK: 15,\n    EBUSY: 16,\n    EEXIST: 17,\n    EXDEV: 18,\n    ENODEV: 19,\n    ENOTDIR: 20,\n    EISDIR: 21,\n    EINVAL: 22,\n    ENFILE: 23,\n    EMFILE: 24,\n    ENOTTY: 25,\n    ETXTBSY: 26,\n    EFBIG: 27,\n    ENOSPC: 28,\n    ESPIPE: 29,\n    EROFS: 30,\n    EMLINK: 31,\n    EPIPE: 32,\n    EDOM: 33,\n    ERANGE: 34,\n    ENOMSG: 42,\n    EIDRM: 43,\n    ECHRNG: 44,\n    EL2NSYNC: 45,\n    EL3HLT: 46,\n    EL3RST: 47,\n    ELNRNG: 48,\n    EUNATCH: 49,\n    ENOCSI: 50,\n    EL2HLT: 51,\n    EDEADLK: 35,\n    ENOLCK: 37,\n    EBADE: 52,\n    EBADR: 53,\n    EXFULL: 54,\n    ENOANO: 55,\n    EBADRQC: 56,\n    EBADSLT: 57,\n    EDEADLOCK: 35,\n    EBFONT: 59,\n    ENOSTR: 60,\n    ENODATA: 61,\n    ETIME: 62,\n    ENOSR: 63,\n    ENONET: 64,\n    ENOPKG: 65,\n    EREMOTE: 66,\n    ENOLINK: 67,\n    EADV: 68,\n    ESRMNT: 69,\n    ECOMM: 70,\n    EPROTO: 71,\n    EMULTIHOP: 72,\n    EDOTDOT: 73,\n    EBADMSG: 74,\n    ENOTUNIQ: 76,\n    EBADFD: 77,\n    EREMCHG: 78,\n    ELIBACC: 79,\n    ELIBBAD: 80,\n    ELIBSCN: 81,\n    ELIBMAX: 82,\n    ELIBEXEC: 83,\n    ENOSYS: 38,\n    ENOTEMPTY: 39,\n    ENAMETOOLONG: 36,\n    ELOOP: 40,\n    EOPNOTSUPP: 95,\n    EPFNOSUPPORT: 96,\n    ECONNRESET: 104,\n    ENOBUFS: 105,\n    EAFNOSUPPORT: 97,\n    EPROTOTYPE: 91,\n    ENOTSOCK: 88,\n    ENOPROTOOPT: 92,\n    ESHUTDOWN: 108,\n    ECONNREFUSED: 111,\n    EADDRINUSE: 98,\n    ECONNABORTED: 103,\n    ENETUNREACH: 101,\n    ENETDOWN: 100,\n    ETIMEDOUT: 110,\n    EHOSTDOWN: 112,\n    EHOSTUNREACH: 113,\n    EINPROGRESS: 115,\n    EALREADY: 114,\n    EDESTADDRREQ: 89,\n    EMSGSIZE: 90,\n    EPROTONOSUPPORT: 93,\n    ESOCKTNOSUPPORT: 94,\n    EADDRNOTAVAIL: 99,\n    ENETRESET: 102,\n    EISCONN: 106,\n    ENOTCONN: 107,\n    ETOOMANYREFS: 109,\n    EUSERS: 87,\n    EDQUOT: 122,\n    ESTALE: 116,\n    ENOTSUP: 95,\n    ENOMEDIUM: 123,\n    EILSEQ: 84,\n    EOVERFLOW: 75,\n    ECANCELED: 125,\n    ENOTRECOVERABLE: 131,\n    EOWNERDEAD: 130,\n    ESTRPIPE: 86\n  };\n\n  function _sysconf(name) {\n    // long sysconf(int name);\n    // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html\n    switch (name) {\n      case 30:\n        return PAGE_SIZE;\n\n      case 85:\n        var maxHeapSize = 2 * 1024 * 1024 * 1024 - 65536;\n        maxHeapSize = HEAPU8.length;\n        return maxHeapSize / PAGE_SIZE;\n\n      case 132:\n      case 133:\n      case 12:\n      case 137:\n      case 138:\n      case 15:\n      case 235:\n      case 16:\n      case 17:\n      case 18:\n      case 19:\n      case 20:\n      case 149:\n      case 13:\n      case 10:\n      case 236:\n      case 153:\n      case 9:\n      case 21:\n      case 22:\n      case 159:\n      case 154:\n      case 14:\n      case 77:\n      case 78:\n      case 139:\n      case 80:\n      case 81:\n      case 82:\n      case 68:\n      case 67:\n      case 164:\n      case 11:\n      case 29:\n      case 47:\n      case 48:\n      case 95:\n      case 52:\n      case 51:\n      case 46:\n        return 200809;\n\n      case 79:\n        return 0;\n\n      case 27:\n      case 246:\n      case 127:\n      case 128:\n      case 23:\n      case 24:\n      case 160:\n      case 161:\n      case 181:\n      case 182:\n      case 242:\n      case 183:\n      case 184:\n      case 243:\n      case 244:\n      case 245:\n      case 165:\n      case 178:\n      case 179:\n      case 49:\n      case 50:\n      case 168:\n      case 169:\n      case 175:\n      case 170:\n      case 171:\n      case 172:\n      case 97:\n      case 76:\n      case 32:\n      case 173:\n      case 35:\n        return -1;\n\n      case 176:\n      case 177:\n      case 7:\n      case 155:\n      case 8:\n      case 157:\n      case 125:\n      case 126:\n      case 92:\n      case 93:\n      case 129:\n      case 130:\n      case 131:\n      case 94:\n      case 91:\n        return 1;\n\n      case 74:\n      case 60:\n      case 69:\n      case 70:\n      case 4:\n        return 1024;\n\n      case 31:\n      case 42:\n      case 72:\n        return 32;\n\n      case 87:\n      case 26:\n      case 33:\n        return 2147483647;\n\n      case 34:\n      case 1:\n        return 47839;\n\n      case 38:\n      case 36:\n        return 99;\n\n      case 43:\n      case 37:\n        return 2048;\n\n      case 0:\n        return 2097152;\n\n      case 3:\n        return 65536;\n\n      case 28:\n        return 32768;\n\n      case 44:\n        return 32767;\n\n      case 75:\n        return 16384;\n\n      case 39:\n        return 1000;\n\n      case 89:\n        return 700;\n\n      case 71:\n        return 256;\n\n      case 40:\n        return 255;\n\n      case 2:\n        return 100;\n\n      case 180:\n        return 64;\n\n      case 25:\n        return 20;\n\n      case 5:\n        return 16;\n\n      case 6:\n        return 6;\n\n      case 73:\n        return 4;\n\n      case 84:\n        {\n          if ((typeof navigator === \"undefined\" ? \"undefined\" : _typeof(navigator)) === 'object') return navigator['hardwareConcurrency'] || 1;\n          return 1;\n        }\n    }\n\n    ___setErrNo(ERRNO_CODES.EINVAL);\n\n    return -1;\n  }\n\n  DYNAMICTOP_PTR = staticAlloc(4);\n  STACK_BASE = STACKTOP = alignMemory(STATICTOP);\n  STACK_MAX = STACK_BASE + TOTAL_STACK;\n  DYNAMIC_BASE = alignMemory(STACK_MAX);\n  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;\n  staticSealed = true; // seal the static portion of memory\n\n  assert(DYNAMIC_BASE < TOTAL_MEMORY, \"TOTAL_MEMORY not big enough for stack\");\n  var ASSERTIONS = true;\n  /** @type {function(string, boolean=, number=)} */\n\n  function intArrayFromString(stringy, dontAddNull, length) {\n    var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n    var u8array = new Array(len);\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n    if (dontAddNull) u8array.length = numBytesWritten;\n    return u8array;\n  }\n\n  function intArrayToString(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      var chr = array[i];\n\n      if (chr > 0xFF) {\n        if (ASSERTIONS) {\n          assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');\n        }\n\n        chr &= 0xFF;\n      }\n\n      ret.push(String.fromCharCode(chr));\n    }\n\n    return ret.join('');\n  } // Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149\n  // This code was written by Tyler Akins and has been placed in the\n  // public domain.  It would be nice if you left this header intact.\n  // Base64 code from Tyler Akins -- http://rumkin.com\n\n  /**\r\n   * Decodes a base64 string.\r\n   * @param {String} input The string to decode.\r\n   */\n\n\n  var decodeBase64 = typeof atob === 'function' ? atob : function (input) {\n    var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var output = '';\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0; // remove all characters that are not A-Z, a-z, 0-9, +, /, or =\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, '');\n\n    do {\n      enc1 = keyStr.indexOf(input.charAt(i++));\n      enc2 = keyStr.indexOf(input.charAt(i++));\n      enc3 = keyStr.indexOf(input.charAt(i++));\n      enc4 = keyStr.indexOf(input.charAt(i++));\n      chr1 = enc1 << 2 | enc2 >> 4;\n      chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n      chr3 = (enc3 & 3) << 6 | enc4;\n      output = output + String.fromCharCode(chr1);\n\n      if (enc3 !== 64) {\n        output = output + String.fromCharCode(chr2);\n      }\n\n      if (enc4 !== 64) {\n        output = output + String.fromCharCode(chr3);\n      }\n    } while (i < input.length);\n\n    return output;\n  }; // Converts a string of base64 into a byte array.\n  // Throws error on invalid input.\n\n  function intArrayFromBase64(s) {\n    if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {\n      var buf;\n\n      try {\n        buf = Buffer.from(s, 'base64');\n      } catch (_) {\n        buf = new Buffer(s, 'base64');\n      }\n\n      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n\n    try {\n      var decoded = decodeBase64(s);\n      var bytes = new Uint8Array(decoded.length);\n\n      for (var i = 0; i < decoded.length; ++i) {\n        bytes[i] = decoded.charCodeAt(i);\n      }\n\n      return bytes;\n    } catch (_) {\n      throw new Error('Converting base64 string to bytes failed.');\n    }\n  } // If filename is a base64 data URI, parses and returns data (Buffer on node,\n  // Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.\n\n\n  function tryParseAsDataURI(filename) {\n    if (!isDataURI(filename)) {\n      return;\n    }\n\n    return intArrayFromBase64(filename.slice(dataURIPrefix.length));\n  }\n\n  function nullFunc_ii(x) {\n    _Module[\"printErr\"](\"Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n\n    _Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");\n\n    abort(x);\n  }\n\n  function nullFunc_iiii(x) {\n    _Module[\"printErr\"](\"Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)\");\n\n    _Module[\"printErr\"](\"Build with ASSERTIONS=2 for more info.\");\n\n    abort(x);\n  }\n\n  _Module['wasmTableSize'] = 16;\n  _Module['wasmMaxTableSize'] = 16;\n\n  function invoke_ii(index, a1) {\n    try {\n      return _Module[\"dynCall_ii\"](index, a1);\n    } catch (e) {\n      if (typeof e !== 'number' && e !== 'longjmp') throw e;\n\n      _Module[\"setThrew\"](1, 0);\n    }\n  }\n\n  function invoke_iiii(index, a1, a2, a3) {\n    try {\n      return _Module[\"dynCall_iiii\"](index, a1, a2, a3);\n    } catch (e) {\n      if (typeof e !== 'number' && e !== 'longjmp') throw e;\n\n      _Module[\"setThrew\"](1, 0);\n    }\n  }\n\n  _Module.asmGlobalArg = {};\n  _Module.asmLibraryArg = {\n    \"abort\": abort,\n    \"assert\": assert,\n    \"enlargeMemory\": enlargeMemory,\n    \"getTotalMemory\": getTotalMemory,\n    \"abortOnCannotGrowMemory\": abortOnCannotGrowMemory,\n    \"abortStackOverflow\": abortStackOverflow,\n    \"nullFunc_ii\": nullFunc_ii,\n    \"nullFunc_iiii\": nullFunc_iiii,\n    \"invoke_ii\": invoke_ii,\n    \"invoke_iiii\": invoke_iiii,\n    \"___lock\": ___lock,\n    \"___setErrNo\": ___setErrNo,\n    \"___syscall140\": ___syscall140,\n    \"___syscall146\": ___syscall146,\n    \"___syscall54\": ___syscall54,\n    \"___syscall6\": ___syscall6,\n    \"___unlock\": ___unlock,\n    \"_emscripten_has_threading_support\": _emscripten_has_threading_support,\n    \"_emscripten_memcpy_big\": _emscripten_memcpy_big,\n    \"_llvm_cttz_i32\": _llvm_cttz_i32,\n    \"_llvm_cttz_i64\": _llvm_cttz_i64,\n    \"_llvm_stackrestore\": _llvm_stackrestore,\n    \"_llvm_stacksave\": _llvm_stacksave,\n    \"_pthread_create\": _pthread_create,\n    \"_pthread_join\": _pthread_join,\n    \"_pthread_mutex_init\": _pthread_mutex_init,\n    \"_sysconf\": _sysconf,\n    \"flush_NO_FILESYSTEM\": flush_NO_FILESYSTEM,\n    \"DYNAMICTOP_PTR\": DYNAMICTOP_PTR,\n    \"tempDoublePtr\": tempDoublePtr,\n    \"ABORT\": ABORT,\n    \"STACKTOP\": STACKTOP,\n    \"STACK_MAX\": STACK_MAX,\n    \"cttz_i8\": cttz_i8\n  }; // EMSCRIPTEN_START_ASM\n\n  var asm = _Module[\"asm\"] // EMSCRIPTEN_END_ASM\n  (_Module.asmGlobalArg, _Module.asmLibraryArg, buffer);\n\n  var real____errno_location = asm[\"___errno_location\"];\n\n  asm[\"___errno_location\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real____errno_location.apply(null, arguments);\n  };\n\n  var real__ccurl_pow = asm[\"_ccurl_pow\"];\n\n  asm[\"_ccurl_pow\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__ccurl_pow.apply(null, arguments);\n  };\n\n  var real__fflush = asm[\"_fflush\"];\n\n  asm[\"_fflush\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__fflush.apply(null, arguments);\n  };\n\n  var real__free = asm[\"_free\"];\n\n  asm[\"_free\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__free.apply(null, arguments);\n  };\n\n  var real__llvm_bswap_i32 = asm[\"_llvm_bswap_i32\"];\n\n  asm[\"_llvm_bswap_i32\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__llvm_bswap_i32.apply(null, arguments);\n  };\n\n  var real__malloc = asm[\"_malloc\"];\n\n  asm[\"_malloc\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__malloc.apply(null, arguments);\n  };\n\n  var real__pthread_mutex_lock = asm[\"_pthread_mutex_lock\"];\n\n  asm[\"_pthread_mutex_lock\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__pthread_mutex_lock.apply(null, arguments);\n  };\n\n  var real__pthread_mutex_unlock = asm[\"_pthread_mutex_unlock\"];\n\n  asm[\"_pthread_mutex_unlock\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__pthread_mutex_unlock.apply(null, arguments);\n  };\n\n  var real__sbrk = asm[\"_sbrk\"];\n\n  asm[\"_sbrk\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real__sbrk.apply(null, arguments);\n  };\n\n  var real_establishStackSpace = asm[\"establishStackSpace\"];\n\n  asm[\"establishStackSpace\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_establishStackSpace.apply(null, arguments);\n  };\n\n  var real_getTempRet0 = asm[\"getTempRet0\"];\n\n  asm[\"getTempRet0\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_getTempRet0.apply(null, arguments);\n  };\n\n  var real_setTempRet0 = asm[\"setTempRet0\"];\n\n  asm[\"setTempRet0\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_setTempRet0.apply(null, arguments);\n  };\n\n  var real_setThrew = asm[\"setThrew\"];\n\n  asm[\"setThrew\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_setThrew.apply(null, arguments);\n  };\n\n  var real_stackAlloc = asm[\"stackAlloc\"];\n\n  asm[\"stackAlloc\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_stackAlloc.apply(null, arguments);\n  };\n\n  var real_stackRestore = asm[\"stackRestore\"];\n\n  asm[\"stackRestore\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_stackRestore.apply(null, arguments);\n  };\n\n  var real_stackSave = asm[\"stackSave\"];\n\n  asm[\"stackSave\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return real_stackSave.apply(null, arguments);\n  };\n\n  _Module[\"asm\"] = asm;\n\n  var ___errno_location = _Module[\"___errno_location\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"___errno_location\"].apply(null, arguments);\n  };\n\n  var _ccurl_pow = _Module[\"_ccurl_pow\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_ccurl_pow\"].apply(null, arguments);\n  };\n\n  var _fflush = _Module[\"_fflush\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_fflush\"].apply(null, arguments);\n  };\n\n  var _free = _Module[\"_free\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_free\"].apply(null, arguments);\n  };\n\n  var _llvm_bswap_i32 = _Module[\"_llvm_bswap_i32\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_llvm_bswap_i32\"].apply(null, arguments);\n  };\n\n  var _malloc = _Module[\"_malloc\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_malloc\"].apply(null, arguments);\n  };\n\n  var _memcpy = _Module[\"_memcpy\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_memcpy\"].apply(null, arguments);\n  };\n\n  var _memset = _Module[\"_memset\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_memset\"].apply(null, arguments);\n  };\n\n  var _pthread_mutex_lock = _Module[\"_pthread_mutex_lock\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_pthread_mutex_lock\"].apply(null, arguments);\n  };\n\n  var _pthread_mutex_unlock = _Module[\"_pthread_mutex_unlock\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_pthread_mutex_unlock\"].apply(null, arguments);\n  };\n\n  var _sbrk = _Module[\"_sbrk\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"_sbrk\"].apply(null, arguments);\n  };\n\n  var establishStackSpace = _Module[\"establishStackSpace\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"establishStackSpace\"].apply(null, arguments);\n  };\n\n  var getTempRet0 = _Module[\"getTempRet0\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"getTempRet0\"].apply(null, arguments);\n  };\n\n  var runPostSets = _Module[\"runPostSets\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"runPostSets\"].apply(null, arguments);\n  };\n\n  var setTempRet0 = _Module[\"setTempRet0\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"setTempRet0\"].apply(null, arguments);\n  };\n\n  var setThrew = _Module[\"setThrew\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"setThrew\"].apply(null, arguments);\n  };\n\n  var stackAlloc = _Module[\"stackAlloc\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"stackAlloc\"].apply(null, arguments);\n  };\n\n  var _stackRestore = _Module[\"stackRestore\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"stackRestore\"].apply(null, arguments);\n  };\n\n  var _stackSave = _Module[\"stackSave\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"stackSave\"].apply(null, arguments);\n  };\n\n  var dynCall_ii = _Module[\"dynCall_ii\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"dynCall_ii\"].apply(null, arguments);\n  };\n\n  var dynCall_iiii = _Module[\"dynCall_iiii\"] = function () {\n    assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');\n    assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');\n    return _Module[\"asm\"][\"dynCall_iiii\"].apply(null, arguments);\n  };\n\n  ; // === Auto-generated postamble setup entry stuff ===\n\n  _Module['asm'] = asm;\n  if (!_Module[\"intArrayFromString\"]) _Module[\"intArrayFromString\"] = function () {\n    abort(\"'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"intArrayToString\"]) _Module[\"intArrayToString\"] = function () {\n    abort(\"'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  _Module[\"ccall\"] = ccall;\n  _Module[\"cwrap\"] = cwrap;\n  if (!_Module[\"setValue\"]) _Module[\"setValue\"] = function () {\n    abort(\"'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getValue\"]) _Module[\"getValue\"] = function () {\n    abort(\"'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"allocate\"]) _Module[\"allocate\"] = function () {\n    abort(\"'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getMemory\"]) _Module[\"getMemory\"] = function () {\n    abort(\"'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"Pointer_stringify\"]) _Module[\"Pointer_stringify\"] = function () {\n    abort(\"'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"AsciiToString\"]) _Module[\"AsciiToString\"] = function () {\n    abort(\"'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToAscii\"]) _Module[\"stringToAscii\"] = function () {\n    abort(\"'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"UTF8ArrayToString\"]) _Module[\"UTF8ArrayToString\"] = function () {\n    abort(\"'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"UTF8ToString\"]) _Module[\"UTF8ToString\"] = function () {\n    abort(\"'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToUTF8Array\"]) _Module[\"stringToUTF8Array\"] = function () {\n    abort(\"'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToUTF8\"]) _Module[\"stringToUTF8\"] = function () {\n    abort(\"'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"lengthBytesUTF8\"]) _Module[\"lengthBytesUTF8\"] = function () {\n    abort(\"'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"UTF16ToString\"]) _Module[\"UTF16ToString\"] = function () {\n    abort(\"'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToUTF16\"]) _Module[\"stringToUTF16\"] = function () {\n    abort(\"'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"lengthBytesUTF16\"]) _Module[\"lengthBytesUTF16\"] = function () {\n    abort(\"'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"UTF32ToString\"]) _Module[\"UTF32ToString\"] = function () {\n    abort(\"'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stringToUTF32\"]) _Module[\"stringToUTF32\"] = function () {\n    abort(\"'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"lengthBytesUTF32\"]) _Module[\"lengthBytesUTF32\"] = function () {\n    abort(\"'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"allocateUTF8\"]) _Module[\"allocateUTF8\"] = function () {\n    abort(\"'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"stackTrace\"]) _Module[\"stackTrace\"] = function () {\n    abort(\"'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnPreRun\"]) _Module[\"addOnPreRun\"] = function () {\n    abort(\"'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnInit\"]) _Module[\"addOnInit\"] = function () {\n    abort(\"'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnPreMain\"]) _Module[\"addOnPreMain\"] = function () {\n    abort(\"'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnExit\"]) _Module[\"addOnExit\"] = function () {\n    abort(\"'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addOnPostRun\"]) _Module[\"addOnPostRun\"] = function () {\n    abort(\"'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"writeStringToMemory\"]) _Module[\"writeStringToMemory\"] = function () {\n    abort(\"'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"writeArrayToMemory\"]) _Module[\"writeArrayToMemory\"] = function () {\n    abort(\"'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"writeAsciiToMemory\"]) _Module[\"writeAsciiToMemory\"] = function () {\n    abort(\"'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addRunDependency\"]) _Module[\"addRunDependency\"] = function () {\n    abort(\"'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"removeRunDependency\"]) _Module[\"removeRunDependency\"] = function () {\n    abort(\"'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS\"]) _Module[\"FS\"] = function () {\n    abort(\"'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"FS_createFolder\"]) _Module[\"FS_createFolder\"] = function () {\n    abort(\"'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createPath\"]) _Module[\"FS_createPath\"] = function () {\n    abort(\"'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createDataFile\"]) _Module[\"FS_createDataFile\"] = function () {\n    abort(\"'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createPreloadedFile\"]) _Module[\"FS_createPreloadedFile\"] = function () {\n    abort(\"'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createLazyFile\"]) _Module[\"FS_createLazyFile\"] = function () {\n    abort(\"'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createLink\"]) _Module[\"FS_createLink\"] = function () {\n    abort(\"'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_createDevice\"]) _Module[\"FS_createDevice\"] = function () {\n    abort(\"'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"FS_unlink\"]) _Module[\"FS_unlink\"] = function () {\n    abort(\"'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you\");\n  };\n  if (!_Module[\"GL\"]) _Module[\"GL\"] = function () {\n    abort(\"'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"staticAlloc\"]) _Module[\"staticAlloc\"] = function () {\n    abort(\"'staticAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"dynamicAlloc\"]) _Module[\"dynamicAlloc\"] = function () {\n    abort(\"'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"warnOnce\"]) _Module[\"warnOnce\"] = function () {\n    abort(\"'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"loadDynamicLibrary\"]) _Module[\"loadDynamicLibrary\"] = function () {\n    abort(\"'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"loadWebAssemblyModule\"]) _Module[\"loadWebAssemblyModule\"] = function () {\n    abort(\"'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getLEB\"]) _Module[\"getLEB\"] = function () {\n    abort(\"'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getFunctionTables\"]) _Module[\"getFunctionTables\"] = function () {\n    abort(\"'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"alignFunctionTables\"]) _Module[\"alignFunctionTables\"] = function () {\n    abort(\"'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"registerFunctions\"]) _Module[\"registerFunctions\"] = function () {\n    abort(\"'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"addFunction\"]) _Module[\"addFunction\"] = function () {\n    abort(\"'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"removeFunction\"]) _Module[\"removeFunction\"] = function () {\n    abort(\"'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getFuncWrapper\"]) _Module[\"getFuncWrapper\"] = function () {\n    abort(\"'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"prettyPrint\"]) _Module[\"prettyPrint\"] = function () {\n    abort(\"'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"makeBigInt\"]) _Module[\"makeBigInt\"] = function () {\n    abort(\"'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"dynCall\"]) _Module[\"dynCall\"] = function () {\n    abort(\"'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"getCompilerSetting\"]) _Module[\"getCompilerSetting\"] = function () {\n    abort(\"'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"intArrayFromBase64\"]) _Module[\"intArrayFromBase64\"] = function () {\n    abort(\"'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"tryParseAsDataURI\"]) _Module[\"tryParseAsDataURI\"] = function () {\n    abort(\"'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n  };\n  if (!_Module[\"ALLOC_NORMAL\"]) Object.defineProperty(_Module, \"ALLOC_NORMAL\", {\n    get: function get() {\n      abort(\"'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  });\n  if (!_Module[\"ALLOC_STACK\"]) Object.defineProperty(_Module, \"ALLOC_STACK\", {\n    get: function get() {\n      abort(\"'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  });\n  if (!_Module[\"ALLOC_STATIC\"]) Object.defineProperty(_Module, \"ALLOC_STATIC\", {\n    get: function get() {\n      abort(\"'ALLOC_STATIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  });\n  if (!_Module[\"ALLOC_DYNAMIC\"]) Object.defineProperty(_Module, \"ALLOC_DYNAMIC\", {\n    get: function get() {\n      abort(\"'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  });\n  if (!_Module[\"ALLOC_NONE\"]) Object.defineProperty(_Module, \"ALLOC_NONE\", {\n    get: function get() {\n      abort(\"'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)\");\n    }\n  }); // Modularize mode returns a function, which can be called to\n  // create instances. The instances provide a then() method,\n  // must like a Promise, that receives a callback. The callback\n  // is called when the module is ready to run, with the module\n  // as a parameter. (Like a Promise, it also returns the module\n  // so you can use the output of .then(..)).\n\n  _Module['then'] = function (func) {\n    // We may already be ready to run code at this time. if\n    // so, just queue a call to the callback.\n    if (_Module['calledRun']) {\n      func(_Module);\n    } else {\n      // we are not ready to call then() yet. we must call it\n      // at the same time we would call onRuntimeInitialized.\n      var old = _Module['onRuntimeInitialized'];\n\n      _Module['onRuntimeInitialized'] = function () {\n        if (old) old();\n        func(_Module);\n      };\n    }\n\n    return _Module;\n  };\n  /**\r\n   * @constructor\r\n   * @extends {Error}\r\n   * @this {ExitStatus}\r\n   */\n\n\n  function ExitStatus(status) {\n    this.name = \"ExitStatus\";\n    this.message = \"Program terminated with exit(\" + status + \")\";\n    this.status = status;\n  }\n\n  ;\n  ExitStatus.prototype = new Error();\n  ExitStatus.prototype.constructor = ExitStatus;\n  var initialStackTop;\n  var calledMain = false;\n\n  dependenciesFulfilled = function runCaller() {\n    // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n    if (!_Module['calledRun']) run();\n    if (!_Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n  };\n  /** @type {function(Array=)} */\n\n\n  function run(args) {\n    args = args || _Module['arguments'];\n\n    if (runDependencies > 0) {\n      return;\n    }\n\n    writeStackCookie();\n    preRun();\n    if (runDependencies > 0) return; // a preRun added a dependency, run will be called later\n\n    if (_Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame\n\n    function doRun() {\n      if (_Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening\n\n      _Module['calledRun'] = true;\n      if (ABORT) return;\n      ensureInitRuntime();\n      preMain();\n      if (_Module['onRuntimeInitialized']) _Module['onRuntimeInitialized']();\n      assert(!_Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n      postRun();\n    }\n\n    if (_Module['setStatus']) {\n      _Module['setStatus']('Running...');\n\n      setTimeout(function () {\n        setTimeout(function () {\n          _Module['setStatus']('');\n        }, 1);\n        doRun();\n      }, 1);\n    } else {\n      doRun();\n    }\n\n    checkStackCookie();\n  }\n\n  _Module['run'] = run;\n\n  function checkUnflushedContent() {\n    // Compiler settings do not allow exiting the runtime, so flushing\n    // the streams is not possible. but in ASSERTIONS mode we check\n    // if there was something to flush, and if so tell the user they\n    // should request that the runtime be exitable.\n    // Normally we would not even include flush() at all, but in ASSERTIONS\n    // builds we do so just for this check, and here we see if there is any\n    // content to flush, that is, we check if there would have been\n    // something a non-ASSERTIONS build would have not seen.\n    // How we flush the streams depends on whether we are in NO_FILESYSTEM\n    // mode (which has its own special function for this; otherwise, all\n    // the code is inside libc)\n    var print = _Module['print'];\n    var printErr = _Module['printErr'];\n    var has = false;\n\n    _Module['print'] = _Module['printErr'] = function (x) {\n      has = true;\n    };\n\n    try {\n      // it doesn't matter if it fails\n      var flush = flush_NO_FILESYSTEM;\n      if (flush) flush(0);\n    } catch (e) {}\n\n    _Module['print'] = print;\n    _Module['printErr'] = printErr;\n\n    if (has) {\n      warnOnce('stdio streams had content in them that was not flushed. you should set NO_EXIT_RUNTIME to 0 (see the FAQ), or make sure to emit a newline when you printf etc.');\n    }\n  }\n\n  function exit(status, implicit) {\n    checkUnflushedContent(); // if this is just main exit-ing implicitly, and the status is 0, then we\n    // don't need to do anything here and can just leave. if the status is\n    // non-zero, though, then we need to report it.\n    // (we may have warned about this earlier, if a situation justifies doing so)\n\n    if (implicit && _Module['noExitRuntime'] && status === 0) {\n      return;\n    }\n\n    if (_Module['noExitRuntime']) {\n      // if exit() was called, we may warn the user if the runtime isn't actually being shut down\n      if (!implicit) {\n        _Module.printErr('exit(' + status + ') called, but NO_EXIT_RUNTIME is set, so halting execution but not exiting the runtime or preventing further async execution (build with NO_EXIT_RUNTIME=0, if you want a true shutdown)');\n      }\n    } else {\n      ABORT = true;\n      EXITSTATUS = status;\n      STACKTOP = initialStackTop;\n      exitRuntime();\n      if (_Module['onExit']) _Module['onExit'](status);\n    }\n\n    if (ENVIRONMENT_IS_NODE) {\n      process['exit'](status);\n    }\n\n    _Module['quit'](status, new ExitStatus(status));\n  }\n\n  _Module['exit'] = exit;\n  var abortDecorators = [];\n\n  function abort(what) {\n    if (_Module['onAbort']) {\n      _Module['onAbort'](what);\n    }\n\n    if (what !== undefined) {\n      _Module.print(what);\n\n      _Module.printErr(what);\n\n      what = JSON.stringify(what);\n    } else {\n      what = '';\n    }\n\n    ABORT = true;\n    EXITSTATUS = 1;\n    var extra = '';\n    var output = 'abort(' + what + ') at ' + stackTrace() + extra;\n\n    if (abortDecorators) {\n      abortDecorators.forEach(function (decorator) {\n        output = decorator(output, what);\n      });\n    }\n\n    throw output;\n  }\n\n  _Module['abort'] = abort; // {{PRE_RUN_ADDITIONS}}\n\n  if (_Module['preInit']) {\n    if (typeof _Module['preInit'] == 'function') _Module['preInit'] = [_Module['preInit']];\n\n    while (_Module['preInit'].length > 0) {\n      _Module['preInit'].pop()();\n    }\n  }\n\n  _Module[\"noExitRuntime\"] = true;\n  run(); // {{POST_RUN_ADDITIONS}}\n  // {{MODULE_ADDITIONS}}\n\n  return _Module;\n};\n\nif (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = Module;else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  return Module;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../iota-pico-lib-browser/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-wasm/wasm/iota-pico-pow-wasm.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/index.js":
/*!********************************************!*\
  !*** ../iota-pico-pow-webgl/dist/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! ./proofOfWorkWebGl */ \"../iota-pico-pow-webgl/dist/proofOfWorkWebGl.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/index.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/pearlDiver/pearlDiver.js":
/*!************************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/pearlDiver/pearlDiver.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pow-webgl/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar spongeFactory_1 = __webpack_require__(/*! @iota-pico/crypto/dist/factories/spongeFactory */ \"../iota-pico-crypto/dist/factories/spongeFactory.js\");\n\nvar trits_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trits */ \"../iota-pico-data/dist/data/trits.js\");\n\nvar add_1 = __importDefault(__webpack_require__(/*! ../shaders/add */ \"../iota-pico-pow-webgl/dist/shaders/add.js\"));\n\nvar checkCol_1 = __importDefault(__webpack_require__(/*! ../shaders/checkCol */ \"../iota-pico-pow-webgl/dist/shaders/checkCol.js\"));\n\nvar checkDo_1 = __importDefault(__webpack_require__(/*! ../shaders/checkDo */ \"../iota-pico-pow-webgl/dist/shaders/checkDo.js\"));\n\nvar checkK_1 = __importDefault(__webpack_require__(/*! ../shaders/checkK */ \"../iota-pico-pow-webgl/dist/shaders/checkK.js\"));\n\nvar finalize_1 = __importDefault(__webpack_require__(/*! ../shaders/finalize */ \"../iota-pico-pow-webgl/dist/shaders/finalize.js\"));\n\nvar headers_1 = __importDefault(__webpack_require__(/*! ../shaders/headers */ \"../iota-pico-pow-webgl/dist/shaders/headers.js\"));\n\nvar increment_1 = __importDefault(__webpack_require__(/*! ../shaders/increment */ \"../iota-pico-pow-webgl/dist/shaders/increment.js\"));\n\nvar init_1 = __importDefault(__webpack_require__(/*! ../shaders/init */ \"../iota-pico-pow-webgl/dist/shaders/init.js\"));\n\nvar transform_1 = __importDefault(__webpack_require__(/*! ../shaders/transform */ \"../iota-pico-pow-webgl/dist/shaders/transform.js\"));\n\nvar webGLWorker_1 = __webpack_require__(/*! ../webGL/webGLWorker */ \"../iota-pico-pow-webgl/dist/webGL/webGLWorker.js\");\n\nvar pearlDiverState_1 = __webpack_require__(/*! ./pearlDiverState */ \"../iota-pico-pow-webgl/dist/pearlDiver/pearlDiverState.js\");\n/**\r\n * PearlDiver.\r\n * Converted from https://github.com/iotaledger/curl.lib.js/blob/master/src/pearldiver.js\r\n */\n\n\nvar PearlDiver =\n/*#__PURE__*/\nfunction () {\n  /* @internal */\n  function PearlDiver(webGLPlatform) {\n    _classCallCheck(this, PearlDiver);\n\n    this._webGLWorker = new webGLWorker_1.WebGLWorker();\n    var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\");\n    var curlConstants = curl.getConstants();\n    this._hashLength = curlConstants.HASH_LENGTH;\n    this._stateLength = curlConstants.STATE_LENGTH;\n    this._numberRounds = curlConstants.NUMBER_OF_ROUNDS;\n    this._transactionLength = this._hashLength * 33;\n    this._nonceLength = this._hashLength / 3;\n    this._nonceStart = this._hashLength - this._nonceLength;\n\n    this._webGLWorker.initialize(webGLPlatform, this._stateLength + 1, PearlDiver.TEXEL_SIZE);\n\n    this._currentBuffer = this._webGLWorker.getIpt().data;\n\n    this._webGLWorker.addProgram(\"init\", headers_1.default + add_1.default + init_1.default, \"gr_offset\");\n\n    this._webGLWorker.addProgram(\"increment\", headers_1.default + add_1.default + increment_1.default);\n\n    this._webGLWorker.addProgram(\"twist\", headers_1.default + transform_1.default);\n\n    this._webGLWorker.addProgram(\"check\", headers_1.default + checkDo_1.default + checkK_1.default, \"minWeightMagnitude\");\n\n    this._webGLWorker.addProgram(\"col_check\", headers_1.default + checkCol_1.default);\n\n    this._webGLWorker.addProgram(\"finalize\", headers_1.default + checkDo_1.default + finalize_1.default);\n\n    this._state = pearlDiverState_1.PearlDiverState.ready;\n    this._queue = [];\n  }\n  /**\r\n   * Initialize the PearlDiver main instance.\r\n   */\n\n\n  _createClass(PearlDiver, [{\n    key: \"searchWithTrytes\",\n\n    /**\r\n     * Perform a search using trytes.\r\n     * @param trytes The trytes to perform the search on.\r\n     * @param minWeightMagnitude The minimum weight magnitude.\r\n     * @returns Promise which resolves to the trytes from the search.\r\n     */\n    value: function () {\n      var _searchWithTrytes = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(trytes, minWeightMagnitude) {\n        var searchStates;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                searchStates = this.prepare(trytes);\n                return _context.abrupt(\"return\", this.search(searchStates, minWeightMagnitude));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function searchWithTrytes(_x, _x2) {\n        return _searchWithTrytes.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(transactionTrytes) {\n      var curl = spongeFactory_1.SpongeFactory.instance().create(\"curl\");\n      curl.initialize();\n      var transactionTrits = trits_1.Trits.fromTrytes(transactionTrytes).toArray();\n      curl.absorb(transactionTrits, 0, this._transactionLength - this._hashLength);\n      var curlState = curl.getState();\n      transactionTrits.slice(this._transactionLength - this._hashLength, this._transactionLength).forEach(function (value, index) {\n        curlState[index] = value;\n      });\n      return this.searchToPair(curlState);\n    }\n    /* @internal */\n\n  }, {\n    key: \"search\",\n    value: function () {\n      var _search = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(states, minWeight) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this._queue.push({\n                    states: states,\n                    minWeightMagnitude: minWeight,\n                    callback: resolve\n                  });\n\n                  if (_this._state === pearlDiverState_1.PearlDiverState.ready) {\n                    _this.searchDoNext();\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function search(_x3, _x4) {\n        return _search.apply(this, arguments);\n      };\n    }()\n    /* @internal */\n\n  }, {\n    key: \"searchToPair\",\n    value: function searchToPair(state) {\n      var states = {\n        low: new Int32Array(this._stateLength),\n        high: new Int32Array(this._stateLength)\n      };\n      state.forEach(function (trit, index) {\n        switch (trit) {\n          case 0:\n            states.low[index] = PearlDiver.HIGH_BITS;\n            states.high[index] = PearlDiver.HIGH_BITS;\n            break;\n\n          case 1:\n            states.low[index] = PearlDiver.LOW_BITS;\n            states.high[index] = PearlDiver.HIGH_BITS;\n            break;\n\n          default:\n            states.low[index] = PearlDiver.HIGH_BITS;\n            states.high[index] = PearlDiver.LOW_BITS;\n        }\n      });\n      this.searchOffset(states, this._nonceStart);\n      return states;\n    }\n    /* @internal */\n\n  }, {\n    key: \"searchOffset\",\n    value: function searchOffset(states, offset) {\n      states.low[offset + 0] = PearlDiver.LOW_0;\n      states.low[offset + 1] = PearlDiver.LOW_1;\n      states.low[offset + 2] = PearlDiver.LOW_2;\n      states.low[offset + 3] = PearlDiver.LOW_3;\n      states.high[offset + 0] = PearlDiver.HIGH_0;\n      states.high[offset + 1] = PearlDiver.HIGH_1;\n      states.high[offset + 2] = PearlDiver.HIGH_2;\n      states.high[offset + 3] = PearlDiver.HIGH_3;\n    }\n    /* @internal */\n\n  }, {\n    key: \"searchDoNext\",\n    value: function searchDoNext() {\n      var next = this._queue.shift();\n\n      if (objectHelper_1.ObjectHelper.isEmpty(next)) {\n        this._state = pearlDiverState_1.PearlDiverState.ready;\n      } else {\n        this._state = pearlDiverState_1.PearlDiverState.searching;\n        this.webGLFindNonce(next);\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"webGLFindNonce\",\n    value: function webGLFindNonce(searchObject) {\n      var _this2 = this;\n\n      this.webGLWriteBuffers(searchObject.states);\n\n      this._webGLWorker.writeData(this._currentBuffer);\n\n      this._webGLWorker.runProgram(\"init\", 1, {\n        name: \"gr_offset\",\n        value: 0\n      });\n\n      setTimeout(function () {\n        return _this2.webGLSearch(searchObject);\n      }, 1);\n    }\n    /* @internal */\n\n  }, {\n    key: \"webGLWriteBuffers\",\n    value: function webGLWriteBuffers(states) {\n      for (var i = 0; i < this._stateLength; i++) {\n        this._currentBuffer[i * PearlDiver.TEXEL_SIZE] = states.low[i];\n        this._currentBuffer[i * PearlDiver.TEXEL_SIZE + 1] = states.high[i];\n        this._currentBuffer[i * PearlDiver.TEXEL_SIZE + 2] = states.low[i];\n        this._currentBuffer[i * PearlDiver.TEXEL_SIZE + 3] = states.high[i];\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"webGLSearch\",\n    value: function webGLSearch(searchObject) {\n      this._webGLWorker.runProgram(\"increment\", 1);\n\n      this._webGLWorker.runProgram(\"twist\", this._numberRounds);\n\n      this._webGLWorker.runProgram(\"check\", 1, {\n        name: \"minWeightMagnitude\",\n        value: searchObject.minWeightMagnitude\n      });\n\n      this._webGLWorker.runProgram(\"col_check\", 1);\n\n      this._webGLWorker.runProgram(\"finalize\", 1);\n\n      var nonce = this._webGLWorker.readData(0, 0, this._webGLWorker.getDimensions().x, 1).reduce(this.pack(4), []).slice(0, this._hashLength).map(function (x) {\n        return x[3];\n      });\n\n      searchObject.callback(trits_1.Trits.fromNumberArray(nonce).toTrytes());\n      this.searchDoNext();\n    }\n    /* @internal */\n\n  }, {\n    key: \"pack\",\n    value: function pack(l) {\n      return function (r, currentValue, currentIndex) {\n        return (currentIndex % l === 0 ? r.push([currentValue]) : r[r.length - 1].push(currentValue)) && r;\n      };\n    }\n  }], [{\n    key: \"initialize\",\n    value: function initialize(webGLPlatform) {\n      if (!PearlDiver.instance) {\n        PearlDiver.instance = new PearlDiver(webGLPlatform);\n      }\n    }\n    /**\r\n     * Closedown the PearlDiver main instance.\r\n     */\n\n  }, {\n    key: \"closedown\",\n    value: function closedown() {\n      if (PearlDiver.instance) {\n        PearlDiver.instance = undefined;\n      }\n    }\n  }]);\n\n  return PearlDiver;\n}();\n/* @internal */\n\n\nPearlDiver.TEXEL_SIZE = 4;\n/* @internal */\n\nPearlDiver.LOW_BITS = 0; // 00000000\n\n/* @internal */\n\nPearlDiver.HIGH_BITS = -1; // 0xFFFFFFFF,FFFFFFFF,4294967295\n\n/* @internal */\n\nPearlDiver.LOW_0 = 0xDB6DB6DB; // 6DB6DB6D,\n\n/* @internal */\n\nPearlDiver.LOW_1 = 0xF1F8FC7E; // 3F1F8FC7,\n\n/* @internal */\n\nPearlDiver.LOW_2 = 0x7FFFE00F; // FFFC01FF,\n\n/* @internal */\n\nPearlDiver.LOW_3 = 0xFFC00000; // 07FFFFFF,\n\n/* @internal */\n\nPearlDiver.HIGH_0 = 0xB6DB6DB6; // DB6DB6DB,\n\n/* @internal */\n\nPearlDiver.HIGH_1 = 0x8FC7E3F1; // F8FC7E3F,\n\n/* @internal */\n\nPearlDiver.HIGH_2 = 0xFFC01FFF; // F803FFFF,\n\n/* @internal */\n\nPearlDiver.HIGH_3 = 0x003FFFFF; //FFFFFFFF,\n\nexports.PearlDiver = PearlDiver;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/pearlDiver/pearlDiver.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/pearlDiver/pearlDiverState.js":
/*!*****************************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/pearlDiver/pearlDiverState.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * PearlDiver State.\r\n */\n\nvar PearlDiverState;\n\n(function (PearlDiverState) {\n  PearlDiverState[PearlDiverState[\"ready\"] = 0] = \"ready\";\n  PearlDiverState[PearlDiverState[\"searching\"] = 1] = \"searching\";\n  PearlDiverState[PearlDiverState[\"interrupted\"] = -1] = \"interrupted\";\n})(PearlDiverState = exports.PearlDiverState || (exports.PearlDiverState = {}));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/pearlDiver/pearlDiverState.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/proofOfWorkWebGl.js":
/*!*******************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/proofOfWorkWebGl.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"../iota-pico-pow-webgl/node_modules/@babel/runtime/regenerator/index.js\");\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar arrayHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/arrayHelper */ \"../iota-pico-core/dist/helpers/arrayHelper.js\");\n\nvar numberHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/numberHelper */ \"../iota-pico-core/dist/helpers/numberHelper.js\");\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar trytes_1 = __webpack_require__(/*! @iota-pico/data/dist/data/trytes */ \"../iota-pico-data/dist/data/trytes.js\");\n\nvar pearlDiver_1 = __webpack_require__(/*! ./pearlDiver/pearlDiver */ \"../iota-pico-pow-webgl/dist/pearlDiver/pearlDiver.js\");\n/**\r\n * ProofOfWork implementation using WebGL.\r\n */\n\n\nvar ProofOfWorkWebGl =\n/*#__PURE__*/\nfunction () {\n  /**\r\n   * Create a new instance of ProofOfWork.\r\n   * @param webGLPlatform Provides platform specific functions, optional mostly used for testing.\r\n   */\n  function ProofOfWorkWebGl(webGLPlatform) {\n    _classCallCheck(this, ProofOfWorkWebGl);\n\n    if (objectHelper_1.ObjectHelper.isEmpty(webGLPlatform)) {\n      this._webGLPlatform = {\n        getWindow: function getWindow() {\n          return window;\n        },\n        getDocument: function getDocument(window) {\n          return window.document;\n        },\n        getCanvas: function getCanvas(document) {\n          return document.createElement(\"canvas\");\n        },\n        getWebGL: function getWebGL(canvas) {\n          var attr = {\n            alpha: false,\n            antialias: false\n          };\n          var gl = canvas.getContext(\"webgl2\", attr);\n          return gl;\n        }\n      };\n    } else {\n      this._webGLPlatform = webGLPlatform;\n    }\n  }\n  /**\r\n   * Allow the proof of work to perform any initialization.\r\n   * Will throw an exception if the implementation is not supported.\r\n   */\n\n\n  _createClass(ProofOfWorkWebGl, [{\n    key: \"initialize\",\n    value: function () {\n      var _initialize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  try {\n                    pearlDiver_1.PearlDiver.initialize(_this._webGLPlatform);\n                    _this._isInitialized = true;\n                    resolve();\n                  } catch (err) {\n                    reject(err);\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      return function initialize() {\n        return _initialize.apply(this, arguments);\n      };\n    }()\n    /**\r\n     * Performs single conversion per pow call.\r\n     * @returns True if pow only does one conversion.\r\n     */\n\n  }, {\n    key: \"performsSingle\",\n    value: function performsSingle() {\n      return true;\n    }\n    /**\r\n     * Perform a proof of work on the data.\r\n     * @param trunkTransaction The trunkTransaction to use for the pow.\r\n     * @param branchTransaction The branchTransaction to use for the pow.\r\n     * @param trytes The trytes to perform the pow on.\r\n     * @param minWeightMagnitude The minimum weight magnitude.\r\n     * @returns The trytes produced by the proof of work.\r\n     */\n\n  }, {\n    key: \"pow\",\n    value: function () {\n      var _pow = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(trunkTransaction, branchTransaction, trytes, minWeightMagnitude) {\n        var nonce, trytesString, nonceString;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._isInitialized) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"WebGL is not initialized, have you called initialize\");\n\n              case 2:\n                if (arrayHelper_1.ArrayHelper.isTyped(trytes, trytes_1.Trytes)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The trytes must be an array of type Trytes\");\n\n              case 4:\n                if (!(!numberHelper_1.NumberHelper.isInteger(minWeightMagnitude) || minWeightMagnitude <= 0)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new cryptoError_1.CryptoError(\"The minWeightMagnitude must be > 0\");\n\n              case 6:\n                _context2.next = 8;\n                return pearlDiver_1.PearlDiver.instance.searchWithTrytes(trytes[0], minWeightMagnitude);\n\n              case 8:\n                nonce = _context2.sent;\n                trytesString = trytes.toString();\n                nonceString = nonce.toString();\n                return _context2.abrupt(\"return\", [trytes_1.Trytes.fromString(trytesString.substr(0, trytesString.length - nonceString.length).concat(nonceString))]);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      return function pow(_x, _x2, _x3, _x4) {\n        return _pow.apply(this, arguments);\n      };\n    }()\n  }]);\n\n  return ProofOfWorkWebGl;\n}();\n\nexports.ProofOfWorkWebGl = ProofOfWorkWebGl;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/proofOfWorkWebGl.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/shaders/add.js":
/*!**************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/shaders/add.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Shaders add.\r\n */\n\nexports.default = \"\\nint sum (int a, int b) {\\n  int my_sum = a + b;\\n  return my_sum == 2 ? -1 : (my_sum == -2) ? 1 : my_sum;\\n}\\nint cons (int a, int b) {\\n  return (a == 1 && b == 1)? 1 : (a == -1 && b == -1) ? -1 : 0;\\n}\\nint any_t (int a, int b) {\\n  int my_any = a + b;\\n  return my_any == 0 ? 0 : (my_any > 0) ? 1 : -1;\\n}\\nivec2 full_adder(int a, int b, int c) {\\n  int c_a, c_b, sum_ab, c_s;\\n\\n  c_a    = cons(a,b);\\n  sum_ab = sum(a,b);\\n  c_b    = cons(sum_ab,c);\\n  c_s    = any_t(c_a, c_b);\\n\\n  return ivec2(sum(sum_ab, c), c_s);\\n}\\nivec2 get_sum_to_index(int from, int to, int number_to_add, int row) {\\n  int trit_to_add, trit_at_index, pow, carry, num_carry;\\n  ivec2 read_in, sum_out, out_trit;\\n  pow = 1;\\n  carry = 0;\\n  num_carry = 0;\\n\\n  for(int i = from; i < to; i++) {\\n    //if(trit_to_add == 0 && sum_out.t == 0) continue;\\n\\n    read_in = read_at ( ivec2 (i, row)).rg;\\n\\n    trit_to_add = ((number_to_add / pow) % 3) + num_carry;\\n    num_carry = trit_to_add > 1 ? 1 : 0;\\n    trit_to_add = (trit_to_add == 2 ? -1 : (trit_to_add == 3 ? 0 : trit_to_add));\\n\\n    sum_out = full_adder(\\n      (read_in.s == LOW_BITS ? 1 : read_in.t == LOW_BITS? -1 : 0),\\n      trit_to_add,\\n      carry\\n    );\\n\\n    if(my_coord.x == i) break;\\n    carry = sum_out.t;\\n    pow *=3;\\n  }\\n  if(sum_out.s == 0) {\\n    return ivec2(HIGH_BITS);\\n  } else if (sum_out.s == 1) {\\n    return ivec2(LOW_BITS, HIGH_BITS);\\n  } else {\\n    return ivec2(HIGH_BITS, LOW_BITS);\\n  }\\n}\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/shaders/add.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/shaders/checkCol.js":
/*!*******************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/shaders/checkCol.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Shaders check_col.\r\n */\n\nexports.default = \"\\nvoid main() {\\n  init();\\n  ivec4 my_vec = read();\\n  int i;\\n  if(my_coord.x == STATE_LENGTH && my_coord.y == 0) {\\n    my_vec.b = 0;\\n    if(my_vec.a == 0) {\\n      ivec4 read_vec;\\n      my_vec.b = -1;\\n      for(i = 1; i < int(size.y); i++) {\\n        read_vec = read_at( ivec2( STATE_LENGTH, i));\\n        if(read_vec.a != 0) {\\n          my_vec.a = read_vec.a;\\n          my_vec.b = i;\\n          break;\\n        }\\n      }\\n    }\\n  }\\n  commit(my_vec);\\n}\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/shaders/checkCol.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/shaders/checkDo.js":
/*!******************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/shaders/checkDo.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Shaders check_do.\r\n */\n\nexports.default = \"\\nint check(int row, int min_weight_magnitude) {\\n  int nonce_probe, i;\\n  ivec2 r_texel;\\n  nonce_probe = HIGH_BITS;\\n  for(i = min_weight_magnitude; i-- > 0; ) {\\n    r_texel = read_at(ivec2(HASH_LENGTH - 1 - i, row)).ba;\\n    nonce_probe &= ~(r_texel.s ^ r_texel.t);\\n    if(nonce_probe == 0) break;\\n  }\\n  return nonce_probe;\\n}\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/shaders/checkDo.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/shaders/checkK.js":
/*!*****************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/shaders/checkK.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Shaders check_k.\r\n */\n\nexports.default = \"\\nuniform int minWeightMagnitude;\\nvoid main() {\\n  init();\\n  ivec4 my_vec = read();\\n  if(my_coord.x == STATE_LENGTH) {\\n    my_vec.r = minWeightMagnitude;\\n    my_vec.a = check(my_coord.y, minWeightMagnitude);\\n  }\\n  commit(my_vec);\\n}\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/shaders/checkK.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/shaders/finalize.js":
/*!*******************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/shaders/finalize.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Shaders finalize.\r\n */\n\nexports.default = \"\\nvoid main() {\\n  init();\\n  ivec4 my_vec = read();\\n  if(my_coord.y == 0 && my_coord.x == STATE_LENGTH) {\\n    my_vec.g = check(my_vec.b, my_vec.r);\\n  }\\n  if(my_coord.y == 0 && my_coord.x < HASH_LENGTH) {\\n    ivec4 info_vec = read_at(ivec2(STATE_LENGTH, 0));\\n    int nonce_probe = info_vec.a;\\n    int row = info_vec.b;\\n    ivec4 hash_vec = read_at(ivec2(my_coord.x, row));\\n    my_vec.a = (hash_vec.r & nonce_probe) == 0? 1 : ((hash_vec.g & nonce_probe) == 0? -1 : 0);\\n  }\\n  commit(my_vec);\\n}\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/shaders/finalize.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/shaders/headers.js":
/*!******************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/shaders/headers.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Shaders add.\r\n */\n\nexports.default = \"\\n#define HASH_LENGTH 243\\n#define NUMBER_OF_ROUNDS 81\\n#define INCREMENT_START HASH_LENGTH - 64\\n#define STATE_LENGTH 3 * HASH_LENGTH\\n#define HALF_LENGTH 364\\n#define HIGH_BITS 0xFFFFFFFF\\n#define LOW_BITS 0x00000000\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/shaders/headers.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/shaders/increment.js":
/*!********************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/shaders/increment.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Shaders increment.\r\n */\n\nexports.default = \"\\nvoid main() {\\n  init();\\n  ivec4 my_vec = read();\\n  if(my_coord.x >= INCREMENT_START && my_coord.x < HASH_LENGTH ) {\\n    my_vec.rg = get_sum_to_index(INCREMENT_START, HASH_LENGTH, 1, my_coord.y);\\n  }\\n  if(my_coord.x == STATE_LENGTH ) {\\n    my_vec.rg = ivec2(0);\\n  }\\n  my_vec.ba = my_vec.rg;\\n  commit(my_vec);\\n}\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/shaders/increment.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/shaders/init.js":
/*!***************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/shaders/init.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Shaders init.\r\n */\n\nexports.default = \"\\nuniform int gr_offset;\\nivec4 offset() {\\n  if(my_coord.x >= HASH_LENGTH / 3 && my_coord.x < HASH_LENGTH / 3 * 2 ) {\\n    ivec4 my_vec;\\n    my_vec.rg = get_sum_to_index(HASH_LENGTH / 3, HASH_LENGTH / 3 * 2, my_coord.y + gr_offset, 0);\\n    return my_vec;\\n  } else {\\n    return read_at(ivec2(my_coord.x,0));\\n  }\\n}\\nvoid main() {\\n  init();\\n  commit(offset());\\n}\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/shaders/init.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/shaders/transform.js":
/*!********************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/shaders/transform.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Shaders transform.\r\n */\n\nexports.default = \"\\nivec2 twist() {\\n  int alpha, beta, gamma, delta;\\n  ivec4 v1, v2;\\n  int j = my_coord.x;\\n\\n  v1 = read_at(ivec2(j == 0? 0:(((j - 1)%2)+1)*HALF_LENGTH - ((j-1)>>1), my_coord.y));\\n  v2 = read_at(ivec2(((j%2)+1)*HALF_LENGTH - ((j)>>1), my_coord.y));\\n  alpha = v1.b;\\n  beta = v1.a;\\n  gamma = v2.a;\\n  delta = (alpha | (~gamma)) & (v2.b ^ beta);//v2.b === state_low[t2]\\n\\n  return ivec2(~delta, (alpha ^ gamma) | delta);\\n}\\nvoid main() {\\n  init();\\n  ivec4 my_vec = read();\\n  if(my_coord.x < STATE_LENGTH)\\n    my_vec.ba = twist();\\n  commit(my_vec);\\n}\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/shaders/transform.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/webGL/stdlib.js":
/*!***************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/webGL/stdlib.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Stdlib.\r\n */\n\nexports.default = \"#version 300 es\\nprecision highp float;\\nprecision highp int;\\nprecision highp isampler2D;\\nuniform isampler2D u_texture;\\nin vec2 pos;\\nout ivec4 color;\\n//out int isFinished;\\n\\nvec2 size;\\nivec2 my_coord;\\n\\nvoid init(void) {\\n  //size = vec2(textureSize(u_texture, 0) - 1);\\n  size = vec2(textureSize(u_texture, 0));\\n  my_coord = ivec2(pos * size);\\n}\\n\\nivec4 read(void) {\\n  return texture(u_texture, pos);\\n}\\n\\nivec4 read_at(ivec2 coord) {\\n  return texelFetch(u_texture, coord, 0);\\n}\\n\\nvoid commit(ivec4 val) {\\n  color = val;\\n}\\n\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/webGL/stdlib.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/webGL/vertexShaderCode.js":
/*!*************************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/webGL/vertexShaderCode.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Vertex Shader code.\r\n */\n\nexports.default = \"#version 300 es\\nlayout(location = 0) in vec2 position;\\nlayout(location = 1) in vec2 texture;\\nout vec2 pos;\\n\\nvoid main(void) {\\n  pos = texture;\\n  gl_Position = vec4(position.xy, 0.0, 1.0);\\n}\";\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/webGL/vertexShaderCode.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/webGL/webGLHelper.js":
/*!********************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/webGL/webGLHelper.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar objectHelper_1 = __webpack_require__(/*! @iota-pico/core/dist/helpers/objectHelper */ \"../iota-pico-core/dist/helpers/objectHelper.js\");\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n/**\r\n * Helper functions for use with WebGL.\r\n */\n\n\nvar WebGLHelper =\n/*#__PURE__*/\nfunction () {\n  function WebGLHelper() {\n    _classCallCheck(this, WebGLHelper);\n  }\n\n  _createClass(WebGLHelper, null, [{\n    key: \"createContext\",\n\n    /**\r\n     * Create a WebGL Context.\r\n     * @returns The context if successfuly or throws an error if it cannot be created.\r\n     */\n    value: function createContext(webGLPlatform) {\n      var window = webGLPlatform.getWindow();\n\n      if (!objectHelper_1.ObjectHelper.isEmpty(window) && typeof window !== \"undefined\") {\n        var document = webGLPlatform.getDocument(window);\n\n        if (!objectHelper_1.ObjectHelper.isEmpty(document)) {\n          var canvas = webGLPlatform.getCanvas(document);\n\n          if (!objectHelper_1.ObjectHelper.isEmpty(canvas)) {\n            var gl = webGLPlatform.getWebGL(canvas);\n\n            if (objectHelper_1.ObjectHelper.isEmpty(gl)) {\n              throw new cryptoError_1.CryptoError(\"Can not create a WebGL context on a <canvas> element.\", {\n                userAgent: window.navigator.userAgent\n              });\n            }\n\n            return gl;\n          } else {\n            throw new cryptoError_1.CryptoError(\"The HTML5 <canvas> element is not available in your browser.\", {\n              userAgent: window.navigator.userAgent\n            });\n          }\n        } else {\n          throw new cryptoError_1.CryptoError(\"window.document is not available, you must be running in an environment with WebGL.\");\n        }\n      } else {\n        throw new cryptoError_1.CryptoError(\"window is not available, you must be running in an environment with WebGL.\");\n      }\n    }\n    /**\r\n     * Create a new WebGL buffer.\r\n     * @param gl The WebGL rendering context.\r\n     * @param data The data to add to the buffer.\r\n     * @param arrayType The data type for the buffer.\r\n     * @param target A GL Enum specifying the binding point (target).\r\n     * @returns The WebGL buffer.\r\n     */\n\n  }, {\n    key: \"createBuffer\",\n    value: function createBuffer(gl, data, arrayType, target) {\n      var buf = gl.createBuffer();\n      gl.bindBuffer(target || gl.ARRAY_BUFFER, buf);\n      gl.bufferData(target || gl.ARRAY_BUFFER, new (arrayType || Float32Array)(data), gl.STATIC_DRAW);\n      return buf;\n    }\n    /**\r\n     * Transfer data onto clamped texture and turn off any filtering\r\n     * @param gl The WebGL rendering context.\r\n     * @param pixelData The pixel data to create the view from.\r\n     * @param dimensions The dimensions to create the texture.\r\n     * @returns The texture.\r\n     */\n\n  }, {\n    key: \"createTexture\",\n    value: function createTexture(gl, pixelData, dimensions) {\n      var texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32I, dimensions.x, dimensions.y, 0, gl.RGBA_INTEGER, gl.INT, pixelData);\n      gl.bindTexture(gl.TEXTURE_2D, null);\n      return texture;\n    }\n    /**\r\n     * Set the texure into the framebuffer.\r\n     * @param gl The WebGL rendering context.\r\n     * @param frameBuffer The frame buffer to set the text in to.\r\n     * @param texture The texture to set in to the framebuffer.\r\n     */\n\n  }, {\n    key: \"frameBufferSetTexture\",\n    value: function frameBufferSetTexture(gl, frameBuffer, texture) {\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); // Test for mobile bug MDN->WebGL_best_practices, bullet 7\n\n      var frameBufferStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n      if (frameBufferStatus !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new cryptoError_1.CryptoError(\"Error attaching float texture to framebuffer. Your device is probably incompatible.\");\n      }\n    }\n  }]);\n\n  return WebGLHelper;\n}();\n\nexports.WebGLHelper = WebGLHelper;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/webGL/webGLHelper.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/dist/webGL/webGLWorker.js":
/*!********************************************************!*\
  !*** ../iota-pico-pow-webgl/dist/webGL/webGLWorker.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar cryptoError_1 = __webpack_require__(/*! @iota-pico/crypto/dist/error/cryptoError */ \"../iota-pico-crypto/dist/error/cryptoError.js\");\n\nvar stdlib_1 = __importDefault(__webpack_require__(/*! ./stdlib */ \"../iota-pico-pow-webgl/dist/webGL/stdlib.js\"));\n\nvar vertexShaderCode_1 = __importDefault(__webpack_require__(/*! ./vertexShaderCode */ \"../iota-pico-pow-webgl/dist/webGL/vertexShaderCode.js\"));\n\nvar webGLHelper_1 = __webpack_require__(/*! ./webGLHelper */ \"../iota-pico-pow-webgl/dist/webGL/webGLHelper.js\");\n/**\r\n * WebGLWorker.\r\n */\n\n\nvar WebGLWorker =\n/*#__PURE__*/\nfunction () {\n  function WebGLWorker() {\n    _classCallCheck(this, WebGLWorker);\n  }\n\n  _createClass(WebGLWorker, [{\n    key: \"initialize\",\n\n    /**\r\n     * Initialize the web GL Worker.\r\n     * @param webGLPlatform The webGL platform.\r\n     * @param stateLength The length of the state.\r\n     * @param texelSize The texel size.\r\n     */\n    value: function initialize(webGLPlatform, stateLength, texelSize) {\n      this._context = webGLHelper_1.WebGLHelper.createContext(webGLPlatform);\n      this._dimensions = {\n        x: stateLength,\n        y: 0\n      };\n      var maxImageSize = Math.pow(this._context.MAX_TEXTURE_SIZE, 2) * 0.5;\n      var imageSize = Math.floor(maxImageSize / this._dimensions.x / texelSize) * this._dimensions.x * texelSize;\n      this._dimensions.y = imageSize / this._dimensions.x / texelSize;\n      this._programs = new Map();\n      this._ipt = {\n        data: new Int32Array(imageSize),\n        length: imageSize\n      }; // GPU texture buffer = from JS typed array\n\n      this._buffers = {\n        position: webGLHelper_1.WebGLHelper.createBuffer(this._context, [-1, -1, 1, -1, 1, 1, -1, 1]),\n        texture: webGLHelper_1.WebGLHelper.createBuffer(this._context, [0, 0, 1, 0, 1, 1, 0, 1]),\n        index: webGLHelper_1.WebGLHelper.createBuffer(this._context, [1, 2, 0, 3, 0, 2], Uint16Array, this._context.ELEMENT_ARRAY_BUFFER)\n      };\n      this._attrib = {\n        position: 0,\n        texture: 1\n      };\n      this._vertexArray = this._context.createVertexArray();\n\n      this._context.bindVertexArray(this._vertexArray);\n\n      this.bindBuffers();\n\n      this._context.bindVertexArray(null);\n\n      this.createVertexShader();\n      this._frameBuffer = this._context.createFramebuffer();\n      this._texture0 = webGLHelper_1.WebGLHelper.createTexture(this._context, this._ipt.data, this._dimensions);\n      this._texture1 = webGLHelper_1.WebGLHelper.createTexture(this._context, new Int32Array(imageSize), this._dimensions);\n    }\n    /**\r\n     * Get the dimensions from the worker.\r\n     * @returns The dimensions.\r\n     */\n\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return this._dimensions;\n    }\n    /**\r\n     * Get the IPT from the worker.\r\n     * @return The ipt.\r\n     */\n\n  }, {\n    key: \"getIpt\",\n    value: function getIpt() {\n      return this._ipt;\n    }\n    /**\r\n     * Add a program to the worker.\r\n     * @param name The name of the program to add.\r\n     * @param code The code for the program.\r\n     * @param uniforms Additional uniform locations.\r\n     */\n\n  }, {\n    key: \"addProgram\",\n    value: function addProgram(name, code) {\n      var fragmentShader = this.createFragmentShader(code);\n\n      var program = this._context.createProgram();\n\n      this._context.attachShader(program, this._vertexShader);\n\n      this._context.attachShader(program, fragmentShader);\n\n      this._context.bindAttribLocation(program, this._attrib.position, \"position\");\n\n      this._context.bindAttribLocation(program, this._attrib.texture, \"texture\");\n\n      this._context.linkProgram(program);\n\n      var uniformVars = new Map();\n\n      for (var _len = arguments.length, uniforms = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        uniforms[_key - 2] = arguments[_key];\n      }\n\n      for (var _i = 0; _i < uniforms.length; _i++) {\n        var variable = uniforms[_i];\n        uniformVars.set(variable, this._context.getUniformLocation(program, variable));\n      }\n\n      this._programs.set(name, {\n        program: program,\n        uniformVars: uniformVars\n      });\n    }\n    /**\r\n     * Run the program in the web worker.\r\n     * @param name The name of the program to run.\r\n     * @param count The number of times to run it.\r\n     * @param uniforms Additional uniform locations to use.\r\n     */\n\n  }, {\n    key: \"runProgram\",\n    value: function runProgram(name, count) {\n      var info = this._programs.get(name);\n\n      var program = info.program;\n\n      if (!this._context.getProgramParameter(program, this._context.LINK_STATUS)) {\n        throw new cryptoError_1.CryptoError(\"Failed to link GLSL program code\");\n      }\n\n      var uniformVars = info.uniformVars;\n\n      var uTexture = this._context.getUniformLocation(program, \"u_texture\");\n\n      this._context.useProgram(program);\n\n      var localCount = count;\n\n      for (var _len2 = arguments.length, uniforms = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        uniforms[_key2 - 2] = arguments[_key2];\n      }\n\n      while (localCount-- > 0) {\n        this._context.bindTexture(this._context.TEXTURE_2D, this._texture0);\n\n        this._context.activeTexture(this._context.TEXTURE0);\n\n        this._context.uniform1i(uTexture, 0);\n\n        this._context.viewport(0, 0, this._dimensions.x, this._dimensions.y);\n\n        webGLHelper_1.WebGLHelper.frameBufferSetTexture(this._context, this._frameBuffer, this._texture1);\n\n        this._context.bindVertexArray(this._vertexArray);\n\n        for (var _i2 = 0; _i2 < uniforms.length; _i2++) {\n          var uVars = uniforms[_i2];\n\n          this._context.uniform1i(uniformVars.get(uVars.name), uVars.value);\n        }\n\n        this._context.drawElements(this._context.TRIANGLES, 6, this._context.UNSIGNED_SHORT, 0);\n\n        var tex0 = this._texture0;\n        this._texture0 = this._texture1;\n        this._texture1 = tex0;\n      }\n\n      this.finishRun();\n    }\n    /**\r\n     * Read data from the worker.\r\n     * @param x The x position to read from.\r\n     * @param y The y position to read from.\r\n     * @param n The width position to read from.\r\n     * @param m The height position to read from.\r\n     */\n\n  }, {\n    key: \"readData\",\n    value: function readData(x, y, n, m) {\n      this._context.bindFramebuffer(this._context.FRAMEBUFFER, this._frameBuffer);\n\n      this._context.readPixels(x, y, n, m, this._context.RGBA_INTEGER, this._context.INT, this._ipt.data);\n\n      this._context.bindFramebuffer(this._context.FRAMEBUFFER, null);\n\n      return this._ipt.data.subarray(0, this._ipt.length);\n    }\n    /**\r\n     * Write data to the worker.\r\n     * @param data The data to write.\r\n     */\n\n  }, {\n    key: \"writeData\",\n    value: function writeData(data) {\n      this._context.bindTexture(this._context.TEXTURE_2D, this._texture0);\n\n      this._context.texImage2D(this._context.TEXTURE_2D, 0, this._context.RGBA32I, this._dimensions.x, this._dimensions.y, 0, this._context.RGBA_INTEGER, this._context.INT, data);\n\n      this._context.bindTexture(this._context.TEXTURE_2D, null);\n    }\n    /* @internal */\n\n  }, {\n    key: \"bindBuffers\",\n    value: function bindBuffers() {\n      this._context.bindBuffer(this._context.ARRAY_BUFFER, this._buffers.texture);\n\n      this._context.enableVertexAttribArray(this._attrib.texture);\n\n      this._context.vertexAttribPointer(this._attrib.texture, 2, this._context.FLOAT, false, 0, 0);\n\n      this._context.bindBuffer(this._context.ARRAY_BUFFER, this._buffers.position);\n\n      this._context.enableVertexAttribArray(this._attrib.position);\n\n      this._context.vertexAttribPointer(this._attrib.position, 2, this._context.FLOAT, false, 0, 0);\n\n      this._context.bindBuffer(this._context.ELEMENT_ARRAY_BUFFER, this._buffers.index);\n    }\n    /* @internal */\n\n  }, {\n    key: \"createVertexShader\",\n    value: function createVertexShader() {\n      this._vertexShader = this._context.createShader(this._context.VERTEX_SHADER);\n\n      this._context.shaderSource(this._vertexShader, vertexShaderCode_1.default);\n\n      this._context.compileShader(this._vertexShader); // This should not fail.\n\n\n      if (!this._context.getShaderParameter(this._vertexShader, this._context.COMPILE_STATUS)) {\n        throw new cryptoError_1.CryptoError(\"Could not build vertex shader.\\n\\n--- CODE DUMP ---\".concat(vertexShaderCode_1.default, \"\\n\\n--- ERROR LOG ---\\n\").concat(this._context.getShaderInfoLog(this._vertexShader)));\n      }\n    }\n    /* @internal */\n\n  }, {\n    key: \"createFragmentShader\",\n    value: function createFragmentShader(code) {\n      var fragmentShader = this._context.createShader(this._context.FRAGMENT_SHADER);\n\n      this._context.shaderSource(fragmentShader, stdlib_1.default + code);\n\n      this._context.compileShader(fragmentShader); // Use this output to debug the shader\n      // Keep in mind that WebGL GLSL is **much** stricter than e.g. OpenGL GLSL\n\n\n      if (!this._context.getShaderParameter(fragmentShader, this._context.COMPILE_STATUS)) {\n        var codeLines = code.split(\"\\n\");\n        var dbgMsg = \"Could not build fragment shader.\\n\\n------------------ KERNEL CODE DUMP ------------------\\n\";\n\n        for (var nl = 0; nl < codeLines.length; nl++) {\n          dbgMsg += \"\".concat(stdlib_1.default.split(\"\\n\").length + nl, \"> \").concat(codeLines[nl], \"\\n\");\n        }\n\n        dbgMsg += \"\\n--------------------- ERROR  LOG ---------------------\\n\".concat(this._context.getShaderInfoLog(fragmentShader));\n        throw new cryptoError_1.CryptoError(dbgMsg);\n      }\n\n      return fragmentShader;\n    }\n    /* @internal */\n\n  }, {\n    key: \"finishRun\",\n    value: function finishRun() {\n      this._context.bindVertexArray(null);\n\n      this._context.bindTexture(this._context.TEXTURE_2D, null);\n\n      this._context.bindFramebuffer(this._context.FRAMEBUFFER, null);\n    }\n  }]);\n\n  return WebGLWorker;\n}();\n\nexports.WebGLWorker = WebGLWorker;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/dist/webGL/webGLWorker.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/node_modules/@babel/runtime/regenerator/index.js":
/*!*******************************************************************************!*\
  !*** ../iota-pico-pow-webgl/node_modules/@babel/runtime/regenerator/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"../iota-pico-pow-webgl/node_modules/regenerator-runtime/runtime-module.js\");\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/node_modules/@babel/runtime/regenerator/index.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/node_modules/regenerator-runtime/runtime-module.js":
/*!*********************************************************************************!*\
  !*** ../iota-pico-pow-webgl/node_modules/regenerator-runtime/runtime-module.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ \"../iota-pico-pow-webgl/node_modules/regenerator-runtime/runtime.js\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/node_modules/regenerator-runtime/runtime-module.js?");

/***/ }),

/***/ "../iota-pico-pow-webgl/node_modules/regenerator-runtime/runtime.js":
/*!**************************************************************************!*\
  !*** ../iota-pico-pow-webgl/node_modules/regenerator-runtime/runtime.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/../iota-pico-pow-webgl/node_modules/regenerator-runtime/runtime.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n  for (var p in m) {\n    if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n  }\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Combined index of all the modules.\r\n */\n\n__export(__webpack_require__(/*! @iota-pico/core */ \"../iota-pico-core/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/data */ \"../iota-pico-data/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/api */ \"../iota-pico-api/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/crypto */ \"../iota-pico-crypto/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/business */ \"../iota-pico-business/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pal-browser */ \"../iota-pico-pal-browser/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pow-box */ \"../iota-pico-pow-box/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pow-js */ \"../iota-pico-pow-js/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pow-wasm */ \"../iota-pico-pow-wasm/dist/index.js\"));\n\n__export(__webpack_require__(/*! @iota-pico/pow-webgl */ \"../iota-pico-pow-webgl/dist/index.js\"));\n\n//# sourceURL=webpack://%5Bobject_Object%5D/./dist/index.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/mock/empty.js":
/*!******************************************************!*\
  !*** ./node_modules/node-libs-browser/mock/empty.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n\n//# sourceURL=webpack://%5Bobject_Object%5D/./node_modules/node-libs-browser/mock/empty.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack://%5Bobject_Object%5D/(webpack)/buildin/module.js?");

/***/ }),

/***/ "./pkg/bootstrap.js":
/*!**************************!*\
  !*** ./pkg/bootstrap.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.default = __webpack_require__(/*! ../dist/index */ \"./dist/index.js\");\n\n//# sourceURL=webpack://%5Bobject_Object%5D/./pkg/bootstrap.js?");

/***/ }),

/***/ "big-integer":
/*!*********************************************************************************************************!*\
  !*** external {"amd":"big-integer","commonjs":"big-integer","commonjs2":"big-integer","root":"bigInt"} ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_big_integer__;\n\n//# sourceURL=webpack://%5Bobject_Object%5D/external_%7B%22amd%22:%22big-integer%22,%22commonjs%22:%22big-integer%22,%22commonjs2%22:%22big-integer%22,%22root%22:%22bigInt%22%7D?");

/***/ })

/******/ })["default"];
});

/***/ }),

/***/ "./getNodeInfo.js":
/*!************************!*\
  !*** ./getNodeInfo.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
}
Object.defineProperty(exports, "__esModule", { value: true });
// Import the all-in-one library
const IotaPico = __importStar(__webpack_require__(/*! @iota-pico/lib-browser */ "../../../../iota-pico-lib-browser/pkg/iota-pico-lib-browser.js"));
(async function () {
    // Create an end point to communicate with the node
    const networkEndpoint = new IotaPico.NetworkEndPoint("https", "nodes.thetangle.org", 443);
    // Create a network client from the PAL
    const networkClient = new IotaPico.NetworkClient(networkEndpoint);
    // Create an API client using the network client and the API version
    const apiClient = new IotaPico.ApiClient(networkClient);
    try {
        // Make the call to the API
        const response = await apiClient.getNodeInfo();
        // And log the response
        console.log(JSON.stringify(response, undefined, "\t"));
    }
    catch (err) {
        // Or log an error if it failed
        console.error(err);
    }
})();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0Tm9kZUluZm8uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJnZXROb2RlSW5mby50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGdDQUFnQztBQUNoQyxpRUFBbUQ7QUFFbkQsQ0FBQyxLQUFLO0lBQ0YsbURBQW1EO0lBQ25ELE1BQU0sZUFBZSxHQUFHLElBQUksUUFBUSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFFMUYsdUNBQXVDO0lBQ3ZDLE1BQU0sYUFBYSxHQUFHLElBQUksUUFBUSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUVsRSxvRUFBb0U7SUFDcEUsTUFBTSxTQUFTLEdBQUcsSUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLGFBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUU3RCxJQUFJLENBQUM7UUFDRCwyQkFBMkI7UUFDM0IsTUFBTSxRQUFRLEdBQUcsTUFBTSxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFL0MsdUJBQXVCO1FBQ3ZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUFDLEtBQUssQ0FBQSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDViwrQkFBK0I7UUFDL0IsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QixDQUFDO0FBQ0wsQ0FBQyxDQUFDLEVBQUUsQ0FBQyJ9

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL0Q6L1dvcmthcmVhL2lvdGFlY28vaW90YS1waWNvLWxpYi1icm93c2VyL25vZGVfbW9kdWxlcy9iaWctaW50ZWdlci9CaWdJbnRlZ2VyLmpzIiwid2VicGFjazovLy9EOi9Xb3JrYXJlYS9pb3RhZWNvL2lvdGEtcGljby1saWItYnJvd3Nlci9wa2cvaW90YS1waWNvLWxpYi1icm93c2VyLmpzIiwid2VicGFjazovLy8uL2dldE5vZGVJbmZvLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs4Q0NuRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxjQUFjLEVBQUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxjQUFjLEVBQUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxjQUFjLEVBQUU7QUFDakU7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLLEVBQUU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSx3QkFBd0I7O0FBRXRHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZEQUE2RDtBQUNwRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUFBO0FBQ0g7Ozs7Ozs7Ozs7Ozs7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QUFvQixxQkFBcUIscUJBQXFCLHFCQUFxQixxQkFBcUIscUJBQXFCLHFCQUFxQixxQkFBcUIscUJBQXFCLHlDQUF5Qyx5Q0FBeUMsb0JBQW9CLG9CQUFvQixxQkFBcUIscUJBQXFCLHFCQUFxQixxQkFBcUIscUJBQXFCLHFCQUFxQixxQkFBcUIscUJBQXFCLHlDQUF5Qyx5Q0FBeUMsb0JBQW9CLG9CQUFvQixxQkFBcUIscUJBQXFCLHFCQUFxQixxQkFBcUIscUJBQXFCLHFCQUFxQixxQkFBcUIscUJBQXFCLG9CQUFvQixvQkFBb0IsMENBQTBDLDBDQUEwQywwQ0FBMEMsMENBQTBDLDBDQUEwQywwQ0FBMEMsMkNBQTJDLDJDQUEyQyx3Q0FBd0Msd0NBQXdDLDBDQUEwQywwQ0FBMEMsMkNBQTJDLDJDQUEyQywyQ0FBMkMsMkNBQTJDLDBDQUEwQywwQ0FBMEMsd0NBQXdDLHdDQUF3QywwQ0FBMEMsMENBQTBDLDBDQUEwQywwQ0FBMEMsMkNBQTJDLDJDQUEyQywwQ0FBMEMsMENBQTBDLHdDQUF3Qyx3Q0FBd0MsMENBQTBDLDBDQUEwQywwQ0FBMEMsMENBQTBDLDBDQUEwQywwQ0FBMEMsMENBQTBDLDBDQUEwQyx3Q0FBd0Msd0NBQXdDLDJDQUEyQywyQ0FBMkMsMENBQTBDLDBDQUEwQywwQ0FBMEMsMENBQTBDLDBDQUEwQywwQ0FBMEMsK0JBQStCLCtCQUErQixtQ0FBbUMsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsbUNBQW1DLCtCQUErQiwrQkFBK0IsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsbUNBQW1DLG1DQUFtQywrQkFBK0IsK0JBQStCLG1DQUFtQyxtQ0FBbUMsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsK0JBQStCLCtCQUErQixtQ0FBbUMsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsbUNBQW1DLCtCQUErQiwrQkFBK0IsbUNBQW1DLG1DQUFtQyxtQ0FBbUMsbUNBQW1D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RUEsc0ZBQXNGOztBQUV0RixPQUFPOztBQUVQO0FBQ0E7QUFDQSxpQkFBaUIsdUZBQXVGO0FBQ3hHO0FBQ0E7QUFDQTs7QUFFQSwrREFBK0Q7O0FBRS9ELE9BQU87O0FBRVAsVUFBVTtBQUNWLENBQUMsRTs7Ozs7Ozs7Ozs7QUNsdUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkNBQTJDLCs4Qjs7Ozs7Ozs7Ozs7QUM1QjNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZXROb2RlSW5mby5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9nZXROb2RlSW5mby5qc1wiKTtcbiIsInZhciBiaWdJbnQgPSAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgdmFyIEJBU0UgPSAxZTcsXHJcbiAgICAgICAgTE9HX0JBU0UgPSA3LFxyXG4gICAgICAgIE1BWF9JTlQgPSA5MDA3MTk5MjU0NzQwOTkyLFxyXG4gICAgICAgIE1BWF9JTlRfQVJSID0gc21hbGxUb0FycmF5KE1BWF9JTlQpLFxyXG4gICAgICAgIExPR19NQVhfSU5UID0gTWF0aC5sb2coTUFYX0lOVCk7XHJcblxyXG4gICAgZnVuY3Rpb24gSW50ZWdlcih2LCByYWRpeCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYWRpeCAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuICtyYWRpeCA9PT0gMTAgPyBwYXJzZVZhbHVlKHYpIDogcGFyc2VCYXNlKHYsIHJhZGl4KTtcclxuICAgICAgICByZXR1cm4gcGFyc2VWYWx1ZSh2KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBCaWdJbnRlZ2VyKHZhbHVlLCBzaWduKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2lnbiA9IHNpZ247XHJcbiAgICAgICAgdGhpcy5pc1NtYWxsID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSW50ZWdlci5wcm90b3R5cGUpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFNtYWxsSW50ZWdlcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnNpZ24gPSB2YWx1ZSA8IDA7XHJcbiAgICAgICAgdGhpcy5pc1NtYWxsID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEludGVnZXIucHJvdG90eXBlKTtcclxuXHJcbiAgICBmdW5jdGlvbiBpc1ByZWNpc2Uobikge1xyXG4gICAgICAgIHJldHVybiAtTUFYX0lOVCA8IG4gJiYgbiA8IE1BWF9JTlQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc21hbGxUb0FycmF5KG4pIHsgLy8gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgZG9lc24ndCByZWZlcmVuY2UgQkFTRSwgbmVlZCB0byBjaGFuZ2UgdGhpcyBmdW5jdGlvbiBpZiBCQVNFIGNoYW5nZXNcclxuICAgICAgICBpZiAobiA8IDFlNylcclxuICAgICAgICAgICAgcmV0dXJuIFtuXTtcclxuICAgICAgICBpZiAobiA8IDFlMTQpXHJcbiAgICAgICAgICAgIHJldHVybiBbbiAlIDFlNywgTWF0aC5mbG9vcihuIC8gMWU3KV07XHJcbiAgICAgICAgcmV0dXJuIFtuICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTcpICUgMWU3LCBNYXRoLmZsb29yKG4gLyAxZTE0KV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXJyYXlUb1NtYWxsKGFycikgeyAvLyBJZiBCQVNFIGNoYW5nZXMgdGhpcyBmdW5jdGlvbiBtYXkgbmVlZCB0byBjaGFuZ2VcclxuICAgICAgICB0cmltKGFycik7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA8IDQgJiYgY29tcGFyZUFicyhhcnIsIE1BWF9JTlRfQVJSKSA8IDApIHtcclxuICAgICAgICAgICAgc3dpdGNoIChsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBhcnJbMF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBhcnJbMF0gKyBhcnJbMV0gKiBCQVNFO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGFyclswXSArIChhcnJbMV0gKyBhcnJbMl0gKiBCQVNFKSAqIEJBU0U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmltKHYpIHtcclxuICAgICAgICB2YXIgaSA9IHYubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlICh2Wy0taV0gPT09IDApO1xyXG4gICAgICAgIHYubGVuZ3RoID0gaSArIDE7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQXJyYXkobGVuZ3RoKSB7IC8vIGZ1bmN0aW9uIHNoYW1lbGVzc2x5IHN0b2xlbiBmcm9tIFlhZmZsZSdzIGxpYnJhcnkgaHR0cHM6Ly9naXRodWIuY29tL1lhZmZsZS9CaWdJbnRlZ2VyXHJcbiAgICAgICAgdmFyIHggPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICB2YXIgaSA9IC0xO1xyXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgeFtpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRydW5jYXRlKG4pIHtcclxuICAgICAgICBpZiAobiA+IDApIHJldHVybiBNYXRoLmZsb29yKG4pO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkKGEsIGIpIHsgLy8gYXNzdW1lcyBhIGFuZCBiIGFyZSBhcnJheXMgd2l0aCBhLmxlbmd0aCA+PSBiLmxlbmd0aFxyXG4gICAgICAgIHZhciBsX2EgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgbF9iID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobF9hKSxcclxuICAgICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgc3VtLCBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsX2I7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gPSBhW2ldICsgYltpXSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IHN1bSA+PSBiYXNlID8gMSA6IDA7XHJcbiAgICAgICAgICAgIHJbaV0gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpIDwgbF9hKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IGFbaV0gKyBjYXJyeTtcclxuICAgICAgICAgICAgY2FycnkgPSBzdW0gPT09IGJhc2UgPyAxIDogMDtcclxuICAgICAgICAgICAgcltpKytdID0gc3VtIC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FycnkgPiAwKSByLnB1c2goY2FycnkpO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEFueShhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEubGVuZ3RoID49IGIubGVuZ3RoKSByZXR1cm4gYWRkKGEsIGIpO1xyXG4gICAgICAgIHJldHVybiBhZGQoYiwgYSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkU21hbGwoYSwgY2FycnkpIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBjYXJyeSBpcyBudW1iZXIgd2l0aCAwIDw9IGNhcnJ5IDwgTUFYX0lOVFxyXG4gICAgICAgIHZhciBsID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQXJyYXkobCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBzdW0sIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBzdW0gPSBhW2ldIC0gYmFzZSArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3Ioc3VtIC8gYmFzZSk7XHJcbiAgICAgICAgICAgIHJbaV0gPSBzdW0gLSBjYXJyeSAqIGJhc2U7XHJcbiAgICAgICAgICAgIGNhcnJ5ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcclxuICAgICAgICAgICAgcltpKytdID0gY2FycnkgJSBiYXNlO1xyXG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IoY2FycnkgLyBiYXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYSA9IHRoaXMudmFsdWUsIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKGEsIE1hdGguYWJzKGIpKSwgdGhpcy5zaWduKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZEFueShhLCBiKSwgdGhpcy5zaWduKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wbHVzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuYWRkO1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmIChhIDwgMCAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KG4ubmVnYXRlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQcmVjaXNlKGEgKyBiKSkgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYSArIGIpO1xyXG4gICAgICAgICAgICBiID0gc21hbGxUb0FycmF5KE1hdGguYWJzKGIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKGFkZFNtYWxsKGIsIE1hdGguYWJzKGEpKSwgYSA8IDApO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUucGx1cyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWRkO1xyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHsgLy8gYXNzdW1lcyBhIGFuZCBiIGFyZSBhcnJheXMgd2l0aCBhID49IGJcclxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGFfbCksXHJcbiAgICAgICAgICAgIGJvcnJvdyA9IDAsXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBpLCBkaWZmZXJlbmNlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBiX2w7IGkrKykge1xyXG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gYVtpXSAtIGJvcnJvdyAtIGJbaV07XHJcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZGlmZmVyZW5jZSArPSBiYXNlO1xyXG4gICAgICAgICAgICAgICAgYm9ycm93ID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIGJvcnJvdyA9IDA7XHJcbiAgICAgICAgICAgIHJbaV0gPSBkaWZmZXJlbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSBiX2w7IGkgPCBhX2w7IGkrKykge1xyXG4gICAgICAgICAgICBkaWZmZXJlbmNlID0gYVtpXSAtIGJvcnJvdztcclxuICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSBkaWZmZXJlbmNlICs9IGJhc2U7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcltpKytdID0gZGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbaV0gPSBkaWZmZXJlbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKDsgaSA8IGFfbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJbaV0gPSBhW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmltKHIpO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0QW55KGEsIGIsIHNpZ24pIHtcclxuICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgaWYgKGNvbXBhcmVBYnMoYSwgYikgPj0gMCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHN1YnRyYWN0KGEsYik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBzdWJ0cmFjdChiLCBhKTtcclxuICAgICAgICAgICAgc2lnbiA9ICFzaWduO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWx1ZSA9IGFycmF5VG9TbWFsbCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAoc2lnbikgdmFsdWUgPSAtdmFsdWU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHZhbHVlLCBzaWduKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdFNtYWxsKGEsIGIsIHNpZ24pIHsgLy8gYXNzdW1lcyBhIGlzIGFycmF5LCBiIGlzIG51bWJlciB3aXRoIDAgPD0gYiA8IE1BWF9JTlRcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gbmV3IEFycmF5KGwpLFxyXG4gICAgICAgICAgICBjYXJyeSA9IC1iLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgaSwgZGlmZmVyZW5jZTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgPSBhW2ldICsgY2Fycnk7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihkaWZmZXJlbmNlIC8gYmFzZSk7XHJcbiAgICAgICAgICAgIGRpZmZlcmVuY2UgJT0gYmFzZTtcclxuICAgICAgICAgICAgcltpXSA9IGRpZmZlcmVuY2UgPCAwID8gZGlmZmVyZW5jZSArIGJhc2UgOiBkaWZmZXJlbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByID0gYXJyYXlUb1NtYWxsKHIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgciA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICBpZiAoc2lnbikgciA9IC1yO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihyKTtcclxuICAgICAgICB9IHJldHVybiBuZXcgQmlnSW50ZWdlcihyLCBzaWduKTtcclxuICAgIH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpO1xyXG4gICAgICAgIGlmICh0aGlzLnNpZ24gIT09IG4uc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQobi5uZWdhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhID0gdGhpcy52YWx1ZSwgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbClcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwoYSwgTWF0aC5hYnMoYiksIHRoaXMuc2lnbik7XHJcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0QW55KGEsIGIsIHRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubWludXMgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmIChhIDwgMCAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChuLm5lZ2F0ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIoYSAtIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VidHJhY3RTbWFsbChiLCBNYXRoLmFicyhhKSwgYSA+PSAwKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm1pbnVzID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHRoaXMudmFsdWUsICF0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzaWduID0gdGhpcy5zaWduO1xyXG4gICAgICAgIHZhciBzbWFsbCA9IG5ldyBTbWFsbEludGVnZXIoLXRoaXMudmFsdWUpO1xyXG4gICAgICAgIHNtYWxsLnNpZ24gPSAhc2lnbjtcclxuICAgICAgICByZXR1cm4gc21hbGw7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy52YWx1ZSwgZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKE1hdGguYWJzKHRoaXMudmFsdWUpKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlMb25nKGEsIGIpIHtcclxuICAgICAgICB2YXIgYV9sID0gYS5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJfbCA9IGIubGVuZ3RoLFxyXG4gICAgICAgICAgICBsID0gYV9sICsgYl9sLFxyXG4gICAgICAgICAgICByID0gY3JlYXRlQXJyYXkobCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBwcm9kdWN0LCBjYXJyeSwgaSwgYV9pLCBiX2o7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFfbDsgKytpKSB7XHJcbiAgICAgICAgICAgIGFfaSA9IGFbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYl9sOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGJfaiA9IGJbal07XHJcbiAgICAgICAgICAgICAgICBwcm9kdWN0ID0gYV9pICogYl9qICsgcltpICsgal07XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcltpICsgal0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgICAgICAgICAgcltpICsgaiArIDFdICs9IGNhcnJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlTbWFsbChhLCBiKSB7IC8vIGFzc3VtZXMgYSBpcyBhcnJheSwgYiBpcyBudW1iZXIgd2l0aCB8YnwgPCBCQVNFXHJcbiAgICAgICAgdmFyIGwgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgciA9IG5ldyBBcnJheShsKSxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgICAgcHJvZHVjdCwgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHByb2R1Y3QgPSBhW2ldICogYiArIGNhcnJ5O1xyXG4gICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xyXG4gICAgICAgICAgICByW2ldID0gcHJvZHVjdCAtIGNhcnJ5ICogYmFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xyXG4gICAgICAgICAgICByW2krK10gPSBjYXJyeSAlIGJhc2U7XHJcbiAgICAgICAgICAgIGNhcnJ5ID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzaGlmdExlZnQoeCwgbikge1xyXG4gICAgICAgIHZhciByID0gW107XHJcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHIucHVzaCgwKTtcclxuICAgICAgICByZXR1cm4gci5jb25jYXQoeCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlLYXJhdHN1YmEoeCwgeSkge1xyXG4gICAgICAgIHZhciBuID0gTWF0aC5tYXgoeC5sZW5ndGgsIHkubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgaWYgKG4gPD0gMzApIHJldHVybiBtdWx0aXBseUxvbmcoeCwgeSk7XHJcbiAgICAgICAgbiA9IE1hdGguY2VpbChuIC8gMik7XHJcblxyXG4gICAgICAgIHZhciBiID0geC5zbGljZShuKSxcclxuICAgICAgICAgICAgYSA9IHguc2xpY2UoMCwgbiksXHJcbiAgICAgICAgICAgIGQgPSB5LnNsaWNlKG4pLFxyXG4gICAgICAgICAgICBjID0geS5zbGljZSgwLCBuKTtcclxuXHJcbiAgICAgICAgdmFyIGFjID0gbXVsdGlwbHlLYXJhdHN1YmEoYSwgYyksXHJcbiAgICAgICAgICAgIGJkID0gbXVsdGlwbHlLYXJhdHN1YmEoYiwgZCksXHJcbiAgICAgICAgICAgIGFiY2QgPSBtdWx0aXBseUthcmF0c3ViYShhZGRBbnkoYSwgYiksIGFkZEFueShjLCBkKSk7XHJcblxyXG4gICAgICAgIHZhciBwcm9kdWN0ID0gYWRkQW55KGFkZEFueShhYywgc2hpZnRMZWZ0KHN1YnRyYWN0KHN1YnRyYWN0KGFiY2QsIGFjKSwgYmQpLCBuKSksIHNoaWZ0TGVmdChiZCwgMiAqIG4pKTtcclxuICAgICAgICB0cmltKHByb2R1Y3QpO1xyXG4gICAgICAgIHJldHVybiBwcm9kdWN0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIGEgc3VyZmFjZSBmaXQgb2YgYSBncmFwaCBwbG90dGluZyB0aGUgcGVyZm9ybWFuY2UgZGlmZmVyZW5jZVxyXG4gICAgLy8gYmV0d2VlbiBsb25nIG11bHRpcGxpY2F0aW9uIGFuZCBrYXJhdHN1YmEgbXVsdGlwbGljYXRpb24gdmVyc3VzIHRoZSBsZW5ndGhzIG9mIHRoZSB0d28gYXJyYXlzLlxyXG4gICAgZnVuY3Rpb24gdXNlS2FyYXRzdWJhKGwxLCBsMikge1xyXG4gICAgICAgIHJldHVybiAtMC4wMTIgKiBsMSAtIDAuMDEyICogbDIgKyAwLjAwMDAxNSAqIGwxICogbDIgPiAwO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodiksXHJcbiAgICAgICAgICAgIGEgPSB0aGlzLnZhbHVlLCBiID0gbi52YWx1ZSxcclxuICAgICAgICAgICAgc2lnbiA9IHRoaXMuc2lnbiAhPT0gbi5zaWduLFxyXG4gICAgICAgICAgICBhYnM7XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgICAgIGlmIChiID09PSAxKSByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgaWYgKGIgPT09IC0xKSByZXR1cm4gdGhpcy5uZWdhdGUoKTtcclxuICAgICAgICAgICAgYWJzID0gTWF0aC5hYnMoYik7XHJcbiAgICAgICAgICAgIGlmIChhYnMgPCBCQVNFKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobXVsdGlwbHlTbWFsbChhLCBhYnMpLCBzaWduKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gc21hbGxUb0FycmF5KGFicyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1c2VLYXJhdHN1YmEoYS5sZW5ndGgsIGIubGVuZ3RoKSkgLy8gS2FyYXRzdWJhIGlzIG9ubHkgZmFzdGVyIGZvciBjZXJ0YWluIGFycmF5IHNpemVzXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseUthcmF0c3ViYShhLCBiKSwgc2lnbik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5TG9uZyhhLCBiKSwgc2lnbik7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRpbWVzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHlTbWFsbEFuZEFycmF5KGEsIGIsIHNpZ24pIHsgLy8gYSA+PSAwXHJcbiAgICAgICAgaWYgKGEgPCBCQVNFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihtdWx0aXBseVNtYWxsKGIsIGEpLCBzaWduKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKG11bHRpcGx5TG9uZyhiLCBzbWFsbFRvQXJyYXkoYSkpLCBzaWduKTtcclxuICAgIH1cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuX211bHRpcGx5QnlTbWFsbCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UoYS52YWx1ZSAqIHRoaXMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcihhLnZhbHVlICogdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG11bHRpcGx5U21hbGxBbmRBcnJheShNYXRoLmFicyhhLnZhbHVlKSwgc21hbGxUb0FycmF5KE1hdGguYWJzKHRoaXMudmFsdWUpKSwgdGhpcy5zaWduICE9PSBhLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLl9tdWx0aXBseUJ5U21hbGwgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICBpZiAoYS52YWx1ZSA9PT0gMCkgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgICAgIGlmIChhLnZhbHVlID09PSAxKSByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgaWYgKGEudmFsdWUgPT09IC0xKSByZXR1cm4gdGhpcy5uZWdhdGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG11bHRpcGx5U21hbGxBbmRBcnJheShNYXRoLmFicyhhLnZhbHVlKSwgdGhpcy52YWx1ZSwgdGhpcy5zaWduICE9PSBhLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBwYXJzZVZhbHVlKHYpLl9tdWx0aXBseUJ5U21hbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS50aW1lcyA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4gICAgZnVuY3Rpb24gc3F1YXJlKGEpIHtcclxuICAgICAgICB2YXIgbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gY3JlYXRlQXJyYXkobCArIGwpLFxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRSxcclxuICAgICAgICAgICAgcHJvZHVjdCwgY2FycnksIGksIGFfaSwgYV9qO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgYV9pID0gYVtpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGFfaiA9IGFbal07XHJcbiAgICAgICAgICAgICAgICBwcm9kdWN0ID0gYV9pICogYV9qICsgcltpICsgal07XHJcbiAgICAgICAgICAgICAgICBjYXJyeSA9IE1hdGguZmxvb3IocHJvZHVjdCAvIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcltpICsgal0gPSBwcm9kdWN0IC0gY2FycnkgKiBiYXNlO1xyXG4gICAgICAgICAgICAgICAgcltpICsgaiArIDFdICs9IGNhcnJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaW0ocik7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihzcXVhcmUodGhpcy52YWx1ZSksIGZhbHNlKTtcclxuICAgIH07XHJcblxyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSAqIHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGlzUHJlY2lzZSh2YWx1ZSkpIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoc3F1YXJlKHNtYWxsVG9BcnJheShNYXRoLmFicyh0aGlzLnZhbHVlKSkpLCBmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGRpdk1vZDEoYSwgYikgeyAvLyBMZWZ0IG92ZXIgZnJvbSBwcmV2aW91cyB2ZXJzaW9uLiBQZXJmb3JtcyBmYXN0ZXIgdGhhbiBkaXZNb2QyIG9uIHNtYWxsZXIgaW5wdXQgc2l6ZXMuXHJcbiAgICAgICAgdmFyIGFfbCA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICBiX2wgPSBiLmxlbmd0aCxcclxuICAgICAgICAgICAgYmFzZSA9IEJBU0UsXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGIubGVuZ3RoKSxcclxuICAgICAgICAgICAgZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0ID0gYltiX2wgLSAxXSxcclxuICAgICAgICAgICAgLy8gbm9ybWFsaXphdGlvblxyXG4gICAgICAgICAgICBsYW1iZGEgPSBNYXRoLmNlaWwoYmFzZSAvICgyICogZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0KSksXHJcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IG11bHRpcGx5U21hbGwoYSwgbGFtYmRhKSxcclxuICAgICAgICAgICAgZGl2aXNvciA9IG11bHRpcGx5U21hbGwoYiwgbGFtYmRhKSxcclxuICAgICAgICAgICAgcXVvdGllbnREaWdpdCwgc2hpZnQsIGNhcnJ5LCBib3Jyb3csIGksIGwsIHE7XHJcbiAgICAgICAgaWYgKHJlbWFpbmRlci5sZW5ndGggPD0gYV9sKSByZW1haW5kZXIucHVzaCgwKTtcclxuICAgICAgICBkaXZpc29yLnB1c2goMCk7XHJcbiAgICAgICAgZGl2aXNvck1vc3RTaWduaWZpY2FudERpZ2l0ID0gZGl2aXNvcltiX2wgLSAxXTtcclxuICAgICAgICBmb3IgKHNoaWZ0ID0gYV9sIC0gYl9sOyBzaGlmdCA+PSAwOyBzaGlmdC0tKSB7XHJcbiAgICAgICAgICAgIHF1b3RpZW50RGlnaXQgPSBiYXNlIC0gMTtcclxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlcltzaGlmdCArIGJfbF0gIT09IGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCkge1xyXG4gICAgICAgICAgICAgIHF1b3RpZW50RGlnaXQgPSBNYXRoLmZsb29yKChyZW1haW5kZXJbc2hpZnQgKyBiX2xdICogYmFzZSArIHJlbWFpbmRlcltzaGlmdCArIGJfbCAtIDFdKSAvIGRpdmlzb3JNb3N0U2lnbmlmaWNhbnREaWdpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcXVvdGllbnREaWdpdCA8PSBiYXNlIC0gMVxyXG4gICAgICAgICAgICBjYXJyeSA9IDA7XHJcbiAgICAgICAgICAgIGJvcnJvdyA9IDA7XHJcbiAgICAgICAgICAgIGwgPSBkaXZpc29yLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2FycnkgKz0gcXVvdGllbnREaWdpdCAqIGRpdmlzb3JbaV07XHJcbiAgICAgICAgICAgICAgICBxID0gTWF0aC5mbG9vcihjYXJyeSAvIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgYm9ycm93ICs9IHJlbWFpbmRlcltzaGlmdCArIGldIC0gKGNhcnJ5IC0gcSAqIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSBxO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvcnJvdyA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGJvcnJvdyArIGJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9ycm93ID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gYm9ycm93O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcnJvdyA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKGJvcnJvdyAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcXVvdGllbnREaWdpdCAtPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FycnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ICs9IHJlbWFpbmRlcltzaGlmdCArIGldIC0gYmFzZSArIGRpdmlzb3JbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcnJ5IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXJbc2hpZnQgKyBpXSA9IGNhcnJ5ICsgYmFzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FycnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmRlcltzaGlmdCArIGldID0gY2Fycnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBib3Jyb3cgKz0gY2Fycnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0W3NoaWZ0XSA9IHF1b3RpZW50RGlnaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRlbm9ybWFsaXphdGlvblxyXG4gICAgICAgIHJlbWFpbmRlciA9IGRpdk1vZFNtYWxsKHJlbWFpbmRlciwgbGFtYmRhKVswXTtcclxuICAgICAgICByZXR1cm4gW2FycmF5VG9TbWFsbChyZXN1bHQpLCBhcnJheVRvU21hbGwocmVtYWluZGVyKV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2TW9kMihhLCBiKSB7IC8vIEltcGxlbWVudGF0aW9uIGlkZWEgc2hhbWVsZXNzbHkgc3RvbGVuIGZyb20gU2lsZW50IE1hdHQncyBsaWJyYXJ5IGh0dHA6Ly9zaWxlbnRtYXR0LmNvbS9iaWdpbnRlZ2VyL1xyXG4gICAgICAgIC8vIFBlcmZvcm1zIGZhc3RlciB0aGFuIGRpdk1vZDEgb24gbGFyZ2VyIGlucHV0IHNpemVzLlxyXG4gICAgICAgIHZhciBhX2wgPSBhLmxlbmd0aCxcclxuICAgICAgICAgICAgYl9sID0gYi5sZW5ndGgsXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxyXG4gICAgICAgICAgICBwYXJ0ID0gW10sXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBndWVzcywgeGxlbiwgaGlnaHgsIGhpZ2h5LCBjaGVjaztcclxuICAgICAgICB3aGlsZSAoYV9sKSB7XHJcbiAgICAgICAgICAgIHBhcnQudW5zaGlmdChhWy0tYV9sXSk7XHJcbiAgICAgICAgICAgIHRyaW0ocGFydCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJlQWJzKHBhcnQsIGIpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goMCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4bGVuID0gcGFydC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGhpZ2h4ID0gcGFydFt4bGVuIC0gMV0gKiBiYXNlICsgcGFydFt4bGVuIC0gMl07XHJcbiAgICAgICAgICAgIGhpZ2h5ID0gYltiX2wgLSAxXSAqIGJhc2UgKyBiW2JfbCAtIDJdO1xyXG4gICAgICAgICAgICBpZiAoeGxlbiA+IGJfbCkge1xyXG4gICAgICAgICAgICAgICAgaGlnaHggPSAoaGlnaHggKyAxKSAqIGJhc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3Vlc3MgPSBNYXRoLmNlaWwoaGlnaHggLyBoaWdoeSk7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrID0gbXVsdGlwbHlTbWFsbChiLCBndWVzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZUFicyhjaGVjaywgcGFydCkgPD0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBndWVzcy0tO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChndWVzcyk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGd1ZXNzKTtcclxuICAgICAgICAgICAgcGFydCA9IHN1YnRyYWN0KHBhcnQsIGNoZWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnJldmVyc2UoKTtcclxuICAgICAgICByZXR1cm4gW2FycmF5VG9TbWFsbChyZXN1bHQpLCBhcnJheVRvU21hbGwocGFydCldO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRpdk1vZFNtYWxsKHZhbHVlLCBsYW1iZGEpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxyXG4gICAgICAgICAgICBxdW90aWVudCA9IGNyZWF0ZUFycmF5KGxlbmd0aCksXHJcbiAgICAgICAgICAgIGJhc2UgPSBCQVNFLFxyXG4gICAgICAgICAgICBpLCBxLCByZW1haW5kZXIsIGRpdmlzb3I7XHJcbiAgICAgICAgcmVtYWluZGVyID0gMDtcclxuICAgICAgICBmb3IgKGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICBkaXZpc29yID0gcmVtYWluZGVyICogYmFzZSArIHZhbHVlW2ldO1xyXG4gICAgICAgICAgICBxID0gdHJ1bmNhdGUoZGl2aXNvciAvIGxhbWJkYSk7XHJcbiAgICAgICAgICAgIHJlbWFpbmRlciA9IGRpdmlzb3IgLSBxICogbGFtYmRhO1xyXG4gICAgICAgICAgICBxdW90aWVudFtpXSA9IHEgfCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW3F1b3RpZW50LCByZW1haW5kZXIgfCAwXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkaXZNb2RBbnkoc2VsZiwgdikge1xyXG4gICAgICAgIHZhciB2YWx1ZSwgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIGEgPSBzZWxmLnZhbHVlLCBiID0gbi52YWx1ZTtcclxuICAgICAgICB2YXIgcXVvdGllbnQ7XHJcbiAgICAgICAgaWYgKGIgPT09IDApIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkaXZpZGUgYnkgemVyb1wiKTtcclxuICAgICAgICBpZiAoc2VsZi5pc1NtYWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFNtYWxsSW50ZWdlcih0cnVuY2F0ZShhIC8gYikpLCBuZXcgU21hbGxJbnRlZ2VyKGEgJSBiKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFtJbnRlZ2VyWzBdLCBzZWxmXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4uaXNTbWFsbCkge1xyXG4gICAgICAgICAgICBpZiAoYiA9PT0gMSkgcmV0dXJuIFtzZWxmLCBJbnRlZ2VyWzBdXTtcclxuICAgICAgICAgICAgaWYgKGIgPT0gLTEpIHJldHVybiBbc2VsZi5uZWdhdGUoKSwgSW50ZWdlclswXV07XHJcbiAgICAgICAgICAgIHZhciBhYnMgPSBNYXRoLmFicyhiKTtcclxuICAgICAgICAgICAgaWYgKGFicyA8IEJBU0UpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGl2TW9kU21hbGwoYSwgYWJzKTtcclxuICAgICAgICAgICAgICAgIHF1b3RpZW50ID0gYXJyYXlUb1NtYWxsKHZhbHVlWzBdKTtcclxuICAgICAgICAgICAgICAgIHZhciByZW1haW5kZXIgPSB2YWx1ZVsxXTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNpZ24pIHJlbWFpbmRlciA9IC1yZW1haW5kZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHF1b3RpZW50ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuc2lnbiAhPT0gbi5zaWduKSBxdW90aWVudCA9IC1xdW90aWVudDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBTbWFsbEludGVnZXIocXVvdGllbnQpLCBuZXcgU21hbGxJbnRlZ2VyKHJlbWFpbmRlcildO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtuZXcgQmlnSW50ZWdlcihxdW90aWVudCwgc2VsZi5zaWduICE9PSBuLnNpZ24pLCBuZXcgU21hbGxJbnRlZ2VyKHJlbWFpbmRlcildO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGIgPSBzbWFsbFRvQXJyYXkoYWJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbXBhcmlzb24gPSBjb21wYXJlQWJzKGEsIGIpO1xyXG4gICAgICAgIGlmIChjb21wYXJpc29uID09PSAtMSkgcmV0dXJuIFtJbnRlZ2VyWzBdLCBzZWxmXTtcclxuICAgICAgICBpZiAoY29tcGFyaXNvbiA9PT0gMCkgcmV0dXJuIFtJbnRlZ2VyW3NlbGYuc2lnbiA9PT0gbi5zaWduID8gMSA6IC0xXSwgSW50ZWdlclswXV07XHJcblxyXG4gICAgICAgIC8vIGRpdk1vZDEgaXMgZmFzdGVyIG9uIHNtYWxsZXIgaW5wdXQgc2l6ZXNcclxuICAgICAgICBpZiAoYS5sZW5ndGggKyBiLmxlbmd0aCA8PSAyMDApXHJcbiAgICAgICAgICAgIHZhbHVlID0gZGl2TW9kMShhLCBiKTtcclxuICAgICAgICBlbHNlIHZhbHVlID0gZGl2TW9kMihhLCBiKTtcclxuXHJcbiAgICAgICAgcXVvdGllbnQgPSB2YWx1ZVswXTtcclxuICAgICAgICB2YXIgcVNpZ24gPSBzZWxmLnNpZ24gIT09IG4uc2lnbixcclxuICAgICAgICAgICAgbW9kID0gdmFsdWVbMV0sXHJcbiAgICAgICAgICAgIG1TaWduID0gc2VsZi5zaWduO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcXVvdGllbnQgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgaWYgKHFTaWduKSBxdW90aWVudCA9IC1xdW90aWVudDtcclxuICAgICAgICAgICAgcXVvdGllbnQgPSBuZXcgU21hbGxJbnRlZ2VyKHF1b3RpZW50KTtcclxuICAgICAgICB9IGVsc2UgcXVvdGllbnQgPSBuZXcgQmlnSW50ZWdlcihxdW90aWVudCwgcVNpZ24pO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbW9kID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGlmIChtU2lnbikgbW9kID0gLW1vZDtcclxuICAgICAgICAgICAgbW9kID0gbmV3IFNtYWxsSW50ZWdlcihtb2QpO1xyXG4gICAgICAgIH0gZWxzZSBtb2QgPSBuZXcgQmlnSW50ZWdlcihtb2QsIG1TaWduKTtcclxuICAgICAgICByZXR1cm4gW3F1b3RpZW50LCBtb2RdO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRpdk1vZEFueSh0aGlzLCB2KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBxdW90aWVudDogcmVzdWx0WzBdLFxyXG4gICAgICAgICAgICByZW1haW5kZXI6IHJlc3VsdFsxXVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5kaXZtb2Q7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gZGl2TW9kQW55KHRoaXMsIHYpWzBdO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUub3ZlciA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZGl2aWRlID0gQmlnSW50ZWdlci5wcm90b3R5cGUub3ZlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiBkaXZNb2RBbnkodGhpcywgdilbMV07XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5yZW1haW5kZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLm1vZCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnJlbWFpbmRlciA9IEJpZ0ludGVnZXIucHJvdG90eXBlLm1vZDtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlLFxyXG4gICAgICAgICAgICB2YWx1ZSwgeCwgeTtcclxuICAgICAgICBpZiAoYiA9PT0gMCkgcmV0dXJuIEludGVnZXJbMV07XHJcbiAgICAgICAgaWYgKGEgPT09IDApIHJldHVybiBJbnRlZ2VyWzBdO1xyXG4gICAgICAgIGlmIChhID09PSAxKSByZXR1cm4gSW50ZWdlclsxXTtcclxuICAgICAgICBpZiAoYSA9PT0gLTEpIHJldHVybiBuLmlzRXZlbigpID8gSW50ZWdlclsxXSA6IEludGVnZXJbLTFdO1xyXG4gICAgICAgIGlmIChuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIEludGVnZXJbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbi5pc1NtYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZXhwb25lbnQgXCIgKyBuLnRvU3RyaW5nKCkgKyBcIiBpcyB0b28gbGFyZ2UuXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgaWYgKGlzUHJlY2lzZSh2YWx1ZSA9IE1hdGgucG93KGEsIGIpKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHRydW5jYXRlKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHggPSB0aGlzO1xyXG4gICAgICAgIHkgPSBJbnRlZ2VyWzFdO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChiICYgMSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICAgICAgICAtLWI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGIgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBiIC89IDI7XHJcbiAgICAgICAgICAgIHggPSB4LnNxdWFyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnBvdyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnBvdztcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RQb3cgPSBmdW5jdGlvbiAoZXhwLCBtb2QpIHtcclxuICAgICAgICBleHAgPSBwYXJzZVZhbHVlKGV4cCk7XHJcbiAgICAgICAgbW9kID0gcGFyc2VWYWx1ZShtb2QpO1xyXG4gICAgICAgIGlmIChtb2QuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0YWtlIG1vZFBvdyB3aXRoIG1vZHVsdXMgMFwiKTtcclxuICAgICAgICB2YXIgciA9IEludGVnZXJbMV0sXHJcbiAgICAgICAgICAgIGJhc2UgPSB0aGlzLm1vZChtb2QpO1xyXG4gICAgICAgIHdoaWxlIChleHAuaXNQb3NpdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlLmlzWmVybygpKSByZXR1cm4gSW50ZWdlclswXTtcclxuICAgICAgICAgICAgaWYgKGV4cC5pc09kZCgpKSByID0gci5tdWx0aXBseShiYXNlKS5tb2QobW9kKTtcclxuICAgICAgICAgICAgZXhwID0gZXhwLmRpdmlkZSgyKTtcclxuICAgICAgICAgICAgYmFzZSA9IGJhc2Uuc3F1YXJlKCkubW9kKG1vZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kUG93ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kUG93O1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBYnMoYSwgYikge1xyXG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoID4gYi5sZW5ndGggPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmNvbXBhcmVBYnMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHJldHVybiAxO1xyXG4gICAgICAgIHJldHVybiBjb21wYXJlQWJzKGEsIGIpO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZUFicyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gTWF0aC5hYnModGhpcy52YWx1ZSksXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgYiA9IE1hdGguYWJzKGIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBhYm91dCBjb21wYXJpc29uIHdpdGggSW5maW5pdHk6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BldGVyb2xzb24vQmlnSW50ZWdlci5qcy9pc3N1ZXMvNjFcclxuICAgICAgICBpZiAodiA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodiA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIG4gPSBwYXJzZVZhbHVlKHYpLFxyXG4gICAgICAgICAgICBhID0gdGhpcy52YWx1ZSxcclxuICAgICAgICAgICAgYiA9IG4udmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbiAhPT0gbi5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuLnNpZ24gPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbiA/IC0xIDogMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVBYnMoYSwgYikgKiAodGhpcy5zaWduID8gLTEgOiAxKTtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHYgPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHYgPT09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBuID0gcGFyc2VWYWx1ZSh2KSxcclxuICAgICAgICAgICAgYSA9IHRoaXMudmFsdWUsXHJcbiAgICAgICAgICAgIGIgPSBuLnZhbHVlO1xyXG4gICAgICAgIGlmIChuLmlzU21hbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEgPCAwICE9PSBuLnNpZ24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSA8IDAgPyAxIDogLTE7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpID09PSAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmVxdWFscyA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh2KSAhPT0gMDtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLm5lcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubmVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPiAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3QgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmdyZWF0ZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ndCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmdyZWF0ZXI7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpIDwgMDtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmx0ID0gU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXNzZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5sdCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3NlcjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ncmVhdGVyT3JFcXVhbHMgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodikgPj0gMDtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmdlcSA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ2VxID0gQmlnSW50ZWdlci5wcm90b3R5cGUuZ3JlYXRlck9yRXF1YWxzO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHYpIDw9IDA7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5sZXEgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLmxlc3Nlck9yRXF1YWxzID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVxID0gQmlnSW50ZWdlci5wcm90b3R5cGUubGVzc2VyT3JFcXVhbHM7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZVswXSAmIDEpID09PSAwO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09PSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMudmFsdWVbMF0gJiAxKSA9PT0gMTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZSAmIDEpID09PSAxO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5zaWduO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA+IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbjtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPCAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1VuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuaXNVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnZhbHVlKSA9PT0gMTtcclxuICAgIH07XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gMDtcclxuICAgIH07XHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5ID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB2YXIgbiA9IHBhcnNlVmFsdWUodik7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gbi52YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUgPT09IDApIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodmFsdWUgPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMikgcmV0dXJuIHRoaXMuaXNFdmVuKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kKG4pLmVxdWFscyhJbnRlZ2VyWzBdKTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzRGl2aXNpYmxlQnkgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc0RpdmlzaWJsZUJ5O1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzQmFzaWNQcmltZSh2KSB7XHJcbiAgICAgICAgdmFyIG4gPSB2LmFicygpO1xyXG4gICAgICAgIGlmIChuLmlzVW5pdCgpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKG4uZXF1YWxzKDIpIHx8IG4uZXF1YWxzKDMpIHx8IG4uZXF1YWxzKDUpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBpZiAobi5pc0V2ZW4oKSB8fCBuLmlzRGl2aXNpYmxlQnkoMykgfHwgbi5pc0RpdmlzaWJsZUJ5KDUpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgaWYgKG4ubGVzc2VyKDI1KSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgLy8gd2UgZG9uJ3Qga25vdyBpZiBpdCdzIHByaW1lOiBsZXQgdGhlIG90aGVyIGZ1bmN0aW9ucyBmaWd1cmUgaXQgb3V0XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaXNQcmltZSA9IGlzQmFzaWNQcmltZSh0aGlzKTtcclxuICAgICAgICBpZiAoaXNQcmltZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gaXNQcmltZTtcclxuICAgICAgICB2YXIgbiA9IHRoaXMuYWJzKCksXHJcbiAgICAgICAgICAgIG5QcmV2ID0gbi5wcmV2KCk7XHJcbiAgICAgICAgdmFyIGEgPSBbMiwgMywgNSwgNywgMTEsIDEzLCAxNywgMTldLFxyXG4gICAgICAgICAgICBiID0gblByZXYsXHJcbiAgICAgICAgICAgIGQsIHQsIGksIHg7XHJcbiAgICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIGIgPSBiLmRpdmlkZSgyKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB4ID0gYmlnSW50KGFbaV0pLm1vZFBvdyhiLCBuKTtcclxuICAgICAgICAgICAgaWYgKHguZXF1YWxzKEludGVnZXJbMV0pIHx8IHguZXF1YWxzKG5QcmV2KSkgY29udGludWU7XHJcbiAgICAgICAgICAgIGZvciAodCA9IHRydWUsIGQgPSBiOyB0ICYmIGQubGVzc2VyKG5QcmV2KSA7IGQgPSBkLm11bHRpcGx5KDIpKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0geC5zcXVhcmUoKS5tb2Qobik7XHJcbiAgICAgICAgICAgICAgICBpZiAoeC5lcXVhbHMoblByZXYpKSB0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5pc1ByaW1lID0gQmlnSW50ZWdlci5wcm90b3R5cGUuaXNQcmltZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5pc1Byb2JhYmxlUHJpbWUgPSBmdW5jdGlvbiAoaXRlcmF0aW9ucykge1xyXG4gICAgICAgIHZhciBpc1ByaW1lID0gaXNCYXNpY1ByaW1lKHRoaXMpO1xyXG4gICAgICAgIGlmIChpc1ByaW1lICE9PSB1bmRlZmluZWQpIHJldHVybiBpc1ByaW1lO1xyXG4gICAgICAgIHZhciBuID0gdGhpcy5hYnMoKTtcclxuICAgICAgICB2YXIgdCA9IGl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCA/IDUgOiBpdGVyYXRpb25zO1xyXG4gICAgICAgIC8vIHVzZSB0aGUgRmVybWF0IHByaW1hbGl0eSB0ZXN0XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0OyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBiaWdJbnQucmFuZEJldHdlZW4oMiwgbi5taW51cygyKSk7XHJcbiAgICAgICAgICAgIGlmICghYS5tb2RQb3cobi5wcmV2KCksIG4pLmlzVW5pdCgpKSByZXR1cm4gZmFsc2U7IC8vIGRlZmluaXRlbHkgY29tcG9zaXRlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBsYXJnZSBjaGFuY2Ugb2YgYmVpbmcgcHJpbWVcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZSA9IEJpZ0ludGVnZXIucHJvdG90eXBlLmlzUHJvYmFibGVQcmltZTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5tb2RJbnYgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHZhciB0ID0gYmlnSW50Lnplcm8sIG5ld1QgPSBiaWdJbnQub25lLCByID0gcGFyc2VWYWx1ZShuKSwgbmV3UiA9IHRoaXMuYWJzKCksIHEsIGxhc3RULCBsYXN0UjtcclxuICAgICAgICB3aGlsZSAoIW5ld1IuZXF1YWxzKGJpZ0ludC56ZXJvKSkge1xyXG4gICAgICAgICAgICBxID0gci5kaXZpZGUobmV3Uik7XHJcbiAgICAgICAgICAgIGxhc3RUID0gdDtcclxuICAgICAgICAgICAgbGFzdFIgPSByO1xyXG4gICAgICAgICAgICB0ID0gbmV3VDtcclxuICAgICAgICAgICAgciA9IG5ld1I7XHJcbiAgICAgICAgICAgIG5ld1QgPSBsYXN0VC5zdWJ0cmFjdChxLm11bHRpcGx5KG5ld1QpKTtcclxuICAgICAgICAgICAgbmV3UiA9IGxhc3RSLnN1YnRyYWN0KHEubXVsdGlwbHkobmV3UikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXIuZXF1YWxzKDEpKSB0aHJvdyBuZXcgRXJyb3IodGhpcy50b1N0cmluZygpICsgXCIgYW5kIFwiICsgbi50b1N0cmluZygpICsgXCIgYXJlIG5vdCBjby1wcmltZVwiKTtcclxuICAgICAgICBpZiAodC5jb21wYXJlKDApID09PSAtMSkge1xyXG4gICAgICAgICAgICB0ID0gdC5hZGQobik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdC5uZWdhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubW9kSW52ID0gQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52O1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5zaWduKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdWJ0cmFjdFNtYWxsKHZhbHVlLCAxLCB0aGlzLnNpZ24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwodmFsdWUsIDEpLCB0aGlzLnNpZ24pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWx1ZSArIDEgPCBNQVhfSU5UKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSArIDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihNQVhfSU5UX0FSUiwgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuc2lnbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIoYWRkU21hbGwodmFsdWUsIDEpLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1YnRyYWN0U21hbGwodmFsdWUsIDEsIHRoaXMuc2lnbik7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlIC0gMSA+IC1NQVhfSU5UKSByZXR1cm4gbmV3IFNtYWxsSW50ZWdlcih2YWx1ZSAtIDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihNQVhfSU5UX0FSUiwgdHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBwb3dlcnNPZlR3byA9IFsxXTtcclxuICAgIHdoaWxlICgyICogcG93ZXJzT2ZUd29bcG93ZXJzT2ZUd28ubGVuZ3RoIC0gMV0gPD0gQkFTRSkgcG93ZXJzT2ZUd28ucHVzaCgyICogcG93ZXJzT2ZUd29bcG93ZXJzT2ZUd28ubGVuZ3RoIC0gMV0pO1xyXG4gICAgdmFyIHBvd2VyczJMZW5ndGggPSBwb3dlcnNPZlR3by5sZW5ndGgsIGhpZ2hlc3RQb3dlcjIgPSBwb3dlcnNPZlR3b1twb3dlcnMyTGVuZ3RoIC0gMV07XHJcblxyXG4gICAgZnVuY3Rpb24gc2hpZnRfaXNTbWFsbChuKSB7XHJcbiAgICAgICAgcmV0dXJuICgodHlwZW9mIG4gPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIG4gPT09IFwic3RyaW5nXCIpICYmICtNYXRoLmFicyhuKSA8PSBCQVNFKSB8fFxyXG4gICAgICAgICAgICAobiBpbnN0YW5jZW9mIEJpZ0ludGVnZXIgJiYgbi52YWx1ZS5sZW5ndGggPD0gMSk7XHJcbiAgICB9XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICBpZiAoIXNoaWZ0X2lzU21hbGwobikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFN0cmluZyhuKSArIFwiIGlzIHRvbyBsYXJnZSBmb3Igc2hpZnRpbmcuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gK247XHJcbiAgICAgICAgaWYgKG4gPCAwKSByZXR1cm4gdGhpcy5zaGlmdFJpZ2h0KC1uKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcztcclxuICAgICAgICB3aGlsZSAobiA+PSBwb3dlcnMyTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWx0aXBseShoaWdoZXN0UG93ZXIyKTtcclxuICAgICAgICAgICAgbiAtPSBwb3dlcnMyTGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tdWx0aXBseShwb3dlcnNPZlR3b1tuXSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdmFyIHJlbVF1bztcclxuICAgICAgICBpZiAoIXNoaWZ0X2lzU21hbGwobikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFN0cmluZyhuKSArIFwiIGlzIHRvbyBsYXJnZSBmb3Igc2hpZnRpbmcuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gK247XHJcbiAgICAgICAgaWYgKG4gPCAwKSByZXR1cm4gdGhpcy5zaGlmdExlZnQoLW4pO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xyXG4gICAgICAgIHdoaWxlIChuID49IHBvd2VyczJMZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5pc1plcm8oKSkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgcmVtUXVvID0gZGl2TW9kQW55KHJlc3VsdCwgaGlnaGVzdFBvd2VyMik7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlbVF1b1sxXS5pc05lZ2F0aXZlKCkgPyByZW1RdW9bMF0ucHJldigpIDogcmVtUXVvWzBdO1xyXG4gICAgICAgICAgICBuIC09IHBvd2VyczJMZW5ndGggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1RdW8gPSBkaXZNb2RBbnkocmVzdWx0LCBwb3dlcnNPZlR3b1tuXSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbVF1b1sxXS5pc05lZ2F0aXZlKCkgPyByZW1RdW9bMF0ucHJldigpIDogcmVtUXVvWzBdO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuc2hpZnRSaWdodCA9IEJpZ0ludGVnZXIucHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4gICAgZnVuY3Rpb24gYml0d2lzZSh4LCB5LCBmbikge1xyXG4gICAgICAgIHkgPSBwYXJzZVZhbHVlKHkpO1xyXG4gICAgICAgIHZhciB4U2lnbiA9IHguaXNOZWdhdGl2ZSgpLCB5U2lnbiA9IHkuaXNOZWdhdGl2ZSgpO1xyXG4gICAgICAgIHZhciB4UmVtID0geFNpZ24gPyB4Lm5vdCgpIDogeCxcclxuICAgICAgICAgICAgeVJlbSA9IHlTaWduID8geS5ub3QoKSA6IHk7XHJcbiAgICAgICAgdmFyIHhEaWdpdCA9IDAsIHlEaWdpdCA9IDA7XHJcbiAgICAgICAgdmFyIHhEaXZNb2QgPSBudWxsLCB5RGl2TW9kID0gbnVsbDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgd2hpbGUgKCF4UmVtLmlzWmVybygpIHx8ICF5UmVtLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIHhEaXZNb2QgPSBkaXZNb2RBbnkoeFJlbSwgaGlnaGVzdFBvd2VyMik7XHJcbiAgICAgICAgICAgIHhEaWdpdCA9IHhEaXZNb2RbMV0udG9KU051bWJlcigpO1xyXG4gICAgICAgICAgICBpZiAoeFNpZ24pIHtcclxuICAgICAgICAgICAgICAgIHhEaWdpdCA9IGhpZ2hlc3RQb3dlcjIgLSAxIC0geERpZ2l0OyAvLyB0d28ncyBjb21wbGVtZW50IGZvciBuZWdhdGl2ZSBudW1iZXJzXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHlEaXZNb2QgPSBkaXZNb2RBbnkoeVJlbSwgaGlnaGVzdFBvd2VyMik7XHJcbiAgICAgICAgICAgIHlEaWdpdCA9IHlEaXZNb2RbMV0udG9KU051bWJlcigpO1xyXG4gICAgICAgICAgICBpZiAoeVNpZ24pIHtcclxuICAgICAgICAgICAgICAgIHlEaWdpdCA9IGhpZ2hlc3RQb3dlcjIgLSAxIC0geURpZ2l0OyAvLyB0d28ncyBjb21wbGVtZW50IGZvciBuZWdhdGl2ZSBudW1iZXJzXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHhSZW0gPSB4RGl2TW9kWzBdO1xyXG4gICAgICAgICAgICB5UmVtID0geURpdk1vZFswXTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZm4oeERpZ2l0LCB5RGlnaXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN1bSA9IGZuKHhTaWduID8gMSA6IDAsIHlTaWduID8gMSA6IDApICE9PSAwID8gYmlnSW50KC0xKSA6IGJpZ0ludCgwKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcbiAgICAgICAgICAgIHN1bSA9IHN1bS5tdWx0aXBseShoaWdoZXN0UG93ZXIyKS5hZGQoYmlnSW50KHJlc3VsdFtpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKS5wcmV2KCk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS5ub3QgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5ub3Q7XHJcblxyXG4gICAgQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICByZXR1cm4gYml0d2lzZSh0aGlzLCBuLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSAmIGI7IH0pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUuYW5kID0gQmlnSW50ZWdlci5wcm90b3R5cGUuYW5kO1xyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICByZXR1cm4gYml0d2lzZSh0aGlzLCBuLCBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSB8IGI7IH0pO1xyXG4gICAgfTtcclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUub3IgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS5vcjtcclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHJldHVybiBiaXR3aXNlKHRoaXMsIG4sIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIF4gYjsgfSk7XHJcbiAgICB9O1xyXG4gICAgU21hbGxJbnRlZ2VyLnByb3RvdHlwZS54b3IgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS54b3I7XHJcblxyXG4gICAgdmFyIExPQk1BU0tfSSA9IDEgPDwgMzAsIExPQk1BU0tfQkkgPSAoQkFTRSAmIC1CQVNFKSAqIChCQVNFICYgLUJBU0UpIHwgTE9CTUFTS19JO1xyXG4gICAgZnVuY3Rpb24gcm91Z2hMT0IobikgeyAvLyBnZXQgbG93ZXN0T25lQml0IChyb3VnaClcclxuICAgICAgICAvLyBTbWFsbEludGVnZXI6IHJldHVybiBNaW4obG93ZXN0T25lQml0KG4pLCAxIDw8IDMwKVxyXG4gICAgICAgIC8vIEJpZ0ludGVnZXI6IHJldHVybiBNaW4obG93ZXN0T25lQml0KG4pLCAxIDw8IDE0KSBbQkFTRT0xZTddXHJcbiAgICAgICAgdmFyIHYgPSBuLnZhbHVlLCB4ID0gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyB2IHwgTE9CTUFTS19JIDogdlswXSArIHZbMV0gKiBCQVNFIHwgTE9CTUFTS19CSTtcclxuICAgICAgICByZXR1cm4geCAmIC14O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1heChhLCBiKSB7XHJcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSk7XHJcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYik7XHJcbiAgICAgICAgcmV0dXJuIGEuZ3JlYXRlcihiKSA/IGEgOiBiO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWluKGEsIGIpIHtcclxuICAgICAgICBhID0gcGFyc2VWYWx1ZShhKTtcclxuICAgICAgICBiID0gcGFyc2VWYWx1ZShiKTtcclxuICAgICAgICByZXR1cm4gYS5sZXNzZXIoYikgPyBhIDogYjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdjZChhLCBiKSB7XHJcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSkuYWJzKCk7XHJcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYikuYWJzKCk7XHJcbiAgICAgICAgaWYgKGEuZXF1YWxzKGIpKSByZXR1cm4gYTtcclxuICAgICAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGI7XHJcbiAgICAgICAgaWYgKGIuaXNaZXJvKCkpIHJldHVybiBhO1xyXG4gICAgICAgIHZhciBjID0gSW50ZWdlclsxXSwgZCwgdDtcclxuICAgICAgICB3aGlsZSAoYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpKSB7XHJcbiAgICAgICAgICAgIGQgPSBNYXRoLm1pbihyb3VnaExPQihhKSwgcm91Z2hMT0IoYikpO1xyXG4gICAgICAgICAgICBhID0gYS5kaXZpZGUoZCk7XHJcbiAgICAgICAgICAgIGIgPSBiLmRpdmlkZShkKTtcclxuICAgICAgICAgICAgYyA9IGMubXVsdGlwbHkoZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XHJcbiAgICAgICAgICAgIGEgPSBhLmRpdmlkZShyb3VnaExPQihhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBiLmRpdmlkZShyb3VnaExPQihiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGEuZ3JlYXRlcihiKSkge1xyXG4gICAgICAgICAgICAgICAgdCA9IGI7IGIgPSBhOyBhID0gdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiID0gYi5zdWJ0cmFjdChhKTtcclxuICAgICAgICB9IHdoaWxlICghYi5pc1plcm8oKSk7XHJcbiAgICAgICAgcmV0dXJuIGMuaXNVbml0KCkgPyBhIDogYS5tdWx0aXBseShjKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGxjbShhLCBiKSB7XHJcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSkuYWJzKCk7XHJcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYikuYWJzKCk7XHJcbiAgICAgICAgcmV0dXJuIGEuZGl2aWRlKGdjZChhLCBiKSkubXVsdGlwbHkoYik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByYW5kQmV0d2VlbihhLCBiKSB7XHJcbiAgICAgICAgYSA9IHBhcnNlVmFsdWUoYSk7XHJcbiAgICAgICAgYiA9IHBhcnNlVmFsdWUoYik7XHJcbiAgICAgICAgdmFyIGxvdyA9IG1pbihhLCBiKSwgaGlnaCA9IG1heChhLCBiKTtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBoaWdoLnN1YnRyYWN0KGxvdykuYWRkKDEpO1xyXG4gICAgICAgIGlmIChyYW5nZS5pc1NtYWxsKSByZXR1cm4gbG93LmFkZChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByYW5nZSkpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSByYW5nZS52YWx1ZS5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgcmVzdHJpY3RlZCA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIHRvcCA9IHJlc3RyaWN0ZWQgPyByYW5nZS52YWx1ZVtpXSA6IEJBU0U7XHJcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IHRydW5jYXRlKE1hdGgucmFuZG9tKCkgKiB0b3ApO1xyXG4gICAgICAgICAgICByZXN1bHQudW5zaGlmdChkaWdpdCk7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdCA8IHRvcCkgcmVzdHJpY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHQgPSBhcnJheVRvU21hbGwocmVzdWx0KTtcclxuICAgICAgICByZXR1cm4gbG93LmFkZCh0eXBlb2YgcmVzdWx0ID09PSBcIm51bWJlclwiID8gbmV3IFNtYWxsSW50ZWdlcihyZXN1bHQpIDogbmV3IEJpZ0ludGVnZXIocmVzdWx0LCBmYWxzZSkpO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhcnNlQmFzZSA9IGZ1bmN0aW9uICh0ZXh0LCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xyXG5cdFx0dmFyIGk7XHJcblx0XHR2YXIgYWJzQmFzZSA9IE1hdGguYWJzKGJhc2UpO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBjID0gdGV4dFtpXS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRpZihjID09PSBcIi1cIikgY29udGludWU7XHJcblx0XHRcdGlmKC9bYS16MC05XS8udGVzdChjKSkge1xyXG5cdFx0XHQgICAgaWYoL1swLTldLy50ZXN0KGMpICYmICtjID49IGFic0Jhc2UpIHtcclxuXHRcdFx0XHRcdGlmKGMgPT09IFwiMVwiICYmIGFic0Jhc2UgPT09IDEpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjICsgXCIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW4gYmFzZSBcIiArIGJhc2UgKyBcIi5cIik7XHJcblx0XHRcdFx0fSBlbHNlIGlmKGMuY2hhckNvZGVBdCgwKSAtIDg3ID49IGFic0Jhc2UpIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihjICsgXCIgaXMgbm90IGEgdmFsaWQgZGlnaXQgaW4gYmFzZSBcIiArIGJhc2UgKyBcIi5cIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcbiAgICAgICAgaWYgKDIgPD0gYmFzZSAmJiBiYXNlIDw9IDM2KSB7XHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPD0gTE9HX01BWF9JTlQgLyBNYXRoLmxvZyhiYXNlKSkge1xyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBwYXJzZUludCh0ZXh0LCBiYXNlKTtcclxuXHRcdFx0XHRpZihpc05hTihyZXN1bHQpKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYyArIFwiIGlzIG5vdCBhIHZhbGlkIGRpZ2l0IGluIGJhc2UgXCIgKyBiYXNlICsgXCIuXCIpO1xyXG5cdFx0XHRcdH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHBhcnNlSW50KHRleHQsIGJhc2UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBiYXNlID0gcGFyc2VWYWx1ZShiYXNlKTtcclxuICAgICAgICB2YXIgZGlnaXRzID0gW107XHJcbiAgICAgICAgdmFyIGlzTmVnYXRpdmUgPSB0ZXh0WzBdID09PSBcIi1cIjtcclxuICAgICAgICBmb3IgKGkgPSBpc05lZ2F0aXZlID8gMSA6IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gdGV4dFtpXS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIGlmICg0OCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSA1NykgZGlnaXRzLnB1c2gocGFyc2VWYWx1ZShjKSk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKDk3IDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDEyMikgZGlnaXRzLnB1c2gocGFyc2VWYWx1ZShjLmNoYXJDb2RlQXQoMCkgLSA4NykpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSBcIjxcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaTtcclxuICAgICAgICAgICAgICAgIGRvIHsgaSsrOyB9IHdoaWxlICh0ZXh0W2ldICE9PSBcIj5cIik7XHJcbiAgICAgICAgICAgICAgICBkaWdpdHMucHVzaChwYXJzZVZhbHVlKHRleHQuc2xpY2Uoc3RhcnQgKyAxLCBpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKGMgKyBcIiBpcyBub3QgYSB2YWxpZCBjaGFyYWN0ZXJcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLCBiYXNlLCBpc05lZ2F0aXZlKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VCYXNlRnJvbUFycmF5KGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgIHZhciB2YWwgPSBJbnRlZ2VyWzBdLCBwb3cgPSBJbnRlZ2VyWzFdLCBpO1xyXG4gICAgICAgIGZvciAoaSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YWwgPSB2YWwuYWRkKGRpZ2l0c1tpXS50aW1lcyhwb3cpKTtcclxuICAgICAgICAgICAgcG93ID0gcG93LnRpbWVzKGJhc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNOZWdhdGl2ZSA/IHZhbC5uZWdhdGUoKSA6IHZhbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoZGlnaXQpIHtcclxuICAgICAgICB2YXIgdiA9IGRpZ2l0LnZhbHVlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikgdiA9IFt2XTtcclxuICAgICAgICBpZiAodi5sZW5ndGggPT09IDEgJiYgdlswXSA8PSAzNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIi5jaGFyQXQodlswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBcIjxcIiArIHYgKyBcIj5cIjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRvQmFzZShuLCBiYXNlKSB7XHJcbiAgICAgICAgYmFzZSA9IGJpZ0ludChiYXNlKTtcclxuICAgICAgICBpZiAoYmFzZS5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIFwiMFwiO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBub256ZXJvIG51bWJlcnMgdG8gYmFzZSAwLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJhc2UuZXF1YWxzKC0xKSkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIFwiMFwiO1xyXG4gICAgICAgICAgICBpZiAobi5pc05lZ2F0aXZlKCkpIHJldHVybiBuZXcgQXJyYXkoMSAtIG4pLmpvaW4oXCIxMFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIFwiMVwiICsgbmV3IEFycmF5KCtuKS5qb2luKFwiMDFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaW51c1NpZ24gPSBcIlwiO1xyXG4gICAgICAgIGlmIChuLmlzTmVnYXRpdmUoKSAmJiBiYXNlLmlzUG9zaXRpdmUoKSkge1xyXG4gICAgICAgICAgICBtaW51c1NpZ24gPSBcIi1cIjtcclxuICAgICAgICAgICAgbiA9IG4uYWJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiYXNlLmVxdWFscygxKSkge1xyXG4gICAgICAgICAgICBpZiAobi5pc1plcm8oKSkgcmV0dXJuIFwiMFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbWludXNTaWduICsgbmV3IEFycmF5KCtuICsgMSkuam9pbigxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG91dCA9IFtdO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gbiwgZGl2bW9kO1xyXG4gICAgICAgIHdoaWxlIChsZWZ0LmlzTmVnYXRpdmUoKSB8fCBsZWZ0LmNvbXBhcmVBYnMoYmFzZSkgPj0gMCkge1xyXG4gICAgICAgICAgICBkaXZtb2QgPSBsZWZ0LmRpdm1vZChiYXNlKTtcclxuICAgICAgICAgICAgbGVmdCA9IGRpdm1vZC5xdW90aWVudDtcclxuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gZGl2bW9kLnJlbWFpbmRlcjtcclxuICAgICAgICAgICAgaWYgKGRpZ2l0LmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgZGlnaXQgPSBiYXNlLm1pbnVzKGRpZ2l0KS5hYnMoKTtcclxuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0Lm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXQucHVzaChzdHJpbmdpZnkoZGlnaXQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0LnB1c2goc3RyaW5naWZ5KGxlZnQpKTtcclxuICAgICAgICByZXR1cm4gbWludXNTaWduICsgb3V0LnJldmVyc2UoKS5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHJhZGl4KSB7XHJcbiAgICAgICAgaWYgKHJhZGl4ID09PSB1bmRlZmluZWQpIHJhZGl4ID0gMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4ICE9PSAxMCkgcmV0dXJuIHRvQmFzZSh0aGlzLCByYWRpeCk7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZhbHVlLCBsID0gdi5sZW5ndGgsIHN0ciA9IFN0cmluZyh2Wy0tbF0pLCB6ZXJvcyA9IFwiMDAwMDAwMFwiLCBkaWdpdDtcclxuICAgICAgICB3aGlsZSAoLS1sID49IDApIHtcclxuICAgICAgICAgICAgZGlnaXQgPSBTdHJpbmcodltsXSk7XHJcbiAgICAgICAgICAgIHN0ciArPSB6ZXJvcy5zbGljZShkaWdpdC5sZW5ndGgpICsgZGlnaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaWduID0gdGhpcy5zaWduID8gXCItXCIgOiBcIlwiO1xyXG4gICAgICAgIHJldHVybiBzaWduICsgc3RyO1xyXG4gICAgfTtcclxuXHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHJhZGl4KSB7XHJcbiAgICAgICAgaWYgKHJhZGl4ID09PSB1bmRlZmluZWQpIHJhZGl4ID0gMTA7XHJcbiAgICAgICAgaWYgKHJhZGl4ICE9IDEwKSByZXR1cm4gdG9CYXNlKHRoaXMsIHJhZGl4KTtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNPTiA9IFNtYWxsSW50ZWdlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nKCk7IH1cclxuXHJcbiAgICBCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiArdGhpcy50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIEJpZ0ludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBCaWdJbnRlZ2VyLnByb3RvdHlwZS52YWx1ZU9mO1xyXG5cclxuICAgIFNtYWxsSW50ZWdlci5wcm90b3R5cGUudmFsdWVPZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBTbWFsbEludGVnZXIucHJvdG90eXBlLnRvSlNOdW1iZXIgPSBTbWFsbEludGVnZXIucHJvdG90eXBlLnZhbHVlT2Y7XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHJpbmdWYWx1ZSh2KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1ByZWNpc2UoK3YpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9ICt2O1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPT09IHRydW5jYXRlKHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU21hbGxJbnRlZ2VyKHgpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIGludGVnZXI6IFwiICsgdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZbMF0gPT09IFwiLVwiO1xyXG4gICAgICAgICAgICBpZiAoc2lnbikgdiA9IHYuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHYuc3BsaXQoL2UvaSk7XHJcbiAgICAgICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAyKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgc3BsaXQuam9pbihcImVcIikpO1xyXG4gICAgICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwID0gc3BsaXRbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhwWzBdID09PSBcIitcIikgZXhwID0gZXhwLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgZXhwID0gK2V4cDtcclxuICAgICAgICAgICAgICAgIGlmIChleHAgIT09IHRydW5jYXRlKGV4cCkgfHwgIWlzUHJlY2lzZShleHApKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGludGVnZXI6IFwiICsgZXhwICsgXCIgaXMgbm90IGEgdmFsaWQgZXhwb25lbnQuXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBzcGxpdFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsUGxhY2UgPSB0ZXh0LmluZGV4T2YoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlY2ltYWxQbGFjZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwIC09IHRleHQubGVuZ3RoIC0gZGVjaW1hbFBsYWNlIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBkZWNpbWFsUGxhY2UpICsgdGV4dC5zbGljZShkZWNpbWFsUGxhY2UgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChleHAgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5jbHVkZSBuZWdhdGl2ZSBleHBvbmVudCBwYXJ0IGZvciBpbnRlZ2Vyc1wiKTtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gKG5ldyBBcnJheShleHAgKyAxKSkuam9pbihcIjBcIik7XHJcbiAgICAgICAgICAgICAgICB2ID0gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IC9eKFswLTldWzAtOV0qKSQvLnRlc3Qodik7XHJcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyOiBcIiArIHYpO1xyXG4gICAgICAgICAgICB2YXIgciA9IFtdLCBtYXggPSB2Lmxlbmd0aCwgbCA9IExPR19CQVNFLCBtaW4gPSBtYXggLSBsO1xyXG4gICAgICAgICAgICB3aGlsZSAobWF4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgci5wdXNoKCt2LnNsaWNlKG1pbiwgbWF4KSk7XHJcbiAgICAgICAgICAgICAgICBtaW4gLT0gbDtcclxuICAgICAgICAgICAgICAgIGlmIChtaW4gPCAwKSBtaW4gPSAwO1xyXG4gICAgICAgICAgICAgICAgbWF4IC09IGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJpbShyKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHIsIHNpZ24pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlTnVtYmVyVmFsdWUodikge1xyXG4gICAgICAgIGlmIChpc1ByZWNpc2UodikpIHtcclxuICAgICAgICAgICAgaWYgKHYgIT09IHRydW5jYXRlKHYpKSB0aHJvdyBuZXcgRXJyb3IodiArIFwiIGlzIG5vdCBhbiBpbnRlZ2VyLlwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFsbEludGVnZXIodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1ZhbHVlKHYudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZU51bWJlclZhbHVlKHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nVmFsdWUodik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2O1xyXG4gICAgfVxyXG4gICAgLy8gUHJlLWRlZmluZSBudW1iZXJzIGluIHJhbmdlIFstOTk5LDk5OV1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKSB7XHJcbiAgICAgICAgSW50ZWdlcltpXSA9IG5ldyBTbWFsbEludGVnZXIoaSk7XHJcbiAgICAgICAgaWYgKGkgPiAwKSBJbnRlZ2VyWy1pXSA9IG5ldyBTbWFsbEludGVnZXIoLWkpO1xyXG4gICAgfVxyXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcclxuICAgIEludGVnZXIub25lID0gSW50ZWdlclsxXTtcclxuICAgIEludGVnZXIuemVybyA9IEludGVnZXJbMF07XHJcbiAgICBJbnRlZ2VyLm1pbnVzT25lID0gSW50ZWdlclstMV07XHJcbiAgICBJbnRlZ2VyLm1heCA9IG1heDtcclxuICAgIEludGVnZXIubWluID0gbWluO1xyXG4gICAgSW50ZWdlci5nY2QgPSBnY2Q7XHJcbiAgICBJbnRlZ2VyLmxjbSA9IGxjbTtcclxuICAgIEludGVnZXIuaXNJbnN0YW5jZSA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgQmlnSW50ZWdlciB8fCB4IGluc3RhbmNlb2YgU21hbGxJbnRlZ2VyOyB9O1xyXG4gICAgSW50ZWdlci5yYW5kQmV0d2VlbiA9IHJhbmRCZXR3ZWVuO1xyXG5cclxuICAgIEludGVnZXIuZnJvbUFycmF5ID0gZnVuY3Rpb24gKGRpZ2l0cywgYmFzZSwgaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUJhc2VGcm9tQXJyYXkoZGlnaXRzLm1hcChwYXJzZVZhbHVlKSwgcGFyc2VWYWx1ZShiYXNlIHx8IDEwKSwgaXNOZWdhdGl2ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBJbnRlZ2VyO1xyXG59KSgpO1xyXG5cclxuLy8gTm9kZS5qcyBjaGVja1xyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuaGFzT3duUHJvcGVydHkoXCJleHBvcnRzXCIpKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJpZ0ludDtcclxufVxyXG5cclxuLy9hbWQgY2hlY2tcclxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcclxuICBkZWZpbmUoIFwiYmlnLWludGVnZXJcIiwgW10sIGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGJpZ0ludDtcclxuICB9KTtcclxufVxyXG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJiaWctaW50ZWdlclwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIkBpb3RhLXBpY28vbGliLWJyb3dzZXJcIiwgW1wiYmlnLWludGVnZXJcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQGlvdGEtcGljby9saWItYnJvd3NlclwiXSA9IGZhY3RvcnkocmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJJb3RhUGljb1wiXSA9IGZhY3Rvcnkocm9vdFtcImJpZ0ludFwiXSk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfYmlnX2ludGVnZXJfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9wa2cvYm9vdHN0cmFwLmpzXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIi4uL2lvdGEtcGljby1hcGkvZGlzdC9jbGllbnQvYXBpQ2xpZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1hcGkvZGlzdC9jbGllbnQvYXBpQ2xpZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX3JlZ2VuZXJhdG9yUnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yICovIFxcXCIuLi9pb3RhLXBpY28tYXBpL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IHN0ZXAoXFxcIm5leHRcXFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBzdGVwKFxcXCJ0aHJvd1xcXCIsIGVycik7IH0gX25leHQoKTsgfSk7IH07IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgYXJyYXlIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBudW1iZXJIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgc3RyaW5nSGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL3N0cmluZ0hlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL3N0cmluZ0hlbHBlci5qc1xcXCIpO1xcblxcbnZhciBhcGlFcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3IvYXBpRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1hcGkvZGlzdC9lcnJvci9hcGlFcnJvci5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYW4gYXBpIGNsaWVudC5cXHJcXG4gKi9cXG5cXG5cXG52YXIgQXBpQ2xpZW50ID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXBpQ2xpZW50LlxcclxcbiAgICogQHBhcmFtIG5ldHdvcmtDbGllbnQgVGhlIG5ldHdvcmsgY2xpZW50IHRvIGNvbW11bmljYXRlIHRocm91Z2guXFxyXFxuICAgKiBAcGFyYW0gYXBpVmVyc2lvbiBUaGUgQVBJIHZlcnNpb24gdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0c1xcclxcbiAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXJzIEV4dHJhIGhlYWRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0cy5cXHJcXG4gICAqL1xcbiAgZnVuY3Rpb24gQXBpQ2xpZW50KG5ldHdvcmtDbGllbnQpIHtcXG4gICAgdmFyIGFwaVZlcnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFxcXCIxXFxcIjtcXG4gICAgdmFyIGFkZGl0aW9uYWxIZWFkZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XFxuXFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcGlDbGllbnQpO1xcblxcbiAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobmV0d29ya0NsaWVudCkpIHtcXG4gICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIG5ldHdvcmtDbGllbnQgbXVzdCBiZSBkZWZpbmVkXFxcIik7XFxuICAgIH1cXG5cXG4gICAgaWYgKHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KGFwaVZlcnNpb24pKSB7XFxuICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXFxcIlRoZSBhcGlWZXJzaW9uIG11c3Qgbm90IGJlIGVtcHR5XFxcIik7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fbmV0d29ya0NsaWVudCA9IG5ldHdvcmtDbGllbnQ7XFxuICAgIHRoaXMuX2FwaVZlcnNpb24gPSBhcGlWZXJzaW9uO1xcbiAgICB0aGlzLl9hZGRpdGlvbmFsSGVhZGVycyA9IGFkZGl0aW9uYWxIZWFkZXJzO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHlvdXIgbm9kZS5cXHJcXG4gICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGdldE5vZGVJbmZvIHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgKi9cXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhBcGlDbGllbnQsIFt7XFxuICAgIGtleTogXFxcImdldE5vZGVJbmZvXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2dldE5vZGVJbmZvID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5zZW5kQ29tbWFuZChcXFwiZ2V0Tm9kZUluZm9cXFwiLCB7fSkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0Tm9kZUluZm8oKSB7XFxuICAgICAgICByZXR1cm4gX2dldE5vZGVJbmZvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXQgb2YgbmVpZ2hib3JzIHlvdSBhcmUgY29ubmVjdGVkIHdpdGgsIGFzIHdlbGwgYXMgdGhlaXIgYWN0aXZpdHkgY291bnQuXFxyXFxuICAgICAqIFRoZSBhY3Rpdml0eSBjb3VudGVyIGlzIHJlc2V0IGFmdGVyIHJlc3RhcnRpbmcgSVJJLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBnZXROZWlnaGJvcnMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldE5laWdoYm9yc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9nZXROZWlnaGJvcnMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB0aGlzLnNlbmRDb21tYW5kKFxcXCJnZXROZWlnaGJvcnNcXFwiLCB7fSkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBnZXROZWlnaGJvcnMoKSB7XFxuICAgICAgICByZXR1cm4gX2dldE5laWdoYm9ycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogQWRkIGEgbGlzdCBvZiBuZWlnaGJvcnMgdG8geW91ciBub2RlLiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCB0aGlzIGlzIG9ubHkgdGVtcG9yYXJ5LFxcclxcbiAgICAgKiBhbmQgdGhlIGFkZGVkIG5laWdoYm9ycyB3aWxsIGJlIHJlbW92ZWQgZnJvbSB5b3VyIHNldCBvZiBuZWlnaGJvcnMgYWZ0ZXIgeW91IHJlbGF1bmNoIElSSS5cXHJcXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgYWRkTmVpZ2hib3JzIHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhZGROZWlnaGJvcnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfYWRkTmVpZ2hib3JzID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhyZXF1ZXN0KSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyZXF1ZXN0KSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QgbXVzdCBiZSBkZWZpbmVkXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QudXJpcykpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXFxcIlRoZSByZXF1ZXN0LnVyaXMgbXVzdCBub3QgYmUgZW1wdHlcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc2VuZENvbW1hbmQoXFxcImFkZE5laWdoYm9yc1xcXCIsIHJlcXVlc3QpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gYWRkTmVpZ2hib3JzKF94KSB7XFxuICAgICAgICByZXR1cm4gX2FkZE5laWdoYm9ycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogUmVtb3ZlcyBhIGxpc3Qgb2YgbmVpZ2hib3JzIGZyb20geW91ciBub2RlLiBUaGlzIGlzIG9ubHkgdGVtcG9yYXJ5LCBhbmQgaWYgeW91IGhhdmUgeW91clxcclxcbiAgICAgKiBuZWlnaGJvcnMgYWRkZWQgdmlhIHRoZSBjb21tYW5kIGxpbmUsIHRoZXkgd2lsbCBiZSByZXRhaW5lZCBhZnRlciB5b3UgcmVzdGFydCB5b3VyIG5vZGUuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHJlbW92ZU5laWdoYm9ycyByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmVtb3ZlTmVpZ2hib3JzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3JlbW92ZU5laWdoYm9ycyA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQocmVxdWVzdCkge1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXFxcIlRoZSByZXF1ZXN0IG11c3QgYmUgZGVmaW5lZFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICBpZiAoIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNFbXB0eShyZXF1ZXN0LnVyaXMpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA0O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdC51cmlzIG11c3Qgbm90IGJlIGVtcHR5XFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB0aGlzLnNlbmRDb21tYW5kKFxcXCJyZW1vdmVOZWlnaGJvcnNcXFwiLCByZXF1ZXN0KSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDU6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZU5laWdoYm9ycyhfeDIpIHtcXG4gICAgICAgIHJldHVybiBfcmVtb3ZlTmVpZ2hib3JzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHRpcHMuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGdldFRpcHMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldFRpcHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfZ2V0VGlwcyA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoKSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc2VuZENvbW1hbmQoXFxcImdldFRpcHNcXFwiLCB7fSkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRUaXBzKCkge1xcbiAgICAgICAgcmV0dXJuIF9nZXRUaXBzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBGaW5kIHRoZSB0cmFuc2FjdGlvbnMgd2hpY2ggbWF0Y2ggdGhlIHNwZWNpZmllZCBpbnB1dCBhbmQgcmV0dXJuLiBBbGwgaW5wdXQgdmFsdWVzIGFyZSBsaXN0cyxcXHJcXG4gICAgICogZm9yIHdoaWNoIGEgbGlzdCBvZiByZXR1cm4gdmFsdWVzICh0cmFuc2FjdGlvbiBoYXNoZXMpLCBpbiB0aGUgc2FtZSBvcmRlciwgaXMgcmV0dXJuZWQgZm9yIGFsbFxcclxcbiAgICAgKiBpbmRpdmlkdWFsIGVsZW1lbnRzLiBUaGUgaW5wdXQgZmllbGRzIGNhbiBlaXRoZXIgYmUgYnVuZGxlcywgYWRkcmVzc2VzLCB0YWdzIG9yIGFwcHJvdmVlcy5cXHJcXG4gICAgICogVXNpbmcgbXVsdGlwbGUgb2YgdGhlc2UgaW5wdXQgZmllbGRzIHJldHVybnMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdmFsdWVzLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBmaW5kVHJhbnNhY3Rpb25zIHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJmaW5kVHJhbnNhY3Rpb25zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2ZpbmRUcmFuc2FjdGlvbnMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHJlcXVlc3QpIHtcXG4gICAgICAgIHZhciBidW5kbGVzRW1wdHksIGFkZHJlc3Nlc0VtcHR5LCB0YWdzRW1wdHksIGFwcHJvdmVlc0VtcHR5O1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXFxcIlRoZSByZXF1ZXN0IG11c3QgYmUgZGVmaW5lZFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICBidW5kbGVzRW1wdHkgPSBhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC5idW5kbGVzKTtcXG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzRW1wdHkgPSBhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC5hZGRyZXNzZXMpO1xcbiAgICAgICAgICAgICAgICB0YWdzRW1wdHkgPSBhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC50YWdzKTtcXG4gICAgICAgICAgICAgICAgYXBwcm92ZWVzRW1wdHkgPSBhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC5hcHByb3ZlZXMpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIShidW5kbGVzRW1wdHkgJiYgYWRkcmVzc2VzRW1wdHkgJiYgdGFnc0VtcHR5ICYmIGFwcHJvdmVlc0VtcHR5KSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gODtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiT25lIG9mIHRoZSBidW5kbGUsIGFkZHJlc3NlcywgdGFncyBvciBhcHByb3ZlZXMgbXVzdCBub3QgYmUgZW1wdHlcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgODpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc2VuZENvbW1hbmQoXFxcImZpbmRUcmFuc2FjdGlvbnNcXFwiLCByZXF1ZXN0KSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDk6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGZpbmRUcmFuc2FjdGlvbnMoX3gzKSB7XFxuICAgICAgICByZXR1cm4gX2ZpbmRUcmFuc2FjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIFJldHVybnMgdGhlIHJhdyB0cmFuc2FjdGlvbiBkYXRhICh0cnl0ZXMpIG9mIGEgc3BlY2lmaWMgdHJhbnNhY3Rpb24uXFxyXFxuICAgICAqIFRoZXNlIHRyeXRlcyBjYW4gdGhlbiBiZSBlYXNpbHkgY29udmVydGVkIGludG8gdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiBvYmplY3QuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGZpbmRUcmFuc2FjdGlvbnMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldFRyeXRlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9nZXRUcnl0ZXMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHJlcXVlc3QpIHtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlcXVlc3QpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC5oYXNoZXMpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA0O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdC5oYXNoZXMgbXVzdCBub3QgYmUgZW1wdHlcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc2VuZENvbW1hbmQoXFxcImdldFRyeXRlc1xcXCIsIHJlcXVlc3QpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0VHJ5dGVzKF94NCkge1xcbiAgICAgICAgcmV0dXJuIF9nZXRUcnl0ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0aGUgaW5jbHVzaW9uIHN0YXRlcyBvZiBhIHNldCBvZiB0cmFuc2FjdGlvbnMuIFRoaXMgaXMgZm9yIGRldGVybWluaW5nIGlmIGEgdHJhbnNhY3Rpb25cXHJcXG4gICAgICogd2FzIGFjY2VwdGVkIGFuZCBjb25maXJtZWQgYnkgdGhlIG5ldHdvcmsgb3Igbm90LiBZb3UgY2FuIHNlYXJjaCBmb3IgbXVsdGlwbGUgdGlwcyAoYW5kIHRodXMsXFxyXFxuICAgICAqIG1pbGVzdG9uZXMpIHRvIGdldCBwYXN0IGluY2x1c2lvbiBzdGF0ZXMgb2YgdHJhbnNhY3Rpb25zLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBnZXRJbmNsdXNpb25TdGF0ZXMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEluY2x1c2lvblN0YXRlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9nZXRJbmNsdXNpb25TdGF0ZXMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KHJlcXVlc3QpIHtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlcXVlc3QpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC50cmFuc2FjdGlvbnMpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSA0O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdC50cmFuc2FjdGlvbnMgbXVzdCBub3QgYmUgZW1wdHlcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC50aXBzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QudGlwcyBtdXN0IG5vdCBiZSBlbXB0eVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5zZW5kQ29tbWFuZChcXFwiZ2V0SW5jbHVzaW9uU3RhdGVzXFxcIiwgcmVxdWVzdCkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA3OlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlOCwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRJbmNsdXNpb25TdGF0ZXMoX3g1KSB7XFxuICAgICAgICByZXR1cm4gX2dldEluY2x1c2lvblN0YXRlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogUmV0dXJucyB0aGUgY29uZmlybWVkIGJhbGFuY2Ugd2hpY2ggYSBsaXN0IG9mIGFkZHJlc3NlcyBoYXZlIGF0IHRoZSBsYXRlc3QgY29uZmlybWVkIG1pbGVzdG9uZS5cXHJcXG4gICAgICogSW4gYWRkaXRpb24gdG8gdGhlIGJhbGFuY2VzLCBpdCBhbHNvIHJldHVybnMgdGhlIG1pbGVzdG9uZSBhcyB3ZWxsIGFzIHRoZSBpbmRleCB3aXRoIHdoaWNoIHRoZVxcclxcbiAgICAgKiBjb25maXJtZWQgYmFsYW5jZSB3YXMgZGV0ZXJtaW5lZC4gVGhlIGJhbGFuY2VzIGlzIHJldHVybmVkIGFzIGEgbGlzdCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcXHJcXG4gICAgICogYWRkcmVzc2VzIHdlcmUgcHJvdmlkZWQgYXMgaW5wdXQuXFxyXFxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBnZXRCYWxhbmNlcyByZXF1ZXN0IG9iamVjdC5cXHJcXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgZ2V0QmFsYW5jZXMgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEJhbGFuY2VzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2dldEJhbGFuY2VzID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOShyZXF1ZXN0KSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyZXF1ZXN0KSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QgbXVzdCBiZSBkZWZpbmVkXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QuYWRkcmVzc2VzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNDtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QuYWRkcmVzc2VzIG11c3Qgbm90IGJlIGVtcHR5XFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHJlcXVlc3QudGhyZXNob2xkKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QudGhyZXNob2xkIG11c3QgYmUgYSB2YWxpZCBudW1iZXJcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc2VuZENvbW1hbmQoXFxcImdldEJhbGFuY2VzXFxcIiwgcmVxdWVzdCkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA3OlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRCYWxhbmNlcyhfeDYpIHtcXG4gICAgICAgIHJldHVybiBfZ2V0QmFsYW5jZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIFRpcCBzZWxlY3Rpb24gd2hpY2ggcmV0dXJucyB0cnVua1RyYW5zYWN0aW9uIGFuZCBicmFuY2hUcmFuc2FjdGlvbi4gVGhlIGlucHV0IHZhbHVlIGlzIGRlcHRoLFxcclxcbiAgICAgKiB3aGljaCBiYXNpY2FsbHkgZGV0ZXJtaW5lcyBob3cgbWFueSBidW5kbGVzIHRvIGdvIGJhY2sgdG8gZm9yIGZpbmRpbmcgdGhlIHRyYW5zYWN0aW9ucyB0byBhcHByb3ZlLlxcclxcbiAgICAgKiBUaGUgaGlnaGVyIHlvdXIgZGVwdGggdmFsdWUsIHRoZSBtb3JlIFxcXCJiYWJ5c2l0dGluZ1xcXCIgeW91IGRvIGZvciB0aGUgbmV0d29yayAoYXMgeW91IGhhdmUgdG8gY29uZmlybSBtb3JlIHRyYW5zYWN0aW9ucykuXFxyXFxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBnZXRUcmFuc2FjdGlvbnNUb0FwcHJvdmUgcmVxdWVzdCBvYmplY3QuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGdldFRyYW5zYWN0aW9uc1RvQXBwcm92ZSByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0VHJhbnNhY3Rpb25zVG9BcHByb3ZlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2dldFRyYW5zYWN0aW9uc1RvQXBwcm92ZSA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKHJlcXVlc3QpIHtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwJChfY29udGV4dDEwKSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyZXF1ZXN0KSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXFxcIlRoZSByZXF1ZXN0IG11c3QgYmUgZGVmaW5lZFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihyZXF1ZXN0LmRlcHRoKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXFxcIlRoZSByZXF1ZXN0LmRlcHRoIG11c3QgYmUgYSB2YWxpZCBudW1iZXJcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgaWYgKCEoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlcXVlc3QucmVmZXJlbmNlKSAmJiBzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNFbXB0eShyZXF1ZXN0LnJlZmVyZW5jZSkpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gNjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QucmVmZXJlbmNlIG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDY6XFxuICAgICAgICAgICAgICAgIGlmICghKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShyZXF1ZXN0Lm51bVdhbGtzKSAmJiAhbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihyZXF1ZXN0Lm51bVdhbGtzKSkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA4O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdC5udW1XYWxrcyBtdXN0IGJlIGEgdmFsaWQgbnVtYmVyXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDg6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5zZW5kQ29tbWFuZChcXFwiZ2V0VHJhbnNhY3Rpb25zVG9BcHByb3ZlXFxcIiwgcmVxdWVzdCkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA5OlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uc1RvQXBwcm92ZShfeDcpIHtcXG4gICAgICAgIHJldHVybiBfZ2V0VHJhbnNhY3Rpb25zVG9BcHByb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBBdHRhY2hlcyB0aGUgc3BlY2lmaWVkIHRyYW5zYWN0aW9ucyAodHJ5dGVzKSB0byB0aGUgVGFuZ2xlIGJ5IGRvaW5nIFByb29mIG9mIFdvcmsuIFlvdSBuZWVkIHRvIHN1cHBseVxcclxcbiAgICAgKiBicmFuY2hUcmFuc2FjdGlvbiBhcyB3ZWxsIGFzIHRydW5rVHJhbnNhY3Rpb24gKGJhc2ljYWxseSB0aGUgdGlwcyB3aGljaCB5b3UncmUgZ29pbmcgdG8gdmFsaWRhdGUgYW5kXFxyXFxuICAgICAqIHJlZmVyZW5jZSB3aXRoIHRoaXMgdHJhbnNhY3Rpb24pIC0gYm90aCBvZiB3aGljaCB5b3UnbGwgZ2V0IHRocm91Z2ggdGhlIGdldFRyYW5zYWN0aW9uc1RvQXBwcm92ZSBBUEkgY2FsbC5cXHJcXG4gICAgICogQHBhcmFtIHJlcXVlc3QgVGhlIGF0dGFjaFRvVGFuZ2xlIHJlcXVlc3Qgb2JqZWN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBhdHRhY2hUb1RhbmdsZSByZXNwb25zZSBvYmplY3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYXR0YWNoVG9UYW5nbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfYXR0YWNoVG9UYW5nbGUgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMShyZXF1ZXN0KSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMSQoX2NvbnRleHQxMSkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNFbXB0eShyZXF1ZXN0LnRydW5rVHJhbnNhY3Rpb24pKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNDtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QudHJ1bmtUcmFuc2FjdGlvbiBtdXN0IG5vdCBiZSBlbXB0eVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KHJlcXVlc3QuYnJhbmNoVHJhbnNhY3Rpb24pKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QuYnJhbmNoVHJhbnNhY3Rpb24gbXVzdCBub3QgYmUgZW1wdHlcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNjpcXG4gICAgICAgICAgICAgICAgaWYgKG51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIocmVxdWVzdC5taW5XZWlnaHRNYWduaXR1ZGUpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gODtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QubWluV2VpZ2h0TWFnbml0dWRlIG11c3QgYmUgYSB2YWxpZCBudW1iZXJcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgODpcXG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC50cnl0ZXMpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTA7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXFxcIlRoZSByZXF1ZXN0LnRyeXRlcyBtdXN0IG5vdCBiZSBlbXB0eVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB0aGlzLnNlbmRDb21tYW5kKFxcXCJhdHRhY2hUb1RhbmdsZVxcXCIsIHJlcXVlc3QpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMTEsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gYXR0YWNoVG9UYW5nbGUoX3g4KSB7XFxuICAgICAgICByZXR1cm4gX2F0dGFjaFRvVGFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBJbnRlcnJ1cHRzIGFuZCBjb21wbGV0ZWx5IGFib3J0cyB0aGUgYXR0YWNoVG9UYW5nbGUgcHJvY2Vzc1xcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggZW1wdHkgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImludGVycnVwdEF0dGFjaGluZ1RvVGFuZ2xlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2ludGVycnVwdEF0dGFjaGluZ1RvVGFuZ2xlID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIoKSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMi5wcmV2ID0gX2NvbnRleHQxMi5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5zZW5kQ29tbWFuZChcXFwiaW50ZXJydXB0QXR0YWNoaW5nVG9UYW5nbGVcXFwiLCB7fSkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTEyLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGludGVycnVwdEF0dGFjaGluZ1RvVGFuZ2xlKCkge1xcbiAgICAgICAgcmV0dXJuIF9pbnRlcnJ1cHRBdHRhY2hpbmdUb1RhbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogQnJvYWRjYXN0IGEgbGlzdCBvZiB0cmFuc2FjdGlvbnMgdG8gYWxsIG5laWdoYm9ycy4gVGhlIGlucHV0IHRyeXRlcyBmb3IgdGhpcyBjYWxsIGFyZSBwcm92aWRlZCBieSBhdHRhY2hUb1RhbmdsZS5cXHJcXG4gICAgICogQHBhcmFtIHJlcXVlc3QgVGhlIGJyb2FkY2FzdFRyYW5zYWN0aW9ucyByZXF1ZXN0IG9iamVjdC5cXHJcXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIGVtcHR5IHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJicm9hZGNhc3RUcmFuc2FjdGlvbnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfYnJvYWRjYXN0VHJhbnNhY3Rpb25zID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTMocmVxdWVzdCkge1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTMkKF9jb250ZXh0MTMpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlcXVlc3QpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QgbXVzdCBiZSBkZWZpbmVkXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QudHJ5dGVzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXFxcIlRoZSByZXF1ZXN0LnRyeXRlcyBtdXN0IG5vdCBiZSBlbXB0eVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc2VuZENvbW1hbmQoXFxcImJyb2FkY2FzdFRyYW5zYWN0aW9uc1xcXCIsIHJlcXVlc3QpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUxMywgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBicm9hZGNhc3RUcmFuc2FjdGlvbnMoX3g5KSB7XFxuICAgICAgICByZXR1cm4gX2Jyb2FkY2FzdFRyYW5zYWN0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogU3RvcmUgdHJhbnNhY3Rpb25zIGludG8gdGhlIGxvY2FsIHN0b3JhZ2UuIFRoZSB0cnl0ZXMgdG8gYmUgdXNlZCBmb3IgdGhpcyBjYWxsIGFyZSByZXR1cm5lZCBieSBhdHRhY2hUb1RhbmdsZS5cXHJcXG4gICAgICogQHBhcmFtIHJlcXVlc3QgVGhlIHN0b3JlVHJhbnNhY3Rpb25zIHJlcXVlc3Qgb2JqZWN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdpdGggZW1wdHkgcmVzcG9uc2Ugb2JqZWN0IG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInN0b3JlVHJhbnNhY3Rpb25zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3N0b3JlVHJhbnNhY3Rpb25zID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTQocmVxdWVzdCkge1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTQkKF9jb250ZXh0MTQpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTQucHJldiA9IF9jb250ZXh0MTQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlcXVlc3QpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QgbXVzdCBiZSBkZWZpbmVkXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0VtcHR5KHJlcXVlc3QudHJ5dGVzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGFwaUVycm9yXzEuQXBpRXJyb3IoXFxcIlRoZSByZXF1ZXN0LnRyeXRlcyBtdXN0IG5vdCBiZSBlbXB0eVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc2VuZENvbW1hbmQoXFxcInN0b3JlVHJhbnNhY3Rpb25zXFxcIiwgcmVxdWVzdCkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA1OlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTE0LCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHN0b3JlVHJhbnNhY3Rpb25zKF94MTApIHtcXG4gICAgICAgIHJldHVybiBfc3RvcmVUcmFuc2FjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0cmFuc2FjdGlvbnMgd2l0aCBtaXNzaW5nIHJlZmVyZW5jZXMuXFxyXFxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBnZXRNaXNzaW5nVHJhbnNhY3Rpb25zIHJlcXVlc3Qgb2JqZWN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBnZXRNaXNzaW5nVHJhbnNhY3Rpb25zIHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRNaXNzaW5nVHJhbnNhY3Rpb25zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2dldE1pc3NpbmdUcmFuc2FjdGlvbnMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNSgpIHtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE1JChfY29udGV4dDE1KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE1LnByZXYgPSBfY29udGV4dDE1Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTUuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB0aGlzLnNlbmRDb21tYW5kKFxcXCJnZXRNaXNzaW5nVHJhbnNhY3Rpb25zXFxcIiwge30pKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUxNSwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRNaXNzaW5nVHJhbnNhY3Rpb25zKCkge1xcbiAgICAgICAgcmV0dXJuIF9nZXRNaXNzaW5nVHJhbnNhY3Rpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBDaGVjayB0aGUgY29uc2lzdGVuY3kgb2YgdGFpbCBoYXNoZXMuXFxyXFxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSBjaGVja0NvbnNpc3RlbmN5IHJlcXVlc3Qgb2JqZWN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBjaGVja0NvbnNpc3RlbmN5IHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjaGVja0NvbnNpc3RlbmN5XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2NoZWNrQ29uc2lzdGVuY3kgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNihyZXF1ZXN0KSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNiQoX2NvbnRleHQxNikge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNi5wcmV2ID0gX2NvbnRleHQxNi5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC50YWlscykpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSA0O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdC50YWlscyBtdXN0IG5vdCBiZSBlbXB0eVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuc2VuZENvbW1hbmQoXFxcImNoZWNrQ29uc2lzdGVuY3lcXFwiLCByZXF1ZXN0KSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDU6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMTYsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gY2hlY2tDb25zaXN0ZW5jeShfeDExKSB7XFxuICAgICAgICByZXR1cm4gX2NoZWNrQ29uc2lzdGVuY3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIEhhdmUgdGhlIHJlcXVlc3RlZCBhZGRyZXNzZXMgYmVlbiBzcGVudCBmcm9tIGFscmVhZHkuXFxyXFxuICAgICAqIEBwYXJhbSByZXF1ZXN0IFRoZSB3ZXJlQWRkcmVzc2VzU3BlbnRGcm9tIHJlcXVlc3Qgb2JqZWN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSB3ZXJlQWRkcmVzc2VzU3BlbnRGcm9tIHJlc3BvbnNlIG9iamVjdCBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ3ZXJlQWRkcmVzc2VzU3BlbnRGcm9tXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3dlcmVBZGRyZXNzZXNTcGVudEZyb20gPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNyhyZXF1ZXN0KSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNyQoX2NvbnRleHQxNykge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNy5wcmV2ID0gX2NvbnRleHQxNy5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocmVxdWVzdCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBhcGlFcnJvcl8xLkFwaUVycm9yKFxcXCJUaGUgcmVxdWVzdCBtdXN0IGJlIGRlZmluZWRcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkocmVxdWVzdC5hZGRyZXNzZXMpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gNDtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYXBpRXJyb3JfMS5BcGlFcnJvcihcXFwiVGhlIHJlcXVlc3QuYWRkcmVzc2VzIG11c3Qgbm90IGJlIGVtcHR5XFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5zZW5kQ29tbWFuZChcXFwid2VyZUFkZHJlc3Nlc1NwZW50RnJvbVxcXCIsIHJlcXVlc3QpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUxNywgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiB3ZXJlQWRkcmVzc2VzU3BlbnRGcm9tKF94MTIpIHtcXG4gICAgICAgIHJldHVybiBfd2VyZUFkZHJlc3Nlc1NwZW50RnJvbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2VuZENvbW1hbmRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfc2VuZENvbW1hbmQgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxOChjb21tYW5kLCByZXF1ZXN0KSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxOCQoX2NvbnRleHQxOCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxOC5wcmV2ID0gX2NvbnRleHQxOC5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1ZXN0LCBcXFwiY29tbWFuZFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogY29tbWFuZCxcXG4gICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuX25ldHdvcmtDbGllbnQucG9zdEpzb24ocmVxdWVzdCwgdW5kZWZpbmVkLCB0aGlzLmNyZWF0ZUhlYWRlcnMoKSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xcbiAgICAgICAgICAgICAgICAgIGlmIChlcnIuYWRkaXRpb25hbCAmJiBlcnIuYWRkaXRpb25hbC5lcnJvclJlc3BvbnNlKSB7XFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgYXBpRXJyb3IgPSBKU09OLnBhcnNlKGVyci5hZGRpdGlvbmFsLmVycm9yUmVzcG9uc2UpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBpRXJyb3IuZXJyb3IpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXJyLmFkZGl0aW9uYWwuZXJyb3JSZXNwb25zZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIuYWRkaXRpb25hbC5hcGlFcnJvciA9IGFwaUVycm9yLmVycm9yO1xcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFwaUVycm9yLmV4Y2VwdGlvbikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlcnIuYWRkaXRpb25hbC5lcnJvclJlc3BvbnNlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5hZGRpdGlvbmFsLmFwaUVycm9yID0gYXBpRXJyb3IuZXhjZXB0aW9uO1xcbiAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgICAgICAgICAgIH0pKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE4LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUxOCwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kQ29tbWFuZChfeDEzLCBfeDE0KSB7XFxuICAgICAgICByZXR1cm4gX3NlbmRDb21tYW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjcmVhdGVIZWFkZXJzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoKSB7XFxuICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLl9hZGRpdGlvbmFsSGVhZGVycyB8fCB7fTtcXG4gICAgICBoZWFkZXJzW1xcXCJYLUlPVEEtQVBJLVZlcnNpb25cXFwiXSA9IHRoaXMuX2FwaVZlcnNpb247XFxuICAgICAgcmV0dXJuIGhlYWRlcnM7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBBcGlDbGllbnQ7XFxufSgpO1xcblxcbmV4cG9ydHMuQXBpQ2xpZW50ID0gQXBpQ2xpZW50O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWFwaS9kaXN0L2NsaWVudC9hcGlDbGllbnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tYXBpL2Rpc3QvZXJyb3IvYXBpRXJyb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1hcGkvZGlzdC9lcnJvci9hcGlFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBjb3JlRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2Vycm9yL2NvcmVFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3IuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBBbiBhcGkgaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXFxyXFxuICovXFxuXFxuXFxudmFyIEFwaUVycm9yID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9jb3JlRXJyb3JfMSRDb3JlRXJybykge1xcbiAgX2luaGVyaXRzKEFwaUVycm9yLCBfY29yZUVycm9yXzEkQ29yZUVycm8pO1xcblxcbiAgZnVuY3Rpb24gQXBpRXJyb3IoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcGlFcnJvcik7XFxuXFxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQXBpRXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBcGlFcnJvcikpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgfVxcblxcbiAgcmV0dXJuIEFwaUVycm9yO1xcbn0oY29yZUVycm9yXzEuQ29yZUVycm9yKTtcXG5cXG5leHBvcnRzLkFwaUVycm9yID0gQXBpRXJyb3I7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tYXBpL2Rpc3QvZXJyb3IvYXBpRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tYXBpL2Rpc3QvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1hcGkvZGlzdC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcXG4gIGZvciAodmFyIHAgaW4gbSkge1xcbiAgICBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xcbiAgfVxcbn1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIENvbWJpbmVkIGluZGV4IG9mIGFsbCB0aGUgbW9kdWxlcy5cXHJcXG4gKi9cXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NsaWVudC9hcGlDbGllbnQgKi8gXFxcIi4uL2lvdGEtcGljby1hcGkvZGlzdC9jbGllbnQvYXBpQ2xpZW50LmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3IvYXBpRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1hcGkvZGlzdC9lcnJvci9hcGlFcnJvci5qc1xcXCIpKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1hcGkvZGlzdC9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1hcGkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1hcGkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgKi8gXFxcIi4uL2lvdGEtcGljby1hcGkvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcXFwiKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1hcGkvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWFwaS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1hcGkvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXFxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXFxudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKTtcXG5cXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXFxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcXFwicmVnZW5lcmF0b3JSdW50aW1lXFxcIikgPj0gMDtcXG5cXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXFxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xcblxcbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcnVudGltZSAqLyBcXFwiLi4vaW90YS1waWNvLWFwaS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXFxcIik7XFxuXFxuaWYgKGhhZFJ1bnRpbWUpIHtcXG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXFxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XFxufSBlbHNlIHtcXG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXFxuICB0cnkge1xcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuICB9IGNhdGNoKGUpIHtcXG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XFxuICB9XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWFwaS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1hcGkvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWFwaS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuIShmdW5jdGlvbihnbG9iYWwpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XFxuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XFxuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IFN5bWJvbCA6IHt9O1xcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcXFwiQEBpdGVyYXRvclxcXCI7XFxuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcXFwiQEBhc3luY0l0ZXJhdG9yXFxcIjtcXG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXFxcIkBAdG9TdHJpbmdUYWdcXFwiO1xcblxcbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXFxcIm9iamVjdFxcXCI7XFxuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuICBpZiAocnVudGltZSkge1xcbiAgICBpZiAoaW5Nb2R1bGUpIHtcXG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XFxuICAgIH1cXG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxcbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XFxuXFxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XFxuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxcbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XFxuXFxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxcbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XFxuXFxuICAgIHJldHVybiBnZW5lcmF0b3I7XFxuICB9XFxuICBydW50aW1lLndyYXAgPSB3cmFwO1xcblxcbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXFxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxcbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIHsgdHlwZTogXFxcIm5vcm1hbFxcXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgcmV0dXJuIHsgdHlwZTogXFxcInRocm93XFxcIiwgYXJnOiBlcnIgfTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcXFwic3VzcGVuZGVkU3RhcnRcXFwiO1xcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcXFwic3VzcGVuZGVkWWllbGRcXFwiO1xcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXFxcImV4ZWN1dGluZ1xcXCI7XFxuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcXFwiY29tcGxldGVkXFxcIjtcXG5cXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XFxuXFxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXFxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxcblxcbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XFxuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XFxuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XFxuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcXG4gIH1cXG5cXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XFxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcXG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XFxuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cXG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiO1xcblxcbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXFxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XFxuICAgIFtcXFwibmV4dFxcXCIsIFxcXCJ0aHJvd1xcXCIsIFxcXCJyZXR1cm5cXFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xcbiAgICByZXR1cm4gY3RvclxcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcXG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCJcXG4gICAgICA6IGZhbHNlO1xcbiAgfTtcXG5cXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XFxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcXG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XFxuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIjtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xcbiAgICByZXR1cm4gZ2VuRnVuO1xcbiAgfTtcXG5cXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xcbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcXG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXFxcIl9fYXdhaXRcXFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXFxuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxcbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcXG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcXG4gICAgICAgIGlmICh2YWx1ZSAmJlxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXFxcIm9iamVjdFxcXCIgJiZcXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXFxcIl9fYXdhaXRcXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICAgICAgICBpbnZva2UoXFxcIm5leHRcXFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgICAgICAgaW52b2tlKFxcXCJ0aHJvd1xcXCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcXG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXFxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXFxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xcbiAgICAgICAgfSwgcmVqZWN0KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcXG5cXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XFxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXFxuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXFxuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XFxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcXG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXFxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxcbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXFxuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcXG4gICAgfVxcblxcbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcXG4gIH1cXG5cXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XFxuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcXG5cXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXFxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxcbiAgICApO1xcblxcbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXFxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xcbiAgICAgICAgfSk7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XFxuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XFxuXFxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICB0aHJvdyBhcmc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XFxuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XFxuXFxuICAgICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XFxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcXG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XFxuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XFxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJuZXh0XFxcIikge1xcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcXG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIGNvbnRleHQuYXJnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XFxuXFxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XFxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJub3JtYWxcXFwiKSB7XFxuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cXG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxcbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XFxuXFxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcXG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXFxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XFxuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XFxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuXFxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XFxuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJyZXR1cm5cXFwiO1xcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XFxuXFxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXFxuICAgICAgICAgICAgLy8gXFxcInJldHVyblxcXCIgdG8gXFxcInRocm93XFxcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxcbiAgICAgICAgICBcXFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xcblxcbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcXG5cXG4gICAgaWYgKCEgaW5mbykge1xcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXFxcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XFxcIik7XFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgaWYgKGluZm8uZG9uZSkge1xcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XFxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcXG5cXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXFxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcXG5cXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXFxcInRocm93XFxcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXFxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcXFwibmV4dFxcXCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxcbiAgICAgIC8vIFxcXCJjb25zdW1lZFxcXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcXG4gICAgICAvLyBcXFwicmV0dXJuXFxcIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXFxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxcbiAgICAgIHJldHVybiBpbmZvO1xcbiAgICB9XFxuXFxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXFxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gIH1cXG5cXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXFxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXFxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xcblxcbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXFxcIkdlbmVyYXRvclxcXCI7XFxuXFxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXFxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG5cXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBcXFwiW29iamVjdCBHZW5lcmF0b3JdXFxcIjtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xcblxcbiAgICBpZiAoMSBpbiBsb2NzKSB7XFxuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xcbiAgICB9XFxuXFxuICAgIGlmICgyIGluIGxvY3MpIHtcXG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcXG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XFxuICAgIH1cXG5cXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcXG4gICAgcmVjb3JkLnR5cGUgPSBcXFwibm9ybWFsXFxcIjtcXG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XFxuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XFxuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXFxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcXFwicm9vdFxcXCIgfV07XFxuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcXG4gICAgdGhpcy5yZXNldCh0cnVlKTtcXG4gIH1cXG5cXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICB2YXIga2V5cyA9IFtdO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XFxuICAgICAga2V5cy5wdXNoKGtleSk7XFxuICAgIH1cXG4gICAga2V5cy5yZXZlcnNlKCk7XFxuXFxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXFxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XFxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXFxuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXFxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gbmV4dDtcXG4gICAgfTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcXG4gICAgaWYgKGl0ZXJhYmxlKSB7XFxuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XFxuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcXG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcXG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XFxuXFxuICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXFxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcXG4gIH1cXG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xcblxcbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcXG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xcbiAgfVxcblxcbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XFxuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxcblxcbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xcbiAgICAgIHRoaXMucHJldiA9IDA7XFxuICAgICAgdGhpcy5uZXh0ID0gMDtcXG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXFxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcXG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcXG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcXG5cXG4gICAgICB0aGlzLm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcXG5cXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcXG5cXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFxcXCJ0XFxcIiAmJlxcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcXG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcXG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xcblxcbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XFxuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcXG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcXG4gICAgfSxcXG5cXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcXG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcXG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcXG5cXG4gICAgICAgIGlmIChjYXVnaHQpIHtcXG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XFxuXFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcXFwicm9vdFxcXCIpIHtcXG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXFxuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXFxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXFxcImVuZFxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcXG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFxcXCJjYXRjaExvY1xcXCIpO1xcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcXFwiZmluYWxseUxvY1xcXCIpO1xcblxcbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXFxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFxcXCJmaW5hbGx5TG9jXFxcIikgJiZcXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcXG4gICAgICAgICAgKHR5cGUgPT09IFxcXCJicmVha1xcXCIgfHxcXG4gICAgICAgICAgIHR5cGUgPT09IFxcXCJjb250aW51ZVxcXCIpICYmXFxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXFxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxcbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XFxuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XFxuXFxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xcbiAgICB9LFxcblxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwiYnJlYWtcXFwiIHx8XFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcXFwiY29udGludWVcXFwiKSB7XFxuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJyZXR1cm5cXFwiKSB7XFxuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XFxuICAgICAgICB0aGlzLm1ldGhvZCA9IFxcXCJyZXR1cm5cXFwiO1xcbiAgICAgICAgdGhpcy5uZXh0ID0gXFxcImVuZFxcXCI7XFxuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcIm5vcm1hbFxcXCIgJiYgYWZ0ZXJMb2MpIHtcXG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfSxcXG5cXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XFxuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIFxcXCJjYXRjaFxcXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XFxuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXFxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XFxcIik7XFxuICAgIH0sXFxuXFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XFxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcXG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcXG4gICAgICB9O1xcblxcbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXFxcIm5leHRcXFwiKSB7XFxuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuICB9O1xcbn0pKFxcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXFxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKVxcbik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tYXBpL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9lcnJvci9idXNpbmVzc0Vycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvZXJyb3IvYnVzaW5lc3NFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgY29yZUVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvZXJyb3IvY29yZUVycm9yLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQSBidXNpbmVzcyBpbXBsZW1lbnRhdGlvbiBvZiBhbiBlcnJvci5cXHJcXG4gKi9cXG5cXG5cXG52YXIgQnVzaW5lc3NFcnJvciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfY29yZUVycm9yXzEkQ29yZUVycm8pIHtcXG4gIF9pbmhlcml0cyhCdXNpbmVzc0Vycm9yLCBfY29yZUVycm9yXzEkQ29yZUVycm8pO1xcblxcbiAgZnVuY3Rpb24gQnVzaW5lc3NFcnJvcigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1c2luZXNzRXJyb3IpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEJ1c2luZXNzRXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihCdXNpbmVzc0Vycm9yKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICByZXR1cm4gQnVzaW5lc3NFcnJvcjtcXG59KGNvcmVFcnJvcl8xLkNvcmVFcnJvcik7XFxuXFxuZXhwb3J0cy5CdXNpbmVzc0Vycm9yID0gQnVzaW5lc3NFcnJvcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L2Vycm9yL2J1c2luZXNzRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9oZWxwZXJzL2J1bmRsZUhlbHBlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9oZWxwZXJzL2J1bmRsZUhlbHBlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIGFycmF5SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBzcG9uZ2VGYWN0b3J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NyeXB0by9kaXN0L2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5ICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnkuanNcXFwiKTtcXG5cXG52YXIgYWRkcmVzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvYWRkcmVzcy5qc1xcXCIpO1xcblxcbnZhciBidW5kbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvYnVuZGxlICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvYnVuZGxlLmpzXFxcIik7XFxuXFxudmFyIGhhc2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvaGFzaCAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2hhc2guanNcXFwiKTtcXG5cXG52YXIgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5qc1xcXCIpO1xcblxcbnZhciB0YWdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdGFnICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdGFnLmpzXFxcIik7XFxuXFxudmFyIHRyYW5zYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyYW5zYWN0aW9uICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb24uanNcXFwiKTtcXG5cXG52YXIgdHJpdHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJpdHMgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cml0cy5qc1xcXCIpO1xcblxcbnZhciB0cnl0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVzLmpzXFxcIik7XFxuXFxudmFyIHRyeXRlTnVtYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi8uLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVOdW1iZXIgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cnl0ZU51bWJlci5qc1xcXCIpO1xcblxcbnZhciBobWFjQ3VybF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2lnbi9obWFjQ3VybCAqLyBcXFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3Qvc2lnbi9obWFjQ3VybC5qc1xcXCIpO1xcblxcbnZhciBzaWduaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zaWduL3NpZ25pbmcgKi8gXFxcIi4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L3NpZ24vc2lnbmluZy5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEhlbHBlciBjbGFzcyBmb3Igc2lnbmluZyBidW5kbGVzLlxcclxcbiAqIENvbnZlcnRlZCBodHRwczovL2dpdGh1Yi5jb20vaW90YWxlZGdlci9pb3RhLmxpYi5qcy9ibG9iL21hc3Rlci9saWIvY3J5cHRvL3NpZ25pbmcvc2lnbmluZy5qc1xcclxcbiAqL1xcblxcblxcbnZhciBCdW5kbGVIZWxwZXIgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBCdW5kbGVIZWxwZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdW5kbGVIZWxwZXIpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKEJ1bmRsZUhlbHBlciwgbnVsbCwgW3tcXG4gICAga2V5OiBcXFwiaXNWYWxpZFxcXCIsXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBJcyB0aGUgYnVuZGxlIHZhbGlkLlxcclxcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUgdG8gY2hlY2sgZm9yIHZhbGlkaXR5LlxcclxcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBidW5kbGUgaXMgdmFsaWQuXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWxpZChidW5kbGUpIHtcXG4gICAgICB2YXIgaXNWYWxpZCA9IGZhbHNlO1xcblxcbiAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGJ1bmRsZSwgYnVuZGxlXzEuQnVuZGxlKSAmJiBhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYnVuZGxlLnRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbikpIHtcXG4gICAgICAgIHZhciB0b3RhbFN1bSA9IDA7XFxuICAgICAgICB2YXIga2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFxcXCJrZXJsXFxcIik7XFxuICAgICAgICBrZXJsLmluaXRpYWxpemUoKTsgLy8gUHJlcGFyZSBmb3Igc2lnbmF0dXJlIHZhbGlkYXRpb25cXG5cXG4gICAgICAgIHZhciBzaWduYXR1cmVzVG9WYWxpZGF0ZSA9IFtdO1xcbiAgICAgICAgaXNWYWxpZCA9IHRydWU7XFxuXFxuICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoICYmIGlzVmFsaWQ7IHQrKykge1xcbiAgICAgICAgICB2YXIgYnVuZGxlVHggPSBidW5kbGUudHJhbnNhY3Rpb25zW3RdO1xcbiAgICAgICAgICB0b3RhbFN1bSArPSBidW5kbGVUeC52YWx1ZS50b051bWJlcigpOyAvLyBjdXJyZW50SW5kZXggaGFzIHRvIGJlIGVxdWFsIHRvIHRoZSBpbmRleCBpbiB0aGUgYXJyYXlcXG5cXG4gICAgICAgICAgaWYgKGJ1bmRsZVR4LmN1cnJlbnRJbmRleC50b051bWJlcigpICE9PSB0KSB7XFxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdHJhbnNhY3Rpb24gdHJ5dGVzXFxuICAgICAgICAgICAgdmFyIHRoaXNUeFRyeXRlcyA9IGJ1bmRsZVR4LnRvVHJ5dGVzKCk7IC8vIEFic29yYiBidW5kbGUgaGFzaCArIHZhbHVlICsgdGltZXN0YW1wICsgbGFzdEluZGV4ICsgY3VycmVudEluZGV4IHRyeXRlcy5cXG5cXG4gICAgICAgICAgICB2YXIgdGhpc1R4VHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXModGhpc1R4VHJ5dGVzLnN1YihzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RILCAxNjIpKS50b0FycmF5KCk7XFxuICAgICAgICAgICAga2VybC5hYnNvcmIodGhpc1R4VHJpdHMsIDAsIHRoaXNUeFRyaXRzLmxlbmd0aCk7IC8vIENoZWNrIGlmIGlucHV0IHRyYW5zYWN0aW9uXFxuXFxuICAgICAgICAgICAgaWYgKGJ1bmRsZVR4LnZhbHVlLnRvTnVtYmVyKCkgPCAwKSB7XFxuICAgICAgICAgICAgICB2YXIgbmV3U2lnbmF0dXJlVG9WYWxpZGF0ZSA9IHtcXG4gICAgICAgICAgICAgICAgYWRkcmVzczogYnVuZGxlVHguYWRkcmVzcyxcXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50czogW2J1bmRsZVR4LnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF1cXG4gICAgICAgICAgICAgIH07IC8vIEZpbmQgdGhlIHN1YnNlcXVlbnQgdHhzIHdpdGggdGhlIHJlbWFpbmluZyBzaWduYXR1cmUgZnJhZ21lbnRcXG5cXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0OyBpIDwgYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGggLSAxOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIG5ld0J1bmRsZVR4ID0gYnVuZGxlLnRyYW5zYWN0aW9uc1tpICsgMV07IC8vIENoZWNrIGlmIG5ldyB0eCBpcyBwYXJ0IG9mIHRoZSBzaWduYXR1cmUgZnJhZ21lbnRcXG5cXG4gICAgICAgICAgICAgICAgaWYgKG5ld0J1bmRsZVR4LmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpID09PSBidW5kbGVUeC5hZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSAmJiBuZXdCdW5kbGVUeC52YWx1ZS50b051bWJlcigpID09PSAwKSB7XFxuICAgICAgICAgICAgICAgICAgbmV3U2lnbmF0dXJlVG9WYWxpZGF0ZS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLnB1c2gobmV3QnVuZGxlVHguc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlc1RvVmFsaWRhdGUucHVzaChuZXdTaWduYXR1cmVUb1ZhbGlkYXRlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gLy8gQ2hlY2sgZm9yIHRvdGFsIHN1bSwgaWYgbm90IGVxdWFsIDAgcmV0dXJuIGVycm9yXFxuXFxuXFxuICAgICAgICBpZiAodG90YWxTdW0gIT09IDApIHtcXG4gICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gZ2V0IHRoZSBidW5kbGUgaGFzaCBmcm9tIHRoZSBidW5kbGUgdHJhbnNhY3Rpb25zXFxuICAgICAgICAgIHZhciBidW5kbGVGcm9tVHhzID0gbmV3IEludDhBcnJheShrZXJsLmdldENvbnN0YW50cygpLkhBU0hfTEVOR1RIKTtcXG4gICAgICAgICAga2VybC5zcXVlZXplKGJ1bmRsZUZyb21UeHMsIDAsIGJ1bmRsZUZyb21UeHMubGVuZ3RoKTtcXG4gICAgICAgICAgdmFyIGJ1bmRsZUZyb21UeHNUcnl0ZXMgPSB0cml0c18xLlRyaXRzLmZyb21BcnJheShidW5kbGVGcm9tVHhzKS50b1RyeXRlcygpLnRvU3RyaW5nKCk7IC8vIENoZWNrIGlmIGJ1bmRsZSBoYXNoIGlzIHRoZSBzYW1lIGFzIHJldHVybmVkIGJ5IHR4IG9iamVjdFxcblxcbiAgICAgICAgICB2YXIgYnVuZGxlSGFzaCA9IGJ1bmRsZS50cmFuc2FjdGlvbnNbMF0uYnVuZGxlO1xcblxcbiAgICAgICAgICBpZiAoYnVuZGxlRnJvbVR4c1RyeXRlcyAhPT0gYnVuZGxlSGFzaC50b1RyeXRlcygpLnRvU3RyaW5nKCkpIHtcXG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy8gTGFzdCB0eCBpbiB0aGUgYnVuZGxlIHNob3VsZCBoYXZlIGN1cnJlbnRJbmRleCA9PT0gbGFzdEluZGV4XFxuICAgICAgICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnNbYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGggLSAxXS5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSAhPT0gYnVuZGxlLnRyYW5zYWN0aW9uc1tidW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLmxhc3RJbmRleC50b051bWJlcigpKSB7XFxuICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBzaWduYXR1cmVzXFxuICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc2lnbmF0dXJlc1RvVmFsaWRhdGUubGVuZ3RoICYmIGlzVmFsaWQ7IF9pKyspIHtcXG4gICAgICAgICAgICAgICAgdmFyIGlzVmFsaWRTaWduYXR1cmUgPSBzaWduaW5nXzEuU2lnbmluZy52YWxpZGF0ZVNpZ25hdHVyZXMoc2lnbmF0dXJlc1RvVmFsaWRhdGVbX2ldLmFkZHJlc3MsIHNpZ25hdHVyZXNUb1ZhbGlkYXRlW19pXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLCBidW5kbGVIYXNoKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKSB7XFxuICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBpc1ZhbGlkO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBWYWxpZGF0ZSBzaWduYXR1cmVzIGZvciBlYWNoIG9mIHRoZSBjby1zaWduZXJzIGluIHRoZSBtdWx0aS1zaWduYXR1cmUgdG8gaW5kZXBlbmRlbnRseSB2ZXJpZnkgdGhhdCBhIGdlbmVyYXRlZFxcclxcbiAgICAgKiB0cmFuc2FjdGlvbiB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHNpZ25hdHVyZXMgb2YgdGhlIGNvLXNpZ25lcnMgaXMgdmFsaWQuXFxyXFxuICAgICAqIEBwYXJhbSBzaWduZWRCdW5kbGUgVGhlIHNpZ25lZCBidW5kbGUgdG8gY2hlY2sgdGhlIHNpZ25hdHVyZXMuXFxyXFxuICAgICAqIEBwYXJhbSBpbnB1dEFkZHJlc3MgVGhlIGFkZHJlc3MgdXNlZCB0byBpbml0aWF0ZSB0aGUgdHJhbnNmZXIuXFxyXFxuICAgICAqIEByZXR1cm5zIFRydWUgaXMgdGhlIHNpZ25hdHVyZXMgYXJlIHZhbGlkLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidmFsaWRhdGVTaWduYXR1cmVzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlU2lnbmF0dXJlcyhzaWduZWRCdW5kbGUsIGlucHV0QWRkcmVzcykge1xcbiAgICAgIHZhciBpc1ZhbGlkID0gZmFsc2U7XFxuXFxuICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2lnbmVkQnVuZGxlLCBidW5kbGVfMS5CdW5kbGUpICYmIGFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChzaWduZWRCdW5kbGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKSAmJiBvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGlucHV0QWRkcmVzcywgYWRkcmVzc18xLkFkZHJlc3MpKSB7XFxuICAgICAgICB2YXIgYnVuZGxlSGFzaDtcXG4gICAgICAgIHZhciBzaWduYXR1cmVGcmFnbWVudHMgPSBbXTtcXG4gICAgICAgIHZhciBpbnB1dEFkZHJlc3NUcnl0ZXMgPSBpbnB1dEFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcblxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduZWRCdW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIGlmIChzaWduZWRCdW5kbGUudHJhbnNhY3Rpb25zW2ldLmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpID09PSBpbnB1dEFkZHJlc3NUcnl0ZXMpIHtcXG4gICAgICAgICAgICBidW5kbGVIYXNoID0gc2lnbmVkQnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5idW5kbGU7IC8vIGlmIHdlIHJlYWNoZWQgcmVtYWluZGVyIGJ1bmRsZVxcblxcbiAgICAgICAgICAgIGlmIChzaWduZWRCdW5kbGUudHJhbnNhY3Rpb25zW2ldLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5FTVBUWS50b1RyeXRlcygpLnRvU3RyaW5nKCkpIHtcXG4gICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBzaWduYXR1cmVGcmFnbWVudHMucHVzaChzaWduZWRCdW5kbGUudHJhbnNhY3Rpb25zW2ldLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChidW5kbGVIYXNoKSB7XFxuICAgICAgICAgIGlzVmFsaWQgPSBzaWduaW5nXzEuU2lnbmluZy52YWxpZGF0ZVNpZ25hdHVyZXMoaW5wdXRBZGRyZXNzLCBzaWduYXR1cmVGcmFnbWVudHMsIGJ1bmRsZUhhc2gpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gaXNWYWxpZDtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwcmVwYXJlQnVuZGxlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVCdW5kbGUodGltZVNlcnZpY2UsIHRyYW5zZmVycykge1xcbiAgICAgIHZhciBidW5kbGUgPSBuZXcgYnVuZGxlXzEuQnVuZGxlKCk7XFxuICAgICAgdmFyIGxhc3RUYWc7XFxuICAgICAgdmFyIHRvdGFsVmFsdWUgPSAwO1xcbiAgICAgIHZhciBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzID0gW107IC8vICBJdGVyYXRlIG92ZXIgYWxsIHRyYW5zZmVycywgZ2V0IHRvdGFsVmFsdWVcXG4gICAgICAvLyAgYW5kIHByZXBhcmUgdGhlIE1lc3NhZ2VzLCBtZXNzYWdlIGFuZCB0YWdcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZmVycy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIHNpZ25hdHVyZU1lc3NhZ2VMZW5ndGggPSAxOyAvLyBJZiBtZXNzYWdlIGxvbmdlciB0aGFuIDIxODcgdHJ5dGVzLCBpbmNyZWFzZSBzaWduYXR1cmVNZXNzYWdlTGVuZ3RoIChhZGQgMm5kIHRyYW5zYWN0aW9uKVxcblxcbiAgICAgICAgdmFyIG1lc3NhZ2VTdHJpbmcgPSB0cmFuc2ZlcnNbaV0ubWVzc2FnZS50b1N0cmluZygpO1xcblxcbiAgICAgICAgaWYgKG1lc3NhZ2VTdHJpbmcubGVuZ3RoID4gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCkge1xcbiAgICAgICAgICAvLyBHZXQgdG90YWwgbGVuZ3RoLCBtZXNzYWdlIC8gbWF4TGVuZ3RoICgyMTg3IHRyeXRlcylcXG4gICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUxlbmd0aCArPSBNYXRoLmZsb29yKG1lc3NhZ2VTdHJpbmcubGVuZ3RoIC8gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCk7XFxuICAgICAgICAgIHZhciBtc2dDb3B5ID0gbWVzc2FnZVN0cmluZzsgLy8gV2hpbGUgdGhlcmUgaXMgc3RpbGwgYSBtZXNzYWdlLCBjb3B5IGl0XFxuXFxuICAgICAgICAgIHdoaWxlIChtc2dDb3B5KSB7XFxuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gbXNnQ29weS5zbGljZSgwLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIKTtcXG4gICAgICAgICAgICBtc2dDb3B5ID0gbXNnQ29weS5zbGljZShzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RILCBtc2dDb3B5Lmxlbmd0aCk7IC8vIFBhZCByZW1haW5kZXIgb2YgZnJhZ21lbnRcXG5cXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgZnJhZ21lbnQubGVuZ3RoIDwgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSDsgaisrKSB7XFxuICAgICAgICAgICAgICBmcmFnbWVudCArPSBcXFwiOVxcXCI7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMucHVzaChzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhmcmFnbWVudCkpKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgLy8gRWxzZSwgZ2V0IHNpbmdsZSBmcmFnbWVudCB3aXRoIDIxODcgb2YgOSdzIHRyeXRlc1xcbiAgICAgICAgICB2YXIgX2ZyYWdtZW50ID0gXFxcIlxcXCI7XFxuXFxuICAgICAgICAgIGlmIChtZXNzYWdlU3RyaW5nKSB7XFxuICAgICAgICAgICAgX2ZyYWdtZW50ID0gbWVzc2FnZVN0cmluZy5zbGljZSgwLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9mcmFnbWVudC5sZW5ndGggPCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIOyBfaisrKSB7XFxuICAgICAgICAgICAgX2ZyYWdtZW50ICs9IFxcXCI5XFxcIjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLnB1c2goc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoX2ZyYWdtZW50KSkpO1xcbiAgICAgICAgfSAvLyBnZXQgY3VycmVudCB0aW1lc3RhbXAgaW4gc2Vjb25kc1xcblxcblxcbiAgICAgICAgdmFyIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IodGltZVNlcnZpY2UubXNTaW5jZUVwb2NoKCkgLyAxMDAwKTtcXG4gICAgICAgIGxhc3RUYWcgPSB0cmFuc2ZlcnNbaV0udGFnOyAvLyBBZGQgZmlyc3QgZW50cmllcyB0byB0aGUgYnVuZGxlXFxuXFxuICAgICAgICBidW5kbGUuYWRkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZU1lc3NhZ2VMZW5ndGgsIHRyYW5zZmVyc1tpXS5hZGRyZXNzLCB0cmFuc2ZlcnNbaV0udmFsdWUsIHRyYW5zZmVyc1tpXS50YWcsIHRpbWVzdGFtcCk7IC8vIFN1bSB1cCB0b3RhbCB2YWx1ZVxcblxcbiAgICAgICAgdG90YWxWYWx1ZSArPSB0cmFuc2ZlcnNbaV0udmFsdWU7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBidW5kbGU6IGJ1bmRsZSxcXG4gICAgICAgIHRvdGFsVmFsdWU6IHRvdGFsVmFsdWUsXFxuICAgICAgICBsYXN0VGFnOiBsYXN0VGFnLFxcbiAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50czogc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50c1xcbiAgICAgIH07XFxuICAgIH1cXG4gICAgLyogQGludGVybmFsICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNpZ25JbnB1dHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbklucHV0cyhzZWVkLCBidW5kbGUsIHRyYW5zZmVyT3B0aW9ucywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgaW5wdXRzLCBhZGRlZEhNQUMpIHtcXG4gICAgICBCdW5kbGVIZWxwZXIuZmluYWxpemVCdW5kbGUoYnVuZGxlKTtcXG4gICAgICBidW5kbGUuYWRkU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzKTsgLy8gIEhlcmUgd2UgZG8gdGhlIGFjdHVhbCBzaWduaW5nIG9mIHRoZSBpbnB1dHNcXG4gICAgICAvLyAgSXRlcmF0ZSBvdmVyIGFsbCBidW5kbGUgdHJhbnNhY3Rpb25zLCBmaW5kIHRoZSBpbnB1dHNcXG4gICAgICAvLyAgR2V0IHRoZSBjb3JyZXNwb25kaW5nIHByaXZhdGUga2V5IGFuZCBjYWxjdWxhdGUgdGhlIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFxcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0udmFsdWUudG9OdW1iZXIoKSA8IDApIHtcXG4gICAgICAgICAgdmFyIGFkZHJlc3NUcnl0ZXMgPSBidW5kbGUudHJhbnNhY3Rpb25zW2ldLmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpOyAvLyBHZXQgdGhlIGNvcnJlc3BvbmRpbmcga2V5SW5kZXggYW5kIHNlY3VyaXR5IG9mIHRoZSBhZGRyZXNzXFxuXFxuICAgICAgICAgIHZhciBrZXlJbmRleCA9IHZvaWQgMDtcXG4gICAgICAgICAgdmFyIGtleVNlY3VyaXR5ID0gdm9pZCAwO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsrKykge1xcbiAgICAgICAgICAgIGlmIChpbnB1dHNba10uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IGFkZHJlc3NUcnl0ZXMpIHtcXG4gICAgICAgICAgICAgIGtleUluZGV4ID0gaW5wdXRzW2tdLmtleUluZGV4O1xcbiAgICAgICAgICAgICAga2V5U2VjdXJpdHkgPSBpbnB1dHNba10uc2VjdXJpdHkgPyBpbnB1dHNba10uc2VjdXJpdHkgOiB0cmFuc2Zlck9wdGlvbnMuc2VjdXJpdHk7XFxuICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gLy8gR2V0IGNvcnJlc3BvbmRpbmcgcHJpdmF0ZSBrZXkgb2YgYWRkcmVzc1xcblxcblxcbiAgICAgICAgICB2YXIga2V5ID0gc2lnbmluZ18xLlNpZ25pbmcua2V5KHNlZWQsIGtleUluZGV4LCBrZXlTZWN1cml0eSk7XFxuICAgICAgICAgIEJ1bmRsZUhlbHBlci5zaWduVHJhbnNhY3Rpb25zKGJ1bmRsZSwgaSwgMCwga2V5LCBhZGRyZXNzVHJ5dGVzLCBrZXlTZWN1cml0eSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChhZGRlZEhNQUMpIHtcXG4gICAgICAgIHZhciBobWFjID0gbmV3IGhtYWNDdXJsXzEuSG1hY0N1cmwodHJhbnNmZXJPcHRpb25zLmhtYWNLZXkpO1xcbiAgICAgICAgaG1hYy5hZGRITUFDKGJ1bmRsZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzaWduVHJhbnNhY3Rpb25zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbnMoYnVuZGxlLCBpbmRleCwgZmlyc3RVbnNpZ25lZEluZGV4LCBrZXlUcml0cywgYWRkcmVzc1RyeXRlcywgc2VjdXJpdHkpIHtcXG4gICAgICB2YXIgYnVuZGxlSGFzaCA9IGJ1bmRsZS50cmFuc2FjdGlvbnNbaW5kZXhdLmJ1bmRsZTsgLy8gIEdldCB0aGUgbm9ybWFsaXplZCBidW5kbGUgaGFzaFxcblxcbiAgICAgIHZhciBub3JtYWxpemVkQnVuZGxlSGFzaCA9IEJ1bmRsZUhlbHBlci5ub3JtYWxpemVkSGFzaChidW5kbGVIYXNoKTtcXG4gICAgICB2YXIgbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50cyA9IFtdOyAvLyBTcGxpdCBoYXNoIGludG8gMyBmcmFnbWVudHNcXG5cXG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IDM7IGwrKykge1xcbiAgICAgICAgbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50c1tsXSA9IG5vcm1hbGl6ZWRCdW5kbGVIYXNoLnNsaWNlKGwgKiAyNywgKGwgKyAxKSAqIDI3KTtcXG4gICAgICB9IC8vICBGaXJzdCA2NTYxIHRyaXRzIGZvciB0aGUgZmlyc3RGcmFnbWVudFxcblxcblxcbiAgICAgIHZhciBmaXJzdEZyYWdtZW50ID0ga2V5VHJpdHMuc2xpY2UoMCwgNjU2MSk7IC8vICBGaXJzdCBidW5kbGUgZnJhZ21lbnQgdXNlcyB0aGUgZmlyc3QgMjcgdHJ5dGVzXFxuXFxuICAgICAgdmFyIGZpcnN0QnVuZGxlRnJhZ21lbnQgPSBub3JtYWxpemVkQnVuZGxlRnJhZ21lbnRzW2ZpcnN0VW5zaWduZWRJbmRleF07IC8vICBDYWxjdWxhdGUgdGhlIG5ldyBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgd2l0aCB0aGUgZmlyc3QgYnVuZGxlIGZyYWdtZW50XFxuXFxuICAgICAgdmFyIGZpcnN0U2lnbmVkRnJhZ21lbnQgPSBCdW5kbGVIZWxwZXIuc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KGZpcnN0QnVuZGxlRnJhZ21lbnQsIGZpcnN0RnJhZ21lbnQpOyAvLyAgQ29udmVydCBzaWduYXR1cmUgdG8gdHJ5dGVzIGFuZCBhc3NpZ24gdGhlIG5ldyBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRcXG5cXG4gICAgICBidW5kbGUudHJhbnNhY3Rpb25zW2luZGV4XS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuZnJvbVRyeXRlcyh0cml0c18xLlRyaXRzLmZyb21BcnJheShmaXJzdFNpZ25lZEZyYWdtZW50KS50b1RyeXRlcygpKTsgLy8gaWYgdXNlciBjaG9vc2VzIGhpZ2hlciB0aGFuIDI3LXRyeXRlIHNlY3VyaXR5XFxuICAgICAgLy8gZm9yIGVhY2ggc2VjdXJpdHkgbGV2ZWwsIGFkZCBhbiBhZGRpdGlvbmFsIHNpZ25hdHVyZVxcblxcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgc2VjdXJpdHk7IGorKykge1xcbiAgICAgICAgLy8gIEJlY2F1c2UgdGhlIHNpZ25hdHVyZSBpcyA+IDIxODcgdHJ5dGVzLCB3ZSBuZWVkIHRvXFxuICAgICAgICAvLyAgZmluZCB0aGUgc3Vic2VxdWVudCB0cmFuc2FjdGlvbiB0byBhZGQgdGhlIHJlbWFpbmRlciBvZiB0aGUgc2lnbmF0dXJlXFxuICAgICAgICAvLyAgU2FtZSBhZGRyZXNzIGFzIHdlbGwgYXMgdmFsdWUgPSAwIChhcyB3ZSBhbHJlYWR5IHNwZW50IHRoZSBpbnB1dClcXG4gICAgICAgIGlmIChidW5kbGUudHJhbnNhY3Rpb25zW2luZGV4ICsgal0uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IGFkZHJlc3NUcnl0ZXMgJiYgYnVuZGxlLnRyYW5zYWN0aW9uc1tpbmRleCArIGpdLnZhbHVlLnRvTnVtYmVyKCkgPT09IDApIHtcXG4gICAgICAgICAgLy8gVXNlIHRoZSBuZXh0IDY1NjEgdHJpdHNcXG4gICAgICAgICAgdmFyIG5leHRGcmFnbWVudCA9IGtleVRyaXRzLnNsaWNlKDY1NjEgKiBqLCAoaiArIDEpICogNjU2MSk7XFxuICAgICAgICAgIHZhciBuZXh0QnVuZGxlRnJhZ21lbnQgPSBub3JtYWxpemVkQnVuZGxlRnJhZ21lbnRzW2pdOyAvLyAgQ2FsY3VsYXRlIHRoZSBuZXcgc2lnbmF0dXJlXFxuXFxuICAgICAgICAgIHZhciBuZXh0U2lnbmVkRnJhZ21lbnQgPSBCdW5kbGVIZWxwZXIuc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KG5leHRCdW5kbGVGcmFnbWVudCwgbmV4dEZyYWdtZW50KTsgLy8gIENvbnZlcnQgc2lnbmF0dXJlIHRvIHRyeXRlcyBhbmQgYXNzaWduIGl0IGFnYWluIHRvIHRoaXMgYnVuZGxlIGVudHJ5XFxuXFxuICAgICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnNbaW5kZXggKyBqXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuZnJvbVRyeXRlcyh0cml0c18xLlRyaXRzLmZyb21BcnJheShuZXh0U2lnbmVkRnJhZ21lbnQpLnRvVHJ5dGVzKCkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZmluYWxpemVCdW5kbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluYWxpemVCdW5kbGUoYnVuZGxlKSB7XFxuICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoID4gMCkge1xcbiAgICAgICAgdmFyIHZhbGlkQnVuZGxlID0gZmFsc2U7XFxuXFxuICAgICAgICB3aGlsZSAoIXZhbGlkQnVuZGxlKSB7XFxuICAgICAgICAgIHZhciBrZXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXFxcImtlcmxcXFwiKTtcXG4gICAgICAgICAga2VybC5pbml0aWFsaXplKCk7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uY3VycmVudEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKGkpO1xcbiAgICAgICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0ubGFzdEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoIC0gMSk7XFxuICAgICAgICAgICAgdmFyIGJ1bmRsZUVzc2VuY2UgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5hZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSArIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0udmFsdWUudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5DSEVDS19WQUxVRSArIGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0ub2Jzb2xldGVUYWcudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS50aW1lc3RhbXAudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5jdXJyZW50SW5kZXgudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5sYXN0SW5kZXgudG9Ucnl0ZXMoKS50b1N0cmluZygpKSkudG9BcnJheSgpO1xcbiAgICAgICAgICAgIGtlcmwuYWJzb3JiKGJ1bmRsZUVzc2VuY2UsIDAsIGJ1bmRsZUVzc2VuY2UubGVuZ3RoKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgaGFzaFRyaXRzID0gbmV3IEludDhBcnJheShrZXJsLmdldENvbnN0YW50cygpLkhBU0hfTEVOR1RIKTtcXG4gICAgICAgICAga2VybC5zcXVlZXplKGhhc2hUcml0cywgMCwgaGFzaFRyaXRzLmxlbmd0aCk7XFxuICAgICAgICAgIHZhciBoYXNoID0gaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cml0c18xLlRyaXRzLmZyb21BcnJheShoYXNoVHJpdHMpLnRvVHJ5dGVzKCkpO1xcblxcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBidW5kbGUudHJhbnNhY3Rpb25zLmxlbmd0aDsgX2kyKyspIHtcXG4gICAgICAgICAgICBidW5kbGUudHJhbnNhY3Rpb25zW19pMl0uYnVuZGxlID0gaGFzaDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgbm9ybWFsaXplZEhhc2ggPSB0aGlzLm5vcm1hbGl6ZWRIYXNoKGhhc2gpO1xcblxcbiAgICAgICAgICBpZiAobm9ybWFsaXplZEhhc2guaW5kZXhPZigxM1xcbiAgICAgICAgICAvKiA9IE0gKi9cXG4gICAgICAgICAgKSAhPT0gLTEpIHtcXG4gICAgICAgICAgICAvLyBJbnNlY3VyZSBidW5kbGUuIEluY3JlbWVudCBUYWcgYW5kIHJlY29tcHV0ZSBidW5kbGUgaGFzaC5cXG4gICAgICAgICAgICB2YXIgaW5jcmVhc2VkVGFnID0gdHJpdHNfMS5Ucml0cy5hZGQodHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKGJ1bmRsZS50cmFuc2FjdGlvbnNbMF0ub2Jzb2xldGVUYWcudG9Ucnl0ZXMoKSksIHRyaXRzXzEuVHJpdHMuZnJvbU51bWJlckFycmF5KFsxXSkpO1xcbiAgICAgICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnNbMF0ub2Jzb2xldGVUYWcgPSB0YWdfMS5UYWcuZnJvbVRyeXRlcyhpbmNyZWFzZWRUYWcudG9Ucnl0ZXMoKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFsaWRCdW5kbGUgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJub3JtYWxpemVkSGFzaFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemVkSGFzaChidW5kbGVIYXNoKSB7XFxuICAgICAgdmFyIG5vcm1hbGl6ZWRCdW5kbGUgPSBuZXcgSW50OEFycmF5KDQgKiAyNyk7XFxuICAgICAgdmFyIGhhc2hTdHJpbmcgPSBidW5kbGVIYXNoLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xcbiAgICAgICAgdmFyIHN1bSA9IDA7XFxuXFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI3OyBqKyspIHtcXG4gICAgICAgICAgdmFyIGhhc2hDaGFyID0gaGFzaFN0cmluZy5jaGFyQXQoaSAqIDI3ICsgaik7XFxuICAgICAgICAgIHZhciB2YWwgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoaGFzaENoYXIpKS50b051bWJlcigpO1xcbiAgICAgICAgICBub3JtYWxpemVkQnVuZGxlW2kgKiAyNyArIGpdID0gdmFsO1xcbiAgICAgICAgICBzdW0gKz0gdmFsO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHN1bSA+PSAwKSB7XFxuICAgICAgICAgIHdoaWxlIChzdW0tLSA+IDApIHtcXG4gICAgICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCAyNzsgX2oyKyspIHtcXG4gICAgICAgICAgICAgIGlmIChub3JtYWxpemVkQnVuZGxlW2kgKiAyNyArIF9qMl0gPiAtMTMpIHtcXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEJ1bmRsZVtpICogMjcgKyBfajJdLS07XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgd2hpbGUgKHN1bSsrIDwgMCkge1xcbiAgICAgICAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IDI3OyBfajMrKykge1xcbiAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRCdW5kbGVbaSAqIDI3ICsgX2ozXSA8IDEzKSB7XFxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRCdW5kbGVbaSAqIDI3ICsgX2ozXSsrO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRCdW5kbGU7XFxuICAgIH1cXG4gICAgLyogQGludGVybmFsICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImRpZ2VzdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaWdlc3Qobm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50LCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRUcml0cykge1xcbiAgICAgIHZhciBidWZmZXI7XFxuICAgICAgdmFyIGtlcmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcXFwia2VybFxcXCIpO1xcbiAgICAgIGtlcmwuaW5pdGlhbGl6ZSgpO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjc7IGkrKykge1xcbiAgICAgICAgYnVmZmVyID0gbmV3IEludDhBcnJheShzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRUcml0cy5zbGljZShpICogMjQzLCAoaSArIDEpICogMjQzKSk7XFxuXFxuICAgICAgICBmb3IgKHZhciBqID0gbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50W2ldICsgMTM7IGotLSA+IDA7KSB7XFxuICAgICAgICAgIHZhciBqS2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFxcXCJrZXJsXFxcIik7XFxuICAgICAgICAgIGpLZXJsLmluaXRpYWxpemUoKTtcXG4gICAgICAgICAgaktlcmwuYWJzb3JiKGJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCk7XFxuICAgICAgICAgIGpLZXJsLnNxdWVlemUoYnVmZmVyLCAwLCBqS2VybC5nZXRDb25zdGFudHMoKS5IQVNIX0xFTkdUSCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBrZXJsLmFic29yYihidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBrZXJsLnNxdWVlemUoYnVmZmVyLCAwLCBrZXJsLmdldENvbnN0YW50cygpLkhBU0hfTEVOR1RIKTtcXG4gICAgICByZXR1cm4gYnVmZmVyO1xcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhZGRyZXNzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZHJlc3MoZGlnZXN0cykge1xcbiAgICAgIHZhciBrZXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXFxcImtlcmxcXFwiKTtcXG4gICAgICBrZXJsLmluaXRpYWxpemUoKTtcXG4gICAgICBrZXJsLmFic29yYihkaWdlc3RzLCAwLCBkaWdlc3RzLmxlbmd0aCk7XFxuICAgICAgdmFyIGFkZHJlc3NUcml0cyA9IG5ldyBJbnQ4QXJyYXkoa2VybC5nZXRDb25zdGFudHMoKS5IQVNIX0xFTkdUSCk7XFxuICAgICAga2VybC5zcXVlZXplKGFkZHJlc3NUcml0cywgMCwgYWRkcmVzc1RyaXRzLmxlbmd0aCk7XFxuICAgICAgcmV0dXJuIGFkZHJlc3NUcml0cztcXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidHJhbnNhY3Rpb25IYXNoXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zYWN0aW9uSGFzaCh0cmFuc2FjdGlvbikge1xcbiAgICAgIHZhciBjdXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXFxcImN1cmxcXFwiKTtcXG4gICAgICB2YXIgdHJhbnNhY3Rpb25Ucml0cyA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyh0cmFuc2FjdGlvbi50b1RyeXRlcygpKS50b0FycmF5KCk7XFxuICAgICAgY3VybC5pbml0aWFsaXplKCk7XFxuICAgICAgY3VybC5hYnNvcmIodHJhbnNhY3Rpb25Ucml0cywgMCwgdHJhbnNhY3Rpb25Ucml0cy5sZW5ndGgpO1xcbiAgICAgIHZhciBoYXNoVHJpdHMgPSBuZXcgSW50OEFycmF5KGN1cmwuZ2V0Q29uc3RhbnRzKCkuSEFTSF9MRU5HVEgpO1xcbiAgICAgIGN1cmwuc3F1ZWV6ZShoYXNoVHJpdHMsIDAsIGhhc2hUcml0cy5sZW5ndGgpO1xcbiAgICAgIHJldHVybiBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGhhc2hUcml0cykudG9Ucnl0ZXMoKSk7XFxuICAgIH1cXG4gICAgLyogQGludGVybmFsICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQobm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50LCBrZXlGcmFnbWVudCkge1xcbiAgICAgIHZhciBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSBrZXlGcmFnbWVudC5zbGljZSgpO1xcbiAgICAgIHZhciBoYXNoO1xcbiAgICAgIHZhciBrZXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXFxcImtlcmxcXFwiKTtcXG4gICAgICB2YXIgaGFzaExlbmd0aCA9IGtlcmwuZ2V0Q29uc3RhbnRzKCkuSEFTSF9MRU5HVEg7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNzsgaSsrKSB7XFxuICAgICAgICBoYXNoID0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LnNsaWNlKGkgKiBoYXNoTGVuZ3RoLCAoaSArIDEpICogaGFzaExlbmd0aCk7XFxuXFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDEzIC0gbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50W2ldOyBqKyspIHtcXG4gICAgICAgICAga2VybC5pbml0aWFsaXplKCk7XFxuICAgICAgICAgIGtlcmwucmVzZXQoKTtcXG4gICAgICAgICAga2VybC5hYnNvcmIoaGFzaCwgMCwgaGFzaExlbmd0aCk7XFxuICAgICAgICAgIGtlcmwuc3F1ZWV6ZShoYXNoLCAwLCBoYXNoTGVuZ3RoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAodmFyIF9qNCA9IDA7IF9qNCA8IGhhc2hMZW5ndGg7IF9qNCsrKSB7XFxuICAgICAgICAgIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFtpICogaGFzaExlbmd0aCArIF9qNF0gPSBoYXNoW19qNF07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQ7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBCdW5kbGVIZWxwZXI7XFxufSgpO1xcblxcbmV4cG9ydHMuQnVuZGxlSGVscGVyID0gQnVuZGxlSGVscGVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvaGVscGVycy9idW5kbGVIZWxwZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX19leHBvcnQobSkge1xcbiAgZm9yICh2YXIgcCBpbiBtKSB7XFxuICAgIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XFxuICB9XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogQ29tYmluZWQgaW5kZXggb2YgYWxsIHRoZSBtb2R1bGVzLlxcclxcbiAqL1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3IvYnVzaW5lc3NFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvZXJyb3IvYnVzaW5lc3NFcnJvci5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hlbHBlcnMvYnVuZGxlSGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9oZWxwZXJzL2J1bmRsZUhlbHBlci5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL211bHRpU2lnL211bHRpU2lnQWRkcmVzcyAqLyBcXFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvbXVsdGlTaWcvbXVsdGlTaWdBZGRyZXNzLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbXVsdGlTaWcvbXVsdGlTaWdDbGllbnQgKi8gXFxcIi4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L211bHRpU2lnL211bHRpU2lnQ2xpZW50LmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2lnbi9zaWduaW5nICovIFxcXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9zaWduL3NpZ25pbmcuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zaWduL2htYWNDdXJsICovIFxcXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9zaWduL2htYWNDdXJsLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNhY3Rpb25zL3RyYW5zYWN0aW9uQ2xpZW50ICovIFxcXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC90cmFuc2FjdGlvbnMvdHJhbnNhY3Rpb25DbGllbnQuanNcXFwiKSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L211bHRpU2lnL211bHRpU2lnQWRkcmVzcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvbXVsdGlTaWcvbXVsdGlTaWdBZGRyZXNzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIGFycmF5SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBzcG9uZ2VGYWN0b3J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NyeXB0by9kaXN0L2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5ICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnkuanNcXFwiKTtcXG5cXG52YXIgYWRkcmVzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvYWRkcmVzcy5qc1xcXCIpO1xcblxcbnZhciB0cml0c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0cyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyaXRzLmpzXFxcIik7XFxuXFxudmFyIHRyeXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cnl0ZXMgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cnl0ZXMuanNcXFwiKTtcXG5cXG52YXIgYnVzaW5lc3NFcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3IvYnVzaW5lc3NFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvZXJyb3IvYnVzaW5lc3NFcnJvci5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEFkZHJlc3MgdXNpbmcgbXVsdGlwbGUgc2lnbmF0dXJlcy5cXHJcXG4gKi9cXG5cXG5cXG52YXIgTXVsdGlTaWdBZGRyZXNzID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIE11bHRpU2lnQWRkcmVzcy5cXHJcXG4gICAqL1xcbiAgZnVuY3Rpb24gTXVsdGlTaWdBZGRyZXNzKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTXVsdGlTaWdBZGRyZXNzKTtcXG5cXG4gICAgdGhpcy5fa2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFxcXCJrZXJsXFxcIik7XFxuICAgIHRoaXMuX2hhc2hMZW5ndGggPSB0aGlzLl9rZXJsLmdldENvbnN0YW50cygpLkhBU0hfTEVOR1RIO1xcblxcbiAgICB0aGlzLl9rZXJsLmluaXRpYWxpemUoKTtcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogQWJzb3JiIGtleSBkaWdlc3RzLlxcclxcbiAgICogQHBhcmFtIGRpZ2VzdHMgVGhlIGRpZ2VzdHMgaGFzaGVzIHRvIGFic29yYi5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKE11bHRpU2lnQWRkcmVzcywgW3tcXG4gICAga2V5OiBcXFwiYWJzb3JiXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFic29yYihkaWdlc3RzKSB7XFxuICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoZGlnZXN0cywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgZGlnZXN0cyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgdHlwZSBUcnl0ZXNcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWdlc3RzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgZGlnZXN0VHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoZGlnZXN0c1tpXSkudG9BcnJheSgpO1xcblxcbiAgICAgICAgdGhpcy5fa2VybC5hYnNvcmIoZGlnZXN0VHJpdHMsIDAsIGRpZ2VzdFRyaXRzLmxlbmd0aCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBGaW5hbGl6ZXMgYW5kIHJldHVybnMgdGhlIG11bHRpc2lnIGFkZHJlc3MgaW4gdHJ5dGVzLlxcclxcbiAgICAgKiBAcGFyYW0gZGlnZXN0cyBUaGUgZmluYWwgZGlnZXN0cyBoYXNoZXMgdG8gYWJzb3JiLlxcclxcbiAgICAgKiBAcmV0dXJucyBUaGUgbXVsdGkgc2lnbmF0dXJlIGFkZHJlc3MuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJmaW5hbGl6ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZShkaWdlc3RzKSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShkaWdlc3RzKSkge1xcbiAgICAgICAgdGhpcy5hYnNvcmIoZGlnZXN0cyk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBhZGRyZXNzVHJpdHMgPSBuZXcgSW50OEFycmF5KHRoaXMuX2hhc2hMZW5ndGgpO1xcblxcbiAgICAgIHRoaXMuX2tlcmwuc3F1ZWV6ZShhZGRyZXNzVHJpdHMsIDAsIGFkZHJlc3NUcml0cy5sZW5ndGgpO1xcblxcbiAgICAgIHJldHVybiBhZGRyZXNzXzEuQWRkcmVzcy5mcm9tVHJ5dGVzKHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGFkZHJlc3NUcml0cykudG9Ucnl0ZXMoKSk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBNdWx0aVNpZ0FkZHJlc3M7XFxufSgpO1xcblxcbmV4cG9ydHMuTXVsdGlTaWdBZGRyZXNzID0gTXVsdGlTaWdBZGRyZXNzO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvbXVsdGlTaWcvbXVsdGlTaWdBZGRyZXNzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvbXVsdGlTaWcvbXVsdGlTaWdDbGllbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvbXVsdGlTaWcvbXVsdGlTaWdDbGllbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfcmVnZW5lcmF0b3JSdW50aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IgKi8gXFxcIi4uL2lvdGEtcGljby1idXNpbmVzcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfSBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBzdGVwKFxcXCJuZXh0XFxcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgc3RlcChcXFwidGhyb3dcXFwiLCBlcnIpOyB9IF9uZXh0KCk7IH0pOyB9OyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIGFycmF5SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgbnVtYmVySGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBvYmplY3RIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIHRpbWVTZXJ2aWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9zZXJ2aWNlcy90aW1lU2VydmljZSAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9zZXJ2aWNlcy90aW1lU2VydmljZS5qc1xcXCIpO1xcblxcbnZhciBhZGRyZXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2FkZHJlc3MgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzLmpzXFxcIik7XFxuXFxudmFyIGJ1bmRsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9idW5kbGUgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9idW5kbGUuanNcXFwiKTtcXG5cXG52YXIgaGFzaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9oYXNoICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvaGFzaC5qc1xcXCIpO1xcblxcbnZhciBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmpzXFxcIik7XFxuXFxudmFyIHRhZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90YWcgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90YWcuanNcXFwiKTtcXG5cXG52YXIgdHJhbnNhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb24gKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cmFuc2FjdGlvbi5qc1xcXCIpO1xcblxcbnZhciB0cmFuc2Zlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cmFuc2ZlciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyYW5zZmVyLmpzXFxcIik7XFxuXFxudmFyIHRyaXRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyaXRzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJpdHMuanNcXFwiKTtcXG5cXG52YXIgdHJ5dGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1xcXCIpO1xcblxcbnZhciBidXNpbmVzc0Vycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvci9idXNpbmVzc0Vycm9yICovIFxcXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9lcnJvci9idXNpbmVzc0Vycm9yLmpzXFxcIik7XFxuXFxudmFyIGJ1bmRsZUhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaGVscGVycy9idW5kbGVIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L2hlbHBlcnMvYnVuZGxlSGVscGVyLmpzXFxcIik7XFxuXFxudmFyIHNpZ25pbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NpZ24vc2lnbmluZyAqLyBcXFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3Qvc2lnbi9zaWduaW5nLmpzXFxcIik7XFxuXFxudmFyIG11bHRpU2lnQWRkcmVzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tdWx0aVNpZ0FkZHJlc3MgKi8gXFxcIi4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L211bHRpU2lnL211bHRpU2lnQWRkcmVzcy5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIE11bHRpcGxlIHNpZ25hdHVyZXMuXFxyXFxuICogQ29udmVydGVkIGh0dHBzOi8vZ2l0aHViLmNvbS9pb3RhbGVkZ2VyL2lvdGEubGliLmpzL2Jsb2IvbWFzdGVyL2xpYi9tdWx0aXNpZy9tdWx0aXNpZy5qc1xcclxcbiAqL1xcblxcblxcbnZhciBNdWx0aVNpZ0NsaWVudCA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qKlxcclxcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBNdWx0aVNpZ0NsaWVudC5cXHJcXG4gICAqIEBwYXJhbSBhcGlDbGllbnQgQW4gQVBJIENsaWVudCB0byBjb21tdW5pY2F0ZSB0aHJvdWdoLlxcclxcbiAgICogQHBhcmFtIHRpbWVTZXJ2aWNlIEEgY2xhc3Mgd2hpY2ggY2FuIHByb3ZpZGUgdGhlIHRpbWUuXFxyXFxuICAgKi9cXG4gIGZ1bmN0aW9uIE11bHRpU2lnQ2xpZW50KGFwaUNsaWVudCkge1xcbiAgICB2YXIgdGltZVNlcnZpY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5ldyB0aW1lU2VydmljZV8xLlRpbWVTZXJ2aWNlKCk7XFxuXFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNdWx0aVNpZ0NsaWVudCk7XFxuXFxuICAgIHRoaXMuX2FwaUNsaWVudCA9IGFwaUNsaWVudDtcXG4gICAgdGhpcy5fdGltZVNlcnZpY2UgPSB0aW1lU2VydmljZTtcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogR2V0IHRoZSBrZXkgdmFsdWUgb2YgYSBzZWVkLlxcclxcbiAgICogQHBhcmFtIHNlZWQgVGhlIHNlZWQgdG8gZ2V0IHRoZSBrZXkgZm9yLlxcclxcbiAgICogQHBhcmFtIGluZGV4IFRoZSBhZGRyZXNzIGluZGV4IHRvIHVzZS5cXHJcXG4gICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgc2VjdXJpdHkgbGV2ZWwgdG8gdXNlLlxcclxcbiAgICogQHJldHVybnMgVGhlIHRyeXRlcyBmb3IgdGhlIGtleS5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKE11bHRpU2lnQ2xpZW50LCBbe1xcbiAgICBrZXk6IFxcXCJwcmVwYXJlVHJhbnNmZXJcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogSW5pdGlhdGVzIHRoZSBjcmVhdGlvbiBvZiBhIG5ldyB0cmFuc2ZlciBieSBnZW5lcmF0aW5nIGFuIGVtcHR5IGJ1bmRsZSB3aXRoIHRoZSBjb3JyZWN0IG51bWJlclxcclxcbiAgICAgKiBvZiBidW5kbGUgZW50cmllcyB0byBiZSBsYXRlciB1c2VkIGZvciB0aGUgc2lnbmluZyBwcm9jZXNzLlxcclxcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBBZGRyZXNzIHdoaWNoIGhhcyBzdWZmaWNpZW50IGJhbGFuY2UgYW5kIGlzIGNvbnRyb2xsZWQgYnkgdGhlIGNvLXNpZ25lcnMuXFxyXFxuICAgICAqIEBwYXJhbSBzZWN1cml0eVN1bSB0aGUgc3VtIG9mIHRoZSBzZWN1cml0eSBsZXZlbHMgZnJvbSBhbGwgY29zaWduZXJzIGNob3NlbiBkdXJpbmcgdGhlIHByaXZhdGUga2V5IGdlbmVyYXRpb24gKGdldEtleSAvIGdldERpZ2VzdClcXHJcXG4gICAgICogQHBhcmFtIGJhbGFuY2UgVGhlIGJhbGFuY2UgYXZhaWxhYmxlIGZvciB0aGUgdHJhbnNmZXIsIGlmIDAgd2lsbCBjYWxsIGdldEJhbGFuY2VzIHRvIGxvb2t1cCBhdmFpbGFibGUuXFxyXFxuICAgICAqIEBwYXJhbSB0cmFuc2ZlcnMgVGhlIHRyYW5zZmVycyB0byBwZXJmb3JtLlxcclxcbiAgICAgKiBAcGFyYW0gcmVtYWluZGVyQWRkcmVzcyBJZiB0aGVyZSBpcyBhIHJlbWFpbmRlciBhZnRlciB0aGUgdHJhbnNmZXIgdGhlbiBzZW5kIHRoZSBhbW91bnQgdG8gdGhpcyBhZGRyZXNzLlxcclxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3ByZXBhcmVUcmFuc2ZlciA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShhZGRyZXNzLCBzZWN1cml0eVN1bSwgYmFsYW5jZSwgdHJhbnNmZXJzLCByZW1haW5kZXJBZGRyZXNzKSB7XFxuICAgICAgICB2YXIgZW1wdHlUcnl0ZXMsIHByZXBhcmVkLCB0b3RhbEJhbGFuY2UsIHJlcXVlc3QsIHJlc3BvbnNlLCB0aW1lc3RhbXA7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBhZGRyZXNzIHNob3VsZCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBBZGRyZXNzXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5U3VtKSB8fCBzZWN1cml0eVN1bSA8IDApKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgc2VjdXJpdHlTdW0gc2hvdWxkIGJlIGEgbnVtYmVyID49IDBcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgaWYgKCEoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoYmFsYW5jZSkgfHwgYmFsYW5jZSA8IDApKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgYmFsYW5jZSBzaG91bGQgYmUgYSBudW1iZXIgPj0gMFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyYW5zZmVycywgdHJhbnNmZXJfMS5UcmFuc2ZlcikpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSB0cmFuc2ZlcnMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHR5cGUgVHJhbnNmZXJcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgODpcXG4gICAgICAgICAgICAgICAgaWYgKCEoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlbWFpbmRlckFkZHJlc3MpICYmICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHJlbWFpbmRlckFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgcmVtYWluZGVyQWRkcmVzcyBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgQWRkcmVzc1xcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxMDpcXG4gICAgICAgICAgICAgICAgZW1wdHlUcnl0ZXMgPSB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhcXFwiXFxcIik7IC8vIElmIG1lc3NhZ2Ugb3IgdGFnIGlzIG5vdCBzdXBwbGllZCwgcHJvdmlkZSBpdFxcblxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNmZXIpIHtcXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zlci5tZXNzYWdlID0gdHJhbnNmZXIubWVzc2FnZSA/IHRyYW5zZmVyLm1lc3NhZ2UgOiBlbXB0eVRyeXRlcztcXG4gICAgICAgICAgICAgICAgICB0cmFuc2Zlci50YWcgPSB0cmFuc2Zlci50YWcgfHwgdGFnXzEuVGFnLkVNUFRZO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgcHJlcGFyZWQgPSBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIucHJlcGFyZUJ1bmRsZSh0aGlzLl90aW1lU2VydmljZSwgdHJhbnNmZXJzKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEocHJlcGFyZWQudG90YWxWYWx1ZSA9PT0gMCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTc7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgdG90YWwgdHJhbnNmZXIgdmFsdWUgaXMgMCwgdGhlIHRyYW5zZmVyIGRvZXMgbm90IHJlcXVpcmUgYSBzaWduYXR1cmVcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTc6XFxuICAgICAgICAgICAgICAgIHRvdGFsQmFsYW5jZSA9IGJhbGFuY2U7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghKHRvdGFsQmFsYW5jZSA9PT0gMCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHtcXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFthZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKV0sXFxuICAgICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxMDBcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIyO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpQ2xpZW50LmdldEJhbGFuY2VzKHJlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyMjpcXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dC5zZW50O1xcbiAgICAgICAgICAgICAgICB0b3RhbEJhbGFuY2UgPSBwYXJzZUludChyZXNwb25zZS5iYWxhbmNlc1swXSwgMTApO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyNDpcXG4gICAgICAgICAgICAgICAgaWYgKCEocHJlcGFyZWQudG90YWxWYWx1ZSA+IHRvdGFsQmFsYW5jZSkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjY7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJOb3QgZW5vdWdoIGJhbGFuY2UgdG8gc2F0aXNmeSB0aGUgdmFsdWVcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgdG90YWxWYWx1ZTogcHJlcGFyZWQudG90YWxWYWx1ZSxcXG4gICAgICAgICAgICAgICAgICB0b3RhbEJhbGFuY2U6IHRvdGFsQmFsYW5jZVxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjY6XFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcCA9IE1hdGguZmxvb3IodGhpcy5fdGltZVNlcnZpY2UubXNTaW5jZUVwb2NoKCkgLyAxMDAwKTsgLy8gQWRkIGlucHV0IGFzIGJ1bmRsZSBlbnRyeVxcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGEgc2luZ2xlIGVudHJ5LCBzaWduYXR1cmVzIHdpbGwgYmUgYWRkZWQgbGF0ZXJcXG5cXG4gICAgICAgICAgICAgICAgcHJlcGFyZWQuYnVuZGxlLmFkZFRyYW5zYWN0aW9ucyhzZWN1cml0eVN1bSwgYWRkcmVzcywgLXRvdGFsQmFsYW5jZSwgcHJlcGFyZWQubGFzdFRhZywgdGltZXN0YW1wKTsgLy8gSWYgdGhlcmUgaXMgYSByZW1haW5kZXIgdmFsdWVcXG4gICAgICAgICAgICAgICAgLy8gQWRkIGV4dHJhIG91dHB1dCB0byBzZW5kIHJlbWFpbmluZyBmdW5kcyB0b1xcblxcbiAgICAgICAgICAgICAgICBpZiAoISh0b3RhbEJhbGFuY2UgPiBwcmVwYXJlZC50b3RhbFZhbHVlKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHJlbWFpbmRlckFkZHJlc3MpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMxO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVHJhbnNmZXIgaGFzIHJlbWFpbmRlciBidXQgbm8gcmVtYWluZGVyIGFkZHJlc3Mgd2FzIHByb3ZpZGVkXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDMxOlxcbiAgICAgICAgICAgICAgICBwcmVwYXJlZC5idW5kbGUuYWRkVHJhbnNhY3Rpb25zKDEsIHJlbWFpbmRlckFkZHJlc3MsIHRvdGFsQmFsYW5jZSAtIHByZXBhcmVkLnRvdGFsVmFsdWUsIHByZXBhcmVkLmxhc3RUYWcsIHRpbWVzdGFtcCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDMyOlxcbiAgICAgICAgICAgICAgICBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuZmluYWxpemVCdW5kbGUocHJlcGFyZWQuYnVuZGxlKTtcXG4gICAgICAgICAgICAgICAgcHJlcGFyZWQuYnVuZGxlLmFkZFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMocHJlcGFyZWQuc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDM0OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBwcmVwYXJlZC5idW5kbGUpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAzNTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByZXBhcmVUcmFuc2ZlcihfeCwgX3gyLCBfeDMsIF94NCwgX3g1KSB7XFxuICAgICAgICByZXR1cm4gX3ByZXBhcmVUcmFuc2Zlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgfV0sIFt7XFxuICAgIGtleTogXFxcImdldEtleVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRLZXkoc2VlZCwgaW5kZXgsIHNlY3VyaXR5KSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNlZWQsIGhhc2hfMS5IYXNoKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgc2VlZCBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgSGFzaFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoaW5kZXgpIHx8IGluZGV4IDwgMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgaW5kZXggc2hvdWxkIGJlIGEgbnVtYmVyID49IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5KSB8fCBzZWN1cml0eSA8IDEgfHwgc2VjdXJpdHkgPiAzKSB7XFxuICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBzZWN1cml0eSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgM1xcXCIsIHtcXG4gICAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KHNpZ25pbmdfMS5TaWduaW5nLmtleShzZWVkLCBpbmRleCwgc2VjdXJpdHkpKS50b1RyeXRlcygpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBHZXQgdGhlIGRpZ2VzdCB2YWx1ZSBvZiBhIHNlZWQuXFxyXFxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIGdldCB0aGUgZGlnZXN0IGZvci5cXHJcXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBhZGRyZXNzIGluZGV4IHRvIHVzZS5cXHJcXG4gICAgICogQHBhcmFtIHNlY3VyaXR5IFRoZSBzZWN1cml0eSBsZXZlbCB0byB1c2UuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgZm9yIHRoZSBkaWdlc3QuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXREaWdlc3RcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlnZXN0KHNlZWQsIGluZGV4LCBzZWN1cml0eSkge1xcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHNlZWQgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGluZGV4KSB8fCBpbmRleCA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIGluZGV4IHNob3VsZCBiZSBhIG51bWJlciA+PSAwXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzZWN1cml0eSkgfHwgc2VjdXJpdHkgPCAxIHx8IHNlY3VyaXR5ID4gMykge1xcbiAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgc2VjdXJpdHkgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDNcXFwiLCB7XFxuICAgICAgICAgIHNlY3VyaXR5OiBzZWN1cml0eVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBrZXkgPSBzaWduaW5nXzEuU2lnbmluZy5rZXkoc2VlZCwgaW5kZXgsIHNlY3VyaXR5KTtcXG4gICAgICByZXR1cm4gdHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoc2lnbmluZ18xLlNpZ25pbmcuZGlnZXN0cyhrZXkpKS50b1RyeXRlcygpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBWYWxpZGF0ZSBhZGRyZXNzLlxcclxcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byB2YWxpZGF0ZSBhZ2FpbnN0IHRoZSBkaWdlc3RzLlxcclxcbiAgICAgKiBAcGFyYW0gZGlnZXN0cyBUaGUgZGlnZXN0cyB0byB1c2UgdG8gdmFsaWRhdGUgdGhlIGFkZHJlc3MuXFxyXFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGFkZHJlc3MgbWF0Y2hlcyB0aGUgZGlnZXN0cy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInZhbGlkYXRlQWRkcmVzc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcywgZGlnZXN0cykge1xcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcXG4gICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIGFkZHJlc3Mgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiB0eXBlIEFkZHJlc3NcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoZGlnZXN0cywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgZGlnZXN0cyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgdHlwZSBUcnl0ZXNcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpID09PSBuZXcgbXVsdGlTaWdBZGRyZXNzXzEuTXVsdGlTaWdBZGRyZXNzKCkuZmluYWxpemUoZGlnZXN0cykudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBBZGRzIHRoZSBjb3NpZ25lciBzaWduYXR1cmVzIHRvIHRoZSBjb3JyZXNwb25kaW5nIGJ1bmRsZSB0cmFuc2FjdGlvbnMuXFxyXFxuICAgICAqIEBwYXJhbSBidW5kbGUgVGhlIGJ1bmRsZSB0byBzaWduLlxcclxcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBtYXRjaCB0aGUgdHJhbnNhY3Rpb25zLlxcclxcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25zIHdpdGguXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhZGRTaWduYXR1cmVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2lnbmF0dXJlKGJ1bmRsZSwgYWRkcmVzcywga2V5KSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGJ1bmRsZSwgYnVuZGxlXzEuQnVuZGxlKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgYnVuZGxlIHNob3VsZCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBCdW5kbGVcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYnVuZGxlLnRyYW5zYWN0aW9ucywgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbikpIHtcXG4gICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIGJ1bmRsZS50cmFuc2FjdGlvbnMgc2hvdWxkIGJlIGFuIGFycmF5IG9mIHR5cGUgVHJhbnNhY3Rpb25cXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgYWRkcmVzcyBzaG91bGQgYmUgYW4gb2JqZWN0IG9mIHR5cGUgQWRkcmVzc1xcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoa2V5LCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBrZXkgc2hvdWxkIGJlIGFuIG9iamVjdCBvZiB0eXBlIFRyeXRlc1xcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIga2V5VHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoa2V5KS50b0FycmF5KCk7IC8vIEdldCB0aGUgc2VjdXJpdHkgdXNlZCBmb3IgdGhlIHByaXZhdGUga2V5XFxuICAgICAgLy8gMSBzZWN1cml0eSBsZXZlbCA9IDIxODcgdHJ5dGVzXFxuXFxuICAgICAgdmFyIHNlY3VyaXR5ID0ga2V5VHJpdHMubGVuZ3RoIC8gMyAvIDIxODc7IC8vIEZpcnN0IGdldCB0aGUgdG90YWwgbnVtYmVyIG9mIGFscmVhZHkgc2lnbmVkIHRyYW5zYWN0aW9uc1xcbiAgICAgIC8vIHVzZSB0aGF0IGZvciB0aGUgYnVuZGxlIGhhc2ggY2FsY3VsYXRpb24gYXMgd2VsbCBhcyBrbm93aW5nXFxuICAgICAgLy8gd2hlcmUgdG8gYWRkIHRoZSBzaWduYXR1cmVcXG5cXG4gICAgICB2YXIgbnVtU2lnbmVkVHhzID0gMDtcXG4gICAgICB2YXIgYWRkcmVzc1RyeXRlcyA9IGFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVuZGxlLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IGFkZHJlc3NUcnl0ZXMpIHtcXG4gICAgICAgICAgaWYgKGJ1bmRsZS50cmFuc2FjdGlvbnNbaV0uc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LnRvVHJ5dGVzKCkudG9TdHJpbmcoKSAhPT0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkVNUFRZLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkge1xcbiAgICAgICAgICAgIC8vIElmIHRyYW5zYWN0aW9uIGlzIGFscmVhZHkgc2lnbmVkLCBpbmNyZWFzZSBjb3VudGVyXFxuICAgICAgICAgICAgbnVtU2lnbmVkVHhzKys7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnNpZ25UcmFuc2FjdGlvbnMoYnVuZGxlLCBpLCBudW1TaWduZWRUeHMgJSAzLCBrZXlUcml0cywgYWRkcmVzc1RyeXRlcywgc2VjdXJpdHkpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gTXVsdGlTaWdDbGllbnQ7XFxufSgpO1xcblxcbmV4cG9ydHMuTXVsdGlTaWdDbGllbnQgPSBNdWx0aVNpZ0NsaWVudDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L211bHRpU2lnL211bHRpU2lnQ2xpZW50LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3Qvc2lnbi9obWFjQ3VybC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L3NpZ24vaG1hY0N1cmwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIHNwb25nZUZhY3RvcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnkgKi8gXFxcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9mYWN0b3JpZXMvc3BvbmdlRmFjdG9yeS5qc1xcXCIpO1xcblxcbnZhciBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmpzXFxcIik7XFxuXFxudmFyIHRyaXRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyaXRzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJpdHMuanNcXFwiKTtcXG5cXG52YXIgdHJ5dGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEhhc2hlZCBNZXNzYWdlIEF1dGhlbnRpY2F0aW9uIENvZGUgdXNpbmcgQ3VybC5cXHJcXG4gKi9cXG5cXG5cXG52YXIgSG1hY0N1cmwgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICAvKipcXHJcXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgSG1hY0N1cmwuXFxyXFxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gc2VlZCB3aXRoLlxcclxcbiAgICovXFxuICBmdW5jdGlvbiBIbWFjQ3VybChrZXkpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhtYWNDdXJsKTtcXG5cXG4gICAgdGhpcy5fa2V5VHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoa2V5KS50b0FycmF5KCk7XFxuICB9XFxuICAvKipcXHJcXG4gICAqIEFkZCBidW5kbGUgdG8gdGhlIEhNQUMuXFxyXFxuICAgKi9cXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhIbWFjQ3VybCwgW3tcXG4gICAga2V5OiBcXFwiYWRkSE1BQ1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRITUFDKGJ1bmRsZSkge1xcbiAgICAgIHZhciBjdXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXFxcImN1cmxcXFwiLCBIbWFjQ3VybC5ITUFDX1JPVU5EUyk7XFxuICAgICAgdmFyIGhhc2hMZW5ndGggPSBjdXJsLmdldENvbnN0YW50cygpLkhBU0hfTEVOR1RIO1xcbiAgICAgIHZhciBrZXkgPSB0aGlzLl9rZXlUcml0cztcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1bmRsZS50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGlmIChidW5kbGUudHJhbnNhY3Rpb25zW2ldLnZhbHVlLnRvTnVtYmVyKCkgPiAwKSB7XFxuICAgICAgICAgIHZhciBidW5kbGVIYXNoVHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5idW5kbGUudG9Ucnl0ZXMoKSkudG9BcnJheSgpO1xcbiAgICAgICAgICB2YXIgaG1hYyA9IG5ldyBJbnQ4QXJyYXkoaGFzaExlbmd0aCk7XFxuICAgICAgICAgIGN1cmwuaW5pdGlhbGl6ZSgpO1xcbiAgICAgICAgICBjdXJsLmFic29yYihrZXksIDAsIGtleS5sZW5ndGgpO1xcbiAgICAgICAgICBjdXJsLmFic29yYihidW5kbGVIYXNoVHJpdHMsIDAsIGJ1bmRsZUhhc2hUcml0cy5sZW5ndGgpO1xcbiAgICAgICAgICBjdXJsLnNxdWVlemUoaG1hYywgMCwgaG1hYy5sZW5ndGgpO1xcbiAgICAgICAgICB2YXIgaG1hY1RyeXRlcyA9IHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGhtYWMpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcXG4gICAgICAgICAgdmFyIHJlc3QgPSBidW5kbGUudHJhbnNhY3Rpb25zW2ldLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC50b1RyeXRlcygpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDgxLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIKTtcXG4gICAgICAgICAgYnVuZGxlLnRyYW5zYWN0aW9uc1tpXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRfMS5TaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhobWFjVHJ5dGVzICsgcmVzdCkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEhtYWNDdXJsO1xcbn0oKTtcXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5cXG5IbWFjQ3VybC5ITUFDX1JPVU5EUyA9IDI3O1xcbmV4cG9ydHMuSG1hY0N1cmwgPSBIbWFjQ3VybDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L3NpZ24vaG1hY0N1cmwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9zaWduL3NpZ25pbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L3NpZ24vc2lnbmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBzcG9uZ2VGYWN0b3J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NyeXB0by9kaXN0L2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5ICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnkuanNcXFwiKTtcXG5cXG52YXIgdHJpdHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJpdHMgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cml0cy5qc1xcXCIpO1xcblxcbnZhciBidW5kbGVIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2hlbHBlcnMvYnVuZGxlSGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9oZWxwZXJzL2J1bmRsZUhlbHBlci5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEhlbHBlciBjbGFzcyBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMuXFxyXFxuICogT3JpZ2luYWwgaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaW90YS5saWIuanMvYmxvYi9tYXN0ZXIvbGliL2NyeXB0by9zaWduaW5nL3NpZ25pbmcuanNcXHJcXG4gKiBAaW50ZXJuYWxcXHJcXG4gKi9cXG5cXG5cXG52YXIgU2lnbmluZyA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIFNpZ25pbmcoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaWduaW5nKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhTaWduaW5nLCBudWxsLCBbe1xcbiAgICBrZXk6IFxcXCJrZXlcXFwiLFxcblxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleShzZWVkLCBpbmRleCwgbGVuZ3RoKSB7XFxuICAgICAgdmFyIHNlZWRUcml0cyA9IHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyhzZWVkLnRvVHJ5dGVzKCkpO1xcbiAgICAgIHZhciBpbmRleFRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tTnVtYmVyKGluZGV4KTtcXG4gICAgICB2YXIgc3Vic2VlZCA9IHRyaXRzXzEuVHJpdHMuYWRkKHNlZWRUcml0cywgaW5kZXhUcml0cykudG9BcnJheSgpO1xcbiAgICAgIHZhciBzdWJzZWVkTGVuZ3RoID0gc3Vic2VlZC5sZW5ndGg7XFxuICAgICAgdmFyIGtlcmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcXFwia2VybFxcXCIpO1xcbiAgICAgIGtlcmwuaW5pdGlhbGl6ZSgpO1xcbiAgICAgIGtlcmwuYWJzb3JiKHN1YnNlZWQsIDAsIHN1YnNlZWRMZW5ndGgpO1xcbiAgICAgIGtlcmwuc3F1ZWV6ZShzdWJzZWVkLCAwLCBzdWJzZWVkTGVuZ3RoKTtcXG4gICAgICBrZXJsLnJlc2V0KCk7XFxuICAgICAga2VybC5hYnNvcmIoc3Vic2VlZCwgMCwgc3Vic2VlZExlbmd0aCk7XFxuICAgICAgdmFyIGtleSA9IG5ldyBJbnQ4QXJyYXkoMjcgKiAyNDMgKiBsZW5ndGgpO1xcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xcbiAgICAgIHZhciBidWZmZXIgPSBuZXcgSW50OEFycmF5KHN1YnNlZWRMZW5ndGgpO1xcbiAgICAgIHZhciBsb2NhbExlbmd0aCA9IGxlbmd0aDtcXG5cXG4gICAgICB3aGlsZSAobG9jYWxMZW5ndGgtLSA+IDApIHtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjc7IGkrKykge1xcbiAgICAgICAgICBrZXJsLnNxdWVlemUoYnVmZmVyLCAwLCBzdWJzZWVkTGVuZ3RoKTtcXG5cXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyNDM7IGorKykge1xcbiAgICAgICAgICAgIGtleVtvZmZzZXQrK10gPSBidWZmZXJbal07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGtleTtcXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZGlnZXN0c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaWdlc3RzKGtleSkge1xcbiAgICAgIHZhciBrZXlMZW5EaXYgPSBNYXRoLmZsb29yKGtleS5sZW5ndGggLyA2NTYxKTtcXG4gICAgICB2YXIgZGlnZXN0cyA9IG5ldyBJbnQ4QXJyYXkoa2V5TGVuRGl2ICogMjQzKTtcXG4gICAgICB2YXIgYnVmZmVyO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5TGVuRGl2OyBpKyspIHtcXG4gICAgICAgIHZhciBpTXVsID0gaSAqIDY1NjE7XFxuICAgICAgICB2YXIga2V5RnJhZ21lbnQgPSBrZXkuc2xpY2UoaU11bCwgaU11bCArIDY1NjEpO1xcblxcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyNzsgaisrKSB7XFxuICAgICAgICAgIHZhciBqTXVsID0gaiAqIDI0MztcXG4gICAgICAgICAgYnVmZmVyID0ga2V5RnJhZ21lbnQuc2xpY2Uoak11bCwgak11bCArIDI0Myk7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgMjY7IGsrKykge1xcbiAgICAgICAgICAgIHZhciBrS2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFxcXCJrZXJsXFxcIik7XFxuICAgICAgICAgICAga0tlcmwuaW5pdGlhbGl6ZSgpO1xcbiAgICAgICAgICAgIGtLZXJsLmFic29yYihidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgpO1xcbiAgICAgICAgICAgIGtLZXJsLnNxdWVlemUoYnVmZmVyLCAwLCBrS2VybC5nZXRDb25zdGFudHMoKS5IQVNIX0xFTkdUSCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IDI0MzsgX2srKykge1xcbiAgICAgICAgICAgIGtleUZyYWdtZW50W2pNdWwgKyBfa10gPSBidWZmZXJbX2tdO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIga2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFxcXCJrZXJsXFxcIik7XFxuICAgICAgICBrZXJsLmluaXRpYWxpemUoKTtcXG4gICAgICAgIGtlcmwuYWJzb3JiKGtleUZyYWdtZW50LCAwLCBrZXlGcmFnbWVudC5sZW5ndGgpO1xcbiAgICAgICAga2VybC5zcXVlZXplKGJ1ZmZlciwgMCwga2VybC5nZXRDb25zdGFudHMoKS5IQVNIX0xFTkdUSCk7XFxuICAgICAgICB2YXIgaU11bDIgPSBpICogMjQzO1xcblxcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IDI0MzsgX2orKykge1xcbiAgICAgICAgICBkaWdlc3RzW2lNdWwyICsgX2pdID0gYnVmZmVyW19qXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGRpZ2VzdHM7XFxuICAgIH1cXG4gICAgLyogQGludGVybmFsICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFkZHJlc3NcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkcmVzcyhkaWdlc3RzKSB7XFxuICAgICAgdmFyIGtlcmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcXFwia2VybFxcXCIpO1xcbiAgICAgIGtlcmwuaW5pdGlhbGl6ZSgpO1xcbiAgICAgIGtlcmwuYWJzb3JiKGRpZ2VzdHMsIDAsIGRpZ2VzdHMubGVuZ3RoKTtcXG4gICAgICB2YXIgYWRkcmVzc1RyaXRzID0gbmV3IEludDhBcnJheShrZXJsLmdldENvbnN0YW50cygpLkhBU0hfTEVOR1RIKTtcXG4gICAgICBrZXJsLnNxdWVlemUoYWRkcmVzc1RyaXRzLCAwLCBhZGRyZXNzVHJpdHMubGVuZ3RoKTtcXG4gICAgICByZXR1cm4gYWRkcmVzc1RyaXRzO1xcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjcmVhdGVDaGVja3N1bVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDaGVja3N1bSh0cml0cywgY2hlY2tzdW1MZW5ndGgpIHtcXG4gICAgICB2YXIga2VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFxcXCJrZXJsXFxcIik7XFxuICAgICAga2VybC5pbml0aWFsaXplKCk7XFxuICAgICAga2VybC5hYnNvcmIodHJpdHMsIDAsIHRyaXRzLmxlbmd0aCk7XFxuICAgICAgdmFyIGNoZWNrc3VtVHJpdHMgPSBuZXcgSW50OEFycmF5KGtlcmwuZ2V0Q29uc3RhbnRzKCkuSEFTSF9MRU5HVEgpO1xcbiAgICAgIGtlcmwuc3F1ZWV6ZShjaGVja3N1bVRyaXRzLCAwLCBjaGVja3N1bVRyaXRzLmxlbmd0aCk7XFxuICAgICAgcmV0dXJuIHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGNoZWNrc3VtVHJpdHMpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoODEgLSBjaGVja3N1bUxlbmd0aCwgODEpO1xcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ2YWxpZGF0ZVNpZ25hdHVyZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVTaWduYXR1cmVzKGV4cGVjdGVkQWRkcmVzcywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgYnVuZGxlSGFzaCkge1xcbiAgICAgIHZhciBub3JtYWxpemVkQnVuZGxlRnJhZ21lbnRzID0gW107XFxuICAgICAgdmFyIG5vcm1hbGl6ZWRCdW5kbGVIYXNoID0gYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLm5vcm1hbGl6ZWRIYXNoKGJ1bmRsZUhhc2gpOyAvLyBTcGxpdCBoYXNoIGludG8gMyBmcmFnbWVudHNcXG5cXG4gICAgICBmb3IgKHZhciBmID0gMDsgZiA8IDM7IGYrKykge1xcbiAgICAgICAgbm9ybWFsaXplZEJ1bmRsZUZyYWdtZW50c1tmXSA9IG5vcm1hbGl6ZWRCdW5kbGVIYXNoLnNsaWNlKGYgKiAyNywgKGYgKyAxKSAqIDI3KTtcXG4gICAgICB9IC8vIEdldCBkaWdlc3RzXFxuXFxuXFxuICAgICAgdmFyIGRpZ2VzdHMgPSBuZXcgSW50OEFycmF5KHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMubGVuZ3RoICogMjQzKTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBkaWdlc3RCdWZmZXIgPSBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuZGlnZXN0KG5vcm1hbGl6ZWRCdW5kbGVGcmFnbWVudHNbaSAlIDNdLCB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXMoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50c1tpXS50b1RyeXRlcygpKS50b0FycmF5KCkpO1xcblxcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyNDM7IGorKykge1xcbiAgICAgICAgICBkaWdlc3RzW2kgKiAyNDMgKyBqXSA9IGRpZ2VzdEJ1ZmZlcltqXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGV4cGVjdGVkQWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCkgPT09IHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KGJ1bmRsZUhlbHBlcl8xLkJ1bmRsZUhlbHBlci5hZGRyZXNzKGRpZ2VzdHMpKS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBTaWduaW5nO1xcbn0oKTtcXG5cXG5leHBvcnRzLlNpZ25pbmcgPSBTaWduaW5nO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3Qvc2lnbi9zaWduaW5nLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvdHJhbnNhY3Rpb25zL3RyYW5zYWN0aW9uQ2xpZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC90cmFuc2FjdGlvbnMvdHJhbnNhY3Rpb25DbGllbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX3JlZ2VuZXJhdG9yUnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yICovIFxcXCIuLi9pb3RhLXBpY28tYnVzaW5lc3Mvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH0gZnVuY3Rpb24gX25leHQodmFsdWUpIHsgc3RlcChcXFwibmV4dFxcXCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IHN0ZXAoXFxcInRocm93XFxcIiwgZXJyKTsgfSBfbmV4dCgpOyB9KTsgfTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBhcnJheUhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG51bWJlckhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBiYWNrZ3JvdW5kVGFza1NlcnZpY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L3NlcnZpY2VzL2JhY2tncm91bmRUYXNrU2VydmljZSAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9zZXJ2aWNlcy9iYWNrZ3JvdW5kVGFza1NlcnZpY2UuanNcXFwiKTtcXG5cXG52YXIgdGltZVNlcnZpY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L3NlcnZpY2VzL3RpbWVTZXJ2aWNlICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L3NlcnZpY2VzL3RpbWVTZXJ2aWNlLmpzXFxcIik7XFxuXFxudmFyIGFkZHJlc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvYWRkcmVzcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2FkZHJlc3MuanNcXFwiKTtcXG5cXG52YXIgYWRkcmVzc1NlY3VyaXR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL2FkZHJlc3NTZWN1cml0eSAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2FkZHJlc3NTZWN1cml0eS5qc1xcXCIpO1xcblxcbnZhciBidW5kbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvYnVuZGxlICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvYnVuZGxlLmpzXFxcIik7XFxuXFxudmFyIGhhc2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvaGFzaCAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2hhc2guanNcXFwiKTtcXG5cXG52YXIgaW5wdXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvaW5wdXQgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9pbnB1dC5qc1xcXCIpO1xcblxcbnZhciB0YWdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdGFnICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdGFnLmpzXFxcIik7XFxuXFxudmFyIHRyYW5zYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyYW5zYWN0aW9uICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb24uanNcXFwiKTtcXG5cXG52YXIgdHJhbnNmZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJhbnNmZXIgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cmFuc2Zlci5qc1xcXCIpO1xcblxcbnZhciB0cml0c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0cyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyaXRzLmpzXFxcIik7XFxuXFxudmFyIHRyeXRlTnVtYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlTnVtYmVyICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVOdW1iZXIuanNcXFwiKTtcXG5cXG52YXIgdHJ5dGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEvZGlzdC9kYXRhL3RyeXRlcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1xcXCIpO1xcblxcbnZhciBidXNpbmVzc0Vycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvci9idXNpbmVzc0Vycm9yICovIFxcXCIuLi9pb3RhLXBpY28tYnVzaW5lc3MvZGlzdC9lcnJvci9idXNpbmVzc0Vycm9yLmpzXFxcIik7XFxuXFxudmFyIGJ1bmRsZUhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaGVscGVycy9idW5kbGVIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L2hlbHBlcnMvYnVuZGxlSGVscGVyLmpzXFxcIik7XFxuXFxudmFyIHNpZ25pbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NpZ24vc2lnbmluZyAqLyBcXFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3Qvc2lnbi9zaWduaW5nLmpzXFxcIik7XFxuLyoqXFxyXFxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgSVRyYW5zYWN0aW9uQ2xpZW50LlxcclxcbiAqL1xcblxcblxcbnZhciBUcmFuc2FjdGlvbkNsaWVudCA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qKlxcclxcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBUcmFuc2FjdGlvbkNsaWVudC5cXHJcXG4gICAqIEBwYXJhbSBhcGlDbGllbnQgQW4gQVBJIENsaWVudCB0byBjb21tdW5pY2F0ZSB0aHJvdWdoLlxcclxcbiAgICogQHBhcmFtIHByb29mT2ZXb3JrIFByb29mIG9mIHdvcmsgbW9kdWxlIHRvIHVzZSwgaWYgdW5kZWZpbmVkIHdpbGwgdXNlIHJlbW90ZS5cXHJcXG4gICAqIEBwYXJhbSB0aW1lU2VydmljZSBBIGNsYXNzIHdoaWNoIGNhbiBwcm92aWRlIHRoZSB0aW1lLlxcclxcbiAgICogQHBhcmFtIGJhY2tncm91bmRUYXNrU2VydmljZSBBIGNsYXNzIHdoaWNoIGNhbiBwcm92aWRlIGJhY2tncm91bmQgdGFza3MuXFxyXFxuICAgKi9cXG4gIGZ1bmN0aW9uIFRyYW5zYWN0aW9uQ2xpZW50KGFwaUNsaWVudCwgcHJvb2ZPZldvcmspIHtcXG4gICAgdmFyIHRpbWVTZXJ2aWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBuZXcgdGltZVNlcnZpY2VfMS5UaW1lU2VydmljZSgpO1xcbiAgICB2YXIgYmFja2dyb3VuZFRhc2tTZXJ2aWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBuZXcgYmFja2dyb3VuZFRhc2tTZXJ2aWNlXzEuQmFja2dyb3VuZFRhc2tTZXJ2aWNlKCk7XFxuXFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2FjdGlvbkNsaWVudCk7XFxuXFxuICAgIHRoaXMuX2FwaUNsaWVudCA9IGFwaUNsaWVudDtcXG4gICAgdGhpcy5fcHJvb2ZPZldvcmsgPSBwcm9vZk9mV29yaztcXG4gICAgdGhpcy5fdGltZVNlcnZpY2UgPSB0aW1lU2VydmljZTtcXG4gICAgdGhpcy5fYmFja2dyb3VuZFRhc2tTZXJ2aWNlID0gYmFja2dyb3VuZFRhc2tTZXJ2aWNlO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9uIGluIHByb2dyZXNzLlxcclxcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byBhIGxpc3Qgb2YgaGFzaGVzIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKFRyYW5zYWN0aW9uQ2xpZW50LCBbe1xcbiAgICBrZXk6IFxcXCJnZXRUcmFuc2FjdGlvbnNJblByb2dyZXNzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2dldFRyYW5zYWN0aW9uc0luUHJvZ3Jlc3MgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XFxuICAgICAgICB2YXIgcmVzcG9uc2U7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwaUNsaWVudC5nZXRUaXBzKCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQuc2VudDtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgJiYgcmVzcG9uc2UuaGFzaGVzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHJlc3BvbnNlLmhhc2hlcy5tYXAoZnVuY3Rpb24gKGhhc2gpIHtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhoYXNoKSk7XFxuICAgICAgICAgICAgICAgIH0pKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNzpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgW10pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA4OlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25zSW5Qcm9ncmVzcygpIHtcXG4gICAgICAgIHJldHVybiBfZ2V0VHJhbnNhY3Rpb25zSW5Qcm9ncmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogRmluZCB0aGUgdHJhbnNhY3Rpb25zIHdoaWNoIG1hdGNoIHRoZSBzcGVjaWZpZWQgaW5wdXQgYW5kIHJldHVybi4gQWxsIGlucHV0IHZhbHVlcyBhcmUgbGlzdHMsXFxyXFxuICAgICAqIGZvciB3aGljaCBhIGxpc3Qgb2YgcmV0dXJuIHZhbHVlcyAodHJhbnNhY3Rpb24gaGFzaGVzKSwgaW4gdGhlIHNhbWUgb3JkZXIsIGlzIHJldHVybmVkIGZvciBhbGxcXHJcXG4gICAgICogaW5kaXZpZHVhbCBlbGVtZW50cy4gVXNpbmcgbXVsdGlwbGUgb2YgdGhlc2UgaW5wdXQgZmllbGRzIHJldHVybnMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdmFsdWVzLlxcclxcbiAgICAgKiBAcGFyYW0gYnVuZGxlcyBCdW5kbGVzIHRvIGxvb2t1cCB0cmFuc2FjdGlvbiBoYXNoZXMgZm9yLlxcclxcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIEFkZHJlc3NlcyB0byBsb29rdXAgdHJhbnNhY3Rpb24gaGFzaGVzIGZvci5cXHJcXG4gICAgICogQHBhcmFtIHRhZ3MgVGFncyB0byBsb29rdXAgdHJhbnNhY3Rpb24gaGFzaGVzIGZvci5cXHJcXG4gICAgICogQHBhcmFtIGFwcHJvdmVlcyBBcHByb3ZlZXMgdG8gbG9va3VwIHRyYW5zYWN0aW9uIGhhc2hlcyBmb3IuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCBhIGxpc3Qgb2YgaGFzaGVzIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZpbmRUcmFuc2FjdGlvbnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfZmluZFRyYW5zYWN0aW9ucyA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoYnVuZGxlcywgYWRkcmVzc2VzLCB0YWdzLCBhcHByb3ZlZXMpIHtcXG4gICAgICAgIHZhciBoYXNCdW5kbGUsIGhhc0FkZHJlc3NlcywgaGFzVGFncywgaGFzQXBwcm92ZWVzLCByZXF1ZXN0LCByZXNwb25zZTtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBoYXNCdW5kbGUgPSBidW5kbGVzICE9PSB1bmRlZmluZWQgJiYgYnVuZGxlcyAhPT0gbnVsbCAmJiBidW5kbGVzLmxlbmd0aCA+IDA7XFxuICAgICAgICAgICAgICAgIGhhc0FkZHJlc3NlcyA9IGFkZHJlc3NlcyAhPT0gdW5kZWZpbmVkICYmIGFkZHJlc3NlcyAhPT0gbnVsbCAmJiBhZGRyZXNzZXMubGVuZ3RoID4gMDtcXG4gICAgICAgICAgICAgICAgaGFzVGFncyA9IHRhZ3MgIT09IHVuZGVmaW5lZCAmJiB0YWdzICE9PSBudWxsICYmIHRhZ3MubGVuZ3RoID4gMDtcXG4gICAgICAgICAgICAgICAgaGFzQXBwcm92ZWVzID0gYXBwcm92ZWVzICE9PSB1bmRlZmluZWQgJiYgYXBwcm92ZWVzICE9PSBudWxsICYmIGFwcHJvdmVlcy5sZW5ndGggPiAwO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIShoYXNCdW5kbGUgJiYgIWFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChidW5kbGVzLCBoYXNoXzEuSGFzaCkpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIGJ1bmRsZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIEhhc2hcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNjpcXG4gICAgICAgICAgICAgICAgaWYgKCEoaGFzQWRkcmVzc2VzICYmICFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYWRkcmVzc2VzLCBhZGRyZXNzXzEuQWRkcmVzcykpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA4O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIGFkZHJlc3NlcyBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgQWRkcmVzc1xcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA4OlxcbiAgICAgICAgICAgICAgICBpZiAoIShoYXNUYWdzICYmICFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQodGFncywgdGFnXzEuVGFnKSkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHRhZ3MgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFRhZ1xcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxMDpcXG4gICAgICAgICAgICAgICAgaWYgKCEoaGFzQXBwcm92ZWVzICYmICFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzVHlwZWQoYXBwcm92ZWVzLCBoYXNoXzEuSGFzaCkpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBhcHByb3ZlZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIEhhc2hcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTI6XFxuICAgICAgICAgICAgICAgIGlmICghKCFoYXNCdW5kbGUgJiYgIWhhc0FkZHJlc3NlcyAmJiAhaGFzVGFncyAmJiAhaGFzQXBwcm92ZWVzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJZb3UgbXVzdCBwcm92aWRlIGJ1bmRsZXMsIGFkZHJlc3NlcywgdGFncyBvciBhcHByb3ZlZXNcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XFxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgYnVuZGxlczogaGFzQnVuZGxlID8gYnVuZGxlcy5tYXAoZnVuY3Rpb24gKGJ1bmRsZSkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1bmRsZS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgICAgICAgfSkgOiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBoYXNBZGRyZXNzZXMgPyBhZGRyZXNzZXMubWFwKGZ1bmN0aW9uIChhZGRyZXNzKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcy50b1RyeXRlcygpLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgICAgICAgfSkgOiB1bmRlZmluZWQsXFxuICAgICAgICAgICAgICAgICAgdGFnczogaGFzVGFncyA/IHRhZ3MubWFwKGZ1bmN0aW9uICh0YWcpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWcudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcbiAgICAgICAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkLFxcbiAgICAgICAgICAgICAgICAgIGFwcHJvdmVlczogaGFzQXBwcm92ZWVzID8gYXBwcm92ZWVzLm1hcChmdW5jdGlvbiAoYXBwcm92ZWUpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHByb3ZlZS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgICAgICAgfSkgOiB1bmRlZmluZWRcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNztcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwaUNsaWVudC5maW5kVHJhbnNhY3Rpb25zKHJlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNzpcXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgJiYgcmVzcG9uc2UuaGFzaGVzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHJlc3BvbnNlLmhhc2hlcy5tYXAoZnVuY3Rpb24gKGhhc2gpIHtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhoYXNoKSk7XFxuICAgICAgICAgICAgICAgIH0pKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBbXSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDIzOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBmaW5kVHJhbnNhY3Rpb25zKF94LCBfeDIsIF94MywgX3g0KSB7XFxuICAgICAgICByZXR1cm4gX2ZpbmRUcmFuc2FjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0aGUgdHJhbnNhY3Rpb24gZGV0YWlscyBvZiBzcGVjaWZpYyB0cmFuc2FjdGlvbnMuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgdHJhbnNhY3Rpb25zIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldFRyYW5zYWN0aW9uc09iamVjdHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfZ2V0VHJhbnNhY3Rpb25zT2JqZWN0cyA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTModHJhbnNhY3Rpb25IYXNoZXMpIHtcXG4gICAgICAgIHZhciByZXF1ZXN0LCByZXNwb25zZTtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyYW5zYWN0aW9uSGFzaGVzLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgdHJhbnNhY3Rpb25IYXNoZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIEhhc2hcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHtcXG4gICAgICAgICAgICAgICAgICBoYXNoZXM6IHRyYW5zYWN0aW9uSGFzaGVzLm1hcChmdW5jdGlvbiAoaGFzaCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2gudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcbiAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwaUNsaWVudC5nZXRUcnl0ZXMocmVxdWVzdCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDU6XFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQzLnNlbnQ7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlICYmIHJlc3BvbnNlLnRyeXRlcykpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDEwO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCByZXNwb25zZS50cnl0ZXMubWFwKGZ1bmN0aW9uICh0cnl0ZXMpIHtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyeXRlcykpO1xcbiAgICAgICAgICAgICAgICB9KSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDEwOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcXFwicmV0dXJuXFxcIiwgW10pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxMTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25zT2JqZWN0cyhfeDUpIHtcXG4gICAgICAgIHJldHVybiBfZ2V0VHJhbnNhY3Rpb25zT2JqZWN0cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogR2V0IHRoZSBpbmNsdXNpb24gc3RhdGVzIG9mIGEgbGlzdCBvZiB0cmFuc2FjdGlvbiBoYXNoZXMuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgaW5jbHVzaW9uIHN0YXRlcyBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRMYXRlc3RJbmNsdXNpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfZ2V0TGF0ZXN0SW5jbHVzaW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNCh0cmFuc2FjdGlvbkhhc2hlcykge1xcbiAgICAgICAgdmFyIG5vZGVJbmZvLCByZXF1ZXN0LCByZXNwb25zZTtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyYW5zYWN0aW9uSGFzaGVzLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgdHJhbnNhY3Rpb25IYXNoZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIEhhc2hcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA0O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpQ2xpZW50LmdldE5vZGVJbmZvKCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgICAgIG5vZGVJbmZvID0gX2NvbnRleHQ0LnNlbnQ7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghKG5vZGVJbmZvICYmIG51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobm9kZUluZm8ubGF0ZXN0U29saWRTdWJ0YW5nbGVNaWxlc3RvbmUpKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTc7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHtcXG4gICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRyYW5zYWN0aW9uSGFzaGVzLm1hcChmdW5jdGlvbiAoaGFzaCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2gudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcbiAgICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICAgIHRpcHM6IFtub2RlSW5mby5sYXRlc3RTb2xpZFN1YnRhbmdsZU1pbGVzdG9uZV1cXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA5O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpQ2xpZW50LmdldEluY2x1c2lvblN0YXRlcyhyZXF1ZXN0KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgOTpcXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDQuc2VudDtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdGVzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMTQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHJlc3BvbnNlLnN0YXRlcyk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE0OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgW10pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNTpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxODtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE3OlxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBub2RlIGNvdWxkIG5vdCBwcm92aWRlIHRoZSBsYXRlc3RTb2xpZFN1YnRhbmdsZU1pbGVzdG9uZVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxODpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0TGF0ZXN0SW5jbHVzaW9uKF94Nikge1xcbiAgICAgICAgcmV0dXJuIF9nZXRMYXRlc3RJbmNsdXNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIEdlbmVyYXRlcyBhZGRyZXNzZXMgd2l0aCBpbmRleC1iYXNlZCBvciB1c2luZyBhcGlzLlxcclxcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZW5lcmF0ZSB0aGUgYWRkcmVzc2VzIGZyb20uXFxyXFxuICAgICAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCB0byBnZW5lcmF0ZSBhZGRyZXNzZXMuXFxyXFxuICAgICAqIEBwYXJhbSBlbmRJbmRleCBUaGUgZW5kIGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cXHJcXG4gICAgICogQHBhcmFtIGluY2x1ZGVDaGVja3N1bSBJbmNsdWRlcyB0aGUgY2hlY2tzdW0gb24gYWRkcmVzc2VzLlxcclxcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIGF0IHdoaWNoIHRvIGNyZWF0ZSB0aGUgYWRkcmVzc2VzLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIGFkZHJlc3NlcyBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXROZXdBZGRyZXNzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2dldE5ld0FkZHJlc3MgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHNlZWQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBpbmNsdWRlQ2hlY2tzdW0sIHNlY3VyaXR5KSB7XFxuICAgICAgICB2YXIgbG9jYWxTdGFydEluZGV4LCBoYXNFbmRJbmRleCwgbG9jYWxTZWN1cml0eSwgYWRkcmVzc2VzLCB0b3RhbDtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWVkLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgc2VlZCBtdXN0IGJlIG9mIHR5cGUgSGFzaFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICBpZiAoISghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoc3RhcnRJbmRleCkgJiYgIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc3RhcnRJbmRleCwgTnVtYmVyKSkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgc3RhcnRJbmRleCBtdXN0IGJlIGFuIGludGVnZXJcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleDogc3RhcnRJbmRleFxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgbG9jYWxTdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIShsb2NhbFN0YXJ0SW5kZXggPCAwKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gNztcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBzdGFydEluZGV4IG11c3QgYmUgPj0gMFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICBsb2NhbFN0YXJ0SW5kZXg6IGxvY2FsU3RhcnRJbmRleFxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNzpcXG4gICAgICAgICAgICAgICAgaGFzRW5kSW5kZXggPSBudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGVuZEluZGV4KTtcXG4gICAgICAgICAgICAgICAgbG9jYWxTZWN1cml0eSA9IHNlY3VyaXR5IHx8IGFkZHJlc3NTZWN1cml0eV8xLkFkZHJlc3NTZWN1cml0eS5tZWRpdW07XFxuXFxuICAgICAgICAgICAgICAgIGlmICghaGFzRW5kSW5kZXgpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDE4O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRvdGFsID0gZW5kSW5kZXggLSBzdGFydEluZGV4ICsgMTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEodG90YWwgPD0gMCB8fCB0b3RhbCA+IFRyYW5zYWN0aW9uQ2xpZW50Lk1BWF9JTlBVVFMpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMztcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSB0b3RhbCBtdXN0IGJlID4gMCBhbmQgPD0gXFxcIi5jb25jYXQoVHJhbnNhY3Rpb25DbGllbnQuTUFYX0lOUFVUUyksIHtcXG4gICAgICAgICAgICAgICAgICB0b3RhbDogdG90YWxcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDEzOlxcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDE1O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBZGRyZXNzZXNCeUluZGV4KHNlZWQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBpbmNsdWRlQ2hlY2tzdW0sIGxvY2FsU2VjdXJpdHkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNTpcXG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzID0gX2NvbnRleHQ1LnNlbnQ7XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjE7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxODpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAyMDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWRkcmVzc2VzVG9VbnVzZWQoc2VlZCwgc3RhcnRJbmRleCwgaW5jbHVkZUNoZWNrc3VtLCBsb2NhbFNlY3VyaXR5KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjA6XFxuICAgICAgICAgICAgICAgIGFkZHJlc3NlcyA9IF9jb250ZXh0NS5zZW50O1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyMTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXFxcInJldHVyblxcXCIsIGFkZHJlc3Nlcyk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDIyOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBnZXROZXdBZGRyZXNzKF94NywgX3g4LCBfeDksIF94MTAsIF94MTEpIHtcXG4gICAgICAgIHJldHVybiBfZ2V0TmV3QWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogR2VuZXJhdGVzIG5ldyBhZGRyZXNzZXMgaW5kZXgtYmFzZWQuXFxyXFxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIGdlbmVyYXRlIHRoZSBhZGRyZXNzZXMgZnJvbS5cXHJcXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cXHJcXG4gICAgICogQHBhcmFtIGVuZEluZGV4IFRoZSBlbmQgaW5kZXggdG8gZ2VuZXJhdGUgYWRkcmVzc2VzLlxcclxcbiAgICAgKiBAcGFyYW0gaW5jbHVkZUNoZWNrc3VtIEluY2x1ZGVzIHRoZSBjaGVja3N1bSBvbiBhZGRyZXNzZXMuXFxyXFxuICAgICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgc2VjdXJpdHkgbGV2ZWwgYXQgd2hpY2ggdG8gY3JlYXRlIHRoZSBhZGRyZXNzZXMuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgYWRkcmVzc2VzIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEFkZHJlc3Nlc0J5SW5kZXhcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfZ2V0QWRkcmVzc2VzQnlJbmRleCA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpIHtcXG4gICAgICAgIHZhciB0b3RhbCwgYWRkcmVzc2VzLCBpO1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNlZWQsIGhhc2hfMS5IYXNoKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBzZWVkIG11c3QgYmUgb2YgdHlwZSBIYXNoXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHN0YXJ0SW5kZXgpIHx8IHN0YXJ0SW5kZXggPCAwKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gNDtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBzdGFydEluZGV4IG11c3QgYmUgYSBudW1iZXIgPj0gMFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgICAgICBpZiAoISghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihlbmRJbmRleCkgfHwgZW5kSW5kZXggPD0gMCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDY7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgZW5kSW5kZXggbXVzdCBiZSBhIG51bWJlciA+IDBcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgZW5kSW5kZXg6IGVuZEluZGV4XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICB0b3RhbCA9IGVuZEluZGV4IC0gc3RhcnRJbmRleCArIDE7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghKHRvdGFsIDw9IDAgfHwgdG90YWwgPiBUcmFuc2FjdGlvbkNsaWVudC5NQVhfSU5QVVRTKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gOTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSB0b3RhbCBtdXN0IGJlID4gMCBhbmQgPD0gXFxcIi5jb25jYXQoVHJhbnNhY3Rpb25DbGllbnQuTUFYX0lOUFVUUyksIHtcXG4gICAgICAgICAgICAgICAgICB0b3RhbDogdG90YWxcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDk6XFxuICAgICAgICAgICAgICAgIGlmICghKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5KSB8fCBzZWN1cml0eSA8IDEgfHwgc2VjdXJpdHkgPiAzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTE7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgc2VjdXJpdHkgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDNcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxMTpcXG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzID0gW107XFxuXFxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2godGhpcy5nZW5lcmF0ZUFkZHJlc3Moc2VlZCwgc3RhcnRJbmRleCArIGksIHNlY3VyaXR5LCBpbmNsdWRlQ2hlY2tzdW0pKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcXFwicmV0dXJuXFxcIiwgUHJvbWlzZS5yZXNvbHZlKGFkZHJlc3NlcykpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNDpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0QWRkcmVzc2VzQnlJbmRleChfeDEyLCBfeDEzLCBfeDE0LCBfeDE1LCBfeDE2KSB7XFxuICAgICAgICByZXR1cm4gX2dldEFkZHJlc3Nlc0J5SW5kZXguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIEdlbmVyYXRlcyBuZXcgYWRkcmVzcyB3aGljaCBoYXZlbnQgYmVlbiB1c2VkIHVzaW5nIGFwaXMuXFxyXFxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIGdlbmVyYXRlIHRoZSBhZGRyZXNzZXMgZnJvbS5cXHJcXG4gICAgICogQHBhcmFtIHN0YXJ0SW5kZXggVGhlIHN0YXJ0IGluZGV4IHRvIGdlbmVyYXRlIGFkZHJlc3Nlcy5cXHJcXG4gICAgICogQHBhcmFtIGluY2x1ZGVDaGVja3N1bSBJbmNsdWRlcyB0aGUgY2hlY2tzdW0gb24gYWRkcmVzc2VzLlxcclxcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIGF0IHdoaWNoIHRvIGNyZWF0ZSB0aGUgYWRkcmVzc2VzLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIGFuIGFkZHJlc3NlcyBsaXN0LCB0aGUgZmlyc3QgdW51c2VkIGFkZHJlc3MgaXMgdGhlIGxhc3QgaW4gdGhlIGxpc3Qgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0QWRkcmVzc2VzVG9VbnVzZWRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfZ2V0QWRkcmVzc2VzVG9VbnVzZWQgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KHNlZWQsIHN0YXJ0SW5kZXgsIGluY2x1ZGVDaGVja3N1bSwgc2VjdXJpdHkpIHtcXG4gICAgICAgIHZhciBsb2NhbFN0YXJ0SW5kZXgsIGlzVXNlZCwgYWRkcmVzc2VzLCBhZGRyZXNzLCBhZGRyZXNzTm9DaGVja3N1bSwgc3BlbnRGcm9tUmVxdWVzdCwgc3BlbnRGcm9tUmVzcG9uc2UsIGZpbmRUcmFuc2FjdGlvbnNSZXF1ZXN0LCBmaW5kUmVzcG9uc2U7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgaGFzaF8xLkhhc2gpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgaWYgKCEoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoc3RhcnRJbmRleCkgfHwgc3RhcnRJbmRleCA8IDApKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA0O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHN0YXJ0SW5kZXggbXVzdCBiZSBhIG51bWJlciA+PSAwXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHN0YXJ0SW5kZXhcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgICAgIGlmICghKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHNlY3VyaXR5KSB8fCBzZWN1cml0eSA8IDEgfHwgc2VjdXJpdHkgPiAzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBzZWN1cml0eSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgM1xcXCIsIHtcXG4gICAgICAgICAgICAgICAgICBzZWN1cml0eTogc2VjdXJpdHlcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDY6XFxuICAgICAgICAgICAgICAgIGxvY2FsU3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XFxuICAgICAgICAgICAgICAgIGFkZHJlc3NlcyA9IFtdO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA4OlxcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5nZW5lcmF0ZUFkZHJlc3Moc2VlZCwgbG9jYWxTdGFydEluZGV4KyssIHNlY3VyaXR5LCBpbmNsdWRlQ2hlY2tzdW0pO1xcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMucHVzaChhZGRyZXNzKTtcXG4gICAgICAgICAgICAgICAgYWRkcmVzc05vQ2hlY2tzdW0gPSBhZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcXG4gICAgICAgICAgICAgICAgc3BlbnRGcm9tUmVxdWVzdCA9IHtcXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFthZGRyZXNzTm9DaGVja3N1bV1cXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAxNDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwaUNsaWVudC53ZXJlQWRkcmVzc2VzU3BlbnRGcm9tKHNwZW50RnJvbVJlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNDpcXG4gICAgICAgICAgICAgICAgc3BlbnRGcm9tUmVzcG9uc2UgPSBfY29udGV4dDcuc2VudDtcXG4gICAgICAgICAgICAgICAgaXNVc2VkID0gc3BlbnRGcm9tUmVzcG9uc2UgJiYgc3BlbnRGcm9tUmVzcG9uc2Uuc3RhdGVzICYmIHNwZW50RnJvbVJlc3BvbnNlLnN0YXRlcy5sZW5ndGggPiAwID8gc3BlbnRGcm9tUmVzcG9uc2Uuc3RhdGVzWzBdIDogZmFsc2U7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChpc1VzZWQpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDIyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGZpbmRUcmFuc2FjdGlvbnNSZXF1ZXN0ID0ge1xcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogW2FkZHJlc3NOb0NoZWNrc3VtXVxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDIwO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpQ2xpZW50LmZpbmRUcmFuc2FjdGlvbnMoZmluZFRyYW5zYWN0aW9uc1JlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyMDpcXG4gICAgICAgICAgICAgICAgZmluZFJlc3BvbnNlID0gX2NvbnRleHQ3LnNlbnQ7XFxuICAgICAgICAgICAgICAgIGlzVXNlZCA9IGZpbmRSZXNwb25zZSAmJiBmaW5kUmVzcG9uc2UuaGFzaGVzICYmIGZpbmRSZXNwb25zZS5oYXNoZXMubGVuZ3RoID4gMDtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjI6XFxuICAgICAgICAgICAgICAgIGlmIChpc1VzZWQpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDcubmV4dCA9IDg7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjM6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBQcm9taXNlLnJlc29sdmUoYWRkcmVzc2VzKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI0OlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlNywgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRBZGRyZXNzZXNUb1VudXNlZChfeDE3LCBfeDE4LCBfeDE5LCBfeDIwKSB7XFxuICAgICAgICByZXR1cm4gX2dldEFkZHJlc3Nlc1RvVW51c2VkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBHZXQgdGhlIGlucHV0IGRhdGEgZm9yIGEgcmFuZ2Ugb2YgYWRkcmVzc2VzLlxcclxcbiAgICAgKiBAcGFyYW0gc2VlZCBUaGUgc2VlZCB0byBnZXQgdGhlIGlucHV0IGRhdGEgZm9yLlxcclxcbiAgICAgKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgc3RhcnQgaW5kZXggdG8gZ2V0IHRoZSBhZGRyZXNzZXMuXFxyXFxuICAgICAqIEBwYXJhbSBlbmRJbmRleCBUaGUgZW5kIGluZGV4IHRvIGdldCB0aGUgYWRkcmVzc2VzLlxcclxcbiAgICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIHNlY3VyaXR5IGxldmVsIHVzZWQgdG8gY3JlYXRlIHRoZSBhZGRyZXNzZXMuXFxyXFxuICAgICAqIEBwYXJhbSB0b3RhbFJlcXVpcmVkIFRoZSB0aHJlc2hvbGQgYXQgd2hpY2ggdG90YWwgYmFsYW5jZSB0byBzdG9wIGdhdGhlcmluZyBhZGRyZXNzZXMuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGlucHV0cyBmb3IgZWFjaCBhZGRyZXNzIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldElucHV0c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9nZXRJbnB1dHMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KHNlZWQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzZWN1cml0eSwgdG90YWxSZXF1aXJlZCkge1xcbiAgICAgICAgdmFyIGFkZHJlc3NlcywgcmVxdWVzdCwgcmVzcG9uc2UsIGlucHV0cywgdG90YWxCYWxhbmNlLCBpLCBiYWxhbmNlO1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlOCQoX2NvbnRleHQ4KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHNlZWQsIGhhc2hfMS5IYXNoKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBzZWVkIG11c3QgYmUgb2YgdHlwZSBIYXNoXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHN0YXJ0SW5kZXgpIHx8IHN0YXJ0SW5kZXggPCAwKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gNDtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBzdGFydEluZGV4IG11c3QgYmUgYSBudW1iZXIgPj0gMFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICBzdGFydEluZGV4OiBzdGFydEluZGV4XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgICAgICBpZiAoISghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzZWN1cml0eSkgfHwgc2VjdXJpdHkgPCAxIHx8IHNlY3VyaXR5ID4gMykpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDY7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgc2VjdXJpdHkgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDNcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICBpZiAoISghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcih0b3RhbFJlcXVpcmVkKSB8fCB0b3RhbFJlcXVpcmVkIDwgMCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDg7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgdG90YWxSZXF1aXJlZCBtdXN0IGJlID49IDBcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgdG90YWxSZXF1aXJlZDogdG90YWxSZXF1aXJlZFxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgODpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAxMDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmV3QWRkcmVzcyhzZWVkLCBzdGFydEluZGV4LCBlbmRJbmRleCwgZmFsc2UsIHNlY3VyaXR5KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTA6XFxuICAgICAgICAgICAgICAgIGFkZHJlc3NlcyA9IF9jb250ZXh0OC5zZW50O1xcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0ge1xcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChmdW5jdGlvbiAoYWRkKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcXG4gICAgICAgICAgICAgICAgICB9KSxcXG4gICAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDEwMFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE0O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpQ2xpZW50LmdldEJhbGFuY2VzKHJlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNDpcXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDguc2VudDtcXG4gICAgICAgICAgICAgICAgaW5wdXRzID0gW107XFxuICAgICAgICAgICAgICAgIHRvdGFsQmFsYW5jZSA9IDA7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDI5O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGkgPSAwO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOTpcXG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IGFkZHJlc3Nlcy5sZW5ndGgpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyOTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBiYWxhbmNlID0gcGFyc2VJbnQocmVzcG9uc2UuYmFsYW5jZXNbaV0sIDEwKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEoYmFsYW5jZSA+IDApKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAyNjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpbnB1dHMucHVzaChpbnB1dF8xLklucHV0LmZyb21QYXJhbXMoYWRkcmVzc2VzW2ldLCBzZWN1cml0eSwgc3RhcnRJbmRleCArIGksIGJhbGFuY2UpKTtcXG4gICAgICAgICAgICAgICAgdG90YWxCYWxhbmNlICs9IGJhbGFuY2U7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghKHRvdGFsUmVxdWlyZWQgPiAwICYmIHRvdGFsQmFsYW5jZSA+PSB0b3RhbFJlcXVpcmVkKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjY7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXFxcImJyZWFrXFxcIiwgMjkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyNjpcXG4gICAgICAgICAgICAgICAgaSsrO1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDE5O1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjk6XFxuICAgICAgICAgICAgICAgIGlmICghKHRvdGFsUmVxdWlyZWQgPiAwICYmIHRvdGFsQmFsYW5jZSA8IHRvdGFsUmVxdWlyZWQpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ4Lm5leHQgPSAzMTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIk5vdCBlbm91Z2ggY29tYmluZWQgYmFsYW5jZSBpbiB0aGUgYWRkcmVzc2VzIHRvIHNhdGlzZnkgdGhlIHRvdGFsIHJlcXVpcmVkXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgIHRvdGFsUmVxdWlyZWQ6IHRvdGFsUmVxdWlyZWQsXFxuICAgICAgICAgICAgICAgICAgdG90YWxCYWxhbmNlOiB0b3RhbEJhbGFuY2VcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDMxOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcXFwicmV0dXJuXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXRzLFxcbiAgICAgICAgICAgICAgICAgIHRvdGFsQmFsYW5jZTogdG90YWxCYWxhbmNlXFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAzMjpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0SW5wdXRzKF94MjEsIF94MjIsIF94MjMsIF94MjQsIF94MjUpIHtcXG4gICAgICAgIHJldHVybiBfZ2V0SW5wdXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBQcmVwYXJlcyB0cmFuc2ZlciBieSBnZW5lcmF0aW5nIGJ1bmRsZSwgZmluZGluZyBhbmQgc2lnbmluZyBpbnB1dHMuXFxyXFxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIHByZXBhcmUgdGhlIHRyYW5zZmVyIGZvci5cXHJcXG4gICAgICogQHBhcmFtIHRyYW5zZmVycyBUaGUgdHJhbnNmZXJzIHRvIHByZXBhcmUuXFxyXFxuICAgICAqIEBwYXJhbSB0cmFuc2Zlck9wdGlvbnNcXHJcXG4gICAgICogICAgICBAcHJvcGVydHkgaW5wdXRzIExpc3Qgb2YgaW5wdXRzIHVzZWQgZm9yIGZ1bmRpbmcgdGhlIHRyYW5zZmVyLlxcclxcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBzZWN1cml0eSBTZWN1cml0eSBsZXZlbCB0byBiZSB1c2VkIGZvciB0aGUgcHJpdmF0ZSBrZXkgLyBhZGRyZXNzZXMuXFxyXFxuICAgICAqICAgICAgQHByb3BlcnR5IHJlbWFpbmRlckFkZHJlc3MgSWYgZGVmaW5lZCwgdGhpcyBhZGRyZXNzIHdpbGwgYmUgdXNlZCBmb3Igc2VuZGluZyB0aGUgcmVtYWluZGVyIHZhbHVlIChvZiB0aGUgaW5wdXRzKSB0by5cXHJcXG4gICAgICogICAgICBAcHJvcGVydHkgaG1hY0tleSBIbWFjIGtleSB0byBzaWduIHRoZSBidW5kbGUuXFxyXFxuICAgICAqICAgICAgQHByb3BlcnR5IHJlZmVyZW5jZSBUaGUgdHJhbnNhY3Rpb24gdG8gcmVmZXJlbmNlLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBhcnJheSBvZiBUcnl0ZXMgZm9yIHRoZSB0cmFuc2ZlciBvciByZWplY3RzIHdpdGggZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwcmVwYXJlVHJhbnNmZXJzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3ByZXBhcmVUcmFuc2ZlcnMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5KHNlZWQsIHRyYW5zZmVycywgdHJhbnNmZXJPcHRpb25zKSB7XFxuICAgICAgICB2YXIgbG9jYWxUcmFuc2Zlck9wdGlvbnMsIGVtcHR5VHJ5dGVzLCBhZGRITUFDLCBhZGRlZEhNQUMsIHByZXBhcmVkLCBidW5kbGUsIGxhc3RUYWcsIHRvdGFsVmFsdWUsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIHJlcXVlc3QsIGJhbGFuY2VzLCBjb25maXJtZWRJbnB1dHMsIHRvdGFsQmFsYW5jZSwgaSwgYmFsYW5jZSwgaW5wdXRzUmVzcG9uc2U7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5JChfY29udGV4dDkpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgaGFzaF8xLkhhc2gpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHNlZWQgbXVzdCBiZSBvZiB0eXBlIEhhc2hcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZCh0cmFuc2ZlcnMsIHRyYW5zZmVyXzEuVHJhbnNmZXIpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA0O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHRyYW5zZmVycyBtdXN0IGJlIGFuIGFycmF5IG9mIFRyYW5zZmVyIG9iamVjdHNcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgbG9jYWxUcmFuc2Zlck9wdGlvbnMgPSB0cmFuc2Zlck9wdGlvbnMgfHwge307XFxuICAgICAgICAgICAgICAgIGxvY2FsVHJhbnNmZXJPcHRpb25zLnNlY3VyaXR5ID0gbG9jYWxUcmFuc2Zlck9wdGlvbnMuc2VjdXJpdHkgfHwgYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5Lm1lZGl1bTtcXG4gICAgICAgICAgICAgICAgZW1wdHlUcnl0ZXMgPSB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhcXFwiXFxcIik7XFxuICAgICAgICAgICAgICAgIGFkZEhNQUMgPSAhb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobG9jYWxUcmFuc2Zlck9wdGlvbnMuaG1hY0tleSk7XFxuICAgICAgICAgICAgICAgIGFkZGVkSE1BQyA9IGZhbHNlOyAvLyBJZiBtZXNzYWdlIG9yIHRhZyBpcyBub3Qgc3VwcGxpZWQsIHByb3ZpZGUgaXRcXG5cXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJzLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZmVyKSB7XFxuICAgICAgICAgICAgICAgICAgdHJhbnNmZXIubWVzc2FnZSA9IHRyYW5zZmVyLm1lc3NhZ2UgPyB0cmFuc2Zlci5tZXNzYWdlIDogZW1wdHlUcnl0ZXM7XFxuICAgICAgICAgICAgICAgICAgdHJhbnNmZXIudGFnID0gdHJhbnNmZXIudGFnIHx8IHRhZ18xLlRhZy5FTVBUWTtcXG5cXG4gICAgICAgICAgICAgICAgICBpZiAoYWRkSE1BQyAmJiB0cmFuc2Zlci52YWx1ZSA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyLm1lc3NhZ2UgPSB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhUcmFuc2FjdGlvbkNsaWVudC5OVUxMX0hBU0hfVFJZVEVTICsgdHJhbnNmZXIubWVzc2FnZS50b1N0cmluZygpKTtcXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkSE1BQyA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTsgLy8gQ3JlYXRlIGEgbmV3IGJ1bmRsZVxcblxcbiAgICAgICAgICAgICAgICBwcmVwYXJlZCA9IGJ1bmRsZUhlbHBlcl8xLkJ1bmRsZUhlbHBlci5wcmVwYXJlQnVuZGxlKHRoaXMuX3RpbWVTZXJ2aWNlLCB0cmFuc2ZlcnMpO1xcbiAgICAgICAgICAgICAgICBidW5kbGUgPSBwcmVwYXJlZC5idW5kbGU7XFxuICAgICAgICAgICAgICAgIGxhc3RUYWcgPSBwcmVwYXJlZC5sYXN0VGFnO1xcbiAgICAgICAgICAgICAgICB0b3RhbFZhbHVlID0gcHJlcGFyZWQudG90YWxWYWx1ZTtcXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyA9IHByZXBhcmVkLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHM7IC8vIEdldCBpbnB1dHMgaWYgd2UgYXJlIHNlbmRpbmcgdG9rZW5zXFxuXFxuICAgICAgICAgICAgICAgIGlmICghdG90YWxWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNDg7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbFRyYW5zZmVyT3B0aW9ucy5pbnB1dHMpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDQxO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBsb2NhbFRyYW5zZmVyT3B0aW9ucy5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0LmFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcbiAgICAgICAgICAgICAgICAgIH0pLFxcbiAgICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAwXFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjA7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcGlDbGllbnQuZ2V0QmFsYW5jZXMocmVxdWVzdCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDIwOlxcbiAgICAgICAgICAgICAgICBiYWxhbmNlcyA9IF9jb250ZXh0OS5zZW50O1xcbiAgICAgICAgICAgICAgICBjb25maXJtZWRJbnB1dHMgPSBbXTtcXG4gICAgICAgICAgICAgICAgdG90YWxCYWxhbmNlID0gMDtcXG4gICAgICAgICAgICAgICAgaSA9IDA7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI0OlxcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgYmFsYW5jZXMuYmFsYW5jZXMubGVuZ3RoKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMzU7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgYmFsYW5jZSA9IHBhcnNlSW50KGJhbGFuY2VzLmJhbGFuY2VzW2ldLCAxMCk7IC8vIElmIGlucHV0IGhhcyBiYWxhbmNlLCBhZGQgaXQgdG8gY29uZmlybWVkSW5wdXRzXFxuXFxuICAgICAgICAgICAgICAgIGlmICghKGJhbGFuY2UgPiAwKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMzI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdG90YWxCYWxhbmNlICs9IGJhbGFuY2U7XFxuICAgICAgICAgICAgICAgIGxvY2FsVHJhbnNmZXJPcHRpb25zLmlucHV0c1tpXS5iYWxhbmNlID0gYmFsYW5jZTtcXG4gICAgICAgICAgICAgICAgY29uZmlybWVkSW5wdXRzLnB1c2gobG9jYWxUcmFuc2Zlck9wdGlvbnMuaW5wdXRzW2ldKTsgLy8gaWYgd2UndmUgYWxyZWFkeSByZWFjaGVkIHRoZSBpbnRlbmRlZCBpbnB1dCB2YWx1ZSwgYnJlYWsgb3V0IG9mIGxvb3BcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEodG90YWxCYWxhbmNlID49IHRvdGFsVmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAzMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcXFwiYnJlYWtcXFwiLCAzNSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDMyOlxcbiAgICAgICAgICAgICAgICBpKys7XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMjQ7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAzNTpcXG4gICAgICAgICAgICAgICAgaWYgKCEodG90YWxWYWx1ZSA+IHRvdGFsQmFsYW5jZSkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDM3O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiTm90IGVub3VnaCBiYWxhbmNlIGluIHRoZSBpbnB1dCBhZGRyZXNzZXMgdG8gc2F0aXNmeSB0aGUgdG90YWwgZm9yIHRoZSB0cmFuc2ZlclxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAzNzpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAzOTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkUmVtYWluZGVyKHNlZWQsIGJ1bmRsZSwgbG9jYWxUcmFuc2Zlck9wdGlvbnMsIGNvbmZpcm1lZElucHV0cywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgdG90YWxWYWx1ZSwgbGFzdFRhZywgYWRkZWRITUFDKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMzk6XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNDY7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0MTpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA0MztcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5wdXRzKHNlZWQsIDAsIHVuZGVmaW5lZCwgbG9jYWxUcmFuc2Zlck9wdGlvbnMuc2VjdXJpdHksIHRvdGFsVmFsdWUpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0MzpcXG4gICAgICAgICAgICAgICAgaW5wdXRzUmVzcG9uc2UgPSBfY29udGV4dDkuc2VudDtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSA0NjtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkUmVtYWluZGVyKHNlZWQsIGJ1bmRsZSwgbG9jYWxUcmFuc2Zlck9wdGlvbnMsIGlucHV0c1Jlc3BvbnNlLmlucHV0cywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgdG90YWxWYWx1ZSwgbGFzdFRhZywgYWRkZWRITUFDKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDY6XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gNTA7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0ODpcXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gaW5wdXQgcmVxdWlyZWQsIGRvbid0IHNpZ24gYW5kIHNpbXBseSBmaW5hbGl6ZSB0aGUgYnVuZGxlXFxuICAgICAgICAgICAgICAgIGJ1bmRsZUhlbHBlcl8xLkJ1bmRsZUhlbHBlci5maW5hbGl6ZUJ1bmRsZShidW5kbGUpO1xcbiAgICAgICAgICAgICAgICBidW5kbGUuYWRkU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNTA6XFxuICAgICAgICAgICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnMgPSBidW5kbGUudHJhbnNhY3Rpb25zLnJldmVyc2UoKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXFxcInJldHVyblxcXCIsIGJ1bmRsZSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDUyOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwcmVwYXJlVHJhbnNmZXJzKF94MjYsIF94MjcsIF94MjgpIHtcXG4gICAgICAgIHJldHVybiBfcHJlcGFyZVRyYW5zZmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogQXR0YWNoIHRoZSB0cmFuc2FjdGlvbnMgdG8gdGhlIHRhbmdsZSBieSBkb2luZyBwcm9vZiBvZiB3b3JrLlxcclxcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIHRvIGF0dGFjaC5cXHJcXG4gICAgICogQHBhcmFtIGRlcHRoIFZhbHVlIHRoYXQgZGV0ZXJtaW5lcyBob3cgZmFyIHRvIGdvIGZvciB0aXAgc2VsZWN0aW9uLlxcclxcbiAgICAgKiBAcGFyYW0gbWluV2VpZ2h0TWFnbml0dWRlIFRoZSBtaW5pbXVtIHdlaWdodCBtYWduaXR1ZGUgZm9yIHRoZSBwcm9vZiBvZiB3b3JrLlxcclxcbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgdG8gc2VuZCB3aXRoIHRoZSB0cmFuc2FjdGlvbnMuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGJ1bmRsZSBvZiB0cmFuc2FjdGlvbnMgY3JlYXRlZCBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJhdHRhY2hUb1RhbmdsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9hdHRhY2hUb1RhbmdsZSA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKGJ1bmRsZSwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgcmVmZXJlbmNlKSB7XFxuICAgICAgICB2YXIgdHJhbnNhY3Rpb25zVG9BcHByb3ZlUmVxdWVzdCwgdHJhbnNhY3Rpb25zVG9BcHByb3ZlLCBwb3dUcmFuc2FjdGlvbnMsIGFsbFRyeXRlcywgYXR0YWNoVG9UYW5nbGVSZXF1ZXN0LCBhdHRhY2hUb1RhbmdsZVJlc3BvbnNlLCBuZXdCdW5kbGU7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGJ1bmRsZSwgYnVuZGxlXzEuQnVuZGxlKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgYnVuZGxlIG11c3QgYmUgYW4gYXJyYXkgb2YgdHlwZSBCdW5kbGVcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZChidW5kbGUudHJhbnNhY3Rpb25zLCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgYnVuZGxlLnRyYW5zYWN0aW9ucyBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgVHJhbnNhY3Rpb25cXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgaWYgKCEoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoZGVwdGgpIHx8IGRlcHRoIDw9IDApKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gNjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBkZXB0aCBtdXN0IGJlIGEgbnVtYmVyID4gMFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICBkZXB0aDogZGVwdGhcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDY6XFxuICAgICAgICAgICAgICAgIGlmICghKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG1pbldlaWdodE1hZ25pdHVkZSkgfHwgbWluV2VpZ2h0TWFnbml0dWRlIDw9IDApKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gODtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBtaW5XZWlnaHRNYWduaXR1ZGUgbXVzdCBiZSBhIG51bWJlciA+IDBcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgbWluV2VpZ2h0TWFnbml0dWRlOiBtaW5XZWlnaHRNYWduaXR1ZGVcXG4gICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDg6XFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uc1RvQXBwcm92ZVJlcXVlc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxcbiAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlID8gcmVmZXJlbmNlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA6IHVuZGVmaW5lZFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxMTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwaUNsaWVudC5nZXRUcmFuc2FjdGlvbnNUb0FwcHJvdmUodHJhbnNhY3Rpb25zVG9BcHByb3ZlUmVxdWVzdCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDExOlxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNUb0FwcHJvdmUgPSBfY29udGV4dDEwLnNlbnQ7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHJvb2ZPZldvcmspIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAyNTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Byb29mT2ZXb3JrLnBlcmZvcm1zU2luZ2xlKCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxOTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSAxNjtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvb2ZPZldvcmtJdGVyYXRlKGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodHJhbnNhY3Rpb25zVG9BcHByb3ZlLnRydW5rVHJhbnNhY3Rpb24pKSwgaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cmFuc2FjdGlvbnNUb0FwcHJvdmUuYnJhbmNoVHJhbnNhY3Rpb24pKSwgYnVuZGxlLnRyYW5zYWN0aW9ucywgbWluV2VpZ2h0TWFnbml0dWRlKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTY6XFxuICAgICAgICAgICAgICAgIHBvd1RyYW5zYWN0aW9ucyA9IF9jb250ZXh0MTAuc2VudDtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMjM7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOTpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMjE7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9vZk9mV29yay5wb3coaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cmFuc2FjdGlvbnNUb0FwcHJvdmUudHJ1bmtUcmFuc2FjdGlvbikpLCBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyYW5zYWN0aW9uc1RvQXBwcm92ZS5icmFuY2hUcmFuc2FjdGlvbikpLCBidW5kbGUudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAodCkge1xcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0LnRvVHJ5dGVzKCk7XFxuICAgICAgICAgICAgICAgIH0pLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyMTpcXG4gICAgICAgICAgICAgICAgYWxsVHJ5dGVzID0gX2NvbnRleHQxMC5zZW50O1xcbiAgICAgICAgICAgICAgICBwb3dUcmFuc2FjdGlvbnMgPSBhbGxUcnl0ZXMubWFwKGZ1bmN0aW9uIChyZXR1cm5Ucnl0ZXMpIHtcXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tVHJ5dGVzKHJldHVyblRyeXRlcyk7XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyMzpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMzA7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyNTpcXG4gICAgICAgICAgICAgICAgYXR0YWNoVG9UYW5nbGVSZXF1ZXN0ID0ge1xcbiAgICAgICAgICAgICAgICAgIHRydW5rVHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uc1RvQXBwcm92ZS50cnVua1RyYW5zYWN0aW9uLFxcbiAgICAgICAgICAgICAgICAgIGJyYW5jaFRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbnNUb0FwcHJvdmUuYnJhbmNoVHJhbnNhY3Rpb24sXFxuICAgICAgICAgICAgICAgICAgbWluV2VpZ2h0TWFnbml0dWRlOiBtaW5XZWlnaHRNYWduaXR1ZGUsXFxuICAgICAgICAgICAgICAgICAgdHJ5dGVzOiBidW5kbGUudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAodCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcbiAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDI4O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpQ2xpZW50LmF0dGFjaFRvVGFuZ2xlKGF0dGFjaFRvVGFuZ2xlUmVxdWVzdCk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI4OlxcbiAgICAgICAgICAgICAgICBhdHRhY2hUb1RhbmdsZVJlc3BvbnNlID0gX2NvbnRleHQxMC5zZW50O1xcbiAgICAgICAgICAgICAgICBwb3dUcmFuc2FjdGlvbnMgPSBhdHRhY2hUb1RhbmdsZVJlc3BvbnNlLnRyeXRlcy5tYXAoZnVuY3Rpb24gKHJldHVyblRyeXRlcykge1xcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcocmV0dXJuVHJ5dGVzKSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAzMDpcXG4gICAgICAgICAgICAgICAgbmV3QnVuZGxlID0gbmV3IGJ1bmRsZV8xLkJ1bmRsZSgpO1xcbiAgICAgICAgICAgICAgICBuZXdCdW5kbGUudHJhbnNhY3Rpb25zID0gcG93VHJhbnNhY3Rpb25zO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIG5ld0J1bmRsZSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDMzOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTEwLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGF0dGFjaFRvVGFuZ2xlKF94MjksIF94MzAsIF94MzEsIF94MzIpIHtcXG4gICAgICAgIHJldHVybiBfYXR0YWNoVG9UYW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIFdyYXBwZXIgZnVuY3Rpb24gdGhhdCBkb2VzIGF0dGFjaFRvVGFuZ2xlIGFuZCB0aGVuIHN0b3JlcyBhbmQgYnJvYWRjYXN0cyB0aGUgdHJhbnNhY3Rpb25zLlxcclxcbiAgICAgKiBAcGFyYW0gYnVuZGxlIFRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIHRvIHNlbmQuXFxyXFxuICAgICAqIEBwYXJhbSBkZXB0aCBWYWx1ZSB0aGF0IGRldGVybWluZXMgaG93IGZhciB0byBnbyBmb3IgdGlwIHNlbGVjdGlvbi5cXHJcXG4gICAgICogQHBhcmFtIG1pbldlaWdodE1hZ25pdHVkZSBUaGUgbWluaW11bSB3ZWlnaHQgbWFnbml0dWRlIGZvciB0aGUgcHJvb2Ygb2Ygd29yay5cXHJcXG4gICAgICogQHBhcmFtIHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIHRvIHNlbmQgd2l0aCB0aGUgdHJhbnNhY3Rpb25zLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBidW5kbGUgb2YgdHJhbnNhY3Rpb25zIGNyZWF0ZWQgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2VuZFRyYW5zYWN0aW9uc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9zZW5kVHJhbnNhY3Rpb25zID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTEoYnVuZGxlLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCByZWZlcmVuY2UpIHtcXG4gICAgICAgIHZhciBhdHRhY2hlZFRyYW5zYWN0aW9uc0J1bmRsZSwgc3RvcmVUcmFuc2FjdGlvbnNSZXF1ZXN0LCBicm9hZGNhc3RUcmFuc2FjdGlvbnNSZXF1ZXN0O1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2hUb1RhbmdsZShidW5kbGUsIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUsIHJlZmVyZW5jZSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGF0dGFjaGVkVHJhbnNhY3Rpb25zQnVuZGxlID0gX2NvbnRleHQxMS5zZW50O1xcbiAgICAgICAgICAgICAgICBzdG9yZVRyYW5zYWN0aW9uc1JlcXVlc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgdHJ5dGVzOiBhdHRhY2hlZFRyYW5zYWN0aW9uc0J1bmRsZS50cmFuc2FjdGlvbnMubWFwKGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdC50b1RyeXRlcygpLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gNjtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FwaUNsaWVudC5zdG9yZVRyYW5zYWN0aW9ucyhzdG9yZVRyYW5zYWN0aW9uc1JlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICBicm9hZGNhc3RUcmFuc2FjdGlvbnNSZXF1ZXN0ID0ge1xcbiAgICAgICAgICAgICAgICAgIHRyeXRlczogc3RvcmVUcmFuc2FjdGlvbnNSZXF1ZXN0LnRyeXRlc1xcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSA5O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpQ2xpZW50LmJyb2FkY2FzdFRyYW5zYWN0aW9ucyhicm9hZGNhc3RUcmFuc2FjdGlvbnNSZXF1ZXN0KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgOTpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBhdHRhY2hlZFRyYW5zYWN0aW9uc0J1bmRsZSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDEwOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTExLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNlbmRUcmFuc2FjdGlvbnMoX3gzMywgX3gzNCwgX3gzNSwgX3gzNikge1xcbiAgICAgICAgcmV0dXJuIF9zZW5kVHJhbnNhY3Rpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBXcmFwcGVyIGZ1bmN0aW9uIHRoYXQgZG9lcyBwcmVwYXJlVHJhbnNmZXJzIGFuZCB0aGVuIHNlbmRUcmFuc2FjdGlvbnMuXFxyXFxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIHNlbmQgdGhlIHRyYW5zZmVyIGZvci5cXHJcXG4gICAgICogQHBhcmFtIGRlcHRoIFZhbHVlIHRoYXQgZGV0ZXJtaW5lcyBob3cgZmFyIHRvIGdvIGZvciB0aXAgc2VsZWN0aW9uLlxcclxcbiAgICAgKiBAcGFyYW0gbWluV2VpZ2h0TWFnbml0dWRlIFRoZSBtaW5pbXVtIHdlaWdodCBtYWduaXR1ZGUgZm9yIHRoZSBwcm9vZiBvZiB3b3JrLlxcclxcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJzIFRoZSB0cmFuc2ZlcnMgdG8gc2VuZC5cXHJcXG4gICAgICogQHBhcmFtIHRyYW5zZmVyT3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB0cmFuc2Zlci5cXHJcXG4gICAgICogICAgICBAcHJvcGVydHkgaW5wdXRzIExpc3Qgb2YgaW5wdXRzIHVzZWQgZm9yIGZ1bmRpbmcgdGhlIHRyYW5zZmVyLlxcclxcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBzZWN1cml0eSBTZWN1cml0eSBsZXZlbCB0byBiZSB1c2VkIGZvciB0aGUgcHJpdmF0ZSBrZXkgLyBhZGRyZXNzZXMuXFxyXFxuICAgICAqICAgICAgQHByb3BlcnR5IHJlbWFpbmRlckFkZHJlc3MgSWYgZGVmaW5lZCwgdGhpcyBhZGRyZXNzIHdpbGwgYmUgdXNlZCBmb3Igc2VuZGluZyB0aGUgcmVtYWluZGVyIHZhbHVlIChvZiB0aGUgaW5wdXRzKSB0by5cXHJcXG4gICAgICogICAgICBAcHJvcGVydHkgaG1hY0tleSBIbWFjIGtleSB0byBzaWduIHRoZSBidW5kbGUuXFxyXFxuICAgICAqIEBwYXJhbSByZWZlcmVuY2UgVGhlIHJlZmVyZW5jZSB0byBzZW5kIHdpdGggdGhlIHRyYW5zYWN0aW9ucy5cXHJcXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbnMgY3JlYXRlZCBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZW5kVHJhbnNmZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfc2VuZFRyYW5zZmVyID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIoc2VlZCwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgdHJhbnNmZXJzLCB0cmFuc2Zlck9wdGlvbnMsIHJlZmVyZW5jZSkge1xcbiAgICAgICAgdmFyIHRyYW5zZmVyVHJ5dGVzO1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTIucHJldiA9IF9jb250ZXh0MTIubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVwYXJlVHJhbnNmZXJzKHNlZWQsIHRyYW5zZmVycywgdHJhbnNmZXJPcHRpb25zKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJUcnl0ZXMgPSBfY29udGV4dDEyLnNlbnQ7XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5zZW5kVHJhbnNhY3Rpb25zKHRyYW5zZmVyVHJ5dGVzLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCByZWZlcmVuY2UpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEyLnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUxMiwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZW5kVHJhbnNmZXIoX3gzNywgX3gzOCwgX3gzOSwgX3g0MCwgX3g0MSwgX3g0Mikge1xcbiAgICAgICAgcmV0dXJuIF9zZW5kVHJhbnNmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIEZpbmQgb3V0IGlmIGEgdHJhbnNhY3Rpb24gaXMgcHJvbW90YWJsZS5cXHJcXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uVGFpbCBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgcHJvbW90ZWQuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgcHJvbW90YWJsZSByZWplY3RzIHdpdGggYW4gZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpc1Byb21vdGFibGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfaXNQcm9tb3RhYmxlID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTModHJhbnNhY3Rpb25UYWlsKSB7XFxuICAgICAgICB2YXIgY2hlY2tDb25zaXN0ZW5jeVJlcXVlc3QsIGNoZWNrQ29uc2lzdGVuY3lSZXNwb25zZTtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEzLnByZXYgPSBfY29udGV4dDEzLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJhbnNhY3Rpb25UYWlsLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHRyYW5zYWN0aW9uVGFpbCBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgY2hlY2tDb25zaXN0ZW5jeVJlcXVlc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgdGFpbHM6IFt0cmFuc2FjdGlvblRhaWwudG9Ucnl0ZXMoKS50b1N0cmluZygpXVxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSA1O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBpQ2xpZW50LmNoZWNrQ29uc2lzdGVuY3koY2hlY2tDb25zaXN0ZW5jeVJlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA1OlxcbiAgICAgICAgICAgICAgICBjaGVja0NvbnNpc3RlbmN5UmVzcG9uc2UgPSBfY29udGV4dDEzLnNlbnQ7XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcXFwicmV0dXJuXFxcIiwgY2hlY2tDb25zaXN0ZW5jeVJlc3BvbnNlLnN0YXRlKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNzpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUxMywgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1Byb21vdGFibGUoX3g0Mykge1xcbiAgICAgICAgcmV0dXJuIF9pc1Byb21vdGFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIERldGVybWluZXMgd2hldGhlciB5b3Ugc2hvdWxkIHJlcGxheSBhIHRyYW5zYWN0aW9uIG9yIG1ha2UgYSBuZXcgb25lIChlaXRoZXIgd2l0aCB0aGUgc2FtZSBpbnB1dCwgb3IgYSBkaWZmZXJlbnQgb25lKS5cXHJcXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyBJbnB1dCBhZGRyZXNzIHlvdSB3YW50IHRvIGhhdmUgdGVzdGVkLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRydWUgaWYgdGhlIGFkZHJlc3NlcyBhcmUgcmVhdHRhY2hhYmxlIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImlzUmVhdHRhY2hhYmxlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2lzUmVhdHRhY2hhYmxlID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTQoYWRkcmVzc2VzKSB7XFxuICAgICAgICB2YXIgYWRkcnNUeHNNYXAsIGksIGFkZHJlc3NTdHJpbmcsIHRyYW5zYWN0aW9ucywgdmFsdWVUcmFuc2FjdGlvbnMsIHJlc3VsdHMsIGluY2x1c2lvblN0YXRlcywgX2kyO1xcblxcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTQkKF9jb250ZXh0MTQpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTQucHJldiA9IF9jb250ZXh0MTQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKGFkZHJlc3NlcywgYWRkcmVzc18xLkFkZHJlc3MpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBhZGRyZXNzZXMgbXVzdCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBBZGRyZXNzXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGFkZHJzVHhzTWFwID0ge307XFxuXFxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzU3RyaW5nID0gYWRkcmVzc2VzW2ldLnRvVHJ5dGVzKCkudG9TdHJpbmcoKTtcXG4gICAgICAgICAgICAgICAgICBhZGRyc1R4c01hcFthZGRyZXNzU3RyaW5nXSA9IFtdO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDY7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRUcmFuc2FjdGlvbk9iamVjdHModW5kZWZpbmVkLCBhZGRyZXNzZXMpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMgPSBfY29udGV4dDE0LnNlbnQ7XFxuICAgICAgICAgICAgICAgIHZhbHVlVHJhbnNhY3Rpb25zID0gW107XFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xcbiAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi52YWx1ZS50b051bWJlcigpIDwgMCkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR4QWRkcmVzcyA9IHRyYW5zYWN0aW9uLmFkZHJlc3M7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgdHhIYXNoID0gYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnRyYW5zYWN0aW9uSGFzaCh0cmFuc2FjdGlvbik7XFxuICAgICAgICAgICAgICAgICAgICBhZGRyc1R4c01hcFt0eEFkZHJlc3MudG9Ucnl0ZXMoKS50b1N0cmluZygpXS5wdXNoKHR4SGFzaCk7XFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVRyYW5zYWN0aW9ucy5wdXNoKHR4SGFzaCk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEodmFsdWVUcmFuc2FjdGlvbnMubGVuZ3RoID4gMCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAxNjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSAxMjtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0SW5jbHVzaW9uKHZhbHVlVHJhbnNhY3Rpb25zKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTI6XFxuICAgICAgICAgICAgICAgIGluY2x1c2lvblN0YXRlcyA9IF9jb250ZXh0MTQuc2VudDtcXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IGFkZHJlc3Nlcy5tYXAoZnVuY3Rpb24gKGFkZHJlc3MpIHtcXG4gICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUmVhdHRhY2ggPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgIHZhciB0eHMgPSBhZGRyc1R4c01hcFthZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKV07XFxuXFxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHR4cy5sZW5ndGg7IF9pKyspIHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eEluZGV4ID0gdmFsdWVUcmFuc2FjdGlvbnMuaW5kZXhPZih0eHNbX2ldKTtcXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlYXR0YWNoID0gIWluY2x1c2lvblN0YXRlc1t0eEluZGV4XTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmVhdHRhY2gpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRSZWF0dGFjaDtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDE4O1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTY6XFxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcXG5cXG4gICAgICAgICAgICAgICAgZm9yIChfaTIgPSAwOyBfaTIgPCBhZGRyZXNzZXMubGVuZ3RoOyBfaTIrKykge1xcbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0cnVlKTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgY2FzZSAxODpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCByZXN1bHRzKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTk6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMTQsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNSZWF0dGFjaGFibGUoX3g0NCkge1xcbiAgICAgICAgcmV0dXJuIF9pc1JlYXR0YWNoYWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogUHJvbW90ZXMgYSB0cmFuc2FjdGlvbiBieSBhZGRpbmcgc3BhbSBvbiB0b3Agb2YgaXQsIGFzIGxvbmcgYXMgaXQgaXMgcHJvbW90YWJsZS5cXHJcXG4gICAgICogV2lsbCBwcm9tb3RlIGJ5IGFkZGluZyB0cmFuc2ZlcnMgb24gdG9wIG9mIHRoZSBjdXJyZW50IG9uZSB3aXRoIGRlbGF5IGludGVydmFsLlxcclxcbiAgICAgKiBVc2UgcHJvbW90ZU9wdGlvbnMuaW50ZXJydXB0IHRvIHRlcm1pbmF0ZSB0aGUgcHJvbW90aW9uLlxcclxcbiAgICAgKiBJZiBwcm9tb3RlT3B0aW9ucy5kZWxheSBpcyBzZXQgdG8gMCBvbmx5IG9uZSBwcm9tb3Rpb24gdHJhbnNmZXIgd2lsbCBiZSBzZW50LlxcclxcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25UYWlsIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBwcm9tb3RlZC5cXHJcXG4gICAgICogQHBhcmFtIGRlcHRoIFZhbHVlIHRoYXQgZGV0ZXJtaW5lcyBob3cgZmFyIHRvIGdvIGZvciB0aXAgc2VsZWN0aW9uLlxcclxcbiAgICAgKiBAcGFyYW0gbWluV2VpZ2h0TWFnbml0dWRlIFRoZSBtaW5pbXVtIHdlaWdodCBtYWduaXR1ZGUgZm9yIHRoZSBwcm9vZiBvZiB3b3JrLlxcclxcbiAgICAgKiBAcGFyYW0gdHJhbnNmZXJzIFRoZSB0cmFuc2ZlcnMgdG8gc2VuZC5cXHJcXG4gICAgICogQHBhcmFtIHByb21vdGVPcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHByb21vdGUuXFxyXFxuICAgICAqICAgICAgQHByb3BlcnR5IGRlbGF5IERlbGF5IGJldHdlZW4gcHJvbW90aW9uIHRyYW5zZmVyc1xcclxcbiAgICAgKiAgICAgIEBwcm9wZXJ0eSBpbnRlcnJ1cHQgRmxhZyBvciBtZXRob2QgdG8gdGVybWluYXRlIHByb21vdGlvbi5cXHJcXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbGlzdCBvZiB0cmFuc2FjdGlvbnMgY3JlYXRlZCBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwcm9tb3RlVHJhbnNhY3Rpb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfcHJvbW90ZVRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTYodHJhbnNhY3Rpb25UYWlsLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlLCB0cmFuc2ZlcnMsIHByb21vdGVPcHRpb25zKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICAgdmFyIGxvY2FsUHJvbW90ZU9wdGlvbnMsIGlzUHJvbW90YWJsZSwgc2VuZFRyYW5zZmVyUmVzcG9uc2U7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNiQoX2NvbnRleHQxNikge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxNi5wcmV2ID0gX2NvbnRleHQxNi5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyYW5zYWN0aW9uVGFpbCwgaGFzaF8xLkhhc2gpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSB0cmFuc2FjdGlvblRhaWwgbXVzdCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBIYXNoXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGRlcHRoKSB8fCBkZXB0aCA8PSAwKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgZGVwdGggbXVzdCBiZSBhIG51bWJlciA+IDBcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoXFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgICAgICBpZiAoISghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihtaW5XZWlnaHRNYWduaXR1ZGUpIHx8IG1pbldlaWdodE1hZ25pdHVkZSA8PSAwKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDY7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUaGUgbWluV2VpZ2h0TWFnbml0dWRlIG11c3QgYmUgYSBudW1iZXIgPiAwXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgIG1pbldlaWdodE1hZ25pdHVkZTogbWluV2VpZ2h0TWFnbml0dWRlXFxuICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyYW5zZmVycywgdHJhbnNmZXJfMS5UcmFuc2ZlcikpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSA4O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHRyYW5zZmVycyBtdXN0IGFuIGFycmF5IG9mIFRyYW5zZmVyIG9iamVjdHNcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgODpcXG4gICAgICAgICAgICAgICAgbG9jYWxQcm9tb3RlT3B0aW9ucyA9IHByb21vdGVPcHRpb25zIHx8IHt9O1xcblxcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobG9jYWxQcm9tb3RlT3B0aW9ucy5pbnRlcnJ1cHQpKSB7XFxuICAgICAgICAgICAgICAgICAgbG9jYWxQcm9tb3RlT3B0aW9ucy5pbnRlcnJ1cHQgPSBmYWxzZTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoIShsb2NhbFByb21vdGVPcHRpb25zLmludGVycnVwdCA9PT0gZmFsc2UgfHwgdHlwZW9mIGxvY2FsUHJvbW90ZU9wdGlvbnMuaW50ZXJydXB0ID09PSBcXFwiZnVuY3Rpb25cXFwiICYmICFsb2NhbFByb21vdGVPcHRpb25zLmludGVycnVwdCgpKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDI4O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDEzO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1Byb21vdGFibGUodHJhbnNhY3Rpb25UYWlsKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTM6XFxuICAgICAgICAgICAgICAgIGlzUHJvbW90YWJsZSA9IF9jb250ZXh0MTYuc2VudDtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb21vdGFibGUpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAyNTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAxNztcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFRyYW5zZmVyKGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJhbnNmZXJzWzBdLmFkZHJlc3MudG9Ucnl0ZXMoKSksIGRlcHRoLCBtaW5XZWlnaHRNYWduaXR1ZGUsIHRyYW5zZmVycywgdW5kZWZpbmVkLCB0cmFuc2FjdGlvblRhaWwpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNzpcXG4gICAgICAgICAgICAgICAgc2VuZFRyYW5zZmVyUmVzcG9uc2UgPSBfY29udGV4dDE2LnNlbnQ7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsb2NhbFByb21vdGVPcHRpb25zLmRlbGF5KSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDIyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5fYmFja2dyb3VuZFRhc2tTZXJ2aWNlLmNyZWF0ZShcXG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgICAgICAgICAgICBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgICAgICAgICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE1KCkge1xcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE1JChfY29udGV4dDE1KSB7XFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTUucHJldiA9IF9jb250ZXh0MTUubmV4dCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LmFicnVwdChcXFwicmV0dXJuXFxcIiwgX3RoaXMucHJvbW90ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uVGFpbCwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSwgdHJhbnNmZXJzLCBsb2NhbFByb21vdGVPcHRpb25zKSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5zdG9wKCk7XFxuICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMTUsIHRoaXMpO1xcbiAgICAgICAgICAgICAgICB9KSksIGxvY2FsUHJvbW90ZU9wdGlvbnMuZGVsYXkpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LmFicnVwdChcXFwicmV0dXJuXFxcIiwgc2VuZFRyYW5zZmVyUmVzcG9uc2UpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyMzpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMjY7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyNTpcXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJUcmFuc2FjdGlvbiBpcyBub3QgcHJvbW90YWJsZVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyNjpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMjk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyODpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTYuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB1bmRlZmluZWQpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUxNiwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwcm9tb3RlVHJhbnNhY3Rpb24oX3g0NSwgX3g0NiwgX3g0NywgX3g0OCwgX3g0OSkge1xcbiAgICAgICAgcmV0dXJuIF9wcm9tb3RlVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIEdldHMgdGhlIGFzc29jaWF0ZWQgYnVuZGxlIHRyYW5zYWN0aW9ucyBvZiBhIHNpbmdsZSB0cmFuc2FjdGlvbi5cXHJcXG4gICAgICogRG9lcyB2YWxpZGF0aW9uIG9mIHNpZ25hdHVyZXMsIHRvdGFsIHN1bSBhcyB3ZWxsIGFzIGJ1bmRsZSBvcmRlci5cXHJcXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSGFzaCBIYXNoIG9mIGEgdHJ1bmsgb3IgYSB0YWlsIHRyYW5zYWN0aW9uIG9mIGEgYnVuZGxlLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBidW5kbGUgdHJhbnNhY3Rpb25zIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldEJ1bmRsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9nZXRCdW5kbGUgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNyh0cmFuc2FjdGlvbkhhc2gpIHtcXG4gICAgICAgIHZhciB0cmFuc2FjdGlvbnMsIGJ1bmRsZSwgaXNWYWxpZDtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE3JChfY29udGV4dDE3KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDE3LnByZXYgPSBfY29udGV4dDE3Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJhbnNhY3Rpb25IYXNoLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE3Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHRyYW5zYWN0aW9uSGFzaCBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gNDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhdmVyc2VCdW5kbGUodHJhbnNhY3Rpb25IYXNoKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zID0gX2NvbnRleHQxNy5zZW50O1xcbiAgICAgICAgICAgICAgICBidW5kbGUgPSBuZXcgYnVuZGxlXzEuQnVuZGxlKCk7XFxuICAgICAgICAgICAgICAgIGJ1bmRsZS50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XFxuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuaXNWYWxpZChidW5kbGUpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTcubmV4dCA9IDEwO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiSW52YWxpZCBidW5kbGUgcHJvdmlkZWRcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTA6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcXFwicmV0dXJuXFxcIiwgYnVuZGxlKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNy5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMTcsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0QnVuZGxlKF94NTApIHtcXG4gICAgICAgIHJldHVybiBfZ2V0QnVuZGxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBUcmF2ZXJzZSB0aGUgQnVuZGxlIGJ5IGdvaW5nIGRvd24gdGhlIHRydW5rVHJhbnNhY3Rpb25zIHVudGlsXFxyXFxuICAgICAqIHRoZSBidW5kbGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gaXMgbm8gbG9uZ2VyIHRoZSBzYW1lLlxcclxcbiAgICAgKiBAcGFyYW0gdHJ1bmtUcmFuc2FjdGlvbiBIYXNoIG9mIGEgdHJ1bmsgb3IgYSB0YWlsIHRyYW5zYWN0aW9uIG9mIGEgYnVuZGxlLlxcclxcbiAgICAgKiBAcGFyYW0gYnVuZGxlSGFzaCBUaGUgYnVuZGxlIGhhc2ggdG8gbWF0Y2guXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGJ1bmRsZSB0cmFuc2FjdGlvbnMgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidHJhdmVyc2VCdW5kbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfdHJhdmVyc2VCdW5kbGUgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxOCh0cnVua1RyYW5zYWN0aW9uLCBidW5kbGVIYXNoKSB7XFxuICAgICAgICB2YXIgYWxsQnVuZGxlVHJhbnNhY3Rpb25zLCBuZXdUcnVua1RyYW5zYWN0aW9uLCBuZXdCdW5kbGVIYXNoLCBnZXRUcnl0ZXNSZXF1ZXN0LCBnZXRUcnl0ZXNSZXNwb25zZSwgdHJ5dGVzLCB0cmFuc2FjdGlvbk9iamVjdCwgaGFzSGFzaCwgbG9jYWxCdW5kbGVIYXNoO1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTgkKF9jb250ZXh0MTgpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTgucHJldiA9IF9jb250ZXh0MTgubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cnVua1RyYW5zYWN0aW9uLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBidXNpbmVzc0Vycm9yXzEuQnVzaW5lc3NFcnJvcihcXFwiVGhlIHRydW5rVHJhbnNhY3Rpb24gbXVzdCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBIYXNoXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGFsbEJ1bmRsZVRyYW5zYWN0aW9ucyA9IFtdO1xcbiAgICAgICAgICAgICAgICBuZXdUcnVua1RyYW5zYWN0aW9uID0gdHJ1bmtUcmFuc2FjdGlvbjtcXG4gICAgICAgICAgICAgICAgbmV3QnVuZGxlSGFzaCA9IGJ1bmRsZUhhc2g7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDU6XFxuICAgICAgICAgICAgICAgIGdldFRyeXRlc1JlcXVlc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgaGFzaGVzOiBbbmV3VHJ1bmtUcmFuc2FjdGlvbi50b1RyeXRlcygpLnRvU3RyaW5nKCldXFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDg7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcGlDbGllbnQuZ2V0VHJ5dGVzKGdldFRyeXRlc1JlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA4OlxcbiAgICAgICAgICAgICAgICBnZXRUcnl0ZXNSZXNwb25zZSA9IF9jb250ZXh0MTguc2VudDtcXG4gICAgICAgICAgICAgICAgdHJ5dGVzID0gIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGdldFRyeXRlc1Jlc3BvbnNlKSAmJiAhb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoZ2V0VHJ5dGVzUmVzcG9uc2UudHJ5dGVzKSAmJiBnZXRUcnl0ZXNSZXNwb25zZS50cnl0ZXMubGVuZ3RoID4gMCA/IGdldFRyeXRlc1Jlc3BvbnNlLnRyeXRlc1swXSA6IHVuZGVmaW5lZDtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0cnl0ZXMpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQxOC5uZXh0ID0gMTQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJCdW5kbGUgdHJhbnNhY3Rpb25zIG5vdCB2aXNpYmxlXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE0OlxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk9iamVjdCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0cnl0ZXMpKTsgLy8gSWYgZmlyc3QgdHJhbnNhY3Rpb24gdG8gc2VhcmNoIGlzIG5vdCBhIHRhaWwsIHJldHVybiBlcnJvclxcblxcbiAgICAgICAgICAgICAgICBoYXNIYXNoID0gIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KG5ld0J1bmRsZUhhc2gpO1xcblxcbiAgICAgICAgICAgICAgICBpZiAoISghaGFzSGFzaCAmJiB0cmFuc2FjdGlvbk9iamVjdC5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSAhPT0gMCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSAxODtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIkludmFsaWQgdGFpbCB0cmFuc2FjdGlvbiBzdXBwbGllZFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxODpcXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gYnVuZGxlIGhhc2gsIGRlZmluZSBpdFxcbiAgICAgICAgICAgICAgICBsb2NhbEJ1bmRsZUhhc2ggPSBoYXNIYXNoID8gbmV3QnVuZGxlSGFzaCA6IHRyYW5zYWN0aW9uT2JqZWN0LmJ1bmRsZTtcXG4gICAgICAgICAgICAgICAgbmV3VHJ1bmtUcmFuc2FjdGlvbiA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgICAgICAgbmV3QnVuZGxlSGFzaCA9IHVuZGVmaW5lZDsgLy8gSWYgc2FtZSBidW5kbGUgaGFzaCBjb250aW51ZVxcblxcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxCdW5kbGVIYXNoLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSA9PT0gdHJhbnNhY3Rpb25PYmplY3QuYnVuZGxlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSkge1xcbiAgICAgICAgICAgICAgICAgIC8vIEFkZCB0cmFuc2FjdGlvbiBvYmplY3QgdG8gYnVuZGxlXFxuICAgICAgICAgICAgICAgICAgYWxsQnVuZGxlVHJhbnNhY3Rpb25zLnB1c2godHJhbnNhY3Rpb25PYmplY3QpOyAvLyBJZiBtb3JlIHRoYW4gb25lIGVsZW1lbnQgdGhlbiBjb250aW51ZVxcblxcbiAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbk9iamVjdC5sYXN0SW5kZXgudG9OdW1iZXIoKSAhPT0gMCB8fCB0cmFuc2FjdGlvbk9iamVjdC5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSAhPT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgbmV3VHJ1bmtUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uT2JqZWN0LnRydW5rVHJhbnNhY3Rpb247XFxuICAgICAgICAgICAgICAgICAgICBuZXdCdW5kbGVIYXNoID0gbG9jYWxCdW5kbGVIYXNoO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgY2FzZSAyMjpcXG4gICAgICAgICAgICAgICAgaWYgKG5ld1RydW5rVHJhbnNhY3Rpb24gIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDU7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjM6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE4LmFicnVwdChcXFwicmV0dXJuXFxcIiwgYWxsQnVuZGxlVHJhbnNhY3Rpb25zKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjQ6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMTgsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdHJhdmVyc2VCdW5kbGUoX3g1MSwgX3g1Mikge1xcbiAgICAgICAgcmV0dXJuIF90cmF2ZXJzZUJ1bmRsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogV3JhcHBlciB3aGljaCBnZXRzIGEgYnVuZGxlIGFuZCB0aGVuIHJlcGxheXMgYSB0cmFuc2ZlciBieSBkb2luZyBQcm9vZiBvZiBXb3JrIGFnYWluLlxcclxcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25IYXNoIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBwcm9tb3RlZC5cXHJcXG4gICAgICogQHBhcmFtIGRlcHRoIFZhbHVlIHRoYXQgZGV0ZXJtaW5lcyBob3cgZmFyIHRvIGdvIGZvciB0aXAgc2VsZWN0aW9uLlxcclxcbiAgICAgKiBAcGFyYW0gbWluV2VpZ2h0TWFnbml0dWRlIFRoZSBtaW5pbXVtIHdlaWdodCBtYWduaXR1ZGUgZm9yIHRoZSBwcm9vZiBvZiB3b3JrLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9ucyBjcmVhdGVkIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlYXR0YWNoQnVuZGxlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3JlYXR0YWNoQnVuZGxlID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTkodHJhbnNhY3Rpb25IYXNoLCBkZXB0aCwgbWluV2VpZ2h0TWFnbml0dWRlKSB7XFxuICAgICAgICB2YXIgYnVuZGxlO1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTkkKF9jb250ZXh0MTkpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTkucHJldiA9IF9jb250ZXh0MTkubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBfY29udGV4dDE5Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCdW5kbGUodHJhbnNhY3Rpb25IYXNoKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgYnVuZGxlID0gX2NvbnRleHQxOS5zZW50O1xcbiAgICAgICAgICAgICAgICBidW5kbGUudHJhbnNhY3Rpb25zID0gYnVuZGxlLnRyYW5zYWN0aW9ucy5yZXZlcnNlKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE5LmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5zZW5kVHJhbnNhY3Rpb25zKGJ1bmRsZSwgZGVwdGgsIG1pbldlaWdodE1hZ25pdHVkZSkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA1OlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTE5LCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlYXR0YWNoQnVuZGxlKF94NTMsIF94NTQsIF94NTUpIHtcXG4gICAgICAgIHJldHVybiBfcmVhdHRhY2hCdW5kbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIFdyYXBwZXIgd2hpY2ggZ2V0cyBhIGJ1bmRsZSBhbmQgdGhlbiBicm9hZGNhc3RzIGl0LlxcclxcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25IYXNoIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBiZSByZS1icm9hZGNhc3QuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmVicm9hZGNhc3RCdW5kbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfcmVicm9hZGNhc3RCdW5kbGUgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyMCh0cmFuc2FjdGlvbkhhc2gpIHtcXG4gICAgICAgIHZhciBidW5kbGUsIGJyb2FkY2FzdFRyYW5zYWN0aW9uc1JlcXVlc3Q7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyMCQoX2NvbnRleHQyMCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyMC5wcmV2ID0gX2NvbnRleHQyMC5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjAubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJ1bmRsZSh0cmFuc2FjdGlvbkhhc2gpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICBidW5kbGUgPSBfY29udGV4dDIwLnNlbnQ7XFxuICAgICAgICAgICAgICAgIGJyb2FkY2FzdFRyYW5zYWN0aW9uc1JlcXVlc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgdHJ5dGVzOiBidW5kbGUudHJhbnNhY3Rpb25zLnJldmVyc2UoKS5tYXAoZnVuY3Rpb24gKGJ0KSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnQudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcbiAgICAgICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjAubmV4dCA9IDY7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcGlDbGllbnQuYnJvYWRjYXN0VHJhbnNhY3Rpb25zKGJyb2FkY2FzdFRyYW5zYWN0aW9uc1JlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIGJ1bmRsZSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDc6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMC5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMjAsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcmVicm9hZGNhc3RCdW5kbGUoX3g1Nikge1xcbiAgICAgICAgcmV0dXJuIF9yZWJyb2FkY2FzdEJ1bmRsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogR2V0IHRyYW5zYWN0aW9uIG9iamVjdHMgYnkgZmlzdCBwZXJmb3JtaW5nIGEgZmluZFRyYW5zYWN0aW9ucyBjYWxsLlxcclxcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIFRoZSBhZGRyZXNzZXMgdG8gZ2V0IHRoZSB0cmFuc2FjdGlvbiBvYmplY3RzIGZvci5cXHJcXG4gICAgICogQHBhcmFtIGJ1bmRsZXMgQnVuZGxlcyB0byBsb29rdXAgdHJhbnNhY3Rpb25zIGZvci5cXHJcXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyBBZGRyZXNzZXMgdG8gbG9va3VwIHRyYW5zYWN0aW9ucyBmb3IuXFxyXFxuICAgICAqIEBwYXJhbSB0YWdzIFRhZ3MgdG8gbG9va3VwIHRyYW5zYWN0aW9ucyBmb3IuXFxyXFxuICAgICAqIEBwYXJhbSBhcHByb3ZlZXMgQXBwcm92ZWVzIHRvIGxvb2t1cCB0cmFuc2FjdGlvbnMgZm9yLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIHRyYW5zYWN0aW9ucyBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJmaW5kVHJhbnNhY3Rpb25PYmplY3RzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2ZpbmRUcmFuc2FjdGlvbk9iamVjdHMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyMShidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcykge1xcbiAgICAgICAgdmFyIHRyYW5zYWN0aW9ucztcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIxJChfY29udGV4dDIxKSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIxLnByZXYgPSBfY29udGV4dDIxLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMS5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZFRyYW5zYWN0aW9ucyhidW5kbGVzLCBhZGRyZXNzZXMsIHRhZ3MsIGFwcHJvdmVlcyk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyA9IF9jb250ZXh0MjEuc2VudDtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEodHJhbnNhY3Rpb25zLmxlbmd0aCA+IDApKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyMS5uZXh0ID0gNztcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMS5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuZ2V0VHJhbnNhY3Rpb25zT2JqZWN0cyh0cmFuc2FjdGlvbnMpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNzpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjEuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBbXSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDg6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMS5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMjEsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZmluZFRyYW5zYWN0aW9uT2JqZWN0cyhfeDU3LCBfeDU4LCBfeDU5LCBfeDYwKSB7XFxuICAgICAgICByZXR1cm4gX2ZpbmRUcmFuc2FjdGlvbk9iamVjdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIFRoZSB0cmFuc2ZlcnMgd2hpY2ggYXJlIGFzc29jaWF0ZWQgd2l0aCBhIHNlZWQuIFRoZSB0cmFuc2ZlcnMgYXJlIGRldGVybWluZWQgYnkgZWl0aGVyIGNhbGN1bGF0aW5nXFxyXFxuICAgICAqIGRldGVybWluaXN0aWNhbGx5IHdoaWNoIGFkZHJlc3NlcyB3ZXJlIGFscmVhZHkgdXNlZCwgb3IgYnkgcHJvdmlkaW5nIGEgbGlzdCBvZiBpbmRleGVzIHRvIGdldCB0aGVcXHJcXG4gICAgICogYWRkcmVzc2VzIGFuZCB0aGUgYXNzb2NpYXRlZCB0cmFuc2ZlcnMgZnJvbS4gVGhlIHRyYW5zZmVycyBhcmUgc29ydGVkIGJ5IHRoZWlyIHRpbWVzdGFtcC5cXHJcXG4gICAgICogQHBhcmFtIHNlZWQgVGhlIHNlZWQgdG8gZ2V0IHRoZSB0cmFuc2ZlcnMgZm9yXFxyXFxuICAgICAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSBzdGFydCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXFxyXFxuICAgICAqIEBwYXJhbSBlbmRJbmRleCBUaGUgZW5kIGluZGV4IHRvIGdldCB0aGUgdHJhbnNmZXJzIGZvci5cXHJcXG4gICAgICogQHBhcmFtIHNlY3VyaXR5IFRoZSBzZWN1cml0eSBsZXZlbCBmb3IgdGhlIHRyYW5zZmVycy5cXHJcXG4gICAgICogQHBhcmFtIGluY2x1c2lvblN0YXRlcyBEbyB5b3Ugd2FudCBpbmNsdXNpb24gc3RhdGVzIGluIHRoZSBidW5kbGVzLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXF1ZXN0ZWQgYnVuZGxlcyBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRUcmFuc2ZlcnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfZ2V0VHJhbnNmZXJzID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMjIoc2VlZCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIHNlY3VyaXR5LCBpbmNsdXNpb25TdGF0ZXMpIHtcXG4gICAgICAgIHZhciBsb2NhbFN0YXJ0SW5kZXgsIGFkZHJlc3NlcztcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIyJChfY29udGV4dDIyKSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIyLnByZXYgPSBfY29udGV4dDIyLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgaGFzaF8xLkhhc2gpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyMi5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBzZWVkIG11c3QgYmUgb2YgdHlwZSBIYXNoXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGxvY2FsU3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsb2NhbFN0YXJ0SW5kZXgpKSB7XFxuICAgICAgICAgICAgICAgICAgbG9jYWxTdGFydEluZGV4ID0gMDtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBfY29udGV4dDIyLm5leHQgPSA2O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROZXdBZGRyZXNzKHNlZWQsIGxvY2FsU3RhcnRJbmRleCwgZW5kSW5kZXgsIGZhbHNlLCBzZWN1cml0eSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDY6XFxuICAgICAgICAgICAgICAgIGFkZHJlc3NlcyA9IF9jb250ZXh0MjIuc2VudDtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjIuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB0aGlzLmJ1bmRsZXNGcm9tQWRkcmVzc2VzKGFkZHJlc3NlcywgaW5jbHVzaW9uU3RhdGVzKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDg6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMi5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMjIsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0VHJhbnNmZXJzKF94NjEsIF94NjIsIF94NjMsIF94NjQsIF94NjUpIHtcXG4gICAgICAgIHJldHVybiBfZ2V0VHJhbnNmZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBTaW1pbGFyIHRvIGdldFRyYW5zZmVycywganVzdCB0aGF0IGl0IHJldHVybnMgYWRkaXRpb25hbCBhY2NvdW50IGRhdGEuXFxyXFxuICAgICAqIEBwYXJhbSBzZWVkIFRoZSBzZWVkIHRvIGdldCB0aGUgdHJhbnNmZXJzIGZvclxcclxcbiAgICAgKiBAcGFyYW0gc3RhcnRJbmRleCBUaGUgc3RhcnQgaW5kZXggdG8gZ2V0IHRoZSB0cmFuc2ZlcnMgZm9yLlxcclxcbiAgICAgKiBAcGFyYW0gZW5kSW5kZXggVGhlIGVuZCBpbmRleCB0byBnZXQgdGhlIHRyYW5zZmVycyBmb3IuXFxyXFxuICAgICAqIEBwYXJhbSBzZWN1cml0eSBUaGUgc2VjdXJpdHkgbGV2ZWwgZm9yIHRoZSB0cmFuc2ZlcnMuXFxyXFxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGFjY291bnQgZGF0YSBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXRBY2NvdW50RGF0YVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9nZXRBY2NvdW50RGF0YSA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIzKHNlZWQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzZWN1cml0eSkge1xcbiAgICAgICAgdmFyIGxvY2FsU3RhcnRJbmRleCwgYWRkcmVzc2VzLCBidW5kbGVzLCBhY2NvdW50RGF0YSwgYmFsYW5jZVJlcXVlc3QsIGJhbGFuY2VSZXNwb25zZSwgaSwgYmFsYW5jZTtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIzJChfY29udGV4dDIzKSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIzLnByZXYgPSBfY29udGV4dDIzLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2VlZCwgaGFzaF8xLkhhc2gpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyMy5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgYnVzaW5lc3NFcnJvcl8xLkJ1c2luZXNzRXJyb3IoXFxcIlRoZSBzZWVkIG11c3QgYmUgb2YgdHlwZSBIYXNoXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGxvY2FsU3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsb2NhbFN0YXJ0SW5kZXgpKSB7XFxuICAgICAgICAgICAgICAgICAgbG9jYWxTdGFydEluZGV4ID0gMDtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBfY29udGV4dDIzLm5leHQgPSA2O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXROZXdBZGRyZXNzKHNlZWQsIGxvY2FsU3RhcnRJbmRleCwgZW5kSW5kZXgsIGZhbHNlLCBzZWN1cml0eSB8fCBhZGRyZXNzU2VjdXJpdHlfMS5BZGRyZXNzU2VjdXJpdHkubWVkaXVtKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNjpcXG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzID0gX2NvbnRleHQyMy5zZW50O1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDIzLm5leHQgPSA5O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idW5kbGVzRnJvbUFkZHJlc3NlcyhhZGRyZXNzZXMsIHRydWUpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA5OlxcbiAgICAgICAgICAgICAgICBidW5kbGVzID0gX2NvbnRleHQyMy5zZW50O1xcbiAgICAgICAgICAgICAgICBhY2NvdW50RGF0YSA9IHtcXG4gICAgICAgICAgICAgICAgICBsYXRlc3RBZGRyZXNzOiBhZGRyZXNzZXMucG9wKCksXFxuICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMsXFxuICAgICAgICAgICAgICAgICAgdHJhbnNmZXJzOiBidW5kbGVzLFxcbiAgICAgICAgICAgICAgICAgIGlucHV0czogW10sXFxuICAgICAgICAgICAgICAgICAgYmFsYW5jZTogMFxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICBiYWxhbmNlUmVxdWVzdCA9IHtcXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IGFjY291bnREYXRhLmFkZHJlc3Nlcy5tYXAoZnVuY3Rpb24gKGFkZCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZC50b1RyeXRlcygpLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgICAgICAgfSksXFxuICAgICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxMDBcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyMy5uZXh0ID0gMTQ7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcGlDbGllbnQuZ2V0QmFsYW5jZXMoYmFsYW5jZVJlcXVlc3QpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNDpcXG4gICAgICAgICAgICAgICAgYmFsYW5jZVJlc3BvbnNlID0gX2NvbnRleHQyMy5zZW50O1xcblxcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFsYW5jZVJlc3BvbnNlLmJhbGFuY2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgICAgYmFsYW5jZSA9IHBhcnNlSW50KGJhbGFuY2VSZXNwb25zZS5iYWxhbmNlc1tpXSwgMTApO1xcblxcbiAgICAgICAgICAgICAgICAgIGlmIChiYWxhbmNlID4gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudERhdGEuaW5wdXRzLnB1c2goaW5wdXRfMS5JbnB1dC5mcm9tUGFyYW1zKGFjY291bnREYXRhLmFkZHJlc3Nlc1tpXSwgc2VjdXJpdHkgfHwgYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5Lm1lZGl1bSwgbG9jYWxTdGFydEluZGV4ICsgaSwgYmFsYW5jZSkpO1xcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudERhdGEuYmFsYW5jZSArPSBiYWxhbmNlO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMy5hYnJ1cHQoXFxcInJldHVyblxcXCIsIGFjY291bnREYXRhKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTc6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMy5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMjMsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZ2V0QWNjb3VudERhdGEoX3g2NiwgX3g2NywgX3g2OCwgX3g2OSkge1xcbiAgICAgICAgcmV0dXJuIF9nZXRBY2NvdW50RGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYnVuZGxlc0Zyb21BZGRyZXNzZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfYnVuZGxlc0Zyb21BZGRyZXNzZXMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNChhZGRyZXNzZXMsIGluY2x1c2lvblN0YXRlcykge1xcbiAgICAgICAgdmFyIHRyYW5zYWN0aW9uT2JqZWN0cywgdGFpbFRyYW5zYWN0aW9ucywgbm9uVGFpbEJ1bmRsZUhhc2hlcywgbm9uVGFpbEJ1bmRsZVRyYW5zYWN0aW9ucywgZmluYWxCdW5kbGVzLCB0YWlsVHhBcnJheSwgdGFpbFR4U3RhdGVzLCBpLCBidW5kbGU7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNCQoX2NvbnRleHQyNCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNC5wcmV2ID0gX2NvbnRleHQyNC5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRUcmFuc2FjdGlvbk9iamVjdHModW5kZWZpbmVkLCBhZGRyZXNzZXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25PYmplY3RzID0gX2NvbnRleHQyNC5zZW50O1xcbiAgICAgICAgICAgICAgICAvLyBzZXQgb2YgdGFpbCB0cmFuc2FjdGlvbnNcXG4gICAgICAgICAgICAgICAgdGFpbFRyYW5zYWN0aW9ucyA9IG5ldyBTZXQoKTtcXG4gICAgICAgICAgICAgICAgbm9uVGFpbEJ1bmRsZUhhc2hlcyA9IG5ldyBTZXQoKTtcXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25PYmplY3RzLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XFxuICAgICAgICAgICAgICAgICAgLy8gU29ydCB0YWlsIGFuZCBub25UYWlsc1xcbiAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5jdXJyZW50SW5kZXgudG9OdW1iZXIoKSA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGFpbFRyYW5zYWN0aW9ucy5hZGQoYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnRyYW5zYWN0aW9uSGFzaCh0cmFuc2FjdGlvbikudG9Ucnl0ZXMoKS50b1N0cmluZygpKTtcXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgbm9uVGFpbEJ1bmRsZUhhc2hlcy5hZGQodHJhbnNhY3Rpb24uYnVuZGxlLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCEobm9uVGFpbEJ1bmRsZUhhc2hlcy5zaXplID4gMCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI0Lm5leHQgPSAxMTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBfY29udGV4dDI0Lm5leHQgPSA5O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kVHJhbnNhY3Rpb25PYmplY3RzKEFycmF5LmZyb20obm9uVGFpbEJ1bmRsZUhhc2hlcykubWFwKGZ1bmN0aW9uIChoYXNoKSB7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoaGFzaCkpO1xcbiAgICAgICAgICAgICAgICB9KSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDk6XFxuICAgICAgICAgICAgICAgIG5vblRhaWxCdW5kbGVUcmFuc2FjdGlvbnMgPSBfY29udGV4dDI0LnNlbnQ7XFxuICAgICAgICAgICAgICAgIG5vblRhaWxCdW5kbGVUcmFuc2FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcXG4gICAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uY3VycmVudEluZGV4LnRvTnVtYmVyKCkgPT09IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHRhaWxUcmFuc2FjdGlvbnMuYWRkKGJ1bmRsZUhlbHBlcl8xLkJ1bmRsZUhlbHBlci50cmFuc2FjdGlvbkhhc2godHJhbnNhY3Rpb24pLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTE6XFxuICAgICAgICAgICAgICAgIGZpbmFsQnVuZGxlcyA9IFtdO1xcbiAgICAgICAgICAgICAgICB0YWlsVHhBcnJheSA9IEFycmF5LmZyb20odGFpbFRyYW5zYWN0aW9ucyk7IC8vIElmIGluY2x1c2lvblN0YXRlcywgZ2V0IHRoZSBjb25maXJtYXRpb24gc3RhdHVzXFxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSB0YWlsIHRyYW5zYWN0aW9ucywgYW5kIHRodXMgdGhlIGJ1bmRsZXNcXG5cXG4gICAgICAgICAgICAgICAgaWYgKCFpbmNsdXNpb25TdGF0ZXMpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI0Lm5leHQgPSAxNztcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBfY29udGV4dDI0Lm5leHQgPSAxNjtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0SW5jbHVzaW9uKHRhaWxUeEFycmF5Lm1hcChmdW5jdGlvbiAodGFpbCkge1xcbiAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRhaWwpKTtcXG4gICAgICAgICAgICAgICAgfSkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNjpcXG4gICAgICAgICAgICAgICAgdGFpbFR4U3RhdGVzID0gX2NvbnRleHQyNC5zZW50O1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNzpcXG4gICAgICAgICAgICAgICAgaSA9IDA7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE4OlxcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgdGFpbFR4QXJyYXkubGVuZ3RoKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDI3O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjQubmV4dCA9IDIxO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCdW5kbGUoaGFzaF8xLkhhc2guZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0YWlsVHhBcnJheVtpXSkpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjE6XFxuICAgICAgICAgICAgICAgIGJ1bmRsZSA9IF9jb250ZXh0MjQuc2VudDtcXG4gICAgICAgICAgICAgICAgYnVuZGxlLmluY2x1c2lvblN0YXRlID0gdGFpbFR4U3RhdGVzID8gdGFpbFR4U3RhdGVzW2ldIDogdW5kZWZpbmVkO1xcbiAgICAgICAgICAgICAgICBmaW5hbEJ1bmRsZXMucHVzaChidW5kbGUpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyNDpcXG4gICAgICAgICAgICAgICAgaSsrO1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDI0Lm5leHQgPSAxODtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI3OlxcbiAgICAgICAgICAgICAgICAvLyBTb3J0IGJ1bmRsZXMgYnkgdGltZXN0YW1wXFxuICAgICAgICAgICAgICAgIGZpbmFsQnVuZGxlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgICAgICAgICAgdmFyIHggPSBhLnRyYW5zYWN0aW9uc1swXS5hdHRhY2htZW50VGltZXN0YW1wLnRvTnVtYmVyKCk7XFxuICAgICAgICAgICAgICAgICAgdmFyIHkgPSBiLnRyYW5zYWN0aW9uc1swXS5hdHRhY2htZW50VGltZXN0YW1wLnRvTnVtYmVyKCk7XFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPCB5ID8gLTEgOiB4ID4geSA/IDEgOiAwO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBmaW5hbEJ1bmRsZXMpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUyNCwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBidW5kbGVzRnJvbUFkZHJlc3NlcyhfeDcwLCBfeDcxKSB7XFxuICAgICAgICByZXR1cm4gX2J1bmRsZXNGcm9tQWRkcmVzc2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZW5lcmF0ZUFkZHJlc3NcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVBZGRyZXNzKHNlZWQsIGluZGV4LCBzZWN1cml0eSwgaW5jbHVkZUNoZWNrc3VtKSB7XFxuICAgICAgdmFyIGtleSA9IHNpZ25pbmdfMS5TaWduaW5nLmtleShzZWVkLCBpbmRleCwgc2VjdXJpdHkpO1xcbiAgICAgIHZhciBkaWdlc3RzID0gc2lnbmluZ18xLlNpZ25pbmcuZGlnZXN0cyhrZXkpO1xcbiAgICAgIHZhciBhZGRyZXNzVHJpdHMgPSBzaWduaW5nXzEuU2lnbmluZy5hZGRyZXNzKGRpZ2VzdHMpO1xcbiAgICAgIHZhciBhZGRyZXNzVHJ5dGVzU3RyaW5nID0gdHJpdHNfMS5Ucml0cy5mcm9tQXJyYXkoYWRkcmVzc1RyaXRzKS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XFxuXFxuICAgICAgaWYgKGluY2x1ZGVDaGVja3N1bSkge1xcbiAgICAgICAgYWRkcmVzc1RyeXRlc1N0cmluZyArPSBzaWduaW5nXzEuU2lnbmluZy5jcmVhdGVDaGVja3N1bShhZGRyZXNzVHJpdHMsIDkpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gYWRkcmVzc18xLkFkZHJlc3MuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhhZGRyZXNzVHJ5dGVzU3RyaW5nKSk7XFxuICAgIH1cXG4gICAgLyogQGludGVybmFsICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFkZFJlbWFpbmRlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9hZGRSZW1haW5kZXIgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNShzZWVkLCBidW5kbGUsIHRyYW5zZmVyT3B0aW9ucywgaW5wdXRzLCBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzLCB0b3RhbFZhbHVlLCB0YWcsIGFkZGVkSE1BQykge1xcbiAgICAgICAgdmFyIHRvdGFsVHJhbnNmZXJWYWx1ZSwgaSwgdGltZXN0YW1wLCByZW1haW5kZXIsIHN0YXJ0SW5kZXgsIGssIGFkZHJlc3NlcywgdHM7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyNSQoX2NvbnRleHQyNSkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyNS5wcmV2ID0gX2NvbnRleHQyNS5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIHRvdGFsVHJhbnNmZXJWYWx1ZSA9IHRvdGFsVmFsdWU7XFxuICAgICAgICAgICAgICAgIGkgPSAwO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgaW5wdXRzLmxlbmd0aCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAzMTtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgPSBNYXRoLmZsb29yKHRoaXMuX3RpbWVTZXJ2aWNlLm1zU2luY2VFcG9jaCgpIC8gMTAwMCk7IC8vIEFkZCBpbnB1dCBhcyBidW5kbGUgZW50cnlcXG5cXG4gICAgICAgICAgICAgICAgYnVuZGxlLmFkZFRyYW5zYWN0aW9ucyhpbnB1dHNbaV0uc2VjdXJpdHksIGlucHV0c1tpXS5hZGRyZXNzLCAtaW5wdXRzW2ldLmJhbGFuY2UsIHRhZywgdGltZXN0YW1wKTsgLy8gSWYgdGhlcmUgaXMgYSByZW1haW5kZXIgdmFsdWVcXG4gICAgICAgICAgICAgICAgLy8gQWRkIGV4dHJhIG91dHB1dCB0byBzZW5kIHJlbWFpbmluZyBmdW5kcyB0b1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIShpbnB1dHNbaV0uYmFsYW5jZSA+PSB0b3RhbFRyYW5zZmVyVmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNS5uZXh0ID0gMjc7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgcmVtYWluZGVyID0gaW5wdXRzW2ldLmJhbGFuY2UgLSB0b3RhbFRyYW5zZmVyVmFsdWU7IC8vIElmIHVzZXIgaGFzIHByb3ZpZGVkIHJlbWFpbmRlciBhZGRyZXNzIHVzZSBpdCB0byBzZW5kIHJlbWFpbmluZyBmdW5kcyB0b1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIShyZW1haW5kZXIgPiAwICYmICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0cmFuc2Zlck9wdGlvbnMpICYmIG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJhbnNmZXJPcHRpb25zLnJlbWFpbmRlckFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAxMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAvLyBSZW1haW5kZXIgYnVuZGxlIGVudHJ5XFxuICAgICAgICAgICAgICAgIGJ1bmRsZS5hZGRUcmFuc2FjdGlvbnMoMSwgdHJhbnNmZXJPcHRpb25zLnJlbWFpbmRlckFkZHJlc3MsIHJlbWFpbmRlciwgdGFnLCB0aW1lc3RhbXApOyAvLyBGaW5hbCBmdW5jdGlvbiBmb3Igc2lnbmluZyBpbnB1dHNcXG5cXG4gICAgICAgICAgICAgICAgYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnNpZ25JbnB1dHMoc2VlZCwgYnVuZGxlLCB0cmFuc2Zlck9wdGlvbnMsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIGlucHV0cywgYWRkZWRITUFDKTtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNS5uZXh0ID0gMjU7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxMjpcXG4gICAgICAgICAgICAgICAgaWYgKCEocmVtYWluZGVyID4gMCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAyNDtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gMDtcXG5cXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGlucHV0cy5sZW5ndGg7IGsrKykge1xcbiAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1heChpbnB1dHNba10ua2V5SW5kZXgsIHN0YXJ0SW5kZXgpO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNS5uZXh0ID0gMTg7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFkZHJlc3Nlc1RvVW51c2VkKHNlZWQsIHN0YXJ0SW5kZXgsIGZhbHNlLCB0cmFuc2Zlck9wdGlvbnMuc2VjdXJpdHkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxODpcXG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzID0gX2NvbnRleHQyNS5zZW50O1xcbiAgICAgICAgICAgICAgICB0cyA9IE1hdGguZmxvb3IodGhpcy5fdGltZVNlcnZpY2UubXNTaW5jZUVwb2NoKCkgLyAxMDAwKTsgLy8gUmVtYWluZGVyIGJ1bmRsZSBlbnRyeVxcblxcbiAgICAgICAgICAgICAgICBidW5kbGUuYWRkVHJhbnNhY3Rpb25zKDEsIGFkZHJlc3Nlc1thZGRyZXNzZXMubGVuZ3RoIC0gMV0sIHJlbWFpbmRlciwgdGFnLCB0cyk7IC8vIEZpbmFsIGZ1bmN0aW9uIGZvciBzaWduaW5nIGlucHV0c1xcblxcbiAgICAgICAgICAgICAgICBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIuc2lnbklucHV0cyhzZWVkLCBidW5kbGUsIHRyYW5zZmVyT3B0aW9ucywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cywgaW5wdXRzLCBhZGRlZEhNQUMpO1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAyNTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI0OlxcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyByZW1haW5kZXIsIGRvIG5vdCBhZGQgdHJhbnNhY3Rpb24gdG8gYnVuZGxlXFxuICAgICAgICAgICAgICAgIC8vIHNpbXBseSBzaWduIGFuZCByZXR1cm5cXG4gICAgICAgICAgICAgICAgYnVuZGxlSGVscGVyXzEuQnVuZGxlSGVscGVyLnNpZ25JbnB1dHMoc2VlZCwgYnVuZGxlLCB0cmFuc2Zlck9wdGlvbnMsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMsIGlucHV0cywgYWRkZWRITUFDKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjU6XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjUubmV4dCA9IDI4O1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjc6XFxuICAgICAgICAgICAgICAgIC8vIElmIG11bHRpcGxlIGlucHV0cyBwcm92aWRlZCwgc3VidHJhY3QgdGhlIHRvdGFsVHJhbnNmZXJWYWx1ZSBieVxcbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5wdXRzIGJhbGFuY2VcXG4gICAgICAgICAgICAgICAgdG90YWxUcmFuc2ZlclZhbHVlIC09IGlucHV0c1tpXS5iYWxhbmNlO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyODpcXG4gICAgICAgICAgICAgICAgaSsrO1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSAyO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMzE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNS5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMjUsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gYWRkUmVtYWluZGVyKF94NzIsIF94NzMsIF94NzQsIF94NzUsIF94NzYsIF94NzcsIF94NzgsIF94NzkpIHtcXG4gICAgICAgIHJldHVybiBfYWRkUmVtYWluZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwcm9vZk9mV29ya0l0ZXJhdGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfcHJvb2ZPZldvcmtJdGVyYXRlID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMjYodHJ1bmtUcmFuc2FjdGlvbiwgYnJhbmNoVHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9ucywgbWluV2VpZ2h0TWFnbml0dWRlKSB7XFxuICAgICAgICB2YXIgZmluYWxUcmFuc2FjdGlvbnMsIHByZXZpb3VzVHJhbnNhY3Rpb25IYXNoLCBpLCBuZXdUcnl0ZXMsIHJldHVybmVkVHJ5dGVzLCByZXR1cm5UcmFuc2FjdGlvbjtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI2JChfY29udGV4dDI2KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDI2LnByZXYgPSBfY29udGV4dDI2Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgZmluYWxUcmFuc2FjdGlvbnMgPSBbXTtcXG4gICAgICAgICAgICAgICAgaSA9IDA7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmICghKGkgPCB0cmFuc2FjdGlvbnMubGVuZ3RoKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjYubmV4dCA9IDI2O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggbGFzdCBpbmRleCB0cmFuc2FjdGlvblxcbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gaXQgdGhlIHRydW5rIC8gYnJhbmNoIHdoaWNoIHRoZSB1c2VyIGhhcyBzdXBwbGllZFxcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGJ1bmRsZSwgY2hhaW4gdGhlIGJ1bmRsZSB0cmFuc2FjdGlvbnMgdmlhXFxuICAgICAgICAgICAgICAgIC8vIHRydW5rVHJhbnNhY3Rpb24gdG9nZXRoZXJcXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zW2ldLmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIodGhpcy5fdGltZVNlcnZpY2UubXNTaW5jZUVwb2NoKCkpO1xcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNbaV0uYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoMCk7XFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uc1tpXS5hdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcihUcmFuc2FjdGlvbkNsaWVudC5NQVhfVElNRVNUQU1QX1ZBTFVFKTsgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdHJhbnNhY3Rpb24sIHRvIGJlIHByb2Nlc3NlZFxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBpdCdzIHRoZSBsYXN0IGluIHRoZSBidW5kbGUgYW5kIHRoZW5cXG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIGl0IHRoZSBzdXBwbGllZCB0cnVuayBhbmQgYnJhbmNoIHRyYW5zYWN0aW9uc1xcblxcbiAgICAgICAgICAgICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHByZXZpb3VzVHJhbnNhY3Rpb25IYXNoKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjYubmV4dCA9IDEzO1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uc1tpXS5sYXN0SW5kZXgudG9OdW1iZXIoKSAhPT0gdHJhbnNhY3Rpb25zW2ldLmN1cnJlbnRJbmRleC50b051bWJlcigpKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjYubmV4dCA9IDk7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGJ1c2luZXNzRXJyb3JfMS5CdXNpbmVzc0Vycm9yKFxcXCJXcm9uZyBidW5kbGUgb3JkZXIuIFRoZSBidW5kbGUgc2hvdWxkIGJlIG9yZGVyZWQgaW4gZGVzY2VuZGluZyBvcmRlciBmcm9tIGN1cnJlbnRJbmRleFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA5OlxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNbaV0udHJ1bmtUcmFuc2FjdGlvbiA9IHRydW5rVHJhbnNhY3Rpb247XFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uc1tpXS5icmFuY2hUcmFuc2FjdGlvbiA9IGJyYW5jaFRyYW5zYWN0aW9uO1xcbiAgICAgICAgICAgICAgICBfY29udGV4dDI2Lm5leHQgPSAxNTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDEzOlxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNbaV0udHJ1bmtUcmFuc2FjdGlvbiA9IHByZXZpb3VzVHJhbnNhY3Rpb25IYXNoO1xcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNbaV0uYnJhbmNoVHJhbnNhY3Rpb24gPSB0cnVua1RyYW5zYWN0aW9uO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNTpcXG4gICAgICAgICAgICAgICAgbmV3VHJ5dGVzID0gdHJhbnNhY3Rpb25zW2ldLnRvVHJ5dGVzKCk7XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjYubmV4dCA9IDE4O1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvb2ZPZldvcmsucG93KHRydW5rVHJhbnNhY3Rpb24sIGJyYW5jaFRyYW5zYWN0aW9uLCBbbmV3VHJ5dGVzXSwgbWluV2VpZ2h0TWFnbml0dWRlKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTg6XFxuICAgICAgICAgICAgICAgIHJldHVybmVkVHJ5dGVzID0gX2NvbnRleHQyNi5zZW50O1xcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnNbaV0ubm9uY2UgPSB0YWdfMS5UYWcuZnJvbVRyeXRlcyhyZXR1cm5lZFRyeXRlc1swXS5zdWIodHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5MRU5HVEggLSB0YWdfMS5UYWcuTEVOR1RILCB0YWdfMS5UYWcuTEVOR1RIKSk7IC8vIENhbGN1bGF0ZSB0aGUgaGFzaCBvZiB0aGUgbmV3IHRyYW5zYWN0aW9uIHdpdGggbm9uY2UgYW5kIHVzZSB0aGF0IGFzIHRoZSBwcmV2aW91cyBoYXNoIGZvciBuZXh0IGVudHJ5XFxuXFxuICAgICAgICAgICAgICAgIHJldHVyblRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5mcm9tVHJ5dGVzKHJldHVybmVkVHJ5dGVzWzBdKTtcXG4gICAgICAgICAgICAgICAgcHJldmlvdXNUcmFuc2FjdGlvbkhhc2ggPSBidW5kbGVIZWxwZXJfMS5CdW5kbGVIZWxwZXIudHJhbnNhY3Rpb25IYXNoKHJldHVyblRyYW5zYWN0aW9uKTtcXG4gICAgICAgICAgICAgICAgZmluYWxUcmFuc2FjdGlvbnMucHVzaChyZXR1cm5UcmFuc2FjdGlvbik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDIzOlxcbiAgICAgICAgICAgICAgICBpKys7XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0MjYubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyNjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjYuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBQcm9taXNlLnJlc29sdmUoZmluYWxUcmFuc2FjdGlvbnMucmV2ZXJzZSgpKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI3OlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjYuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTI2LCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHByb29mT2ZXb3JrSXRlcmF0ZShfeDgwLCBfeDgxLCBfeDgyLCBfeDgzKSB7XFxuICAgICAgICByZXR1cm4gX3Byb29mT2ZXb3JrSXRlcmF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFRyYW5zYWN0aW9uQ2xpZW50O1xcbn0oKTtcXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5cXG5UcmFuc2FjdGlvbkNsaWVudC5OVUxMX0hBU0hfVFJZVEVTID0gXFxcIjlcXFwiLnJlcGVhdCgyNDMpO1xcbi8qIEBpbnRlcm5hbCAqL1xcblxcblRyYW5zYWN0aW9uQ2xpZW50Lk1BWF9USU1FU1RBTVBfVkFMVUUgPSAoTWF0aC5wb3coMywgMjcpIC0gMSkgLyAyO1xcbi8qIEBpbnRlcm5hbCAqL1xcblxcblRyYW5zYWN0aW9uQ2xpZW50Lk1BWF9JTlBVVFMgPSA1MDA7XFxuZXhwb3J0cy5UcmFuc2FjdGlvbkNsaWVudCA9IFRyYW5zYWN0aW9uQ2xpZW50O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWJ1c2luZXNzL2Rpc3QvdHJhbnNhY3Rpb25zL3RyYW5zYWN0aW9uQ2xpZW50LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1idXNpbmVzcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWdlbmVyYXRvci1ydW50aW1lICovIFxcXCIuLi9pb3RhLXBpY28tYnVzaW5lc3Mvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcXFwiKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1idXNpbmVzcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tYnVzaW5lc3Mvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1idXNpbmVzcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xcbnZhciBnID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFxcXCJyZXR1cm4gdGhpc1xcXCIpKCk7XFxuXFxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXFxuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxcbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXFxcInJlZ2VuZXJhdG9yUnVudGltZVxcXCIpID49IDA7XFxuXFxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxcbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcXG5cXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXFxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3J1bnRpbWUgKi8gXFxcIi4uL2lvdGEtcGljby1idXNpbmVzcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXFxcIik7XFxuXFxuaWYgKGhhZFJ1bnRpbWUpIHtcXG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXFxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XFxufSBlbHNlIHtcXG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXFxuICB0cnkge1xcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuICB9IGNhdGNoKGUpIHtcXG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XFxuICB9XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWJ1c2luZXNzL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWJ1c2luZXNzL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWJ1c2luZXNzL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIi8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXFxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgPyBTeW1ib2wgOiB7fTtcXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXFxcIkBAaXRlcmF0b3JcXFwiO1xcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXFxcIkBAYXN5bmNJdGVyYXRvclxcXCI7XFxuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFxcXCJAQHRvU3RyaW5nVGFnXFxcIjtcXG5cXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFxcXCJvYmplY3RcXFwiO1xcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xcbiAgaWYgKHJ1bnRpbWUpIHtcXG4gICAgaWYgKGluTW9kdWxlKSB7XFxuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXFxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xcbiAgICB9XFxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xcblxcbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XFxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XFxuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xcblxcbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xcblxcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xcbiAgfVxcbiAgcnVudGltZS53cmFwID0gd3JhcDtcXG5cXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxcbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXFxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiB7IHR5cGU6IFxcXCJub3JtYWxcXFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHJldHVybiB7IHR5cGU6IFxcXCJ0aHJvd1xcXCIsIGFyZzogZXJyIH07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXFxcInN1c3BlbmRlZFN0YXJ0XFxcIjtcXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXFxcInN1c3BlbmRlZFlpZWxkXFxcIjtcXG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFxcXCJleGVjdXRpbmdcXFwiO1xcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXFxcImNvbXBsZXRlZFxcXCI7XFxuXFxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXFxuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXFxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xcblxcbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXFxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cXG5cXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcXG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXFxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcXG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcblxcbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXFxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXFxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXFxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XFxuICB9XFxuXFxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxcbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XFxuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcXG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIjtcXG5cXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXFxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxcbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xcbiAgICBbXFxcIm5leHRcXFwiLCBcXFwidGhyb3dcXFwiLCBcXFwicmV0dXJuXFxcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcXG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcXG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcXG4gICAgcmV0dXJuIGN0b3JcXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXFxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXFxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiXFxuICAgICAgOiBmYWxzZTtcXG4gIH07XFxuXFxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcXG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XFxuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCI7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcXG4gICAgcmV0dXJuIGdlbkZ1bjtcXG4gIH07XFxuXFxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFxcXCJfX2F3YWl0XFxcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcXG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XFxuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XFxuICAgICAgICBpZiAodmFsdWUgJiZcXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFxcXCJvYmplY3RcXFwiICYmXFxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFxcXCJfX2F3YWl0XFxcIikpIHtcXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICAgICAgaW52b2tlKFxcXCJuZXh0XFxcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xcbiAgICAgICAgICAgIGludm9rZShcXFwidGhyb3dcXFwiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcXG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXFxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXFxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXFxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxcbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcXG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXFxuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXFxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XFxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcXG4gICAgICAgIH0sIHJlamVjdCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XFxuXFxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcXG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxcbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXFxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xcbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xcbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XFxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcXG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XFxuICAgIH1cXG5cXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXFxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XFxuICB9XFxuXFxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XFxuXFxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXFxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxcbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XFxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcXG4gICAgKTtcXG5cXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXFxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcXG4gICAgICAgIH0pO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xcblxcbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XFxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcXG4gICAgICAgIGlmIChtZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgdGhyb3cgYXJnO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcXG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xcblxcbiAgICAgIHdoaWxlICh0cnVlKSB7XFxuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XFxuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwibmV4dFxcXCIpIHtcXG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXFxuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXFxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XFxuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJyZXR1cm5cXFwiKSB7XFxuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBjb250ZXh0LmFyZyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xcblxcbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwibm9ybWFsXFxcIikge1xcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XFxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xcblxcbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XFxuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXFxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXFxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxcbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcXG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcblxcbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXFxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwicmV0dXJuXFxcIjtcXG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xcblxcbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxcbiAgICAgICAgICAgIC8vIFxcXCJyZXR1cm5cXFwiIHRvIFxcXCJ0aHJvd1xcXCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXFxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcXG4gICAgICAgICAgXFxcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcXG5cXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XFxuXFxuICAgIGlmICghIGluZm8pIHtcXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxcXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFxcXCIpO1xcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIGlmIChpbmZvLmRvbmUpIHtcXG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXFxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XFxuXFxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxcbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XFxuXFxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFxcXCJ0aHJvd1xcXCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXFxcIm5leHRcXFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cXG4gICAgICAvLyBcXFwiY29uc3VtZWRcXFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXFxuICAgICAgLy8gXFxcInJldHVyblxcXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXFxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxcbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cXG4gICAgICByZXR1cm4gaW5mbztcXG4gICAgfVxcblxcbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxcbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICB9XFxuXFxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxcbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcXG5cXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFxcXCJHZW5lcmF0b3JcXFwiO1xcblxcbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXFxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXFxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gXFxcIltvYmplY3QgR2VuZXJhdG9yXVxcXCI7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcXG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcXG5cXG4gICAgaWYgKDEgaW4gbG9jcykge1xcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcXG4gICAgfVxcblxcbiAgICBpZiAoMiBpbiBsb2NzKSB7XFxuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XFxuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xcbiAgICB9XFxuXFxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcXG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XFxuICAgIHJlY29yZC50eXBlID0gXFxcIm5vcm1hbFxcXCI7XFxuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxcbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXFxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXFxcInJvb3RcXFwiIH1dO1xcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XFxuICAgIHRoaXMucmVzZXQodHJ1ZSk7XFxuICB9XFxuXFxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcXG4gICAgdmFyIGtleXMgPSBbXTtcXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xcbiAgICAgIGtleXMucHVzaChrZXkpO1xcbiAgICB9XFxuICAgIGtleXMucmV2ZXJzZSgpO1xcblxcbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcXG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcXG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XFxuICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxcbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XFxuICAgICAgcmV0dXJuIG5leHQ7XFxuICAgIH07XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XFxuICAgIGlmIChpdGVyYWJsZSkge1xcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcXG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcXG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICByZXR1cm4gaXRlcmFibGU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XFxuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XFxuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcXG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xcblxcbiAgICAgICAgICByZXR1cm4gbmV4dDtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxcbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XFxuICB9XFxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcXG5cXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XFxuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcXG4gIH1cXG5cXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcXG5cXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcXG4gICAgICB0aGlzLnByZXYgPSAwO1xcbiAgICAgIHRoaXMubmV4dCA9IDA7XFxuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxcbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XFxuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XFxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XFxuXFxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XFxuXFxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XFxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcXG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcXG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcXFwidFxcXCIgJiZcXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXFxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XFxuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XFxuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcXG5cXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XFxuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XFxuICAgIH0sXFxuXFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcXG4gICAgICBpZiAodGhpcy5kb25lKSB7XFxuICAgICAgICB0aHJvdyBleGNlcHRpb247XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcXG4gICAgICAgIHJlY29yZC50eXBlID0gXFxcInRocm93XFxcIjtcXG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XFxuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XFxuXFxuICAgICAgICBpZiAoY2F1Z2h0KSB7XFxuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXFxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xcblxcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXFxcInJvb3RcXFwiKSB7XFxuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXFxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xcbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxcbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFxcXCJlbmRcXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XFxuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcXFwiY2F0Y2hMb2NcXFwiKTtcXG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXFxcImZpbmFsbHlMb2NcXFwiKTtcXG5cXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcXFwiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcXFwiZmluYWxseUxvY1xcXCIpICYmXFxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXFxuICAgICAgICAgICh0eXBlID09PSBcXFwiYnJlYWtcXFwiIHx8XFxuICAgICAgICAgICB0eXBlID09PSBcXFwiY29udGludWVcXFwiKSAmJlxcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcXG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xcblxcbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcXG4gICAgICAgIHRoaXMubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XFxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcXG4gICAgfSxcXG5cXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcImJyZWFrXFxcIiB8fFxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXFxcImNvbnRpbnVlXFxcIikge1xcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcXG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcXFwicmV0dXJuXFxcIjtcXG4gICAgICAgIHRoaXMubmV4dCA9IFxcXCJlbmRcXFwiO1xcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJub3JtYWxcXFwiICYmIGFmdGVyTG9jKSB7XFxuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH0sXFxuXFxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XFxuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBcXFwiY2F0Y2hcXFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcXG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XFxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB0aHJvd247XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxcbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFxcXCIpO1xcbiAgICB9LFxcblxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XFxuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFxcXCJuZXh0XFxcIikge1xcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcXG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcbiAgfTtcXG59KShcXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXFxuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXFxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxcbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFxcXCJyZXR1cm4gdGhpc1xcXCIpKClcXG4pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWJ1c2luZXNzL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2Vycm9yL2NvcmVFcnJvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9kaXN0L2Vycm9yL2NvcmVFcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5mdW5jdGlvbiBfZXh0ZW5kYWJsZUJ1aWx0aW4oY2xzKSB7XFxuICBmdW5jdGlvbiBFeHRlbmRhYmxlQnVpbHRpbigpIHtcXG4gICAgdmFyIGluc3RhbmNlID0gUmVmbGVjdC5jb25zdHJ1Y3QoY2xzLCBBcnJheS5mcm9tKGFyZ3VtZW50cykpO1xcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XFxuICAgIHJldHVybiBpbnN0YW5jZTtcXG4gIH1cXG5cXG4gIEV4dGVuZGFibGVCdWlsdGluLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoY2xzLnByb3RvdHlwZSwge1xcbiAgICBjb25zdHJ1Y3Rvcjoge1xcbiAgICAgIHZhbHVlOiBjbHMsXFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXFxuICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgIH1cXG4gIH0pO1xcblxcbiAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoRXh0ZW5kYWJsZUJ1aWx0aW4sIGNscyk7XFxuICB9IGVsc2Uge1xcbiAgICBFeHRlbmRhYmxlQnVpbHRpbi5fX3Byb3RvX18gPSBjbHM7XFxuICB9XFxuXFxuICByZXR1cm4gRXh0ZW5kYWJsZUJ1aWx0aW47XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIGpzb25IZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2hlbHBlcnMvanNvbkhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2pzb25IZWxwZXIuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBBIGNvcmUgaW1wbGVtZW50YXRpb24gb2YgYW4gZXJyb3IuXFxyXFxuICovXFxuXFxuXFxudmFyIENvcmVFcnJvciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uIChfZXh0ZW5kYWJsZUJ1aWx0aW4yKSB7XFxuICBfaW5oZXJpdHMoQ29yZUVycm9yLCBfZXh0ZW5kYWJsZUJ1aWx0aW4yKTtcXG5cXG4gIC8qKlxcclxcbiAgICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIENvcmVFcnJvci5cXHJcXG4gICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIGZvciB0aGUgZXJyb3IuXFxyXFxuICAgKiBAcGFyYW0gYWRkaXRpb25hbCBBZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yLlxcclxcbiAgICogQHBhcmFtIGlubmVyRXJyb3IgQWRkIGluZm9ybWF0aW9uIGZyb20gaW5uZXIgZXJyb3IgaWYgdGhlcmUgd2FzIG9uZS5cXHJcXG4gICAqL1xcbiAgZnVuY3Rpb24gQ29yZUVycm9yKG1lc3NhZ2UsIGFkZGl0aW9uYWwsIGlubmVyRXJyb3IpIHtcXG4gICAgdmFyIF90aGlzO1xcblxcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29yZUVycm9yKTtcXG5cXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ29yZUVycm9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29yZUVycm9yKSkuY2FsbCh0aGlzLCBtZXNzYWdlKSk7XFxuICAgIF90aGlzLmFkZGl0aW9uYWwgPSBhZGRpdGlvbmFsID8gYWRkaXRpb25hbCA6IHt9O1xcbiAgICBfdGhpcy5pbm5lckVycm9yID0gaW5uZXJFcnJvcjtcXG4gICAgcmV0dXJuIF90aGlzO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgY291bGQgYmUgYSBDb3JlRXJyb3IuXFxyXFxuICAgKiBAcGFyYW0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgaWYgaXQgaXMgYSBDb3JlRXJyb3IuXFxyXFxuICAgKiBAcmV0dXJucyB0cnVlIElmIHRoZSB0ZXN0ZWQgb2JqZWN0IGlzIGEgQ29yZUVycm9yLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoQ29yZUVycm9yLCBbe1xcbiAgICBrZXk6IFxcXCJmb3JtYXRcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogRm9ybWF0IHRoZSBlcnJvciB0byBhIHJlYWRhYmxlIHZlcnNpb24uXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9ybWF0KCkge1xcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xcblxcbiAgICAgIHZhciBvdXQgPSB0aGlzLm1lc3NhZ2UgfHwgXFxcIlxcXCI7XFxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmFkZGl0aW9uYWwpO1xcblxcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIGlmIChvdXQubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICBvdXQgKz0gXFxcIlxcXFxuXFxcIjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgICAgIG91dCArPSBcXFwiXFxcXHRcXFwiLmNvbmNhdChrZXksIFxcXCI6IFxcXCIpLmNvbmNhdChqc29uSGVscGVyXzEuSnNvbkhlbHBlci5zdHJpbmdpZnkoX3RoaXMyLmFkZGl0aW9uYWxba2V5XSksIFxcXCJcXFxcblxcXCIpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvdXQ7XFxuICAgIH1cXG4gIH1dLCBbe1xcbiAgICBrZXk6IFxcXCJpc0Vycm9yXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRXJyb3Iob2JqKSB7XFxuICAgICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IFxcXCJvYmplY3RcXFwiICYmIFxcXCJtZXNzYWdlXFxcIiBpbiBvYmogJiYgXFxcImFkZGl0aW9uYWxcXFwiIGluIG9iajtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIENvcmVFcnJvcjtcXG59KF9leHRlbmRhYmxlQnVpbHRpbihFcnJvcikpO1xcblxcbmV4cG9ydHMuQ29yZUVycm9yID0gQ29yZUVycm9yO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWNvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2ZhY3Rvcmllcy9mYWN0b3J5QmFzZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9kaXN0L2ZhY3Rvcmllcy9mYWN0b3J5QmFzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogRmFjdG9yeSB0byBnZW5lcmF0ZSB0eXBlcy5cXHJcXG4gKiBAdHlwZXBhcmFtIFQgVGhlIGdlbmVyaWMgdHlwZSBmb3IgdGhlIG9iamVjdCB0eXBlcyBpbiB0aGUgZmFjdG9yeS5cXHJcXG4gKi9cXG5cXG52YXIgRmFjdG9yeUJhc2UgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBGYWN0b3J5QmFzZSgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZhY3RvcnlCYXNlKTtcXG5cXG4gICAgLyogQGludGVybmFsICovXFxuICAgIHRoaXMuX3R5cGVzID0ge307XFxuICB9XFxuICAvKipcXHJcXG4gICAqIFJlZ2lzdGVyIGEgbmV3IHR5cGUgd2l0aCB0aGUgZmFjdG9yeS5cXHJcXG4gICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlIHRvIHJlZ2lzdGVyLlxcclxcbiAgICogQHBhcmFtIHR5cGVDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSB0eXBlLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoRmFjdG9yeUJhc2UsIFt7XFxuICAgIGtleTogXFxcInJlZ2lzdGVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5hbWUsIHR5cGVDb25zdHJ1Y3Rvcikge1xcbiAgICAgIHRoaXMuZ2V0SW5zdGFuY2UoKS5fdHlwZXNbbmFtZV0gPSB0eXBlQ29uc3RydWN0b3I7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIFVucmVnaXN0ZXIgYSB0eXBlIGZyb20gdGhlIGZhY3RvcnkuXFxyXFxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlIHRvIHVucmVnaXN0ZXIuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ1bnJlZ2lzdGVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucmVnaXN0ZXIobmFtZSkge1xcbiAgICAgIGRlbGV0ZSB0aGlzLmdldEluc3RhbmNlKCkuX3R5cGVzW25hbWVdO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBEb2VzIHRoZSBmYWN0b3J5IGNvbnRhaW4gYSBzcGVjaWZpYyB0eXBlLlxcclxcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdHlwZSB0byBsb29rIGZvci5cXHJcXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHlwZSBleGlzdHMuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJleGlzdHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXhpc3RzKG5hbWUpIHtcXG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSgpLl90eXBlc1tuYW1lXSAhPT0gdW5kZWZpbmVkO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IGZyb20gdGhlIGZhY3RvcnkuXFxyXFxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0eXBlIHRvIGNyZWF0ZS5cXHJcXG4gICAgICogQHBhcmFtIGFyZ3MgQW55IHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgY29uc3RydWN0b3IuXFxyXFxuICAgICAqIEByZXR1cm5zIEEgbmV3IGluc3RhbmNlIG9mIHRoZSB0eXBlIGlmIGl0IGV4aXN0cywgb3IgdW5kZWZpbmVkIGlmIGl0IGRvZXMgbm90LlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY3JlYXRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShuYW1lKSB7XFxuICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xcblxcbiAgICAgIGlmIChpbnN0YW5jZS5fdHlwZXNbbmFtZV0pIHtcXG4gICAgICAgIHZhciBfaW5zdGFuY2UkX3R5cGVzO1xcblxcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiAoX2luc3RhbmNlJF90eXBlcyA9IGluc3RhbmNlLl90eXBlcylbbmFtZV0uYXBwbHkoX2luc3RhbmNlJF90eXBlcywgYXJncyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gRmFjdG9yeUJhc2U7XFxufSgpO1xcblxcbmV4cG9ydHMuRmFjdG9yeUJhc2UgPSBGYWN0b3J5QmFzZTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1jb3JlL2Rpc3QvZmFjdG9yaWVzL2ZhY3RvcnlCYXNlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9mYWN0b3JpZXMvbmV0d29ya0NsaWVudEZhY3RvcnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWNvcmUvZGlzdC9mYWN0b3JpZXMvbmV0d29ya0NsaWVudEZhY3RvcnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgZmFjdG9yeUJhc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmFjdG9yeUJhc2UgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvZmFjdG9yaWVzL2ZhY3RvcnlCYXNlLmpzXFxcIik7XFxuLyoqXFxyXFxuICogRmFjdG9yeSB0byBnZW5lcmF0ZSBuZXR3b3JrIGNsaWVudHMuXFxyXFxuICovXFxuXFxuXFxudmFyIE5ldHdvcmtDbGllbnRGYWN0b3J5ID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9mYWN0b3J5QmFzZV8xJEZhY3Rvcikge1xcbiAgX2luaGVyaXRzKE5ldHdvcmtDbGllbnRGYWN0b3J5LCBfZmFjdG9yeUJhc2VfMSRGYWN0b3IpO1xcblxcbiAgLyoqXFxyXFxuICAgKiBEb24ndCBhbGxvdyBtYW51YWwgY29uc3RydWN0aW9uIG9mIHRoZSBmYWN0b3J5LlxcclxcbiAgICogQGludGVybmFsXFxyXFxuICAgKi9cXG4gIGZ1bmN0aW9uIE5ldHdvcmtDbGllbnRGYWN0b3J5KCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmV0d29ya0NsaWVudEZhY3RvcnkpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE5ldHdvcmtDbGllbnRGYWN0b3J5Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTmV0d29ya0NsaWVudEZhY3RvcnkpKS5jYWxsKHRoaXMpKTtcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogR2V0IHRoZSBpbnN0YW5jZSBvZiB0aGUgZmFjdG9yeS5cXHJcXG4gICAqIEByZXR1cm5zIFRoZSBmYWN0b3J5IGluc3RhbmNlLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoTmV0d29ya0NsaWVudEZhY3RvcnksIFt7XFxuICAgIGtleTogXFxcImdldEluc3RhbmNlXFxcIixcXG5cXG4gICAgLyogQGludGVybmFsICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcXG4gICAgICByZXR1cm4gTmV0d29ya0NsaWVudEZhY3RvcnkuaW5zdGFuY2UoKTtcXG4gICAgfVxcbiAgfV0sIFt7XFxuICAgIGtleTogXFxcImluc3RhbmNlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc3RhbmNlKCkge1xcbiAgICAgIGlmICghTmV0d29ya0NsaWVudEZhY3RvcnkuX2luc3RhbmNlKSB7XFxuICAgICAgICBOZXR3b3JrQ2xpZW50RmFjdG9yeS5faW5zdGFuY2UgPSBuZXcgTmV0d29ya0NsaWVudEZhY3RvcnkoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIE5ldHdvcmtDbGllbnRGYWN0b3J5Ll9pbnN0YW5jZTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIE5ldHdvcmtDbGllbnRGYWN0b3J5O1xcbn0oZmFjdG9yeUJhc2VfMS5GYWN0b3J5QmFzZSk7XFxuXFxuZXhwb3J0cy5OZXR3b3JrQ2xpZW50RmFjdG9yeSA9IE5ldHdvcmtDbGllbnRGYWN0b3J5O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWNvcmUvZGlzdC9mYWN0b3JpZXMvbmV0d29ya0NsaWVudEZhY3RvcnkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBvYmplY3RIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vb2JqZWN0SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQXJyYXkgaGVscGVyIG1ldGhvZHMuXFxyXFxuICovXFxuXFxuXFxudmFyIEFycmF5SGVscGVyID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gQXJyYXlIZWxwZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBcnJheUhlbHBlcik7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoQXJyYXlIZWxwZXIsIG51bGwsIFt7XFxuICAgIGtleTogXFxcImlzQXJyYXlcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogSXMgdGhlIHZhbHVlIGFuIGFycmF5LlxcclxcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QuXFxyXFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGFuIGFycmF5LlxcclxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogQXJyYXkuaXNBcnJheSh2YWx1ZSk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIElzIHRoZSB2YWx1ZSBhIGVtcHR5IGFycmF5LlxcclxcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QuXFxyXFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZW1wdHkgYXJyYXkuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpc0VtcHR5XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcXG4gICAgICByZXR1cm4gIUFycmF5SGVscGVyLmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA9PT0gMDtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogSXMgdGhlIHZhbHVlIGEgbm9uIGVtcHR5IGFycmF5IG9mIHNwZWNpZmljIHR5cGUuXFxyXFxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdC5cXHJcXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG9iamVjdFxcclxcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbiBlbXB0eSBhcnJheSBvZiBhIHNwZWNpZmljIHR5cGUuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpc1R5cGVkXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVHlwZWQodmFsdWUsIHR5cGUpIHtcXG4gICAgICByZXR1cm4gIUFycmF5SGVscGVyLmlzRW1wdHkodmFsdWUpICYmICF2YWx1ZS5pbmNsdWRlcyh1bmRlZmluZWQpICYmICF2YWx1ZS5pbmNsdWRlcyhudWxsKSAmJiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoYSwgdHlwZSk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBBcnJheUhlbHBlcjtcXG59KCk7XFxuXFxuZXhwb3J0cy5BcnJheUhlbHBlciA9IEFycmF5SGVscGVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2Vycm9ySGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvZXJyb3JIZWxwZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgY29yZUVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvci9jb3JlRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvZXJyb3IvY29yZUVycm9yLmpzXFxcIik7XFxuXFxudmFyIGpzb25IZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vanNvbkhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2pzb25IZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgc3RyaW5nSGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0cmluZ0hlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL3N0cmluZ0hlbHBlci5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEhhbmRsZSBlcnJvcnMgYXMgZ3JhY2VmdWxseSBhcyBwb3NzaWJsZS5cXHJcXG4gKi9cXG5cXG5cXG52YXIgRXJyb3JIZWxwZXIgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBFcnJvckhlbHBlcigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVycm9ySGVscGVyKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhFcnJvckhlbHBlciwgbnVsbCwgW3tcXG4gICAga2V5OiBcXFwiZm9ybWF0XFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIEZvcm1hdCBhbiBlcnJvciBvYmplY3QgaW50byBzb21ldGhpbmcgcmVhZGFibGUuXFxyXFxuICAgICAqIEBwYXJhbSBlcnIgVGhlIG9iamVjdCB0byBmb3JtYXQuXFxyXFxuICAgICAqIEBwYXJhbSBpbmNsdWRlU3RhY2sgSW5jbHVkZSB0aGUgc3RhY2sgdHJhY2UgaWYgdGhlcmUgaXMgb25lLlxcclxcbiAgICAgKiBAcmV0dXJucyBGb3JtYXR0ZWQgdmVyc2lvbiBvZiB0aGUgZXJyb3Igb2JqZWN0LlxcclxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdChlcnIsIGluY2x1ZGVTdGFjaykge1xcbiAgICAgIGlmIChlcnIgPT09IG51bGwgfHwgZXJyID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIHJldHVybiBcXFwidW5rbm93biBlcnJvclxcXCI7XFxuICAgICAgfSBlbHNlIGlmIChjb3JlRXJyb3JfMS5Db3JlRXJyb3IuaXNFcnJvcihlcnIpKSB7XFxuICAgICAgICB2YXIgcmV0ID0gZXJyLmZvcm1hdCgpO1xcblxcbiAgICAgICAgaWYgKGluY2x1ZGVTdGFjayAmJiBlcnIuc3RhY2spIHtcXG4gICAgICAgICAgcmV0ICs9IFxcXCJcXFxcblN0YWNrIFRyYWNlXFxcIjtcXG4gICAgICAgICAgdmFyIHBhcnRzID0gZXJyLnN0YWNrLnNwbGl0KFxcXCJcXFxcblxcXCIpO1xcbiAgICAgICAgICBwYXJ0cy5zaGlmdCgpO1xcbiAgICAgICAgICByZXQgKz0gXFxcIlxcXFxuXFxcIi5jb25jYXQocGFydHMuam9pbihcXFwiXFxcXG5cXFwiKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZXJyLmlubmVyRXJyb3IpIHtcXG4gICAgICAgICAgaWYgKGluY2x1ZGVTdGFjayAmJiBlcnIuaW5uZXJFcnJvci5zdGFjaykge1xcbiAgICAgICAgICAgIHJldCArPSBcXFwiXFxcXG5cXFxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcIjtcXG4gICAgICAgICAgICByZXQgKz0gXFxcIlxcXFxuSW5uZXIgU3RhY2sgVHJhY2VcXFxcblxcXCI7XFxuICAgICAgICAgICAgcmV0ICs9IGVyci5pbm5lckVycm9yLnN0YWNrO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldCArPSBcXFwiXFxcXG5Jbm5lciBFcnJvcjogXFxcIi5jb25jYXQoZXJyLmlubmVyRXJyb3IubWVzc2FnZSwgXFxcIlxcXFxuXFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgfSBlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICAgICAgdmFyIF9yZXQgPSBcXFwiXFxcIjtcXG5cXG4gICAgICAgIGlmIChpbmNsdWRlU3RhY2sgJiYgZXJyLnN0YWNrKSB7XFxuICAgICAgICAgIF9yZXQgKz0gZXJyLnN0YWNrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgX3JldCArPSBlcnIubWVzc2FnZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBfcmV0O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmlzU3RyaW5nKGVycikpIHtcXG4gICAgICAgICAgcmV0dXJuIGVycjtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHJldHVybiBqc29uSGVscGVyXzEuSnNvbkhlbHBlci5zdHJpbmdpZnkoZXJyLCB1bmRlZmluZWQsIFxcXCJcXFxcdFxcXCIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEVycm9ySGVscGVyO1xcbn0oKTtcXG5cXG5leHBvcnRzLkVycm9ySGVscGVyID0gRXJyb3JIZWxwZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvZXJyb3JIZWxwZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvanNvbkhlbHBlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvanNvbkhlbHBlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogSnNvbiBoZWxwZXIgbWV0aG9kcy5cXHJcXG4gKi9cXG5cXG52YXIgSnNvbkhlbHBlciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIEpzb25IZWxwZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKc29uSGVscGVyKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhKc29uSGVscGVyLCBudWxsLCBbe1xcbiAgICBrZXk6IFxcXCJzdHJpbmdpZnlcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogU3RyaW5naWZ5IGFuIG9iamVjdCB3aXRoIHJlY3Vyc2lvbiBicmVha2luZy5cXHJcXG4gICAgICogQHBhcmFtIHZhbHVlIEEgSmF2YVNjcmlwdCB2YWx1ZSwgdXN1YWxseSBhbiBvYmplY3Qgb3IgYXJyYXksIHRvIGJlIGNvbnZlcnRlZC5cXHJcXG4gICAgICogQHBhcmFtIHJlcGxhY2VyIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIHRoZSByZXN1bHRzLlxcclxcbiAgICAgKiBAcGFyYW0gc3BhY2UgQWRkcyBpbmRlbnRhdGlvbiwgd2hpdGUgc3BhY2UsIGFuZCBsaW5lIGJyZWFrIGNoYXJhY3RlcnMgdG8gdGhlIHJldHVybi12YWx1ZSBKU09OIHRleHQgdG8gbWFrZSBpdCBlYXNpZXIgdG8gcmVhZC5cXHJcXG4gICAgICogQHJldHVybnMgU3RyaW5nIHZlcnNpb24gb2YgdGhlIG9iamVjdC5cXHJcXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xcbiAgICAgIC8vIGVsaW1pbmF0ZXMgYW55IHJlY3Vyc2lvbiBpbiB0aGUgc3RyaW5naWZ5XFxuICAgICAgdmFyIGNhY2hlID0gW107XFxuXFxuICAgICAgdmFyIHJlY3VzaW9uUmVwbGFjZXIgPSBmdW5jdGlvbiByZWN1c2lvblJlcGxhY2VyKGtleSwgcmVwbGFjZVZhbHVlKSB7XFxuICAgICAgICBpZiAoX3R5cGVvZihyZXBsYWNlVmFsdWUpID09PSBcXFwib2JqZWN0XFxcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiByZXBsYWNlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICBpZiAoY2FjaGUuaW5kZXhPZihyZXBsYWNlVmFsdWUpICE9PSAtMSkge1xcbiAgICAgICAgICAgIC8vIGNpcmN1bGFyIHJlZmVyZW5jZSBmb3VuZCwgZGlzY2FyZCBrZXlcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY2FjaGUucHVzaChyZXBsYWNlVmFsdWUpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVwbGFjZXIgPyByZXBsYWNlcihrZXksIHJlcGxhY2VWYWx1ZSkgOiByZXBsYWNlVmFsdWU7XFxuICAgICAgfTtcXG5cXG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHJlY3VzaW9uUmVwbGFjZXIsIHNwYWNlKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEpzb25IZWxwZXI7XFxufSgpO1xcblxcbmV4cG9ydHMuSnNvbkhlbHBlciA9IEpzb25IZWxwZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvanNvbkhlbHBlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIE51bWJlciBoZWxwZXIgbWV0aG9kcy5cXHJcXG4gKi9cXG5cXG52YXIgTnVtYmVySGVscGVyID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gTnVtYmVySGVscGVyKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVySGVscGVyKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhOdW1iZXJIZWxwZXIsIG51bGwsIFt7XFxuICAgIGtleTogXFxcImlzSW50ZWdlclxcXCIsXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBJcyB0aGUgdmFsdWUgYSBudW1iZXIuXFxyXFxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdCBmb3IgaXRzIG51bWJlcnluZXNzLlxcclxcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvYmplY3QgaXMgYSBudW1iZXIuXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmICFOdW1iZXIuaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBOdW1iZXJIZWxwZXI7XFxufSgpO1xcblxcbmV4cG9ydHMuTnVtYmVySGVscGVyID0gTnVtYmVySGVscGVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIE9iamVjdCBoZWxwZXIgbWV0aG9kcy5cXHJcXG4gKi9cXG5cXG52YXIgT2JqZWN0SGVscGVyID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gT2JqZWN0SGVscGVyKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0SGVscGVyKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhPYmplY3RIZWxwZXIsIG51bGwsIFt7XFxuICAgIGtleTogXFxcImlzRW1wdHlcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogSXMgdGhlIHZhbHVlIGVtcHR5LlxcclxcbiAgICAgKiBAcGFyYW0gdmFsdWUgT2JqZWN0IHRvIHRlc3QuXFxyXFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGVtcHR5LlxcclxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcXG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogSXMgdGhlIHZhbHVlIGFuIG9iamVjdC5cXHJcXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpc09iamVjdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfdHlwZW9mKHZhbHVlKSA9PT0gXFxcIm9iamVjdFxcXCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBJcyB0aGUgdmFsdWUgYW4gb2JqZWN0IGlmIGdpdmVuIHR5cGUuXFxyXFxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdC5cXHJcXG4gICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIG9iamVjdFxcclxcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCB0eXBlLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiaXNUeXBlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZUNvbnN0cnVjdG9yKSB7XFxuICAgICAgdmFyIHZhbHVlQ2xhc3NOYW1lID0gT2JqZWN0SGVscGVyLmdldENsYXNzTmFtZSh2YWx1ZSk7XFxuICAgICAgcmV0dXJuIHZhbHVlQ2xhc3NOYW1lICE9PSB1bmRlZmluZWQgJiYgdmFsdWVDbGFzc05hbWUgPT09IE9iamVjdEhlbHBlci5nZXRDbGFzc05hbWUodHlwZUNvbnN0cnVjdG9yKTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogR2V0IHRoZSBjbGFzcyBuYW1lIG9mIGFuIG9iamVjdCBpZiBpdCBoYXMgb25lLlxcclxcbiAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gZ2V0IHRoZSBjbGFzcyBuYW1lIGZvci5cXHJcXG4gICAgICogQHJldHVybnMgVGhlIGNsYXNzIG5hbWUgaWYgaXQgaGFzIG9uZSBvciB1bmRlZmluZWQgaWYgbm90LlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0Q2xhc3NOYW1lXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsYXNzTmFtZShvYmplY3QpIHtcXG4gICAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgX2NvbnN0cnVjdG9yID0gdHlwZW9mIG9iamVjdCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IG9iamVjdC50b1N0cmluZygpIDogb2JqZWN0LmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XFxuXFxuICAgICAgICB2YXIgcmVzdWx0cyA9IF9jb25zdHJ1Y3Rvci5tYXRjaCgvXFxcXHcrL2cpO1xcblxcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGggPiAxID8gcmVzdWx0c1sxXSA6IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBPYmplY3RIZWxwZXI7XFxufSgpO1xcblxcbmV4cG9ydHMuT2JqZWN0SGVscGVyID0gT2JqZWN0SGVscGVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvc3RyaW5nSGVscGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIFN0cmluZyBoZWxwZXIgbWV0aG9kcy5cXHJcXG4gKi9cXG5cXG52YXIgU3RyaW5nSGVscGVyID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gU3RyaW5nSGVscGVyKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaW5nSGVscGVyKTtcXG4gIH1cXG5cXG4gIF9jcmVhdGVDbGFzcyhTdHJpbmdIZWxwZXIsIG51bGwsIFt7XFxuICAgIGtleTogXFxcImlzU3RyaW5nXFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIElzIHRoZSB2YWx1ZSBhIHN0cmluZy5cXHJcXG4gICAgICogQHBhcmFtIHZhbHVlIE9iamVjdCB0byB0ZXN0IGZvciBpdHMgc3RyaW5neW5lc3MuXFxyXFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIG9iamVjdCBpcyBhIHN0cmluZy5cXHJcXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcXFwiW29iamVjdCBTdHJpbmddXFxcIjtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogSXMgdGhlIHZhbHVlIGEgc3RyaW5nIHRoYXQgaXMgZW1wdHkuXFxyXFxuICAgICAqIEBwYXJhbSB2YWx1ZSBPYmplY3QgdG8gdGVzdCBmb3IgaXRzIG5vIGVtcHR5bmVzcy5cXHJcXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGVtcHR5IHN0cmluZy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImlzRW1wdHlcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xcbiAgICAgIHJldHVybiAhU3RyaW5nSGVscGVyLmlzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDA7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIElzIHRoZSBzdHJpbmcgYWxsIEFTQ0lJIGNoYXJhY3RlcnMuXFxyXFxuICAgICAqIEBwYXJhbSB2YWx1ZSBzdHJpbmcgdG8gdGVzdCBpZiBpcyBpcyBBU0NJSS5cXHJcXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFsbCBBU0NJSS5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImlzQXNjaWlcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBc2NpaSh2YWx1ZSkge1xcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAvXltcXFxceDAwLVxcXFx4RkZdKiQvLnRlc3QodmFsdWUpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBFbmNvZGUgbm9uIEFTQ0lJIGNoYXJhY3RlcnMgd2l0aCBjb250cm9sIGNoYXJhY3RlcnMuXFxyXFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgc3RyaW5nIHZhbHVlIHRvIGVzY2FwZS5cXHJcXG4gICAgICogQHJldHVybnMgVGhlIGVzY2FwZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZW5jb2RlTm9uQVNDSUlcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5jb2RlTm9uQVNDSUkodmFsdWUpIHtcXG4gICAgICByZXR1cm4gU3RyaW5nSGVscGVyLmlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UoL1tcXFxcdTAwN0YtXFxcXHVGRkZGXS9nLCBmdW5jdGlvbiAoY2hyKSB7XFxuICAgICAgICByZXR1cm4gXFxcIlxcXFxcXFxcdVxcXCIuY29uY2F0KFxcXCIwMDAwXFxcIi5jb25jYXQoY2hyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTQpKTtcXG4gICAgICB9KSA6IHVuZGVmaW5lZDtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogRGVjb2RlIGNvbnRyb2wgY2hhcmFjdGVycyB0byBBU0NJSS5cXHJcXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBlbmNvZGVkIHN0cmluZyB0byBjb252ZXJ0IGJhY2sgdG8gQVNDSUkuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHZlcnNpb24gb2YgdGhlIHN0cmluZy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImRlY29kZU5vbkFTQ0lJXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZU5vbkFTQ0lJKHZhbHVlKSB7XFxuICAgICAgcmV0dXJuIFN0cmluZ0hlbHBlci5pc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5yZXBsYWNlKC9cXFxcXFxcXHUoW1xcXFxkXFxcXHddezR9KS9naSwgZnVuY3Rpb24gKG1hdGNoLCBncnApIHtcXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGdycCwgMTYpKTtcXG4gICAgICB9KSA6IHVuZGVmaW5lZDtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFN0cmluZ0hlbHBlcjtcXG59KCk7XFxuXFxuZXhwb3J0cy5TdHJpbmdIZWxwZXIgPSBTdHJpbmdIZWxwZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvc3RyaW5nSGVscGVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX19leHBvcnQobSkge1xcbiAgZm9yICh2YXIgcCBpbiBtKSB7XFxuICAgIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XFxuICB9XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogQ29tYmluZWQgaW5kZXggb2YgYWxsIHRoZSBtb2R1bGVzLlxcclxcbiAqL1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXJyb3IvY29yZUVycm9yICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2Vycm9yL2NvcmVFcnJvci5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZhY3Rvcmllcy9mYWN0b3J5QmFzZSAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9mYWN0b3JpZXMvZmFjdG9yeUJhc2UuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mYWN0b3JpZXMvbmV0d29ya0NsaWVudEZhY3RvcnkgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvZmFjdG9yaWVzL25ldHdvcmtDbGllbnRGYWN0b3J5LmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGVscGVycy9hcnJheUhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGVscGVycy9lcnJvckhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2Vycm9ySGVscGVyLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGVscGVycy9qc29uSGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvanNvbkhlbHBlci5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hlbHBlcnMvbnVtYmVySGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGVscGVycy9zdHJpbmdIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXIuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZ2dlcnMvY29uc29sZUxvZ2dlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9sb2dnZXJzL2NvbnNvbGVMb2dnZXIuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2dnZXJzL251bGxMb2dnZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvbG9nZ2Vycy9udWxsTG9nZ2VyLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbmV0d29yay9uZXR3b3JrRW5kUG9pbnQgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvbmV0d29yay9uZXR3b3JrRW5kUG9pbnQuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZXJ2aWNlcy9iYWNrZ3JvdW5kVGFza1NlcnZpY2UgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3Qvc2VydmljZXMvYmFja2dyb3VuZFRhc2tTZXJ2aWNlLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2VydmljZXMvdGltZVNlcnZpY2UgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3Qvc2VydmljZXMvdGltZVNlcnZpY2UuanNcXFwiKSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY29yZS9kaXN0L2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9sb2dnZXJzL2NvbnNvbGVMb2dnZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWNvcmUvZGlzdC9sb2dnZXJzL2NvbnNvbGVMb2dnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBhcnJheUhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaGVscGVycy9hcnJheUhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIGVycm9ySGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9oZWxwZXJzL2Vycm9ySGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvZXJyb3JIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBzdHJpbmdIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2hlbHBlcnMvc3RyaW5nSGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvc3RyaW5nSGVscGVyLmpzXFxcIik7XFxuLyoqXFxyXFxuICogSW1wbGVtZW50YXRpb24gb2YgSUxvZ2dlciB3aGljaCBzZW5kcyB0byB0aGUgdGhpcy5fbG9nZ2luZ09iamVjdC5cXHJcXG4gKi9cXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1jb25zb2xlXFxuXFxuXFxudmFyIENvbnNvbGVMb2dnZXIgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICAvKipcXHJcXG4gICAqIENyZWF0ZSBhbmQgaW5zdGFuY2Ugb2YgdGhlIGNvbnNvbGUgbG9nZ2VyLlxcclxcbiAgICovXFxuICBmdW5jdGlvbiBDb25zb2xlTG9nZ2VyKGxvZ2dpbmdPYmplY3QpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnNvbGVMb2dnZXIpO1xcblxcbiAgICB0aGlzLl9sb2dnaW5nT2JqZWN0ID0gbG9nZ2luZ09iamVjdCB8fCBjb25zb2xlO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBTZW5kIGJhbm5lciB0byB0aGUgbG9nZ2VyLlxcclxcbiAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxcclxcbiAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKENvbnNvbGVMb2dnZXIsIFt7XFxuICAgIGtleTogXFxcImJhbm5lclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYW5uZXIobWVzc2FnZSkge1xcbiAgICAgIHRoaXMuX2xvZ2dpbmdPYmplY3QubG9nKFxcXCI9XFxcIi5yZXBlYXQoODApKTtcXG5cXG4gICAgICB0aGlzLl9sb2dnaW5nT2JqZWN0LmxvZyhtZXNzYWdlKTtcXG5cXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XFxuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5sb2dBcmdzKHRoaXMuX2xvZ2dpbmdPYmplY3QubG9nLCBhcmdzKTtcXG5cXG4gICAgICB0aGlzLl9sb2dnaW5nT2JqZWN0LmxvZyhcXFwiPVxcXCIucmVwZWF0KDgwKSk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIFNlbmQgbG9nIHRvIHRoZSBsb2dnZXIuXFxyXFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cXHJcXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImxvZ1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2cobWVzc2FnZSkge1xcbiAgICAgIHRoaXMuX2xvZ2dpbmdPYmplY3QubG9nKG1lc3NhZ2UpO1xcblxcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XFxuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmxvZ0FyZ3ModGhpcy5fbG9nZ2luZ09iamVjdC5sb2csIGFyZ3MpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBTZW5kIGluZm9ybWF0aW9uIHRvIHRoZSBsb2dnZXIuXFxyXFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cXHJcXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImluZm9cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5mbyhtZXNzYWdlKSB7XFxuICAgICAgdGhpcy5fbG9nZ2luZ09iamVjdC5pbmZvKG1lc3NhZ2UpO1xcblxcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XFxuICAgICAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmxvZ0FyZ3ModGhpcy5fbG9nZ2luZ09iamVjdC5pbmZvLCBhcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogU2VuZCB3YXJuaW5nIHRvIHRoZSBsb2dnZXIuXFxyXFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cXHJcXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcIndhcm5pbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XFxuICAgICAgdGhpcy5fbG9nZ2luZ09iamVjdC53YXJuKG1lc3NhZ2UpO1xcblxcbiAgICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCA+IDEgPyBfbGVuNCAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XFxuICAgICAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmxvZ0FyZ3ModGhpcy5fbG9nZ2luZ09iamVjdC53YXJuLCBhcmdzKTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogU2VuZCBlcnJvciB0byB0aGUgbG9nZ2VyLlxcclxcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBsb2cuXFxyXFxuICAgICAqIEBwYXJhbSBlcnIgQW4gZXJyb3Igb2JqZWN0IHRvIGxvZy5cXHJcXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImVycm9yXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIGVycikge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5fbG9nZ2luZ09iamVjdC5lcnJvcihtZXNzYWdlKTtcXG5cXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGVycikpIHtcXG4gICAgICAgIHZhciBsaW5lcyA9IGVycm9ySGVscGVyXzEuRXJyb3JIZWxwZXIuZm9ybWF0KGVyciwgdHJ1ZSkuc3BsaXQoXFxcIlxcXFxuXFxcIik7XFxuICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgICAgICAgIF90aGlzLl9sb2dnaW5nT2JqZWN0LmVycm9yKFxcXCJcXFxcdFxcXCIuY29uY2F0KGxpbmUpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUgPiAyID8gX2xlbjUgLSAyIDogMCksIF9rZXk1ID0gMjsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xcbiAgICAgICAgYXJnc1tfa2V5NSAtIDJdID0gYXJndW1lbnRzW19rZXk1XTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5sb2dBcmdzKHRoaXMuX2xvZ2dpbmdPYmplY3QuZXJyb3IsIGFyZ3MpO1xcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJsb2dBcmdzXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvZ0FyZ3MobG9nTWV0aG9kLCBhcmdzKSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgaWYgKCFhcnJheUhlbHBlcl8xLkFycmF5SGVscGVyLmlzRW1wdHkoYXJncykpIHtcXG4gICAgICAgIHZhciBpbmRlbnQgPSBcXFwiXFxcXHRcXFwiO1xcblxcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkoYXJnc1swXSkpIHtcXG4gICAgICAgICAgICB0aGlzLmxvZ0l0ZW0oaW5kZW50LCBcXFwiXFxcIiwgYXJnc1swXSwgbG9nTWV0aG9kKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcsIGluZGV4KSB7XFxuICAgICAgICAgICAgX3RoaXMyLmxvZ0l0ZW0oaW5kZW50LCBpbmRleC50b1N0cmluZygpLCBhcmcsIGxvZ01ldGhvZCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibG9nSXRlbVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2dJdGVtKGluZGVudCwga2V5LCBpdGVtLCBsb2dNZXRob2QpIHtcXG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc0FycmF5KGl0ZW0pKSB7XFxuICAgICAgICB2YXIgbmV3SW5kZW50ID0gXFxcIlxcXCIuY29uY2F0KGluZGVudCwgXFxcIlxcXFx0XFxcIik7XFxuXFxuICAgICAgICBpZiAoc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmlzRW1wdHkoa2V5KSkge1xcbiAgICAgICAgICBsb2dNZXRob2QoXFxcIlxcXCIuY29uY2F0KGluZGVudCwgXFxcIiBbXFxcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgbG9nTWV0aG9kKFxcXCJcXFwiLmNvbmNhdChpbmRlbnQpLmNvbmNhdChrZXksIFxcXCI6IFtcXFwiKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpdGVtLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XFxuICAgICAgICAgIF90aGlzMy5sb2dJdGVtKG5ld0luZGVudCwgXFxcIlxcXCIsIGVsZW1lbnQsIGxvZ01ldGhvZCk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIGxvZ01ldGhvZChcXFwiXFxcIi5jb25jYXQoaW5kZW50LCBcXFwiXVxcXCIpKTtcXG4gICAgICB9IGVsc2UgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc09iamVjdChpdGVtKSkge1xcbiAgICAgICAgdmFyIF9uZXdJbmRlbnQgPSBcXFwiXFxcIi5jb25jYXQoaW5kZW50LCBcXFwiXFxcXHRcXFwiKTtcXG5cXG4gICAgICAgIGlmIChzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNFbXB0eShrZXkpKSB7XFxuICAgICAgICAgIGxvZ01ldGhvZChcXFwiXFxcIi5jb25jYXQoaW5kZW50LCBcXFwiIHtcXFwiKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBsb2dNZXRob2QoXFxcIlxcXCIuY29uY2F0KGluZGVudCkuY29uY2F0KGtleSwgXFxcIjoge1xcXCIpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZvciAodmFyIGtleTIgaW4gaXRlbSkge1xcbiAgICAgICAgICB0aGlzLmxvZ0l0ZW0oX25ld0luZGVudCwga2V5MiwgaXRlbVtrZXkyXSwgbG9nTWV0aG9kKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxvZ01ldGhvZChcXFwiXFxcIi5jb25jYXQoaW5kZW50LCBcXFwifVxcXCIpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KGtleSkpIHtcXG4gICAgICAgICAgbG9nTWV0aG9kKFxcXCJcXFwiLmNvbmNhdChpbmRlbnQpLmNvbmNhdChpdGVtKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBsb2dNZXRob2QoXFxcIlxcXCIuY29uY2F0KGluZGVudCkuY29uY2F0KGtleSwgXFxcIjogXFxcIikuY29uY2F0KGl0ZW0pKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBDb25zb2xlTG9nZ2VyO1xcbn0oKTtcXG5cXG5leHBvcnRzLkNvbnNvbGVMb2dnZXIgPSBDb25zb2xlTG9nZ2VyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWNvcmUvZGlzdC9sb2dnZXJzL2NvbnNvbGVMb2dnZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2xvZ2dlcnMvbnVsbExvZ2dlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9kaXN0L2xvZ2dlcnMvbnVsbExvZ2dlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogSW1wbGVtZW50YXRpb24gb2YgSUxvZ2dlciB3aGljaCBpcyBzaWxlbnQuXFxyXFxuICovXFxuXFxudmFyIE51bGxMb2dnZXIgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBOdWxsTG9nZ2VyKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVsbExvZ2dlcik7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoTnVsbExvZ2dlciwgW3tcXG4gICAga2V5OiBcXFwiYmFubmVyXFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIFNlbmQgYmFubmVyIHRvIHRoZSBsb2dnZXIuXFxyXFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cXHJcXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cXHJcXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYW5uZXIobWVzc2FnZSkge31cXG4gICAgLyoqXFxyXFxuICAgICAqIFNlbmQgbG9nIHRvIHRoZSBsb2dnZXIuXFxyXFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cXHJcXG4gICAgICogQHBhcmFtIGFyZ3MgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGxvZy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImxvZ1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2cobWVzc2FnZSkge31cXG4gICAgLyoqXFxyXFxuICAgICAqIFNlbmQgaW5mb3JtYXRpb24gdG8gdGhlIGxvZ2dlci5cXHJcXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxcclxcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gbG9nLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiaW5mb1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmZvKG1lc3NhZ2UpIHt9XFxuICAgIC8qKlxcclxcbiAgICAgKiBTZW5kIHdhcm5pbmcgdG8gdGhlIGxvZ2dlci5cXHJcXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gbG9nLlxcclxcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gbG9nLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwid2FybmluZ1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHt9XFxuICAgIC8qKlxcclxcbiAgICAgKiBTZW5kIGVycm9yIHRvIHRoZSBsb2dnZXIuXFxyXFxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGxvZy5cXHJcXG4gICAgICogQHBhcmFtIGVyciBBbiBlcnJvciBvYmplY3QgdG8gbG9nLlxcclxcbiAgICAgKiBAcGFyYW0gYXJncyBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gbG9nLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZXJyb3JcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IobWVzc2FnZSwgZXJyKSB7fVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIE51bGxMb2dnZXI7XFxufSgpO1xcblxcbmV4cG9ydHMuTnVsbExvZ2dlciA9IE51bGxMb2dnZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY29yZS9kaXN0L2xvZ2dlcnMvbnVsbExvZ2dlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvbmV0d29yay9uZXR3b3JrRW5kUG9pbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9kaXN0L25ldHdvcmsvbmV0d29ya0VuZFBvaW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBjb3JlRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2NvcmVFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3IuanNcXFwiKTtcXG5cXG52YXIgbnVtYmVySGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9oZWxwZXJzL251bWJlckhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBvYmplY3RIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2hlbHBlcnMvb2JqZWN0SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIHN0cmluZ0hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaGVscGVycy9zdHJpbmdIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXIuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGEgbmV0d29yayBlbmRwb2ludC5cXHJcXG4gKi9cXG5cXG5cXG52YXIgTmV0d29ya0VuZFBvaW50ID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgTmV0d29ya0VuZFBvaW50LlxcclxcbiAgICogQHBhcmFtIHByb3RvY29sIFRoZSBwcm90b2NvbCB0byBhY2Nlc3MgdGhlIGVuZHBvaW50IHdpdGguXFxyXFxuICAgKiBAcGFyYW0gaG9zdCBUaGUgaG9zdCBuYW1lIG9yIGlwIG9mIHRoZSBlbmRwb2ludC5cXHJcXG4gICAqIEBwYXJhbSBwb3J0IFRoZSBwb3J0IG9mIHRoZSBlbmRwb2ludC5cXHJcXG4gICAqIEBwYXJhbSByb290UGF0aCBUaGUgcGF0aCB0byB0aGUgZW5kcG9pbnQuXFxyXFxuICAgKi9cXG4gIGZ1bmN0aW9uIE5ldHdvcmtFbmRQb2ludChwcm90b2NvbCwgaG9zdCwgcG9ydCwgcm9vdFBhdGgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5ldHdvcmtFbmRQb2ludCk7XFxuXFxuICAgIGlmICghc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmlzU3RyaW5nKHByb3RvY29sKSB8fCAhL2h0dHB8aHR0cHMvLnRlc3QocHJvdG9jb2wpKSB7XFxuICAgICAgdGhyb3cgbmV3IGNvcmVFcnJvcl8xLkNvcmVFcnJvcihcXFwiVGhlIHByb3RvY29sIG11c3QgYmUgZGVmaW5lZCBhcyBodHRwIG9yIGh0dHBzXFxcIik7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcoaG9zdCkpIHtcXG4gICAgICB0aHJvdyBuZXcgY29yZUVycm9yXzEuQ29yZUVycm9yKFxcXCJUaGUgaG9zdCBtdXN0IGJlIGRlZmluZWRcXFwiKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIocG9ydCkgfHwgcG9ydCA8PSAwKSB7XFxuICAgICAgdGhyb3cgbmV3IGNvcmVFcnJvcl8xLkNvcmVFcnJvcihcXFwiVGhlIHBvcnQgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gemVyb1xcXCIpO1xcbiAgICB9XFxuXFxuICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkocm9vdFBhdGgpICYmICFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcocm9vdFBhdGgpKSB7XFxuICAgICAgdGhyb3cgbmV3IGNvcmVFcnJvcl8xLkNvcmVFcnJvcihcXFwiVGhlIHJvb3RQYXRoIG11c3QgYmUgYSB2YWxpZCBzdHJpbmdcXFwiKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9wcm90b2NvbCA9IHByb3RvY29sO1xcbiAgICB0aGlzLl9ob3N0ID0gaG9zdC5yZXBsYWNlKC9eXFxcXC8qLywgXFxcIlxcXCIpLnJlcGxhY2UoL1xcXFwvKiQvLCBcXFwiXFxcIik7XFxuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xcbiAgICB0aGlzLl9yb290UGF0aCA9IChyb290UGF0aCB8fCBcXFwiXFxcIikucmVwbGFjZSgvXlxcXFwvKi8sIFxcXCJcXFwiKS5yZXBsYWNlKC9cXFxcLyokLywgXFxcIlxcXCIpO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBUaGUgcHJvdG9jb2wgdG8gYWNjZXNzIHRoZSBlbmRwb2ludCB3aXRoLlxcclxcbiAgICogQHJldHVybiBUaGUgcHJvdG9jb2wuXFxyXFxuICAgKi9cXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhOZXR3b3JrRW5kUG9pbnQsIFt7XFxuICAgIGtleTogXFxcImdldFByb3RvY29sXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb3RvY29sKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogVGhlIGhvc3QgbmFtZSBvciBpcCBvZiB0aGUgZW5kcG9pbnQuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSBob3N0LlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0SG9zdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIb3N0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9ob3N0O1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgZW5kcG9pbnQuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSBwYXRoLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0Um9vdFBhdGhcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9vdFBhdGgoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RQYXRoO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBUaGUgcG9ydCBvZiB0aGUgZW5kcG9pbnQuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSBwb3J0LlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0UG9ydFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3J0KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9wb3J0O1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBUaGUgY29tcGxldGUgdXJpLlxcclxcbiAgICAgKiBAcmV0dXJucyBUaGUgdXJpLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0VXJpXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVyaSgpIHtcXG4gICAgICByZXR1cm4gXFxcIlxcXCIuY29uY2F0KHRoaXMuX3Byb3RvY29sLCBcXFwiOi8vXFxcIikuY29uY2F0KHRoaXMuX2hvc3QsIFxcXCI6XFxcIikuY29uY2F0KHRoaXMuX3BvcnQsIFxcXCIvXFxcIikuY29uY2F0KHRoaXMuX3Jvb3RQYXRoKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIE5ldHdvcmtFbmRQb2ludDtcXG59KCk7XFxuXFxuZXhwb3J0cy5OZXR3b3JrRW5kUG9pbnQgPSBOZXR3b3JrRW5kUG9pbnQ7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY29yZS9kaXN0L25ldHdvcmsvbmV0d29ya0VuZFBvaW50LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9zZXJ2aWNlcy9iYWNrZ3JvdW5kVGFza1NlcnZpY2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWNvcmUvZGlzdC9zZXJ2aWNlcy9iYWNrZ3JvdW5kVGFza1NlcnZpY2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcInZhciBfcmVnZW5lcmF0b3JSdW50aW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IHN0ZXAoXFxcIm5leHRcXFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBzdGVwKFxcXCJ0aHJvd1xcXCIsIGVycik7IH0gX25leHQoKTsgfSk7IH07IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG4vKipcXHJcXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGJhY2tncm91bmQgdGFzayBzZXJ2aWNlLlxcclxcbiAqL1xcblxcbnZhciBCYWNrZ3JvdW5kVGFza1NlcnZpY2UgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBCYWNrZ3JvdW5kVGFza1NlcnZpY2UoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYWNrZ3JvdW5kVGFza1NlcnZpY2UpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKEJhY2tncm91bmRUYXNrU2VydmljZSwgW3tcXG4gICAga2V5OiBcXFwiY3JlYXRlXFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIENyZWF0ZSBhIGJhY2tncm91bmQgdGFzay5cXHJcXG4gICAgICogQHBhcmFtIHRhc2sgVGhlIHRhc2sgdG8gcnVuIGluIHRoZSBiYWNrZ3JvdW5kLlxcclxcbiAgICAgKiBAcGFyYW0gZGVsYXkgVGhlIGRlbGF5IGJlZm9yZSBydW5uaW5nIHRoZSB0YXNrLlxcclxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2NyZWF0ZSA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSh0YXNrLCBkZWxheSkge1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0YXNrKCkpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgIH0sIGRlbGF5KTtcXG4gICAgICAgICAgICAgICAgfSkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlKF94LCBfeDIpIHtcXG4gICAgICAgIHJldHVybiBfY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICB9XSk7XFxuXFxuICByZXR1cm4gQmFja2dyb3VuZFRhc2tTZXJ2aWNlO1xcbn0oKTtcXG5cXG5leHBvcnRzLkJhY2tncm91bmRUYXNrU2VydmljZSA9IEJhY2tncm91bmRUYXNrU2VydmljZTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1jb3JlL2Rpc3Qvc2VydmljZXMvYmFja2dyb3VuZFRhc2tTZXJ2aWNlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9zZXJ2aWNlcy90aW1lU2VydmljZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1jb3JlL2Rpc3Qvc2VydmljZXMvdGltZVNlcnZpY2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogUmVwcmVzZW50cyBhIGNsYXNzIHdoaWNoIGNhbiBwcm92aWRlIHRoZSB0aW1lLlxcclxcbiAqL1xcblxcbnZhciBUaW1lU2VydmljZSA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIFRpbWVTZXJ2aWNlKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZVNlcnZpY2UpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFRpbWVTZXJ2aWNlLCBbe1xcbiAgICBrZXk6IFxcXCJtc1NpbmNlRXBvY2hcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSAxOTcwLzAxLzAxLlxcclxcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxcclxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1zU2luY2VFcG9jaCgpIHtcXG4gICAgICByZXR1cm4gRGF0ZS5ub3coKTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFRpbWVTZXJ2aWNlO1xcbn0oKTtcXG5cXG5leHBvcnRzLlRpbWVTZXJ2aWNlID0gVGltZVNlcnZpY2U7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY29yZS9kaXN0L3NlcnZpY2VzL3RpbWVTZXJ2aWNlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNvcmUvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXFxcIik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY29yZS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tY29yZS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY29yZS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXFxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXFxudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKTtcXG5cXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXFxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcXFwicmVnZW5lcmF0b3JSdW50aW1lXFxcIikgPj0gMDtcXG5cXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXFxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xcblxcbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcnVudGltZSAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xcXCIpO1xcblxcbmlmIChoYWRSdW50aW1lKSB7XFxuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxcbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xcbn0gZWxzZSB7XFxuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxcbiAgdHJ5IHtcXG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xcbiAgfSBjYXRjaChlKSB7XFxuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xcbiAgfVxcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1jb3JlL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNvcmUvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1jb3JlL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuIShmdW5jdGlvbihnbG9iYWwpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XFxuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XFxuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IFN5bWJvbCA6IHt9O1xcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcXFwiQEBpdGVyYXRvclxcXCI7XFxuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcXFwiQEBhc3luY0l0ZXJhdG9yXFxcIjtcXG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXFxcIkBAdG9TdHJpbmdUYWdcXFwiO1xcblxcbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXFxcIm9iamVjdFxcXCI7XFxuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuICBpZiAocnVudGltZSkge1xcbiAgICBpZiAoaW5Nb2R1bGUpIHtcXG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XFxuICAgIH1cXG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxcbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XFxuXFxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XFxuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxcbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XFxuXFxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxcbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XFxuXFxuICAgIHJldHVybiBnZW5lcmF0b3I7XFxuICB9XFxuICBydW50aW1lLndyYXAgPSB3cmFwO1xcblxcbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXFxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxcbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIHsgdHlwZTogXFxcIm5vcm1hbFxcXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgcmV0dXJuIHsgdHlwZTogXFxcInRocm93XFxcIiwgYXJnOiBlcnIgfTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcXFwic3VzcGVuZGVkU3RhcnRcXFwiO1xcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcXFwic3VzcGVuZGVkWWllbGRcXFwiO1xcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXFxcImV4ZWN1dGluZ1xcXCI7XFxuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcXFwiY29tcGxldGVkXFxcIjtcXG5cXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XFxuXFxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXFxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxcblxcbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XFxuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XFxuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XFxuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcXG4gIH1cXG5cXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XFxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcXG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XFxuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cXG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiO1xcblxcbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXFxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XFxuICAgIFtcXFwibmV4dFxcXCIsIFxcXCJ0aHJvd1xcXCIsIFxcXCJyZXR1cm5cXFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xcbiAgICByZXR1cm4gY3RvclxcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcXG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCJcXG4gICAgICA6IGZhbHNlO1xcbiAgfTtcXG5cXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XFxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcXG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XFxuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIjtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xcbiAgICByZXR1cm4gZ2VuRnVuO1xcbiAgfTtcXG5cXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xcbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcXG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXFxcIl9fYXdhaXRcXFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXFxuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxcbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcXG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcXG4gICAgICAgIGlmICh2YWx1ZSAmJlxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXFxcIm9iamVjdFxcXCIgJiZcXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXFxcIl9fYXdhaXRcXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICAgICAgICBpbnZva2UoXFxcIm5leHRcXFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgICAgICAgaW52b2tlKFxcXCJ0aHJvd1xcXCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcXG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXFxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXFxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xcbiAgICAgICAgfSwgcmVqZWN0KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcXG5cXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XFxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXFxuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXFxuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XFxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcXG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXFxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxcbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXFxuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcXG4gICAgfVxcblxcbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcXG4gIH1cXG5cXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XFxuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcXG5cXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXFxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxcbiAgICApO1xcblxcbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXFxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xcbiAgICAgICAgfSk7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XFxuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XFxuXFxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICB0aHJvdyBhcmc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XFxuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XFxuXFxuICAgICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XFxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcXG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XFxuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XFxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJuZXh0XFxcIikge1xcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcXG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIGNvbnRleHQuYXJnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XFxuXFxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XFxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJub3JtYWxcXFwiKSB7XFxuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cXG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxcbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XFxuXFxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcXG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXFxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XFxuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XFxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuXFxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XFxuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJyZXR1cm5cXFwiO1xcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XFxuXFxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXFxuICAgICAgICAgICAgLy8gXFxcInJldHVyblxcXCIgdG8gXFxcInRocm93XFxcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxcbiAgICAgICAgICBcXFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xcblxcbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcXG5cXG4gICAgaWYgKCEgaW5mbykge1xcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXFxcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XFxcIik7XFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgaWYgKGluZm8uZG9uZSkge1xcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XFxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcXG5cXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXFxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcXG5cXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXFxcInRocm93XFxcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXFxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcXFwibmV4dFxcXCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxcbiAgICAgIC8vIFxcXCJjb25zdW1lZFxcXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcXG4gICAgICAvLyBcXFwicmV0dXJuXFxcIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXFxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxcbiAgICAgIHJldHVybiBpbmZvO1xcbiAgICB9XFxuXFxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXFxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gIH1cXG5cXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXFxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXFxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xcblxcbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXFxcIkdlbmVyYXRvclxcXCI7XFxuXFxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXFxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG5cXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBcXFwiW29iamVjdCBHZW5lcmF0b3JdXFxcIjtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xcblxcbiAgICBpZiAoMSBpbiBsb2NzKSB7XFxuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xcbiAgICB9XFxuXFxuICAgIGlmICgyIGluIGxvY3MpIHtcXG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcXG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XFxuICAgIH1cXG5cXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcXG4gICAgcmVjb3JkLnR5cGUgPSBcXFwibm9ybWFsXFxcIjtcXG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XFxuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XFxuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXFxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcXFwicm9vdFxcXCIgfV07XFxuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcXG4gICAgdGhpcy5yZXNldCh0cnVlKTtcXG4gIH1cXG5cXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICB2YXIga2V5cyA9IFtdO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XFxuICAgICAga2V5cy5wdXNoKGtleSk7XFxuICAgIH1cXG4gICAga2V5cy5yZXZlcnNlKCk7XFxuXFxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXFxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XFxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXFxuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXFxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gbmV4dDtcXG4gICAgfTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcXG4gICAgaWYgKGl0ZXJhYmxlKSB7XFxuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XFxuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcXG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcXG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XFxuXFxuICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXFxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcXG4gIH1cXG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xcblxcbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcXG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xcbiAgfVxcblxcbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XFxuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxcblxcbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xcbiAgICAgIHRoaXMucHJldiA9IDA7XFxuICAgICAgdGhpcy5uZXh0ID0gMDtcXG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXFxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcXG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcXG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcXG5cXG4gICAgICB0aGlzLm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcXG5cXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcXG5cXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFxcXCJ0XFxcIiAmJlxcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcXG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcXG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xcblxcbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XFxuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcXG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcXG4gICAgfSxcXG5cXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcXG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcXG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcXG5cXG4gICAgICAgIGlmIChjYXVnaHQpIHtcXG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XFxuXFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcXFwicm9vdFxcXCIpIHtcXG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXFxuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXFxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXFxcImVuZFxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcXG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFxcXCJjYXRjaExvY1xcXCIpO1xcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcXFwiZmluYWxseUxvY1xcXCIpO1xcblxcbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXFxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFxcXCJmaW5hbGx5TG9jXFxcIikgJiZcXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcXG4gICAgICAgICAgKHR5cGUgPT09IFxcXCJicmVha1xcXCIgfHxcXG4gICAgICAgICAgIHR5cGUgPT09IFxcXCJjb250aW51ZVxcXCIpICYmXFxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXFxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxcbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XFxuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XFxuXFxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xcbiAgICB9LFxcblxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwiYnJlYWtcXFwiIHx8XFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcXFwiY29udGludWVcXFwiKSB7XFxuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJyZXR1cm5cXFwiKSB7XFxuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XFxuICAgICAgICB0aGlzLm1ldGhvZCA9IFxcXCJyZXR1cm5cXFwiO1xcbiAgICAgICAgdGhpcy5uZXh0ID0gXFxcImVuZFxcXCI7XFxuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcIm5vcm1hbFxcXCIgJiYgYWZ0ZXJMb2MpIHtcXG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfSxcXG5cXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XFxuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIFxcXCJjYXRjaFxcXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XFxuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXFxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XFxcIik7XFxuICAgIH0sXFxuXFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XFxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcXG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcXG4gICAgICB9O1xcblxcbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXFxcIm5leHRcXFwiKSB7XFxuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuICB9O1xcbn0pKFxcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXFxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKVxcbik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY29yZS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2RpZ2VzdHMvc2hhMy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9kaWdlc3RzL3NoYTMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgY3J5cHRvRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2NyeXB0b0Vycm9yICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3IuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBTaGEzIGltcGxlbWVudGF0aW9uLlxcclxcbiAqL1xcblxcblxcbnZhciBTaGEzID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgU0hBMy5cXHJcXG4gICAqIEBwYXJhbSBiaXRzIFRoZSBudW1iZXIgb2YgaW5wdXQgYml0cy5cXHJcXG4gICAqIEBwYXJhbSBwYWRkaW5nIFRoZSBwYWRkaW5nIHRvIHVzZS5cXHJcXG4gICAqIEBwYXJhbSBvdXRwdXRCaXRzIFRoZSBudW1iZXIgb2Ygb3V0cHV0IGJpdHMuXFxyXFxuICAgKi9cXG4gIGZ1bmN0aW9uIFNoYTMoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hhMyk7XFxuXFxuICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xcbiAgICB0aGlzLl9vdXRwdXRCaXRzID0gb3V0cHV0Qml0cztcXG4gICAgdGhpcy5fYmxvY2tDb3VudCA9IDE2MDAgLSAoYml0cyA8PCAxKSA+PiA1O1xcbiAgICB0aGlzLl9ieXRlQ291bnQgPSB0aGlzLl9ibG9ja0NvdW50IDw8IDI7XFxuICAgIHRoaXMuX291dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcXG4gICAgdGhpcy5fZXh0cmFCeXRlcyA9IChvdXRwdXRCaXRzICYgMzEpID4+IDM7XFxuICAgIHRoaXMucmVzZXQoKTtcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogUmVzZXQgdGhlIGRpZ2VzdC5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKFNoYTMsIFt7XFxuICAgIGtleTogXFxcInJlc2V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xcbiAgICAgIHRoaXMuX3Jlc2V0ID0gdHJ1ZTtcXG4gICAgICB0aGlzLl9ibG9jayA9IDA7XFxuICAgICAgdGhpcy5fc3RhcnQgPSAwO1xcbiAgICAgIHRoaXMuX2Jsb2NrcyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9ibG9ja0NvdW50ICsgMSk7XFxuICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgVWludDMyQXJyYXkoNTApO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBVcGRhdGUgdGhlIGRpZ2VzdC5cXHJcXG4gICAgICogQHBhcmFtIGlucHV0IEFycmF5IG9mIGRhdGEgdG8gdXNlIGluIHRoZSB1cGRhdGUuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ1cGRhdGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKGlucHV0KSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGlucHV0LCBBcnJheUJ1ZmZlcikpIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJJbnB1dCBpcyBub3Qgb2YgdHlwZSBBcnJheUJ1ZmZlclxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcXG4gICAgICB2YXIgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGg7XFxuICAgICAgdmFyIGluZGV4ID0gMDtcXG4gICAgICB2YXIgaTtcXG5cXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcXG4gICAgICAgIGlmICh0aGlzLl9yZXNldCkge1xcbiAgICAgICAgICB0aGlzLl9yZXNldCA9IGZhbHNlO1xcbiAgICAgICAgICB0aGlzLl9ibG9ja3NbMF0gPSB0aGlzLl9ibG9jaztcXG5cXG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IHRoaXMuX2Jsb2NrQ291bnQgKyAxOyArK2kpIHtcXG4gICAgICAgICAgICB0aGlzLl9ibG9ja3NbaV0gPSAwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKGkgPSB0aGlzLl9zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IHRoaXMuX2J5dGVDb3VudDsgKytpbmRleCkge1xcbiAgICAgICAgICB0aGlzLl9ibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTaGEzLlNISUZUW2krKyAmIDNdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fbGFzdEJ5dGVJbmRleCA9IGk7XFxuXFxuICAgICAgICBpZiAoaSA+PSB0aGlzLl9ieXRlQ291bnQpIHtcXG4gICAgICAgICAgdGhpcy5fc3RhcnQgPSBpIC0gdGhpcy5fYnl0ZUNvdW50O1xcbiAgICAgICAgICB0aGlzLl9ibG9jayA9IHRoaXMuX2Jsb2Nrc1t0aGlzLl9ibG9ja0NvdW50XTtcXG5cXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Jsb2NrQ291bnQ7ICsraSkge1xcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlW2ldIF49IHRoaXMuX2Jsb2Nrc1tpXTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aGlzLmtlY2Nha1Blcm11dGF0aW9uKHRoaXMuX3N0YXRlKTtcXG4gICAgICAgICAgdGhpcy5fcmVzZXQgPSB0cnVlO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5fc3RhcnQgPSBpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogRmluYWxpemUgYW5kIHJldHVybiB0aGUgaGFzaCBmb3IgdGhlIGRpZ2VzdCwgd2lsbCBhbHNvIHJlc2V0IHRoZSBzdGF0ZS5cXHJcXG4gICAgICogQHJldHVybiBBcnJheSBidWZmZXIgY29udGFpbmluZyB0aGUgZGlnZXN0LlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZGlnZXN0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpZ2VzdCgpIHtcXG4gICAgICB0aGlzLmZpbmFsaXplKCk7XFxuICAgICAgdmFyIGkgPSAwO1xcbiAgICAgIHZhciBqID0gMDtcXG4gICAgICB2YXIgYnl0ZXMgPSB0aGlzLl9vdXRwdXRCaXRzID4+IDM7XFxuICAgICAgdmFyIGJ1ZmZlcjtcXG5cXG4gICAgICBpZiAodGhpcy5fZXh0cmFCeXRlcykge1xcbiAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuX291dHB1dEJsb2NrcyArIDEgPDwgMik7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcyk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBhcnJheSA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xcblxcbiAgICAgIHdoaWxlIChqIDwgdGhpcy5fb3V0cHV0QmxvY2tzKSB7XFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tDb3VudCAmJiBqIDwgdGhpcy5fb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xcbiAgICAgICAgICBhcnJheVtqXSA9IHRoaXMuX3N0YXRlW2ldO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fZXh0cmFCeXRlcykge1xcbiAgICAgICAgYXJyYXlbaV0gPSB0aGlzLl9zdGF0ZVtpXTtcXG4gICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBieXRlcyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMucmVzZXQoKTtcXG4gICAgICByZXR1cm4gYnVmZmVyO1xcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJmaW5hbGl6ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcXG4gICAgICB2YXIgaSA9IHRoaXMuX2xhc3RCeXRlSW5kZXg7XFxuICAgICAgdGhpcy5fYmxvY2tzW2kgPj4gMl0gfD0gdGhpcy5fcGFkZGluZ1tpICYgM107XFxuXFxuICAgICAgaWYgKHRoaXMuX2xhc3RCeXRlSW5kZXggPT09IHRoaXMuX2J5dGVDb3VudCkge1xcbiAgICAgICAgdGhpcy5fYmxvY2tzWzBdID0gdGhpcy5fYmxvY2tzW3RoaXMuX2Jsb2NrQ291bnRdO1xcblxcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHRoaXMuX2Jsb2NrQ291bnQgKyAxOyArK2kpIHtcXG4gICAgICAgICAgdGhpcy5fYmxvY2tzW2ldID0gMDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fYmxvY2tzW3RoaXMuX2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xcblxcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9ibG9ja0NvdW50OyArK2kpIHtcXG4gICAgICAgIHRoaXMuX3N0YXRlW2ldIF49IHRoaXMuX2Jsb2Nrc1tpXTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5rZWNjYWtQZXJtdXRhdGlvbih0aGlzLl9zdGF0ZSk7XFxuICAgIH1cXG4gICAgLyogQGludGVybmFsICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImtlY2Nha1Blcm11dGF0aW9uXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtlY2Nha1Blcm11dGF0aW9uKHMpIHtcXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b25lLXZhcmlhYmxlLXBlci1kZWNsYXJhdGlvblxcbiAgICAgIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSwgYjAsIGIxLCBiMiwgYjMsIGI0LCBiNSwgYjYsIGI3LCBiOCwgYjksIGIxMCwgYjExLCBiMTIsIGIxMywgYjE0LCBiMTUsIGIxNiwgYjE3LCBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTtcXG5cXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgNDg7IG4gKz0gMikge1xcbiAgICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XFxuICAgICAgICBjMSA9IHNbMV0gXiBzWzExXSBeIHNbMjFdIF4gc1szMV0gXiBzWzQxXTtcXG4gICAgICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdO1xcbiAgICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XFxuICAgICAgICBjNCA9IHNbNF0gXiBzWzE0XSBeIHNbMjRdIF4gc1szNF0gXiBzWzQ0XTtcXG4gICAgICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdO1xcbiAgICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XFxuICAgICAgICBjNyA9IHNbN10gXiBzWzE3XSBeIHNbMjddIF4gc1szN10gXiBzWzQ3XTtcXG4gICAgICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdO1xcbiAgICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XFxuICAgICAgICBoID0gYzggXiAoYzIgPDwgMSB8IGMzID4+PiAzMSk7XFxuICAgICAgICBsID0gYzkgXiAoYzMgPDwgMSB8IGMyID4+PiAzMSk7XFxuICAgICAgICBzWzBdIF49IGg7XFxuICAgICAgICBzWzFdIF49IGw7XFxuICAgICAgICBzWzEwXSBePSBoO1xcbiAgICAgICAgc1sxMV0gXj0gbDtcXG4gICAgICAgIHNbMjBdIF49IGg7XFxuICAgICAgICBzWzIxXSBePSBsO1xcbiAgICAgICAgc1szMF0gXj0gaDtcXG4gICAgICAgIHNbMzFdIF49IGw7XFxuICAgICAgICBzWzQwXSBePSBoO1xcbiAgICAgICAgc1s0MV0gXj0gbDtcXG4gICAgICAgIGggPSBjMCBeIChjNCA8PCAxIHwgYzUgPj4+IDMxKTtcXG4gICAgICAgIGwgPSBjMSBeIChjNSA8PCAxIHwgYzQgPj4+IDMxKTtcXG4gICAgICAgIHNbMl0gXj0gaDtcXG4gICAgICAgIHNbM10gXj0gbDtcXG4gICAgICAgIHNbMTJdIF49IGg7XFxuICAgICAgICBzWzEzXSBePSBsO1xcbiAgICAgICAgc1syMl0gXj0gaDtcXG4gICAgICAgIHNbMjNdIF49IGw7XFxuICAgICAgICBzWzMyXSBePSBoO1xcbiAgICAgICAgc1szM10gXj0gbDtcXG4gICAgICAgIHNbNDJdIF49IGg7XFxuICAgICAgICBzWzQzXSBePSBsO1xcbiAgICAgICAgaCA9IGMyIF4gKGM2IDw8IDEgfCBjNyA+Pj4gMzEpO1xcbiAgICAgICAgbCA9IGMzIF4gKGM3IDw8IDEgfCBjNiA+Pj4gMzEpO1xcbiAgICAgICAgc1s0XSBePSBoO1xcbiAgICAgICAgc1s1XSBePSBsO1xcbiAgICAgICAgc1sxNF0gXj0gaDtcXG4gICAgICAgIHNbMTVdIF49IGw7XFxuICAgICAgICBzWzI0XSBePSBoO1xcbiAgICAgICAgc1syNV0gXj0gbDtcXG4gICAgICAgIHNbMzRdIF49IGg7XFxuICAgICAgICBzWzM1XSBePSBsO1xcbiAgICAgICAgc1s0NF0gXj0gaDtcXG4gICAgICAgIHNbNDVdIF49IGw7XFxuICAgICAgICBoID0gYzQgXiAoYzggPDwgMSB8IGM5ID4+PiAzMSk7XFxuICAgICAgICBsID0gYzUgXiAoYzkgPDwgMSB8IGM4ID4+PiAzMSk7XFxuICAgICAgICBzWzZdIF49IGg7XFxuICAgICAgICBzWzddIF49IGw7XFxuICAgICAgICBzWzE2XSBePSBoO1xcbiAgICAgICAgc1sxN10gXj0gbDtcXG4gICAgICAgIHNbMjZdIF49IGg7XFxuICAgICAgICBzWzI3XSBePSBsO1xcbiAgICAgICAgc1szNl0gXj0gaDtcXG4gICAgICAgIHNbMzddIF49IGw7XFxuICAgICAgICBzWzQ2XSBePSBoO1xcbiAgICAgICAgc1s0N10gXj0gbDtcXG4gICAgICAgIGggPSBjNiBeIChjMCA8PCAxIHwgYzEgPj4+IDMxKTtcXG4gICAgICAgIGwgPSBjNyBeIChjMSA8PCAxIHwgYzAgPj4+IDMxKTtcXG4gICAgICAgIHNbOF0gXj0gaDtcXG4gICAgICAgIHNbOV0gXj0gbDtcXG4gICAgICAgIHNbMThdIF49IGg7XFxuICAgICAgICBzWzE5XSBePSBsO1xcbiAgICAgICAgc1syOF0gXj0gaDtcXG4gICAgICAgIHNbMjldIF49IGw7XFxuICAgICAgICBzWzM4XSBePSBoO1xcbiAgICAgICAgc1szOV0gXj0gbDtcXG4gICAgICAgIHNbNDhdIF49IGg7XFxuICAgICAgICBzWzQ5XSBePSBsO1xcbiAgICAgICAgYjAgPSBzWzBdO1xcbiAgICAgICAgYjEgPSBzWzFdO1xcbiAgICAgICAgYjMyID0gc1sxMV0gPDwgNCB8IHNbMTBdID4+PiAyODtcXG4gICAgICAgIGIzMyA9IHNbMTBdIDw8IDQgfCBzWzExXSA+Pj4gMjg7XFxuICAgICAgICBiMTQgPSBzWzIwXSA8PCAzIHwgc1syMV0gPj4+IDI5O1xcbiAgICAgICAgYjE1ID0gc1syMV0gPDwgMyB8IHNbMjBdID4+PiAyOTtcXG4gICAgICAgIGI0NiA9IHNbMzFdIDw8IDkgfCBzWzMwXSA+Pj4gMjM7XFxuICAgICAgICBiNDcgPSBzWzMwXSA8PCA5IHwgc1szMV0gPj4+IDIzO1xcbiAgICAgICAgYjI4ID0gc1s0MF0gPDwgMTggfCBzWzQxXSA+Pj4gMTQ7XFxuICAgICAgICBiMjkgPSBzWzQxXSA8PCAxOCB8IHNbNDBdID4+PiAxNDtcXG4gICAgICAgIGIyMCA9IHNbMl0gPDwgMSB8IHNbM10gPj4+IDMxO1xcbiAgICAgICAgYjIxID0gc1szXSA8PCAxIHwgc1syXSA+Pj4gMzE7XFxuICAgICAgICBiMiA9IHNbMTNdIDw8IDEyIHwgc1sxMl0gPj4+IDIwO1xcbiAgICAgICAgYjMgPSBzWzEyXSA8PCAxMiB8IHNbMTNdID4+PiAyMDtcXG4gICAgICAgIGIzNCA9IHNbMjJdIDw8IDEwIHwgc1syM10gPj4+IDIyO1xcbiAgICAgICAgYjM1ID0gc1syM10gPDwgMTAgfCBzWzIyXSA+Pj4gMjI7XFxuICAgICAgICBiMTYgPSBzWzMzXSA8PCAxMyB8IHNbMzJdID4+PiAxOTtcXG4gICAgICAgIGIxNyA9IHNbMzJdIDw8IDEzIHwgc1szM10gPj4+IDE5O1xcbiAgICAgICAgYjQ4ID0gc1s0Ml0gPDwgMiB8IHNbNDNdID4+PiAzMDtcXG4gICAgICAgIGI0OSA9IHNbNDNdIDw8IDIgfCBzWzQyXSA+Pj4gMzA7XFxuICAgICAgICBiNDAgPSBzWzVdIDw8IDMwIHwgc1s0XSA+Pj4gMjtcXG4gICAgICAgIGI0MSA9IHNbNF0gPDwgMzAgfCBzWzVdID4+PiAyO1xcbiAgICAgICAgYjIyID0gc1sxNF0gPDwgNiB8IHNbMTVdID4+PiAyNjtcXG4gICAgICAgIGIyMyA9IHNbMTVdIDw8IDYgfCBzWzE0XSA+Pj4gMjY7XFxuICAgICAgICBiNCA9IHNbMjVdIDw8IDExIHwgc1syNF0gPj4+IDIxO1xcbiAgICAgICAgYjUgPSBzWzI0XSA8PCAxMSB8IHNbMjVdID4+PiAyMTtcXG4gICAgICAgIGIzNiA9IHNbMzRdIDw8IDE1IHwgc1szNV0gPj4+IDE3O1xcbiAgICAgICAgYjM3ID0gc1szNV0gPDwgMTUgfCBzWzM0XSA+Pj4gMTc7XFxuICAgICAgICBiMTggPSBzWzQ1XSA8PCAyOSB8IHNbNDRdID4+PiAzO1xcbiAgICAgICAgYjE5ID0gc1s0NF0gPDwgMjkgfCBzWzQ1XSA+Pj4gMztcXG4gICAgICAgIGIxMCA9IHNbNl0gPDwgMjggfCBzWzddID4+PiA0O1xcbiAgICAgICAgYjExID0gc1s3XSA8PCAyOCB8IHNbNl0gPj4+IDQ7XFxuICAgICAgICBiNDIgPSBzWzE3XSA8PCAyMyB8IHNbMTZdID4+PiA5O1xcbiAgICAgICAgYjQzID0gc1sxNl0gPDwgMjMgfCBzWzE3XSA+Pj4gOTtcXG4gICAgICAgIGIyNCA9IHNbMjZdIDw8IDI1IHwgc1syN10gPj4+IDc7XFxuICAgICAgICBiMjUgPSBzWzI3XSA8PCAyNSB8IHNbMjZdID4+PiA3O1xcbiAgICAgICAgYjYgPSBzWzM2XSA8PCAyMSB8IHNbMzddID4+PiAxMTtcXG4gICAgICAgIGI3ID0gc1szN10gPDwgMjEgfCBzWzM2XSA+Pj4gMTE7XFxuICAgICAgICBiMzggPSBzWzQ3XSA8PCAyNCB8IHNbNDZdID4+PiA4O1xcbiAgICAgICAgYjM5ID0gc1s0Nl0gPDwgMjQgfCBzWzQ3XSA+Pj4gODtcXG4gICAgICAgIGIzMCA9IHNbOF0gPDwgMjcgfCBzWzldID4+PiA1O1xcbiAgICAgICAgYjMxID0gc1s5XSA8PCAyNyB8IHNbOF0gPj4+IDU7XFxuICAgICAgICBiMTIgPSBzWzE4XSA8PCAyMCB8IHNbMTldID4+PiAxMjtcXG4gICAgICAgIGIxMyA9IHNbMTldIDw8IDIwIHwgc1sxOF0gPj4+IDEyO1xcbiAgICAgICAgYjQ0ID0gc1syOV0gPDwgNyB8IHNbMjhdID4+PiAyNTtcXG4gICAgICAgIGI0NSA9IHNbMjhdIDw8IDcgfCBzWzI5XSA+Pj4gMjU7XFxuICAgICAgICBiMjYgPSBzWzM4XSA8PCA4IHwgc1szOV0gPj4+IDI0O1xcbiAgICAgICAgYjI3ID0gc1szOV0gPDwgOCB8IHNbMzhdID4+PiAyNDtcXG4gICAgICAgIGI4ID0gc1s0OF0gPDwgMTQgfCBzWzQ5XSA+Pj4gMTg7XFxuICAgICAgICBiOSA9IHNbNDldIDw8IDE0IHwgc1s0OF0gPj4+IDE4O1xcbiAgICAgICAgc1swXSA9IGIwIF4gfmIyICYgYjQ7XFxuICAgICAgICBzWzFdID0gYjEgXiB+YjMgJiBiNTtcXG4gICAgICAgIHNbMTBdID0gYjEwIF4gfmIxMiAmIGIxNDtcXG4gICAgICAgIHNbMTFdID0gYjExIF4gfmIxMyAmIGIxNTtcXG4gICAgICAgIHNbMjBdID0gYjIwIF4gfmIyMiAmIGIyNDtcXG4gICAgICAgIHNbMjFdID0gYjIxIF4gfmIyMyAmIGIyNTtcXG4gICAgICAgIHNbMzBdID0gYjMwIF4gfmIzMiAmIGIzNDtcXG4gICAgICAgIHNbMzFdID0gYjMxIF4gfmIzMyAmIGIzNTtcXG4gICAgICAgIHNbNDBdID0gYjQwIF4gfmI0MiAmIGI0NDtcXG4gICAgICAgIHNbNDFdID0gYjQxIF4gfmI0MyAmIGI0NTtcXG4gICAgICAgIHNbMl0gPSBiMiBeIH5iNCAmIGI2O1xcbiAgICAgICAgc1szXSA9IGIzIF4gfmI1ICYgYjc7XFxuICAgICAgICBzWzEyXSA9IGIxMiBeIH5iMTQgJiBiMTY7XFxuICAgICAgICBzWzEzXSA9IGIxMyBeIH5iMTUgJiBiMTc7XFxuICAgICAgICBzWzIyXSA9IGIyMiBeIH5iMjQgJiBiMjY7XFxuICAgICAgICBzWzIzXSA9IGIyMyBeIH5iMjUgJiBiMjc7XFxuICAgICAgICBzWzMyXSA9IGIzMiBeIH5iMzQgJiBiMzY7XFxuICAgICAgICBzWzMzXSA9IGIzMyBeIH5iMzUgJiBiMzc7XFxuICAgICAgICBzWzQyXSA9IGI0MiBeIH5iNDQgJiBiNDY7XFxuICAgICAgICBzWzQzXSA9IGI0MyBeIH5iNDUgJiBiNDc7XFxuICAgICAgICBzWzRdID0gYjQgXiB+YjYgJiBiODtcXG4gICAgICAgIHNbNV0gPSBiNSBeIH5iNyAmIGI5O1xcbiAgICAgICAgc1sxNF0gPSBiMTQgXiB+YjE2ICYgYjE4O1xcbiAgICAgICAgc1sxNV0gPSBiMTUgXiB+YjE3ICYgYjE5O1xcbiAgICAgICAgc1syNF0gPSBiMjQgXiB+YjI2ICYgYjI4O1xcbiAgICAgICAgc1syNV0gPSBiMjUgXiB+YjI3ICYgYjI5O1xcbiAgICAgICAgc1szNF0gPSBiMzQgXiB+YjM2ICYgYjM4O1xcbiAgICAgICAgc1szNV0gPSBiMzUgXiB+YjM3ICYgYjM5O1xcbiAgICAgICAgc1s0NF0gPSBiNDQgXiB+YjQ2ICYgYjQ4O1xcbiAgICAgICAgc1s0NV0gPSBiNDUgXiB+YjQ3ICYgYjQ5O1xcbiAgICAgICAgc1s2XSA9IGI2IF4gfmI4ICYgYjA7XFxuICAgICAgICBzWzddID0gYjcgXiB+YjkgJiBiMTtcXG4gICAgICAgIHNbMTZdID0gYjE2IF4gfmIxOCAmIGIxMDtcXG4gICAgICAgIHNbMTddID0gYjE3IF4gfmIxOSAmIGIxMTtcXG4gICAgICAgIHNbMjZdID0gYjI2IF4gfmIyOCAmIGIyMDtcXG4gICAgICAgIHNbMjddID0gYjI3IF4gfmIyOSAmIGIyMTtcXG4gICAgICAgIHNbMzZdID0gYjM2IF4gfmIzOCAmIGIzMDtcXG4gICAgICAgIHNbMzddID0gYjM3IF4gfmIzOSAmIGIzMTtcXG4gICAgICAgIHNbNDZdID0gYjQ2IF4gfmI0OCAmIGI0MDtcXG4gICAgICAgIHNbNDddID0gYjQ3IF4gfmI0OSAmIGI0MTtcXG4gICAgICAgIHNbOF0gPSBiOCBeIH5iMCAmIGIyO1xcbiAgICAgICAgc1s5XSA9IGI5IF4gfmIxICYgYjM7XFxuICAgICAgICBzWzE4XSA9IGIxOCBeIH5iMTAgJiBiMTI7XFxuICAgICAgICBzWzE5XSA9IGIxOSBeIH5iMTEgJiBiMTM7XFxuICAgICAgICBzWzI4XSA9IGIyOCBeIH5iMjAgJiBiMjI7XFxuICAgICAgICBzWzI5XSA9IGIyOSBeIH5iMjEgJiBiMjM7XFxuICAgICAgICBzWzM4XSA9IGIzOCBeIH5iMzAgJiBiMzI7XFxuICAgICAgICBzWzM5XSA9IGIzOSBeIH5iMzEgJiBiMzM7XFxuICAgICAgICBzWzQ4XSA9IGI0OCBeIH5iNDAgJiBiNDI7XFxuICAgICAgICBzWzQ5XSA9IGI0OSBeIH5iNDEgJiBiNDM7XFxuICAgICAgICBzWzBdIF49IFNoYTMuUk9VTkRfQ09OU1RBTlRTW25dO1xcbiAgICAgICAgc1sxXSBePSBTaGEzLlJPVU5EX0NPTlNUQU5UU1tuICsgMV07XFxuICAgICAgfVxcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gU2hhMztcXG59KCk7XFxuLyogUGFkZGluZyB0byB1c2UgZm9yIEtlY2NhayAqL1xcblxcblxcblNoYTMuS0VDQ0FLX1BBRERJTkcgPSBuZXcgVWludDMyQXJyYXkoWzEsIDI1NiwgNjU1MzYsIDE2Nzc3MjE2XSk7XFxuLyogQGludGVybmFsICovXFxuXFxuU2hhMy5TSElGVCA9IG5ldyBVaW50OEFycmF5KFswLCA4LCAxNiwgMjRdKTtcXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5TaGEzLlJPVU5EX0NPTlNUQU5UUyA9IG5ldyBVaW50MzJBcnJheShbMSwgMCwgMzI4OTgsIDAsIDMyOTA2LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDE2LCAyMTQ3NDgzNjQ4LCAzMjkwNywgMCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI3NzcsIDIxNDc0ODM2NDgsIDEzOCwgMCwgMTM2LCAwLCAyMTQ3NTE2NDI1LCAwLCAyMTQ3NDgzNjU4LCAwLCAyMTQ3NTE2NTU1LCAwLCAxMzksIDIxNDc0ODM2NDgsIDMyOTA1LCAyMTQ3NDgzNjQ4LCAzMjc3MSwgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyODk2LCAyMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NDI0LCAyMTQ3NDgzNjQ4XSk7XFxuZXhwb3J0cy5TaGEzID0gU2hhMztcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9kaWdlc3RzL3NoYTMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9lcnJvci9jcnlwdG9FcnJvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBjb3JlRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2Vycm9yL2NvcmVFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3IuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBBIGNyeXB0byBpbXBsZW1lbnRhdGlvbiBvZiBhbiBlcnJvci5cXHJcXG4gKi9cXG5cXG5cXG52YXIgQ3J5cHRvRXJyb3IgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX2NvcmVFcnJvcl8xJENvcmVFcnJvKSB7XFxuICBfaW5oZXJpdHMoQ3J5cHRvRXJyb3IsIF9jb3JlRXJyb3JfMSRDb3JlRXJybyk7XFxuXFxuICBmdW5jdGlvbiBDcnlwdG9FcnJvcigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENyeXB0b0Vycm9yKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDcnlwdG9FcnJvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENyeXB0b0Vycm9yKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XFxuICB9XFxuXFxuICByZXR1cm4gQ3J5cHRvRXJyb3I7XFxufShjb3JlRXJyb3JfMS5Db3JlRXJyb3IpO1xcblxcbmV4cG9ydHMuQ3J5cHRvRXJyb3IgPSBDcnlwdG9FcnJvcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9lcnJvci9jcnlwdG9FcnJvci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9mYWN0b3JpZXMvc3BvbmdlRmFjdG9yeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSkgeyByZXR1cm4gY2FsbDsgfSBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcXFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXFxcIik7IH0gcmV0dXJuIHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cXFwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBmYWN0b3J5QmFzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvZmFjdG9yaWVzL2ZhY3RvcnlCYXNlICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2ZhY3Rvcmllcy9mYWN0b3J5QmFzZS5qc1xcXCIpO1xcblxcbnZhciBjdXJsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zcG9uZ2VzL2N1cmwgKi8gXFxcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9zcG9uZ2VzL2N1cmwuanNcXFwiKTtcXG5cXG52YXIga2VybF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc3Bvbmdlcy9rZXJsICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3Qvc3Bvbmdlcy9rZXJsLmpzXFxcIik7XFxuLyoqXFxyXFxuICogRmFjdG9yeSB0byBnZW5lcmF0ZSBzcG9uZ2VzLlxcclxcbiAqL1xcblxcblxcbnZhciBTcG9uZ2VGYWN0b3J5ID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKF9mYWN0b3J5QmFzZV8xJEZhY3Rvcikge1xcbiAgX2luaGVyaXRzKFNwb25nZUZhY3RvcnksIF9mYWN0b3J5QmFzZV8xJEZhY3Rvcik7XFxuXFxuICAvKipcXHJcXG4gICAqIERvbid0IGFsbG93IG1hbnVhbCBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZhY3RvcnkuXFxyXFxuICAgKiBAaW50ZXJuYWxcXHJcXG4gICAqL1xcbiAgZnVuY3Rpb24gU3BvbmdlRmFjdG9yeSgpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwb25nZUZhY3RvcnkpO1xcblxcbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNwb25nZUZhY3RvcnkuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTcG9uZ2VGYWN0b3J5KSkuY2FsbCh0aGlzKSk7XFxuICB9XFxuICAvKipcXHJcXG4gICAqIEdldCB0aGUgaW5zdGFuY2Ugb2YgdGhlIGZhY3RvcnkuXFxyXFxuICAgKiBAcmV0dXJucyBUaGUgZmFjdG9yeSBpbnN0YW5jZS5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKFNwb25nZUZhY3RvcnksIFt7XFxuICAgIGtleTogXFxcImdldEluc3RhbmNlXFxcIixcXG5cXG4gICAgLyogQGludGVybmFsICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcXG4gICAgICByZXR1cm4gU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpO1xcbiAgICB9XFxuICB9XSwgW3tcXG4gICAga2V5OiBcXFwiaW5zdGFuY2VcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zdGFuY2UoKSB7XFxuICAgICAgaWYgKCFTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZSkge1xcbiAgICAgICAgU3BvbmdlRmFjdG9yeS5faW5zdGFuY2UgPSBuZXcgU3BvbmdlRmFjdG9yeSgpO1xcblxcbiAgICAgICAgU3BvbmdlRmFjdG9yeS5faW5zdGFuY2UucmVnaXN0ZXIoXFxcImN1cmxcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xcbiAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIG5ldyAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuYXBwbHkoY3VybF8xLkN1cmwsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZS5yZWdpc3RlcihcXFwia2VybFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIG5ldyBrZXJsXzEuS2VybCgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBTcG9uZ2VGYWN0b3J5Ll9pbnN0YW5jZTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFNwb25nZUZhY3Rvcnk7XFxufShmYWN0b3J5QmFzZV8xLkZhY3RvcnlCYXNlKTtcXG5cXG5leHBvcnRzLlNwb25nZUZhY3RvcnkgPSBTcG9uZ2VGYWN0b3J5O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2ZhY3Rvcmllcy9zcG9uZ2VGYWN0b3J5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2hlbHBlcnMvYmlnSW50ZWdlckhlbHBlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9oZWxwZXJzL2JpZ0ludGVnZXJIZWxwZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbnZhciBfX2ltcG9ydERlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcXG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XFxuICAgIFxcXCJkZWZhdWx0XFxcIjogbW9kXFxuICB9O1xcbn07XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgbnVtYmVySGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBvYmplY3RIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyLmpzXFxcIik7IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTppbXBvcnQtbmFtZVxcblxcblxcbnZhciBiaWdfaW50ZWdlcl8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIGJpZy1pbnRlZ2VyICovIFxcXCJiaWctaW50ZWdlclxcXCIpKTtcXG5cXG52YXIgY3J5cHRvRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2NyeXB0b0Vycm9yICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3IuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBIZWxwZXIgY2xhc3MgdG8gY29udmVydCBiZXR3ZWVuIEJpZ0ludGVnZXIgYW5kIG90aGVyIHR5cGVzLlxcclxcbiAqIENvbnZlcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9pb3RhbGVkZ2VyL2lyaS9ibG9iL2Rldi9zcmMvbWFpbi9qYXZhL2NvbS9pb3RhL2lyaS9oYXNoL0tlcmwuamF2YVxcclxcbiAqL1xcblxcblxcbnZhciBCaWdJbnRlZ2VySGVscGVyID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gQmlnSW50ZWdlckhlbHBlcigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJpZ0ludGVnZXJIZWxwZXIpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKEJpZ0ludGVnZXJIZWxwZXIsIG51bGwsIFt7XFxuICAgIGtleTogXFxcInRyaXRzVG9CaWdJbnRlZ2VyXFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgdHJpdHMgdG8gYSBiaWdJbnRlZ2VyLlxcclxcbiAgICAgKiBAcGFyYW0gdHJpdHMgVGhlIHRyaXRzIHRvIGNvbnZlcnQuXFxyXFxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IHdpdGhpbiB0aGUgYXJyYXkgdG8gc3RhcnQuXFxyXFxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgdHJpdHMgYXJyYXkgdG8gY29udmVydC5cXHJcXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cml0c1RvQmlnSW50ZWdlcih0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJpdHMsIEludDhBcnJheSkgfHwgdHJpdHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIHRyaXRzIG11c3QgYmUgYSBub24gZW1wdHkgSW50OEFycmF5XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJUaGUgb2Zmc2V0IG11c3QgYmUgYSBudW1iZXIgPj0gMFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPD0gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlciA+IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9mZnNldCArIGxlbmd0aCA+IHRyaXRzLmxlbmd0aCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB2YWx1ZSA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdC56ZXJvO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tdWx0aXBseShCaWdJbnRlZ2VySGVscGVyLlJBRElYKS5hZGQoYmlnX2ludGVnZXJfMS5kZWZhdWx0KHRyaXRzW29mZnNldCArIGldKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogQ29udmVydCBiaWdJbnRlZ2VyIHRvIHRyaXRzLlxcclxcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGJpZ0ludGVnZXIgdG8gY29udmVydCB0byB0cml0cy5cXHJcXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSBhcnJheSB0byByZWNlaXZlIHRoZSB0cml0cy5cXHJcXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IHRvIHBsYWNlIHRoZSB0cml0cyBpbiB0aGUgYXJyYXkuXFxyXFxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJiaWdJbnRlZ2VyVG9Ucml0c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaWdJbnRlZ2VyVG9Ucml0cyh2YWx1ZSwgdHJpdHMsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHZhbHVlLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIHZhbHVlIG11c3QgYmUgYSBiaWdJbnRlZ2VyIHR5cGVcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyaXRzLCBJbnQ4QXJyYXkpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIHRyaXRzIG11c3QgYmUgYW4gSW50OEFycmF5XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJUaGUgb2Zmc2V0IG11c3QgYmUgYSBudW1iZXIgPj0gMFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPD0gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBsZW5ndGggbXVzdCBiZSBhIG51bWJlciA+IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9mZnNldCArIGxlbmd0aCA+IHRyaXRzLmxlbmd0aCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBhYnNvbHV0ZVZhbHVlID0gdmFsdWUuY29tcGFyZVRvKGJpZ19pbnRlZ2VyXzEuZGVmYXVsdC56ZXJvKSA8IDAgPyB2YWx1ZS5uZWdhdGUoKSA6IHZhbHVlO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBkaXZSZW1haW5kZXIgPSBhYnNvbHV0ZVZhbHVlLmRpdm1vZChCaWdJbnRlZ2VySGVscGVyLlJBRElYKTtcXG4gICAgICAgIGFic29sdXRlVmFsdWUgPSBkaXZSZW1haW5kZXIucXVvdGllbnQ7XFxuICAgICAgICB2YXIgcmVtYWluZGVyID0gZGl2UmVtYWluZGVyLnJlbWFpbmRlcjtcXG5cXG4gICAgICAgIGlmIChyZW1haW5kZXIgPiBCaWdJbnRlZ2VySGVscGVyLk1BWF9UUklUX1ZBTFVFKSB7XFxuICAgICAgICAgIHJlbWFpbmRlciA9IEJpZ0ludGVnZXJIZWxwZXIuTUlOX1RSSVRfVkFMVUU7XFxuICAgICAgICAgIGFic29sdXRlVmFsdWUgPSBhYnNvbHV0ZVZhbHVlLmFkZChiaWdfaW50ZWdlcl8xLmRlZmF1bHRbXFxcIjFcXFwiXSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0cml0c1tvZmZzZXQgKyBpXSA9IHJlbWFpbmRlci50b0pTTnVtYmVyKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh2YWx1ZS5jb21wYXJlVG8oYmlnX2ludGVnZXJfMS5kZWZhdWx0Lnplcm8pIDwgMCkge1xcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xcbiAgICAgICAgICAvLyBBdm9pZCBuZWdhdGl2ZSB6ZXJvXFxuICAgICAgICAgIHRyaXRzW29mZnNldCArIF9pXSA9IHRyaXRzW29mZnNldCArIF9pXSA9PT0gMCA/IDAgOiAtdHJpdHNbb2Zmc2V0ICsgX2ldO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogQ29udmVydCB0aGUgYmlnSW50ZWdlciBpbnRvIGJ5dGVzLlxcclxcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXFxyXFxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiBUaGUgZGVzdGluYXRpb24gYXJyYXkgdG8gc3RvcmUgdGhlIGJ5dGVzLlxcclxcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgd2l0aGluIHRoZSBhcnJheSB0byBzdG9yZSB0aGUgYnl0ZXMuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJiaWdJbnRlZ2VyVG9CeXRlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaWdJbnRlZ2VyVG9CeXRlcyh2YWx1ZSwgZGVzdGluYXRpb24sIG9mZnNldCkge1xcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh2YWx1ZSwgYmlnX2ludGVnZXJfMS5kZWZhdWx0KSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSB2YWx1ZSBtdXN0IGJlIGEgYmlnSW50ZWdlciB0eXBlXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShkZXN0aW5hdGlvbiwgQXJyYXlCdWZmZXIpIHx8IGRlc3RpbmF0aW9uLmJ5dGVMZW5ndGggPT09IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJUaGUgZGVzdGluYXRpb24gbXVzdCBiZSBhbiBhcnJheVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIob2Zmc2V0KSB8fCBvZmZzZXQgPCAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIG9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRlc3RpbmF0aW9uLmJ5dGVMZW5ndGggLSBvZmZzZXQgPCBCaWdJbnRlZ2VySGVscGVyLkJZVEVfSEFTSF9MRU5HVEgpIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJEZXN0aW5hdGlvbiBhcnJheSBoYXMgaW52YWxpZCBzaXplLCBpdCBtdXN0IGJlIGF0IGxlYXN0IFxcXCIuY29uY2F0KEJpZ0ludGVnZXJIZWxwZXIuQllURV9IQVNIX0xFTkdUSCkpO1xcbiAgICAgIH0gLy8gUmVtZW1iZXIgaWYgaXQgaXMgbmVnYXRpdmUgZm9yIGxhdGVyXFxuXFxuXFxuICAgICAgdmFyIGlzTmVnID0gdmFsdWUuaXNOZWdhdGl2ZSgpID8gLTEgOiAwO1xcbiAgICAgIHZhciBoZXhTdHJpbmcgPSB2YWx1ZS50b1N0cmluZygxNik7XFxuXFxuICAgICAgaWYgKGlzTmVnID09PSAtMSkge1xcbiAgICAgICAgLy8gQnV0IHJlbW92ZSBpdCBmb3Igbm93XFxuICAgICAgICBoZXhTdHJpbmcgPSBoZXhTdHJpbmcuc2xpY2UoMSk7XFxuICAgICAgfSAvLyBOb3cgbWFrZSBzdXJlIHRoZSBoZXggc3RyaW5nIGlzIGFuIGV2ZW4gbGVuZ3RoIHNvIHRoZSByZWdleCB3b3Jrc1xcblxcblxcbiAgICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMiA9PT0gMSkge1xcbiAgICAgICAgaGV4U3RyaW5nID0gXFxcIjBcXFwiLmNvbmNhdChoZXhTdHJpbmcpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbWF0Y2hlcyA9IGhleFN0cmluZy5tYXRjaCgvWzAtOWEtZl17Mn0vZyk7IC8vIENvbnZlcnQgdGhlIGhleCB0byBudW1iZXJzXFxuXFxuICAgICAgdmFyIHNpZ25lZEJ5dGVzID0gbmV3IEludDhBcnJheShtYXRjaGVzLm1hcChmdW5jdGlvbiAoaGV4KSB7XFxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoXFxcIjB4XFxcIi5jb25jYXQoaGV4KSwgMTYpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICBpZiAoaXNOZWcgPT09IC0xKSB7XFxuICAgICAgICBCaWdJbnRlZ2VySGVscGVyLnR3b3NDb21wbGVtZW50KHNpZ25lZEJ5dGVzKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRlc3RpbmF0aW9uKTsgLy8gUGFkIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVyIHdpdGggdGhlIG5lZyB2YWx1ZVxcblxcbiAgICAgIHZhciBpID0gb2Zmc2V0O1xcblxcbiAgICAgIHdoaWxlIChpICsgc2lnbmVkQnl0ZXMubGVuZ3RoIDwgQmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIKSB7XFxuICAgICAgICBkYXRhVmlldy5zZXRJbnQ4KGkrKywgaXNOZWcpO1xcbiAgICAgIH0gLy8gQW5kIGNvcHkgaW4gdGhlIGFjdHVhbCBieXRlc1xcblxcblxcbiAgICAgIGZvciAodmFyIGogPSBzaWduZWRCeXRlcy5sZW5ndGg7IGotLSA+IDA7KSB7XFxuICAgICAgICBkYXRhVmlldy5zZXRJbnQ4KGkrKywgc2lnbmVkQnl0ZXNbc2lnbmVkQnl0ZXMubGVuZ3RoIC0gMSAtIGpdKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgYnl0ZXMgdG8gYSBiaWdJbnRlZ2VyLlxcclxcbiAgICAgKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2UgYnl0ZXMuXFxyXFxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB3aXRoaW4gdGhlIGJ5dGVzIHRvIHN0YXJ0IGNvbnZlcnNpb24uXFxyXFxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgYnl0ZXMgdG8gdXNlIGZvciBjb252ZXJzaW9uLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYnl0ZXNUb0JpZ0ludGVnZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludGVnZXIoc291cmNlLCBvZmZzZXQsIGxlbmd0aCkge1xcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzb3VyY2UsIEFycmF5QnVmZmVyKSB8fCBzb3VyY2UuYnl0ZUxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBzb3VyY2UgbXVzdCBiZSBhIG5vbiBlbXB0eSBudW1iZXIgYXJyYXlcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBvZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8PSAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIGxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyID4gMFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc291cmNlLmJ5dGVMZW5ndGggLSBvZmZzZXQgPCBCaWdJbnRlZ2VySGVscGVyLkJZVEVfSEFTSF9MRU5HVEgpIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJTb3VyY2UgYXJyYXkgaGFzIGludmFsaWQgc2l6ZSwgaXQgbXVzdCBiZSBhdCBsZWFzdCBcXFwiLmNvbmNhdChCaWdJbnRlZ2VySGVscGVyLkJZVEVfSEFTSF9MRU5HVEgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZSk7XFxuICAgICAgdmFyIHNpZ25lZEJ5dGVzID0gbmV3IEludDhBcnJheShkYXRhVmlldy5ieXRlTGVuZ3RoKTtcXG5cXG4gICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGRhdGFWaWV3LmJ5dGVMZW5ndGg7IGIrKykge1xcbiAgICAgICAgc2lnbmVkQnl0ZXNbYl0gPSBkYXRhVmlldy5nZXRJbnQ4KGIgKyBvZmZzZXQpO1xcbiAgICAgIH0gLy8gUmVtb3ZlIHRoZSBpbml0aWFsIHBhZGRpbmcgbGVhdmluZyBhdCBsZWFzdCBvbmUgYnl0ZVxcblxcblxcbiAgICAgIHZhciBwYWRkaW5nT2Zmc2V0ID0gMDtcXG4gICAgICB2YXIgZmlyc3RCeXRlID0gc2lnbmVkQnl0ZXNbMF07XFxuICAgICAgdmFyIGlzTmVnID0gZmlyc3RCeXRlIDwgMDsgLy8gSWYgdGhlIGZpcnN0IHBhZGRpbmcgY2hhcmFjdGVyIGlzIG5lZ2F0aXZlIHRoZW4gcmV2ZXJzZSB0aGUgMnMgY29tcGxlbWVudFxcbiAgICAgIC8vIGJ1dCBmaXJzdCBzdHJpcCBvZiB0aGUgbGVhZGluZyBwYWRkaW5nXFxuXFxuICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMCB8fCBmaXJzdEJ5dGUgPT09IC0xKSB7XFxuICAgICAgICB3aGlsZSAoc2lnbmVkQnl0ZXNbcGFkZGluZ09mZnNldF0gPT09IGZpcnN0Qnl0ZSAmJiBwYWRkaW5nT2Zmc2V0IDwgc2lnbmVkQnl0ZXMubGVuZ3RoIC0gMSkge1xcbiAgICAgICAgICBwYWRkaW5nT2Zmc2V0Kys7XFxuICAgICAgICB9IC8vIFN0cmlwIGFueSBwYWRkaW5nXFxuXFxuXFxuICAgICAgICBzaWduZWRCeXRlcyA9IHNpZ25lZEJ5dGVzLnNsaWNlKHBhZGRpbmdPZmZzZXQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXNOZWcpIHtcXG4gICAgICAgIEJpZ0ludGVnZXJIZWxwZXIudHdvc0NvbXBsZW1lbnQoc2lnbmVkQnl0ZXMpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgaGV4U3RyaW5nID0gaXNOZWcgPyBcXFwiLVxcXCIgOiBcXFwiXFxcIjtcXG4gICAgICB2YXIgZHYgPSBuZXcgRGF0YVZpZXcoc2lnbmVkQnl0ZXMuYnVmZmVyKTtcXG5cXG4gICAgICBmb3IgKHZhciBoID0gMDsgaCA8IGR2LmJ5dGVMZW5ndGg7IGgrKykge1xcbiAgICAgICAgaGV4U3RyaW5nICs9IFxcXCIwMFxcXCIuY29uY2F0KGR2LmdldFVpbnQ4KGgpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gYmlnX2ludGVnZXJfMS5kZWZhdWx0KGhleFN0cmluZywgMTYpO1xcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0d29zQ29tcGxlbWVudFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0d29zQ29tcGxlbWVudChzaWduZWRCeXRlcykge1xcbiAgICAgIC8vIGlmIHRoZSB3aG9sZSBudW1iZXIgaXMgbmVnYXRpdmUgdGhlblxcbiAgICAgIC8vIGNoYW5nZSB0byAyJ3MgY29tcGxlbWVudHMgYnkgbm90aW5nIGFsbCB0aGUgbnVtYmVyc1xcbiAgICAgIC8vIGFuZCBhZGRpbmcgMSB0byB0aGUgbGFzdCBpLmUuIH5iaWdudW0rMVxcbiAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgc2lnbmVkQnl0ZXMubGVuZ3RoOyBiKyspIHtcXG4gICAgICAgIHNpZ25lZEJ5dGVzW2JdID0gfnNpZ25lZEJ5dGVzW2JdO1xcbiAgICAgIH0gLy8gQWRkIDEgdG8gbGFzdCBudW1iZXIsIGlmIHRoZSBudW1iZXIgaXMgMHhGRiBjb250aW51ZSB0byBjYXJyeVxcblxcblxcbiAgICAgIHZhciBjID0gc2lnbmVkQnl0ZXMubGVuZ3RoIC0gMTtcXG5cXG4gICAgICBkbyB7XFxuICAgICAgICBzaWduZWRCeXRlc1tjXSsrO1xcbiAgICAgIH0gd2hpbGUgKHNpZ25lZEJ5dGVzW2MtLV0gPT09IDAgJiYgYyA+IDApO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gQmlnSW50ZWdlckhlbHBlcjtcXG59KCk7XFxuLyogQGludGVybmFsICovXFxuXFxuXFxuQmlnSW50ZWdlckhlbHBlci5SQURJWCA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCgzKTtcXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5CaWdJbnRlZ2VySGVscGVyLk1BWF9UUklUX1ZBTFVFID0gQmlnSW50ZWdlckhlbHBlci5SQURJWC5taW51cygxKS5kaXZpZGUoMik7XFxuLyogQGludGVybmFsICovXFxuXFxuQmlnSW50ZWdlckhlbHBlci5NSU5fVFJJVF9WQUxVRSA9IEJpZ0ludGVnZXJIZWxwZXIuTUFYX1RSSVRfVkFMVUUubmVnYXRlKCk7XFxuLyogQGludGVybmFsICovXFxuXFxuQmlnSW50ZWdlckhlbHBlci5CSVRfSEFTSF9MRU5HVEggPSAzODQ7XFxuLyogQGludGVybmFsICovXFxuXFxuQmlnSW50ZWdlckhlbHBlci5CWVRFX0hBU0hfTEVOR1RIID0gQmlnSW50ZWdlckhlbHBlci5CSVRfSEFTSF9MRU5HVEggLyA4O1xcbmV4cG9ydHMuQmlnSW50ZWdlckhlbHBlciA9IEJpZ0ludGVnZXJIZWxwZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvaGVscGVycy9iaWdJbnRlZ2VySGVscGVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfX2V4cG9ydChtKSB7XFxuICBmb3IgKHZhciBwIGluIG0pIHtcXG4gICAgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcXG4gIH1cXG59XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG4vKipcXHJcXG4gKiBDb21iaW5lZCBpbmRleCBvZiBhbGwgdGhlIG1vZHVsZXMuXFxyXFxuICovXFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kaWdlc3RzL3NoYTMgKi8gXFxcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9kaWdlc3RzL3NoYTMuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lcnJvci9jcnlwdG9FcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnkgKi8gXFxcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9mYWN0b3JpZXMvc3BvbmdlRmFjdG9yeS5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hlbHBlcnMvYmlnSW50ZWdlckhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2hlbHBlcnMvYmlnSW50ZWdlckhlbHBlci5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Nwb25nZXMvY3VybCAqLyBcXFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L3Nwb25nZXMvY3VybC5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Nwb25nZXMva2VybCAqLyBcXFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L3Nwb25nZXMva2VybC5qc1xcXCIpKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9zcG9uZ2VzL2N1cmwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3Qvc3Bvbmdlcy9jdXJsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBudW1iZXJIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgY3J5cHRvRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2NyeXB0b0Vycm9yICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3IuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBJU3BvbmdlIHVzaW5nIEN1cmwgYWxnb3JpdGhtLlxcclxcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9pb3RhbGVkZ2VyL2lvdGEubGliLmpzL2Jsb2IvbWFzdGVyL2xpYi9jcnlwdG8vY3VybC9jdXJsLmpzXFxyXFxuICovXFxuXFxuXFxudmFyIEN1cmwgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICAvKipcXHJcXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBDdXJsLlxcclxcbiAgICogQHBhcmFtIHJvdW5kcyBUaGUgbnVtYmVyIG9mIHJvdW5kcyB0byB1c2UuXFxyXFxuICAgKi9cXG4gIGZ1bmN0aW9uIEN1cmwoKSB7XFxuICAgIHZhciByb3VuZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IEN1cmwuTlVNQkVSX09GX1JPVU5EUztcXG5cXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cmwpO1xcblxcbiAgICB0aGlzLl9udW1iZXJPZlJvdW5kcyA9IHJvdW5kcztcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogR2V0IHRoZSBjb25zdGFudCBmb3IgdGhlIGhhc2hlci5cXHJcXG4gICAqIEByZXR1cm5zIFRoZSBjb25zdGFudHMuXFxyXFxuICAgKi9cXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhDdXJsLCBbe1xcbiAgICBrZXk6IFxcXCJnZXRDb25zdGFudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29uc3RhbnRzKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBIQVNIX0xFTkdUSDogQ3VybC5IQVNIX0xFTkdUSCxcXG4gICAgICAgIFNUQVRFX0xFTkdUSDogQ3VybC5TVEFURV9MRU5HVEgsXFxuICAgICAgICBOVU1CRVJfT0ZfUk9VTkRTOiB0aGlzLl9udW1iZXJPZlJvdW5kc1xcbiAgICAgIH07XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0aGUgc3RhdGUuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSBzdGF0ZS5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldFN0YXRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogSW5pdGlhbGlzZSB0aGUgaGFzaGVyLlxcclxcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIGluaXRpYWwgc3RhdGUgZm9yIHRoZSBoYXNoZXIuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpbml0aWFsaXplXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoc3RhdGUpIHtcXG4gICAgICBpZiAoc3RhdGUpIHtcXG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3IEludDhBcnJheShDdXJsLlNUQVRFX0xFTkdUSCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBSZXNldCB0aGUgaGFzaGVyLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicmVzZXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XFxuICAgICAgdGhpcy5pbml0aWFsaXplKCk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEFic29yYiB0cml0cyBpbnRvIHRoZSBoYXNoLlxcclxcbiAgICAgKiBAcGFyYW0gdHJpdHMgVGhlIHRyaXRzIHRvIGFic29yYi5cXHJcXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IGludG8gdGhlIHRyaXRzIHRvIGFic29yYiBmcm9tLlxcclxcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgdHJpdHMgdG8gYWJzb3JiLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYWJzb3JiXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFic29yYih0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJpdHMsIEludDhBcnJheSkgfHwgdHJpdHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVHJpdHMgbXVzdCBiZSBhIG5vbiBlbXB0eSBJbnQ4QXJyYXlcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIk9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDwgMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIkxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyID49IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA+IHRyaXRzLmxlbmd0aCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBsb2NhbE9mZnNldCA9IG9mZnNldDtcXG4gICAgICB2YXIgbG9jYWxMZW5ndGggPSBsZW5ndGg7XFxuXFxuICAgICAgZG8ge1xcbiAgICAgICAgdmFyIGkgPSAwO1xcbiAgICAgICAgdmFyIGxpbWl0ID0gbG9jYWxMZW5ndGggPCBDdXJsLkhBU0hfTEVOR1RIID8gbG9jYWxMZW5ndGggOiBDdXJsLkhBU0hfTEVOR1RIO1xcblxcbiAgICAgICAgd2hpbGUgKGkgPCBsaW1pdCkge1xcbiAgICAgICAgICB0aGlzLl9zdGF0ZVtpKytdID0gdHJpdHNbbG9jYWxPZmZzZXQrK107XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnRyYW5zZm9ybSgpO1xcbiAgICAgICAgbG9jYWxMZW5ndGggLT0gQ3VybC5IQVNIX0xFTkdUSDtcXG4gICAgICB9IHdoaWxlIChsb2NhbExlbmd0aCA+IDApO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBTcXVlZXplIHRyaXRzIGludG8gdGhlIGhhc2guXFxyXFxuICAgICAqIEBwYXJhbSB0cml0cyBUaGUgdHJpdHMgdG8gc3F1ZWV6ZS5cXHJcXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0IGludG8gdGhlIHRyaXRzIHRvIHNxdWVlemUgZnJvbS5cXHJcXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbnVtYmVyIG9mIHRyaXRzIHRvIHNxdWVlemUuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzcXVlZXplXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNxdWVlemUodHJpdHMsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyaXRzLCBJbnQ4QXJyYXkpIHx8IHRyaXRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRyaXRzIG11c3QgYmUgYSBub24gZW1wdHkgSW50OEFycmF5XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJPZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJMZW5ndGggbXVzdCBiZSBhIG51bWJlciA+PSAwXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChsZW5ndGggKyBvZmZzZXQgPiB0cml0cy5sZW5ndGgpIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJUaGUgb2Zmc2V0ICsgbGVuZ3RoIGlzIGJleW9uZCB0aGUgbGVuZ3RoIG9mIHRoZSB0cml0c1xcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbG9jYWxPZmZzZXQgPSBvZmZzZXQ7XFxuICAgICAgdmFyIGxvY2FsTGVuZ3RoID0gbGVuZ3RoO1xcblxcbiAgICAgIGRvIHtcXG4gICAgICAgIHZhciBpID0gMDtcXG4gICAgICAgIHZhciBsaW1pdCA9IGxvY2FsTGVuZ3RoIDwgQ3VybC5IQVNIX0xFTkdUSCA/IGxlbmd0aCA6IEN1cmwuSEFTSF9MRU5HVEg7XFxuXFxuICAgICAgICB3aGlsZSAoaSA8IGxpbWl0KSB7XFxuICAgICAgICAgIHRyaXRzW2xvY2FsT2Zmc2V0KytdID0gdGhpcy5fc3RhdGVbaSsrXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMudHJhbnNmb3JtKCk7XFxuICAgICAgICBsb2NhbExlbmd0aCAtPSBDdXJsLkhBU0hfTEVOR1RIO1xcbiAgICAgIH0gd2hpbGUgKGxvY2FsTGVuZ3RoID4gMCk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIFRyYW5zZm9ybSB0aGUgaGFzaC5cXHJcXG4gICAgICogQGludGVybmFsXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0cmFuc2Zvcm1cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtKCkge1xcbiAgICAgIHZhciBzdGF0ZUNvcHk7XFxuICAgICAgdmFyIGluZGV4ID0gMDtcXG5cXG4gICAgICBmb3IgKHZhciByb3VuZCA9IDA7IHJvdW5kIDwgdGhpcy5fbnVtYmVyT2ZSb3VuZHM7IHJvdW5kKyspIHtcXG4gICAgICAgIHN0YXRlQ29weSA9IG5ldyBJbnQ4QXJyYXkodGhpcy5fc3RhdGUuc2xpY2UoKSk7XFxuXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEN1cmwuU1RBVEVfTEVOR1RIOyBpKyspIHtcXG4gICAgICAgICAgdGhpcy5fc3RhdGVbaV0gPSBDdXJsLlRSVVRIX1RBQkxFW3N0YXRlQ29weVtpbmRleF0gKyAoc3RhdGVDb3B5W2luZGV4ICs9IGluZGV4IDwgMzY1ID8gMzY0IDogLTM2NV0gPDwgMikgKyA1XTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBDdXJsO1xcbn0oKTtcXG5cXG5DdXJsLkhBU0hfTEVOR1RIID0gMjQzO1xcbkN1cmwuTlVNQkVSX09GX1JPVU5EUyA9IDgxO1xcbkN1cmwuU1RBVEVfTEVOR1RIID0gQ3VybC5IQVNIX0xFTkdUSCAqIDM7XFxuLyogQGludGVybmFsICovXFxuXFxuQ3VybC5UUlVUSF9UQUJMRSA9IG5ldyBJbnQ4QXJyYXkoWzEsIDAsIC0xLCAyLCAxLCAtMSwgMCwgMiwgLTEsIDEsIDBdKTtcXG5leHBvcnRzLkN1cmwgPSBDdXJsO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L3Nwb25nZXMvY3VybC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9zcG9uZ2VzL2tlcmwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3Qvc3Bvbmdlcy9rZXJsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBudW1iZXJIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgc2hhM18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGlnZXN0cy9zaGEzICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZGlnZXN0cy9zaGEzLmpzXFxcIik7XFxuXFxudmFyIGNyeXB0b0Vycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvci9jcnlwdG9FcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yLmpzXFxcIik7XFxuXFxudmFyIGJpZ0ludGVnZXJIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2hlbHBlcnMvYmlnSW50ZWdlckhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2hlbHBlcnMvYmlnSW50ZWdlckhlbHBlci5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEltcGxlbWVudGF0aW9uIG9mIElTcG9uZ2UgdXNpbmcgS2VybCBhbGdvcml0aG0uXFxyXFxuICogaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvaXJpL2Jsb2IvZGV2L3NyYy9tYWluL2phdmEvY29tL2lvdGEvaXJpL2hhc2gvS2VybC5qYXZhXFxyXFxuICovXFxuXFxuXFxudmFyIEtlcmwgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICAvKipcXHJcXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBLZXJsLlxcclxcbiAgICovXFxuICBmdW5jdGlvbiBLZXJsKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2VybCk7XFxuXFxuICAgIHRoaXMuX2tlY2NhayA9IG5ldyBzaGEzXzEuU2hhMygzODQsIHNoYTNfMS5TaGEzLktFQ0NBS19QQURESU5HLCAzODQpO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBHZXQgdGhlIGNvbnN0YW50IGZvciB0aGUgaGFzaGVyLlxcclxcbiAgICogQHJldHVybnMgVGhlIGNvbnN0YW50cy5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKEtlcmwsIFt7XFxuICAgIGtleTogXFxcImdldENvbnN0YW50c1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25zdGFudHMoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIEhBU0hfTEVOR1RIOiBLZXJsLkhBU0hfTEVOR1RILFxcbiAgICAgICAgQklUX0hBU0hfTEVOR1RIOiBLZXJsLkJJVF9IQVNIX0xFTkdUSCxcXG4gICAgICAgIEJZVEVfSEFTSF9MRU5HVEg6IEtlcmwuQllURV9IQVNIX0xFTkdUSFxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0aGUgc3RhdGUuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSBzdGF0ZS5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImdldFN0YXRlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEluaXRpYWxpc2UgdGhlIGhhc2hlci5cXHJcXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBpbml0aWFsIHN0YXRlIGZvciB0aGUgaGFzaGVyLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiaW5pdGlhbGl6ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKHN0YXRlKSB7fVxcbiAgICAvKipcXHJcXG4gICAgICogUmVzZXQgdGhlIGhhc2hlci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInJlc2V0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xcbiAgICAgIHRoaXMuX2tlY2Nhay5yZXNldCgpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBBYnNvcmIgdHJpdHMgaW50byB0aGUgaGFzaC5cXHJcXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSB0cml0cyB0byBhYnNvcmIuXFxyXFxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCBpbnRvIHRoZSB0cml0cyB0byBhYnNvcmIgZnJvbS5cXHJcXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbnVtYmVyIG9mIHRyaXRzIHRvIGFic29yYi5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFic29yYlxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhYnNvcmIodHJpdHMsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyaXRzLCBJbnQ4QXJyYXkpIHx8IHRyaXRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRyaXRzIG11c3QgYmUgYSBub24gZW1wdHkgSW50OEFycmF5XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihvZmZzZXQpIHx8IG9mZnNldCA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJPZmZzZXQgbXVzdCBiZSBhIG51bWJlciA+PSAwXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJMZW5ndGggbXVzdCBiZSBhIG51bWJlciA+PSAwXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChsZW5ndGggKyBvZmZzZXQgPiB0cml0cy5sZW5ndGgpIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJUaGUgb2Zmc2V0ICsgbGVuZ3RoIGlzIGJleW9uZCB0aGUgbGVuZ3RoIG9mIHRoZSB0cml0c1xcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAobGVuZ3RoICUgMjQzICE9PSAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiBcXFwiLmNvbmNhdChLZXJsLkhBU0hfTEVOR1RIKSwge1xcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBsb2NhbE9mZnNldCA9IG9mZnNldDtcXG4gICAgICB2YXIgbG9jYWxMZW5ndGggPSBsZW5ndGg7XFxuXFxuICAgICAgZG8ge1xcbiAgICAgICAgdmFyIHRyaXRTdGF0ZSA9IHRyaXRzLnNsaWNlKGxvY2FsT2Zmc2V0LCBsb2NhbE9mZnNldCArIEtlcmwuSEFTSF9MRU5HVEgpO1xcbiAgICAgICAgdHJpdFN0YXRlW0tlcmwuSEFTSF9MRU5HVEggLSAxXSA9IDA7XFxuICAgICAgICB2YXIgYmlnSW50ID0gYmlnSW50ZWdlckhlbHBlcl8xLkJpZ0ludGVnZXJIZWxwZXIudHJpdHNUb0JpZ0ludGVnZXIodHJpdFN0YXRlLCAwLCB0cml0U3RhdGUubGVuZ3RoKTtcXG4gICAgICAgIHZhciBieXRlU3RhdGUgPSBuZXcgQXJyYXlCdWZmZXIoS2VybC5CWVRFX0hBU0hfTEVOR1RIKTtcXG4gICAgICAgIGJpZ0ludGVnZXJIZWxwZXJfMS5CaWdJbnRlZ2VySGVscGVyLmJpZ0ludGVnZXJUb0J5dGVzKGJpZ0ludCwgYnl0ZVN0YXRlLCAwKTtcXG5cXG4gICAgICAgIHRoaXMuX2tlY2Nhay51cGRhdGUoYnl0ZVN0YXRlKTtcXG5cXG4gICAgICAgIGxvY2FsT2Zmc2V0ICs9IEtlcmwuSEFTSF9MRU5HVEg7XFxuICAgICAgICBsb2NhbExlbmd0aCAtPSBLZXJsLkhBU0hfTEVOR1RIO1xcbiAgICAgIH0gd2hpbGUgKGxvY2FsTGVuZ3RoID4gMCk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIFNxdWVlemUgdHJpdHMgaW50byB0aGUgaGFzaC5cXHJcXG4gICAgICogQHBhcmFtIHRyaXRzIFRoZSB0cml0cyB0byBzcXVlZXplLlxcclxcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgaW50byB0aGUgdHJpdHMgdG8gc3F1ZWV6ZSBmcm9tLlxcclxcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgdHJpdHMgdG8gc3F1ZWV6ZS5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNxdWVlemVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3F1ZWV6ZSh0cml0cywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJpdHMsIEludDhBcnJheSkgfHwgdHJpdHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVHJpdHMgbXVzdCBiZSBhIG5vbiBlbXB0eSBJbnQ4QXJyYXlcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG9mZnNldCkgfHwgb2Zmc2V0IDwgMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIk9mZnNldCBtdXN0IGJlIGEgbnVtYmVyID49IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDwgMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIkxlbmd0aCBtdXN0IGJlIGEgbnVtYmVyID49IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGxlbmd0aCArIG9mZnNldCA+IHRyaXRzLmxlbmd0aCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBvZmZzZXQgKyBsZW5ndGggaXMgYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChsZW5ndGggJSAyNDMgIT09IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIFxcXCIuY29uY2F0KEtlcmwuSEFTSF9MRU5HVEgpLCB7XFxuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGxvY2FsT2Zmc2V0ID0gb2Zmc2V0O1xcbiAgICAgIHZhciBsb2NhbExlbmd0aCA9IGxlbmd0aDtcXG5cXG4gICAgICBkbyB7XFxuICAgICAgICB2YXIgYnl0ZVN0YXRlQnVmZmVyID0gdGhpcy5fa2VjY2FrLmRpZ2VzdCgpO1xcblxcbiAgICAgICAgdmFyIGJpZ0ludCA9IGJpZ0ludGVnZXJIZWxwZXJfMS5CaWdJbnRlZ2VySGVscGVyLmJ5dGVzVG9CaWdJbnRlZ2VyKGJ5dGVTdGF0ZUJ1ZmZlciwgMCwgS2VybC5CWVRFX0hBU0hfTEVOR1RIKTtcXG4gICAgICAgIHZhciB0cml0U3RhdGUgPSBuZXcgSW50OEFycmF5KEtlcmwuSEFTSF9MRU5HVEgpO1xcbiAgICAgICAgYmlnSW50ZWdlckhlbHBlcl8xLkJpZ0ludGVnZXJIZWxwZXIuYmlnSW50ZWdlclRvVHJpdHMoYmlnSW50LCB0cml0U3RhdGUsIDAsIEtlcmwuSEFTSF9MRU5HVEgpO1xcbiAgICAgICAgdHJpdFN0YXRlW0tlcmwuSEFTSF9MRU5HVEggLSAxXSA9IDA7XFxuICAgICAgICB2YXIgaSA9IDA7XFxuXFxuICAgICAgICB3aGlsZSAoaSA8IEtlcmwuSEFTSF9MRU5HVEgpIHtcXG4gICAgICAgICAgdHJpdHNbbG9jYWxPZmZzZXQrK10gPSB0cml0U3RhdGVbaSsrXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBkdiA9IG5ldyBEYXRhVmlldyhieXRlU3RhdGVCdWZmZXIpO1xcblxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGR2LmJ5dGVMZW5ndGg7IGkrKykge1xcbiAgICAgICAgICBkdi5zZXRVaW50OChpLCBkdi5nZXRVaW50OChpKSBeIDB4RkYpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fa2VjY2FrLnVwZGF0ZShieXRlU3RhdGVCdWZmZXIpO1xcblxcbiAgICAgICAgbG9jYWxMZW5ndGggLT0gS2VybC5IQVNIX0xFTkdUSDtcXG4gICAgICB9IHdoaWxlIChsb2NhbExlbmd0aCA+IDApO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gS2VybDtcXG59KCk7XFxuLyogQGludGVybmFsICovXFxuXFxuXFxuS2VybC5IQVNIX0xFTkdUSCA9IDI0MztcXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5LZXJsLkJJVF9IQVNIX0xFTkdUSCA9IDM4NDtcXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5LZXJsLkJZVEVfSEFTSF9MRU5HVEggPSBLZXJsLkJJVF9IQVNIX0xFTkdUSCAvIDg7XFxuZXhwb3J0cy5LZXJsID0gS2VybDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9zcG9uZ2VzL2tlcmwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2NvbnZlcnRlcnMvYXNjaWlUcnl0ZXNDb252ZXJ0ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1kYXRhL2Rpc3QvY29udmVydGVycy9hc2NpaVRyeXRlc0NvbnZlcnRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBvYmplY3RIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIHN0cmluZ0hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgdHJ5dGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhL3RyeXRlcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1xcXCIpO1xcblxcbnZhciBkYXRhRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2RhdGFFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBUcnl0ZXMgY29udmVydGVyIHRoYXQgY29udmVydHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuXFxyXFxuICovXFxuXFxuXFxudmFyIEFzY2lpVHJ5dGVzQ29udmVydGVyID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gQXNjaWlUcnl0ZXNDb252ZXJ0ZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc2NpaVRyeXRlc0NvbnZlcnRlcik7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoQXNjaWlUcnl0ZXNDb252ZXJ0ZXIsIFt7XFxuICAgIGtleTogXFxcInRvXFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgYSBzdHJpbmcgdmFsdWUgaW50byB0cnl0ZXMuXFxyXFxuICAgICAqIEBwYXJhbSBzdHJpbmcgdmFsdWUgdG8gY29udmVydCBpbnRvIHRyeXRlcy5cXHJcXG4gICAgICogQHJldHVybnMgVGhlIHRyeXRlcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUuXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG8odmFsdWUpIHtcXG4gICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc1N0cmluZyh2YWx1ZSkpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSB2YWx1ZSBtdXN0IG5vdCBiZSBzdHJpbmdcXFwiLCB7XFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmlzQXNjaWkodmFsdWUpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgdmFsdWUgY29udGFpbnMgbm9uIEFTQ0lJIGNoYXJhY3RlcnNcXFwiLCB7XFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0cnl0ZXMgPSBcXFwiXFxcIjtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgYXNjaWlWYWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XFxuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IGFzY2lpVmFsdWUgJSAyNztcXG4gICAgICAgIHZhciBzZWNvbmRWYWx1ZSA9IChhc2NpaVZhbHVlIC0gZmlyc3RWYWx1ZSkgLyAyNztcXG4gICAgICAgIHRyeXRlcyArPSB0cnl0ZXNfMS5Ucnl0ZXMuQUxQSEFCRVRbZmlyc3RWYWx1ZV0gKyB0cnl0ZXNfMS5Ucnl0ZXMuQUxQSEFCRVRbc2Vjb25kVmFsdWVdO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodHJ5dGVzKTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogQ29udmVydCB0cnl0ZXMgaW50byBhIHN0cmluZyB2YWx1ZS5cXHJcXG4gICAgICogQHBhcmFtIHRyeXRlcyB0byBjb252ZXJ0IGludG8gYSBzdHJpbmcgdmFsdWUuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgdmFsdWUgY29udmVydGVkIGZyb20gdGhlIHRyeXRlcy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZyb21cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbSh0cnl0ZXMpIHtcXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodHJ5dGVzLCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgdHJ5dGVzIHBhcmFtZXRlciBpcyBlbXB0eSBvciBub3QgdGhlIGNvcnJlY3QgdHlwZVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdHJ5dGVzU3RyaW5nID0gdHJ5dGVzLnRvU3RyaW5nKCk7XFxuXFxuICAgICAgaWYgKHRyeXRlc1N0cmluZy5sZW5ndGggJSAyID09PSAxKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgdHJ5dGVzIGxlbmd0aCBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBhc2NpaSA9IFxcXCJcXFwiO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJ5dGVzU3RyaW5nLmxlbmd0aDsgaSArPSAyKSB7XFxuICAgICAgICB2YXIgdHJ5dGVzUGFpciA9IHRyeXRlc1N0cmluZ1tpXSArIHRyeXRlc1N0cmluZ1tpICsgMV07XFxuICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IHRyeXRlc18xLlRyeXRlcy5BTFBIQUJFVC5pbmRleE9mKHRyeXRlc1BhaXJbMF0pO1xcbiAgICAgICAgdmFyIHNlY29uZFZhbHVlID0gdHJ5dGVzXzEuVHJ5dGVzLkFMUEhBQkVULmluZGV4T2YodHJ5dGVzUGFpclsxXSk7XFxuICAgICAgICB2YXIgZGVjaW1hbFZhbHVlID0gZmlyc3RWYWx1ZSArIHNlY29uZFZhbHVlICogMjc7XFxuICAgICAgICBhc2NpaSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlY2ltYWxWYWx1ZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBhc2NpaTtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEFzY2lpVHJ5dGVzQ29udmVydGVyO1xcbn0oKTtcXG5cXG5leHBvcnRzLkFzY2lpVHJ5dGVzQ29udmVydGVyID0gQXNjaWlUcnl0ZXNDb252ZXJ0ZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tZGF0YS9kaXN0L2NvbnZlcnRlcnMvYXNjaWlUcnl0ZXNDb252ZXJ0ZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2NvbnZlcnRlcnMvb2JqZWN0VHJ5dGVzQ29udmVydGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWRhdGEvZGlzdC9jb252ZXJ0ZXJzL29iamVjdFRyeXRlc0NvbnZlcnRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIganNvbkhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9qc29uSGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvanNvbkhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBvYmplY3RIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIHN0cmluZ0hlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9zdHJpbmdIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgdHJ5dGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhL3RyeXRlcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1xcXCIpO1xcblxcbnZhciBkYXRhRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2RhdGFFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanNcXFwiKTtcXG5cXG52YXIgYXNjaWlUcnl0ZXNDb252ZXJ0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXNjaWlUcnl0ZXNDb252ZXJ0ZXIgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvY29udmVydGVycy9hc2NpaVRyeXRlc0NvbnZlcnRlci5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIFRyeXRlcyBjb252ZXJ0ZXIgdGhhdCBjb252ZXJ0cyB0byBhbmQgZnJvbSBhbiBvYmplY3QuXFxyXFxuICogQHR5cGVwYXJhbSBUIFRoZSBnZW5lcmljIHR5cGUgZm9yIHRoZSBjb252ZXJzaW9uIG1ldGhvZHMuXFxyXFxuICovXFxuXFxuXFxudmFyIE9iamVjdFRyeXRlc0NvbnZlcnRlciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIE9iamVjdFRyeXRlc0NvbnZlcnRlcigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdFRyeXRlc0NvbnZlcnRlcik7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoT2JqZWN0VHJ5dGVzQ29udmVydGVyLCBbe1xcbiAgICBrZXk6IFxcXCJ0b1xcXCIsXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBDb252ZXJ0IGFuIG9iamVjdCB2YWx1ZSBpbnRvIHRyeXRlcy5cXHJcXG4gICAgICogQHBhcmFtIG9iamVjdCB0byBjb252ZXJ0IGludG8gdHJ5dGVzLlxcclxcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG8odmFsdWUpIHtcXG4gICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkodmFsdWUpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgdmFsdWUgY2FuIG5vdCBiZSBlbXB0eVxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIganNvbjtcXG5cXG4gICAgICB0cnkge1xcbiAgICAgICAganNvbiA9IGpzb25IZWxwZXJfMS5Kc29uSGVscGVyLnN0cmluZ2lmeSh2YWx1ZSk7XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGVyZSB3YXMgYSBwcm9ibGVtIGNvbnZlcnRpbmcgdGhlIG9iamVjdCB0byBKU09OXFxcIiwge1xcbiAgICAgICAgICBlcnI6IGVyclxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBuZXcgYXNjaWlUcnl0ZXNDb252ZXJ0ZXJfMS5Bc2NpaVRyeXRlc0NvbnZlcnRlcigpLnRvKHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5lbmNvZGVOb25BU0NJSShqc29uKSk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgdHJ5dGVzIGludG8gYSBzdHJpbmcgdmFsdWUuXFxyXFxuICAgICAqIEBwYXJhbSB0cnl0ZXMgdG8gY29udmVydCBpbnRvIGEgc3RyaW5nIHZhbHVlLlxcclxcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHZhbHVlIGNvbnZlcnRlZCBmcm9tIHRoZSB0cnl0ZXMuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJmcm9tXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20odHJ5dGVzKSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRyeXRlcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHRyeXRlcyBwYXJhbWV0ZXIgaXMgZW1wdHkgb3Igbm90IHRoZSBjb3JyZWN0IHR5cGVcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGFzY2lpID0gbmV3IGFzY2lpVHJ5dGVzQ29udmVydGVyXzEuQXNjaWlUcnl0ZXNDb252ZXJ0ZXIoKS5mcm9tKHRyeXRlcyk7IC8vIE11c3QgaGF2ZSBhIGEgc3RhcnQgYW5kIGNsb3NpbmcgcGFpcnNcXG5cXG4gICAgICBpZiAoYXNjaWkubGVuZ3RoIDwgMikge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHRyeXRlcyBkbyBub3QgcmVwcmVzZW50IGFuIG9iamVjdFxcXCIpO1xcbiAgICAgIH0gLy8gVGhlIHN0YXJ0IGFuZCBlbmQgbXVzdCBiZSBlaXRoZXIge30gb3IgXFxcIlxcXCIgdG8gcmVwcmVzZW50IGEgSlNPTiBvYmplY3RcXG5cXG5cXG4gICAgICBpZiAoIShhc2NpaVswXSA9PT0gXFxcIntcXFwiICYmIGFzY2lpW2FzY2lpLmxlbmd0aCAtIDFdID09PSBcXFwifVxcXCIgfHwgYXNjaWlbMF0gPT09IFxcXCJcXFxcXFxcIlxcXCIgJiYgYXNjaWlbYXNjaWkubGVuZ3RoIC0gMV0gPT09IFxcXCJcXFxcXFxcIlxcXCIpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgdHJ5dGVzIGRvIG5vdCByZXByZXNlbnQgYW4gb2JqZWN0XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkZWNvZGVkID0gc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmRlY29kZU5vbkFTQ0lJKGFzY2lpKTtcXG4gICAgICB2YXIgb2JqO1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBvYmogPSBKU09OLnBhcnNlKGRlY29kZWQpO1xcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlcmUgd2FzIGEgcHJvYmxlbSBjb252ZXJ0aW5nIHRoZSBvYmplY3QgZnJvbSBKU09OXFxcIiwge1xcbiAgICAgICAgICBlcnI6IGVyclxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvYmo7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBPYmplY3RUcnl0ZXNDb252ZXJ0ZXI7XFxufSgpO1xcblxcbmV4cG9ydHMuT2JqZWN0VHJ5dGVzQ29udmVydGVyID0gT2JqZWN0VHJ5dGVzQ29udmVydGVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWRhdGEvZGlzdC9jb252ZXJ0ZXJzL29iamVjdFRyeXRlc0NvbnZlcnRlci5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9hZGRyZXNzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBkYXRhRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2RhdGFFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanNcXFwiKTtcXG5cXG52YXIgdHJ5dGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyeXRlcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIGFkZHJlc3Nlcy5cXHJcXG4gKi9cXG5cXG5cXG52YXIgQWRkcmVzcyA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qIEBpbnRlcm5hbCAqL1xcbiAgZnVuY3Rpb24gQWRkcmVzcyhhZGRyZXNzVHJ5dGVzLCBjaGVja3N1bVRyeXRlcykge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWRkcmVzcyk7XFxuXFxuICAgIHRoaXMuX2FkZHJlc3NUcnl0ZXMgPSBhZGRyZXNzVHJ5dGVzO1xcbiAgICB0aGlzLl9jaGVja3N1bVRyeXRlcyA9IGNoZWNrc3VtVHJ5dGVzO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgYWRkcmVzcyBmcm9tIHRyeXRlcy5cXHJcXG4gICAqIEBwYXJhbSBhZGRyZXNzIFRoZSB0cnl0ZXMgdG8gY3JlYXRlIHRoZSBhZGRyZXNzIGZyb20uXFxyXFxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBBZGRyZXNzLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoQWRkcmVzcywgW3tcXG4gICAga2V5OiBcXFwidG9Ucnl0ZXNcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQ29udmVydCB0aGUgYWRkcmVzcyB0byB0cnl0ZXMgd2l0aCBubyBjaGVja3N1bS5cXHJcXG4gICAgICogQHJldHVybnMgVHJ5dGVzIHZlcnNpb24gb2YgdGhlIGFkZHJlc3Mgd2l0aCBubyBjaGVja3N1bS5cXHJcXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1RyeXRlcygpIHtcXG4gICAgICByZXR1cm4gdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcodGhpcy5fYWRkcmVzc1RyeXRlcyk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgdGhlIGFkZHJlc3MgdG8gdHJ5dGVzIHdpdGggYSBjaGVja3N1bSwgY3JlYXRpbmcgYSBibGFuayBvbmUgaWYgbmVlZGVkLlxcclxcbiAgICAgKiBAcmV0dXJucyBUcnl0ZXMgdmVyc2lvbiBvZiB0aGUgYWRkcmVzcyB3aXRoIGNoZWNrc3UsLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9Ucnl0ZXNXaXRoQ2hlY2tzdW1cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Ucnl0ZXNXaXRoQ2hlY2tzdW0oKSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0aGlzLl9jaGVja3N1bVRyeXRlcykpIHtcXG4gICAgICAgIHJldHVybiB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0aGlzLl9hZGRyZXNzVHJ5dGVzICsgdGhpcy5fY2hlY2tzdW1Ucnl0ZXMpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGlzIGFkZHJlc3MgaGFzIG5vIGNoZWNrc3VtIGNhbGN1bGF0ZWQgZm9yIGl0XFxcIik7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBHZXQgdGhlIHN0cmluZyB2aWV3IG9mIHRoZSBvYmplY3QuXFxyXFxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9TdHJpbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0aGlzLl9jaGVja3N1bVRyeXRlcykpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRyZXNzVHJ5dGVzICsgdGhpcy5fY2hlY2tzdW1Ucnl0ZXM7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRyZXNzVHJ5dGVzO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0sIFt7XFxuICAgIGtleTogXFxcImZyb21Ucnl0ZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVRyeXRlcyhhZGRyZXNzKSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGFkZHJlc3MsIHRyeXRlc18xLlRyeXRlcykpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBhZGRyZXNzIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRyeXRlc1N0cmluZyA9IGFkZHJlc3MudG9TdHJpbmcoKTtcXG5cXG4gICAgICBpZiAodHJ5dGVzU3RyaW5nLmxlbmd0aCAhPT0gQWRkcmVzcy5MRU5HVEggJiYgdHJ5dGVzU3RyaW5nLmxlbmd0aCAhPT0gQWRkcmVzcy5MRU5HVEhfV0lUSF9DSEVDS1NVTSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIGFkZHJlc3Mgc2hvdWxkIGVpdGhlciBiZSBcXFwiLmNvbmNhdChBZGRyZXNzLkxFTkdUSCwgXFxcIiBvciBcXFwiKS5jb25jYXQoQWRkcmVzcy5MRU5HVEhfV0lUSF9DSEVDS1NVTSwgXFxcIiBjaGFyYWN0ZXJzIGluIGxlbmd0aFxcXCIpLCB7XFxuICAgICAgICAgIGxlbmd0aDogdHJ5dGVzU3RyaW5nLmxlbmd0aFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBhZGRyZXNzVHJ5dGVzID0gdHJ5dGVzU3RyaW5nLnN1YnN0cigwLCBBZGRyZXNzLkxFTkdUSCk7XFxuICAgICAgdmFyIGNoZWNrc3VtVHJ5dGVzO1xcblxcbiAgICAgIGlmICh0cnl0ZXNTdHJpbmcubGVuZ3RoID09PSBBZGRyZXNzLkxFTkdUSF9XSVRIX0NIRUNLU1VNKSB7XFxuICAgICAgICBjaGVja3N1bVRyeXRlcyA9IHRyeXRlc1N0cmluZy5zdWJzdHIoQWRkcmVzcy5MRU5HVEgpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbmV3IEFkZHJlc3MoYWRkcmVzc1RyeXRlcywgY2hlY2tzdW1Ucnl0ZXMpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gQWRkcmVzcztcXG59KCk7XFxuLyoqXFxyXFxuICogVGhlIGxlbmd0aCBmb3IgYSB2YWxpZCBhZGRyZXNzIHdpdGhvdXQgY2hlY2tzdW0gKDgxKS5cXHJcXG4gKi9cXG5cXG5cXG5BZGRyZXNzLkxFTkdUSCA9IDgxO1xcbi8qKlxcclxcbiAqIFRoZSBsZW5ndGggZm9yIGFuIGFkZHJlc3MgY2hlY2tzdW0gKDkpLlxcclxcbiAqL1xcblxcbkFkZHJlc3MuTEVOR1RIX0NIRUNLU1VNID0gOTtcXG4vKipcXHJcXG4gKiBUaGUgbGVuZ3RoIGZvciB2YWxpZCBhZGRyZXNzIHdpdGggY2hlY2tzdW0gKDkwKS5cXHJcXG4gKi9cXG5cXG5BZGRyZXNzLkxFTkdUSF9XSVRIX0NIRUNLU1VNID0gQWRkcmVzcy5MRU5HVEggKyBBZGRyZXNzLkxFTkdUSF9DSEVDS1NVTTtcXG5leHBvcnRzLkFkZHJlc3MgPSBBZGRyZXNzO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2FkZHJlc3MuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvYWRkcmVzc1NlY3VyaXR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2FkZHJlc3NTZWN1cml0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIFJlcHJlc2VudHMgYW4gZW51bSBmb3IgdGhlIGFkZHJlc3Mgc2VjdXJpdHkgdmFsdWVzLlxcclxcbiAqL1xcblxcbnZhciBBZGRyZXNzU2VjdXJpdHk7XFxuXFxuKGZ1bmN0aW9uIChBZGRyZXNzU2VjdXJpdHkpIHtcXG4gIEFkZHJlc3NTZWN1cml0eVtBZGRyZXNzU2VjdXJpdHlbXFxcImxvd1xcXCJdID0gMV0gPSBcXFwibG93XFxcIjtcXG4gIEFkZHJlc3NTZWN1cml0eVtBZGRyZXNzU2VjdXJpdHlbXFxcIm1lZGl1bVxcXCJdID0gMl0gPSBcXFwibWVkaXVtXFxcIjtcXG4gIEFkZHJlc3NTZWN1cml0eVtBZGRyZXNzU2VjdXJpdHlbXFxcImhpZ2hcXFwiXSA9IDNdID0gXFxcImhpZ2hcXFwiO1xcbn0pKEFkZHJlc3NTZWN1cml0eSA9IGV4cG9ydHMuQWRkcmVzc1NlY3VyaXR5IHx8IChleHBvcnRzLkFkZHJlc3NTZWN1cml0eSA9IHt9KSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvYWRkcmVzc1NlY3VyaXR5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2J1bmRsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9idW5kbGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgZGF0YUVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvci9kYXRhRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZXJyb3IvZGF0YUVycm9yLmpzXFxcIik7XFxuXFxudmFyIGhhc2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGFzaCAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2hhc2guanNcXFwiKTtcXG5cXG52YXIgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5qc1xcXCIpO1xcblxcbnZhciB0YWdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFnICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdGFnLmpzXFxcIik7XFxuXFxudmFyIHRyYW5zYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zYWN0aW9uICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb24uanNcXFwiKTtcXG5cXG52YXIgdHJ5dGVOdW1iZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJ5dGVOdW1iZXIgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cnl0ZU51bWJlci5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIGJ1bmRsZXMuXFxyXFxuICovXFxuXFxuXFxudmFyIEJ1bmRsZSA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qKlxcclxcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEJ1bmRsZS5cXHJcXG4gICAqL1xcbiAgZnVuY3Rpb24gQnVuZGxlKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVuZGxlKTtcXG5cXG4gICAgdGhpcy50cmFuc2FjdGlvbnMgPSBbXTtcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogQWRkIG5ldyB0cmFuc2FjdGlvbnMgdG8gdGhlIGJ1bmRsZS5cXHJcXG4gICAqIEBwYXJhbSBzaWduYXR1cmVNZXNzYWdlTGVuZ3RoIFRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIHRvIGFkZC5cXHJcXG4gICAqIEBwYXJhbSBhZGRyZXNzIFRoZSBhZGRyZXNzIGZvciB0aGUgdHJhbnNhY3Rpb25zLlxcclxcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBmb3IgdGhlIGZpcnN0IG9mIHRoZSB0cmFuc2FjdGlvbnMuXFxyXFxuICAgKiBAcGFyYW0gdGFnIFRoZSB0YWcgdG8gaW5jbHVkZSBpbiB0aGUgdHJhbnNhY3Rpb25zLlxcclxcbiAgICogQHBhcmFtIHRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIGZvciB0aGUgdHJhbnNhY3Rpb25zLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoQnVuZGxlLCBbe1xcbiAgICBrZXk6IFxcXCJhZGRUcmFuc2FjdGlvbnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkVHJhbnNhY3Rpb25zKHNpZ25hdHVyZU1lc3NhZ2VMZW5ndGgsIGFkZHJlc3MsIHZhbHVlLCB0YWcsIHRpbWVzdGFtcCkge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlTWVzc2FnZUxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9ucy5wdXNoKHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbVBhcmFtcyh1bmRlZmluZWQsIGFkZHJlc3MsIGkgPT09IDAgPyB2YWx1ZSA6IDAsIHRhZywgdGltZXN0YW1wLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGFnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEFkZCBzaWduYXR1cmUgZnJhZ21lbnRzIHRvIHRoZSBidW5kbGUuXFxyXFxuICAgICAqIEBwYXJhbSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzIFRoZSBzaWduYXR1cmUgZnJhZ21lbnRzIHRvIGFkZCB0byB0aGUgYnVuZGxlIHRyYW5zYWN0aW9ucy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFkZFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzKSB7XFxuICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudHMpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50cyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50c1xcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgPSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnRzW2ldIHx8IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5FTVBUWTtcXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLnRydW5rVHJhbnNhY3Rpb24gPSBoYXNoXzEuSGFzaC5FTVBUWTtcXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLmJyYW5jaFRyYW5zYWN0aW9uID0gaGFzaF8xLkhhc2guRU1QVFk7XFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS5hdHRhY2htZW50VGltZXN0YW1wID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85O1xcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbnNbaV0uYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzk7XFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uc1tpXS5hdHRhY2htZW50VGltZXN0YW1wVXBwZXJCb3VuZCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOTtcXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zW2ldLm5vbmNlID0gdGFnXzEuVGFnLkVNUFRZO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIEJ1bmRsZTtcXG59KCk7XFxuXFxuZXhwb3J0cy5CdW5kbGUgPSBCdW5kbGU7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvYnVuZGxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2hhc2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2hhc2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBvYmplY3RIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIGRhdGFFcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZXJyb3IvZGF0YUVycm9yICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2Vycm9yL2RhdGFFcnJvci5qc1xcXCIpO1xcblxcbnZhciB0cnl0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJ5dGVzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVzLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgaGFzaGVzLlxcclxcbiAqL1xcblxcblxcbnZhciBIYXNoID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgLyogQGludGVybmFsICovXFxuICBmdW5jdGlvbiBIYXNoKHRyeXRlcykge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGFzaCk7XFxuXFxuICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogQ3JlYXRlIGhhc2ggZnJvbSB0cnl0ZXMuXFxyXFxuICAgKiBAcGFyYW0gaGFzaCBUaGUgdHJ5dGVzIHRvIGNyZWF0ZSB0aGUgaGFzaCBmcm9tLlxcclxcbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgSGFzaC5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKEhhc2gsIFt7XFxuICAgIGtleTogXFxcInRvVHJ5dGVzXFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgdGhlIGhhc2ggdG8gdHJ5dGVzLlxcclxcbiAgICAgKiBAcmV0dXJucyBUcnl0ZXMgdmVyc2lvbiBvZiB0aGUgaGFzaC5cXHJcXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1RyeXRlcygpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBHZXQgdGhlIHN0cmluZyB2aWV3IG9mIHRoZSBvYmplY3QuXFxyXFxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9TdHJpbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcy50b1N0cmluZygpO1xcbiAgICB9XFxuICB9XSwgW3tcXG4gICAga2V5OiBcXFwiZnJvbVRyeXRlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tVHJ5dGVzKGhhc2gpIHtcXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoaGFzaCwgdHJ5dGVzXzEuVHJ5dGVzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIGhhc2ggc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbGVuZ3RoID0gaGFzaC5sZW5ndGgoKTtcXG5cXG4gICAgICBpZiAobGVuZ3RoICE9PSBIYXNoLkxFTkdUSCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIGhhc2ggc2hvdWxkIGJlIFxcXCIuY29uY2F0KEhhc2guTEVOR1RILCBcXFwiIGNoYXJhY3RlcnMgaW4gbGVuZ3RoXFxcIiksIHtcXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbmV3IEhhc2goaGFzaCk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBIYXNoO1xcbn0oKTtcXG4vKipcXHJcXG4gKiBUaGUgbGVuZ3RoIGZvciBhIHZhbGlkIGhhc2ggKDgxKS5cXHJcXG4gKi9cXG5cXG5cXG5IYXNoLkxFTkdUSCA9IDgxO1xcbi8qKlxcclxcbiAqIEFuIGVtcHR5IGhhc2ggYWxsIDlzLlxcclxcbiAqL1xcblxcbkhhc2guRU1QVFkgPSBIYXNoLmZyb21Ucnl0ZXModHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcoXFxcIjlcXFwiLnJlcGVhdChIYXNoLkxFTkdUSCkpKTtcXG5leHBvcnRzLkhhc2ggPSBIYXNoO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2hhc2guanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvaW5wdXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9pbnB1dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBudW1iZXJIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgZGF0YUVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvci9kYXRhRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZXJyb3IvZGF0YUVycm9yLmpzXFxcIik7XFxuXFxudmFyIGFkZHJlc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWRkcmVzcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2FkZHJlc3MuanNcXFwiKTtcXG5cXG52YXIgYWRkcmVzc1NlY3VyaXR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FkZHJlc3NTZWN1cml0eSAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2FkZHJlc3NTZWN1cml0eS5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIGlucHV0cy5cXHJcXG4gKi9cXG5cXG5cXG52YXIgSW5wdXQgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICAvKiBAaW50ZXJuYWwgKi9cXG4gIGZ1bmN0aW9uIElucHV0KCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5wdXQpO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgaW5wdXQgZnJvbSBwYXJhbWV0ZXJzLlxcclxcbiAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3MuXFxyXFxuICAgKiBAcGFyYW0gc2VjdXJpdHkgVGhlIGFkZHJlc3Mgc2VjdXJpdHkuXFxyXFxuICAgKiBAcGFyYW0ga2V5SW5kZXggVGhlIGtleSBpbmRleC5cXHJcXG4gICAqIEBwYXJhbSBiYWxhbmNlIFRoZSBiYWxhbmNlIG9mIHRoZSBhZGRyZXNzLlxcclxcbiAgICogQHJldHVybiBOZXcgaW5zdGFuY2Ugb2YgSW5wdXQuXFxyXFxuICAgKi9cXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhJbnB1dCwgbnVsbCwgW3tcXG4gICAga2V5OiBcXFwiZnJvbVBhcmFtc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUGFyYW1zKGFkZHJlc3MsIHNlY3VyaXR5LCBrZXlJbmRleCwgYmFsYW5jZSkge1xcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShhZGRyZXNzLCBhZGRyZXNzXzEuQWRkcmVzcykpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBhZGRyZXNzIHNob3VsZCBiZSBhIHZhbGlkIEFkZHJlc3Mgb2JqZWN0XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzZWN1cml0eSkgfHwgc2VjdXJpdHkgPCBhZGRyZXNzU2VjdXJpdHlfMS5BZGRyZXNzU2VjdXJpdHkubG93IHx8IHNlY3VyaXR5ID4gYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5LmhpZ2gpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBzZWN1cml0eSBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiBcXFwiLmNvbmNhdChhZGRyZXNzU2VjdXJpdHlfMS5BZGRyZXNzU2VjdXJpdHkubG93LCBcXFwiIGFuZCBcXFwiKS5jb25jYXQoYWRkcmVzc1NlY3VyaXR5XzEuQWRkcmVzc1NlY3VyaXR5LmhpZ2gpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGtleUluZGV4KSB8fCBrZXlJbmRleCA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBrZXlJbmRleCBzaG91bGQgYmUgYSBudW1iZXIgPj0gMFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIoYmFsYW5jZSkgfHwgYmFsYW5jZSA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBiYWxhbmNlIHNob3VsZCBiZSBhIG51bWJlciA+PSAwXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBpbnB1dCA9IG5ldyBJbnB1dCgpO1xcbiAgICAgIGlucHV0LmFkZHJlc3MgPSBhZGRyZXNzO1xcbiAgICAgIGlucHV0LnNlY3VyaXR5ID0gc2VjdXJpdHk7XFxuICAgICAgaW5wdXQua2V5SW5kZXggPSBrZXlJbmRleDtcXG4gICAgICBpbnB1dC5iYWxhbmNlID0gYmFsYW5jZTtcXG4gICAgICByZXR1cm4gaW5wdXQ7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBJbnB1dDtcXG59KCk7XFxuXFxuZXhwb3J0cy5JbnB1dCA9IElucHV0O1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2lucHV0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3NpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgZGF0YUVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvci9kYXRhRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZXJyb3IvZGF0YUVycm9yLmpzXFxcIik7XFxuXFxudmFyIHRyeXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cnl0ZXMgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cnl0ZXMuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyBzaWduYXR1cmUgbWVzc2FnZSBmcmFnbWVudHMuXFxyXFxuICovXFxuXFxuXFxudmFyIFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qIEBpbnRlcm5hbCAqL1xcbiAgZnVuY3Rpb24gU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KHRyeXRlcykge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50KTtcXG5cXG4gICAgdGhpcy5fdHJ5dGVzID0gdHJ5dGVzO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgc2lnbmF0dXJlIGZyYWdtZW50IGZyb20gdHJ5dGVzLlxcclxcbiAgICogQHBhcmFtIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCBUaGUgdHJ5dGVzIHRvIGNyZWF0ZSB0aGUgc2lnbmF0dXJlIGZyYWdtZW50IGZyb20uXFxyXFxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuXFxyXFxuICAgKi9cXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQsIFt7XFxuICAgIGtleTogXFxcInRvVHJ5dGVzXFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgdGhlIHNpZ25hdHVyZSBmcmFnbWVudCB0byB0cnl0ZXMuXFxyXFxuICAgICAqIEByZXR1cm5zIFRyeXRlcyB2ZXJzaW9uIG9mIHRoZSBzaWduYXR1cmUgZnJhZ21lbnQuXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Ucnl0ZXMoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3RyeXRlcztcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogR2V0IHRoZSBzdHJpbmcgdmlldyBvZiB0aGUgb2JqZWN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBzdHJpbmcgb2YgdGhlIHRyeXRlcy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRvU3RyaW5nXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl90cnl0ZXMudG9TdHJpbmcoKTtcXG4gICAgfVxcbiAgfV0sIFt7XFxuICAgIGtleTogXFxcImZyb21Ucnl0ZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVRyeXRlcyhzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpIHtcXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LCB0cnl0ZXNfMS5Ucnl0ZXMpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGxlbmd0aCA9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5sZW5ndGgoKTtcXG5cXG4gICAgICBpZiAobGVuZ3RoICE9PSBTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RIKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50IHNob3VsZCBiZSBcXFwiLmNvbmNhdChTaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuTEVOR1RILCBcXFwiIGNoYXJhY3RlcnMgaW4gbGVuZ3RoXFxcIiksIHtcXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudChzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQpO1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50O1xcbn0oKTtcXG4vKipcXHJcXG4gKiBUaGUgbGVuZ3RoIG9mIGEgdmFsaWQgc2lnbmF0dXJlIG1lc3NhZ2UgZnJhZ21lbnQgKDIxODcpXFxyXFxuICovXFxuXFxuXFxuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCA9IDIxODc7XFxuLyoqXFxyXFxuICogQW4gZW1wdHkgc2lnbmF0dXJlIG1lc3NhZ2UgZnJhZ21lbnQgYWxsIDlzLlxcclxcbiAqL1xcblxcblNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5FTVBUWSA9IFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5mcm9tVHJ5dGVzKHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKFxcXCI5XFxcIi5yZXBlYXQoU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCkpKTtcXG5leHBvcnRzLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCA9IFNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdGFnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RhZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBkYXRhRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2RhdGFFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanNcXFwiKTtcXG5cXG52YXIgdHJ5dGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyeXRlcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRhZ3MuXFxyXFxuICovXFxuXFxuXFxudmFyIFRhZyA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qIEBpbnRlcm5hbCAqL1xcbiAgZnVuY3Rpb24gVGFnKHRyeXRlcykge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGFnKTtcXG5cXG4gICAgdGhpcy5fdHJ5dGVzID0gdHJ5dGVzO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgdGFnIGZyb20gdHJ5dGVzLlxcclxcbiAgICogQHBhcmFtIHRhZyBUaGUgdHJ5dGVzIHRvIGNyZWF0ZSB0aGUgdGFnIGZyb20uXFxyXFxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUYWcuXFxyXFxuICAgKi9cXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhUYWcsIFt7XFxuICAgIGtleTogXFxcInRvVHJ5dGVzXFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgdGhlIHRhZyB0byB0cnl0ZXMuXFxyXFxuICAgICAqIEByZXR1cm5zIFRyeXRlcyB2ZXJzaW9uIG9mIHRoZSB0YWcuXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Ucnl0ZXMoKSB7XFxuICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRoaXMuX3RyeXRlcyk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cXHJcXG4gICAgICogQHJldHVybnMgc3RyaW5nIG9mIHRoZSB0cnl0ZXMuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b1N0cmluZ1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzO1xcbiAgICB9XFxuICB9XSwgW3tcXG4gICAga2V5OiBcXFwiZnJvbVRyeXRlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tVHJ5dGVzKHRhZykge1xcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0YWcsIHRyeXRlc18xLlRyeXRlcykpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSB0YWcgc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdHJ5dGVzU3RyaW5nID0gdGFnLnRvU3RyaW5nKCk7XFxuXFxuICAgICAgaWYgKHRyeXRlc1N0cmluZy5sZW5ndGggPiBUYWcuTEVOR1RIKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgdGFnIHNob3VsZCBiZSBhdCBtb3N0IFxcXCIuY29uY2F0KFRhZy5MRU5HVEgsIFxcXCIgY2hhcmFjdGVycyBpbiBsZW5ndGhcXFwiKSwge1xcbiAgICAgICAgICBsZW5ndGg6IHRyeXRlc1N0cmluZy5sZW5ndGhcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB3aGlsZSAodHJ5dGVzU3RyaW5nLmxlbmd0aCA8IFRhZy5MRU5HVEgpIHtcXG4gICAgICAgIHRyeXRlc1N0cmluZyArPSBcXFwiOVxcXCI7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBuZXcgVGFnKHRyeXRlc1N0cmluZyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBUYWc7XFxufSgpO1xcbi8qKlxcclxcbiAqIFRoZSBsZW5ndGggb2YgYSB2YWxpZCB0YWcgKDI3KS5cXHJcXG4gKi9cXG5cXG5cXG5UYWcuTEVOR1RIID0gMjc7XFxuLyoqXFxyXFxuICogQW4gZW1wdHkgdGFnIGFsbCA5cy5cXHJcXG4gKi9cXG5cXG5UYWcuRU1QVFkgPSBUYWcuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyhcXFwiOVxcXCIucmVwZWF0KFRhZy5MRU5HVEgpKSk7XFxuZXhwb3J0cy5UYWcgPSBUYWc7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdGFnLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyYW5zYWN0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBkYXRhRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2RhdGFFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanNcXFwiKTtcXG5cXG52YXIgYWRkcmVzc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hZGRyZXNzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvYWRkcmVzcy5qc1xcXCIpO1xcblxcbnZhciBoYXNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hhc2ggKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9oYXNoLmpzXFxcIik7XFxuXFxudmFyIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQuanNcXFwiKTtcXG5cXG52YXIgdGFnXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RhZyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RhZy5qc1xcXCIpO1xcblxcbnZhciB0cnl0ZU51bWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cnl0ZU51bWJlciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlTnVtYmVyLmpzXFxcIik7XFxuXFxudmFyIHRyeXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cnl0ZXMgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cnl0ZXMuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyB0cmFuc2FjdGlvbnMuXFxyXFxuICovXFxuXFxuXFxudmFyIFRyYW5zYWN0aW9uID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgLyogQGludGVybmFsICovXFxuICBmdW5jdGlvbiBUcmFuc2FjdGlvbigpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyYW5zYWN0aW9uKTtcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogQ3JlYXRlIGluc3RhbmNlIG9mIHRyYW5zYWN0aW9uIGZyb20gcGFyYW1ldGVycy5cXHJcXG4gICAqIEBwYXJhbSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgVGhlIHNpZ25hdHVyZSBtZXNzYWdlIGZyYWdtZW50LlxcclxcbiAgICogQHBhcmFtIGFkZHJlc3MgVGhlIGFkZHJlc3MuXFxyXFxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlLlxcclxcbiAgICogQHBhcmFtIG9ic29sZXRlVGFnIE9ic29sZXRlIHRyYW5zYWN0aW9uIHRhZy5cXHJcXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgVGhlIHRpbWVzdGFtcC5cXHJcXG4gICAqIEBwYXJhbSBjdXJyZW50SW5kZXggVGhlIGN1cnJlbnQgaW5kZXguXFxyXFxuICAgKiBAcGFyYW0gbGFzdEluZGV4IFRoZSBsYXN0IGluZGV4LlxcclxcbiAgICogQHBhcmFtIGJ1bmRsZSBUaGUgYnVuZGxlLlxcclxcbiAgICogQHBhcmFtIHRydW5rVHJhbnNhY3Rpb24gVGhlIHRydW5rIHRyYW5zYWN0aW9uLlxcclxcbiAgICogQHBhcmFtIGJyYW5jaFRyYW5zYWN0aW9uIFRoZSBicmFuY2ggdHJhbnNhY3Rpb24uXFxyXFxuICAgKiBAcGFyYW0gdGFnIFRoZSB0YWcuXFxyXFxuICAgKiBAcGFyYW0gYXR0YWNobWVudFRpbWVzdGFtcCBUaGUgYXR0YWNobWVudCB0aW1lc3RhbXAuXFxyXFxuICAgKiBAcGFyYW0gYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgVGhlIGF0dGFjaG1lbnQgdGltZXN0YW1wIGxvd2VyIGJvdW5kLlxcclxcbiAgICogQHBhcmFtIGF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kICBUaGUgYXR0YWNobWVudCB0aW1lc3RhbXAgdXBwZXIgYm91bmQuXFxyXFxuICAgKiBAcGFyYW0gbm9uY2UgVGhlIG5vbmNlLlxcclxcbiAgICogQHJldHVybiBOZXcgaW5zdGFuY2Ugb2YgdHJhbnNhY3Rpb24uXFxyXFxuICAgKi9cXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhUcmFuc2FjdGlvbiwgW3tcXG4gICAga2V5OiBcXFwidG9Ucnl0ZXNcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQ29udmVydCB0aGUgdHJhbnNhY3Rpb24gdG8gdHJ5dGVzLlxcclxcbiAgICAgKiBAcmV0dXJuIFRoZSB0cmFuc2FjdGlvbiBhcyB0cnl0ZXMuXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Ucnl0ZXMoKSB7XFxuICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRoaXMudG9TdHJpbmcoKSk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0aGUgc3RyaW5nIHZpZXcgb2YgdGhlIG9iamVjdC5cXHJcXG4gICAgICogQHJldHVybnMgc3RyaW5nIG9mIHRoZSB0cnl0ZXMuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b1N0cmluZ1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGhpcy5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQsIHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBzaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQgbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc1xcXCIsIHtcXG4gICAgICAgICAgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50OiB0aGlzLnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLmFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIGFkZHJlc3MgbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc1xcXCIsIHtcXG4gICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRoaXMub2Jzb2xldGVUYWcsIHRhZ18xLlRhZykpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBvYnNvbGV0ZVRhZyBtdXN0IGJlIHNldCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gdHJ5dGVzXFxcIiwge1xcbiAgICAgICAgICBvYnNvbGV0ZVRhZzogdGhpcy5vYnNvbGV0ZVRhZ1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLmJ1bmRsZSwgaGFzaF8xLkhhc2gpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgYnVuZGxlIG11c3QgYmUgc2V0IHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiB0cnl0ZXNcXFwiLCB7XFxuICAgICAgICAgIGJ1bmRsZTogdGhpcy5idW5kbGVcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodGhpcy50cnVua1RyYW5zYWN0aW9uLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSB0cnVua1RyYW5zYWN0aW9uIG11c3QgYmUgc2V0IHRvIGNyZWF0ZSB0cmFuc2FjdGlvbiB0cnl0ZXNcXFwiLCB7XFxuICAgICAgICAgIHRydW5rVHJhbnNhY3Rpb246IHRoaXMudHJ1bmtUcmFuc2FjdGlvblxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLmJyYW5jaFRyYW5zYWN0aW9uLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBicmFuY2hUcmFuc2FjdGlvbiBtdXN0IGJlIHNldCB0byBjcmVhdGUgdHJhbnNhY3Rpb24gdHJ5dGVzXFxcIiwge1xcbiAgICAgICAgICBicmFuY2hUcmFuc2FjdGlvbjogdGhpcy5icmFuY2hUcmFuc2FjdGlvblxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0aGlzLm5vbmNlLCB0YWdfMS5UYWcpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgbm9uY2UgbXVzdCBiZSBzZXQgdG8gY3JlYXRlIHRyYW5zYWN0aW9uIHRyeXRlc1xcXCIsIHtcXG4gICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2VcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgdHJ5dGVzID0gdGhpcy5zaWduYXR1cmVNZXNzYWdlRnJhZ21lbnQudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgdGhpcy5hZGRyZXNzLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSArICh0aGlzLnZhbHVlIHx8IFRyYW5zYWN0aW9uLkVNUFRZXzExKS50b1RyeXRlcygpLnRvU3RyaW5nKCkgKyBUcmFuc2FjdGlvbi5DSEVDS19WQUxVRSArIHRoaXMub2Jzb2xldGVUYWcudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgKHRoaXMudGltZXN0YW1wIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgKHRoaXMuY3VycmVudEluZGV4IHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgKHRoaXMubGFzdEluZGV4IHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgdGhpcy5idW5kbGUudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgdGhpcy50cnVua1RyYW5zYWN0aW9uLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSArIHRoaXMuYnJhbmNoVHJhbnNhY3Rpb24udG9Ucnl0ZXMoKS50b1N0cmluZygpICsgKHRoaXMudGFnIHx8IHRoaXMub2Jzb2xldGVUYWcpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSArICh0aGlzLmF0dGFjaG1lbnRUaW1lc3RhbXAgfHwgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5FTVBUWV85KS50b1RyeXRlcygpLnRvU3RyaW5nKCkgKyAodGhpcy5hdHRhY2htZW50VGltZXN0YW1wTG93ZXJCb3VuZCB8fCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkVNUFRZXzkpLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSArICh0aGlzLmF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kIHx8IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuRU1QVFlfOSkudG9Ucnl0ZXMoKS50b1N0cmluZygpICsgdGhpcy5ub25jZS50b1RyeXRlcygpLnRvU3RyaW5nKCk7XFxuICAgICAgdmFyIGxlbmd0aCA9IHRyeXRlcy5sZW5ndGg7XFxuXFxuICAgICAgaWYgKGxlbmd0aCAhPT0gVHJhbnNhY3Rpb24uTEVOR1RIKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgdHJ5dGVzIG11c3QgYmUgXFxcIi5jb25jYXQoVHJhbnNhY3Rpb24uTEVOR1RILCBcXFwiIGluIGxlbmd0aCBcXFwiKS5jb25jYXQobGVuZ3RoKSwge1xcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0cnl0ZXM7XFxuICAgIH1cXG4gIH1dLCBbe1xcbiAgICBrZXk6IFxcXCJmcm9tUGFyYW1zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21QYXJhbXMoc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LCBhZGRyZXNzLCB2YWx1ZSwgb2Jzb2xldGVUYWcsIHRpbWVzdGFtcCwgY3VycmVudEluZGV4LCBsYXN0SW5kZXgsIGJ1bmRsZSwgdHJ1bmtUcmFuc2FjdGlvbiwgYnJhbmNoVHJhbnNhY3Rpb24sIHRhZywgYXR0YWNobWVudFRpbWVzdGFtcCwgYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQsIGF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kLCBub25jZSkge1xcbiAgICAgIHZhciB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xcbiAgICAgIHR4LnNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudCA9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudDtcXG4gICAgICB0eC5hZGRyZXNzID0gYWRkcmVzcztcXG4gICAgICB0eC52YWx1ZSA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbU51bWJlcih2YWx1ZSwgMTEpO1xcbiAgICAgIHR4Lm9ic29sZXRlVGFnID0gb2Jzb2xldGVUYWc7XFxuICAgICAgdHgudGltZXN0YW1wID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKHRpbWVzdGFtcCk7XFxuICAgICAgdHguY3VycmVudEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKGN1cnJlbnRJbmRleCk7XFxuICAgICAgdHgubGFzdEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKGxhc3RJbmRleCk7XFxuICAgICAgdHguYnVuZGxlID0gYnVuZGxlO1xcbiAgICAgIHR4LnRydW5rVHJhbnNhY3Rpb24gPSB0cnVua1RyYW5zYWN0aW9uO1xcbiAgICAgIHR4LmJyYW5jaFRyYW5zYWN0aW9uID0gYnJhbmNoVHJhbnNhY3Rpb247XFxuICAgICAgdHgudGFnID0gdGFnO1xcbiAgICAgIHR4LmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoYXR0YWNobWVudFRpbWVzdGFtcCk7XFxuICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21OdW1iZXIoYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQpO1xcbiAgICAgIHR4LmF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKGF0dGFjaG1lbnRUaW1lc3RhbXBVcHBlckJvdW5kKTtcXG4gICAgICB0eC5ub25jZSA9IG5vbmNlO1xcbiAgICAgIHJldHVybiB0eDtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogQ3JlYXRlIGluc3RhbmNlIG9mIHRyYW5zYWN0aW9uIGZyb20gdHJ5dGVzLlxcclxcbiAgICAgKiBAcGFyYW0gdHJ5dGVzIFRoZSB0cnl0ZXMgZm9yIHRoZSB0aGlzLlxcclxcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGlzLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZnJvbVRyeXRlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tVHJ5dGVzKHRyeXRlcykge1xcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh0cnl0ZXMsIHRyeXRlc18xLlRyeXRlcykpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSB0cnl0ZXMgc2hvdWxkIGJlIGEgdmFsaWQgVHJ5dGVzIG9iamVjdFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbGVuZ3RoID0gdHJ5dGVzLmxlbmd0aCgpO1xcblxcbiAgICAgIGlmIChsZW5ndGggIT09IFRyYW5zYWN0aW9uLkxFTkdUSCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHRyeXRlcyBtdXN0IGJlIFxcXCIuY29uY2F0KFRyYW5zYWN0aW9uLkxFTkdUSCwgXFxcIiBpbiBsZW5ndGhcXFwiKSwge1xcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBjaGVja0luZGV4U3RhcnQgPSAyMjc5O1xcbiAgICAgIHZhciBjaGVja0luZGV4TGVuZ3RoID0gMTY7XFxuICAgICAgdmFyIGNoZWNrID0gdHJ5dGVzLnN1YihjaGVja0luZGV4U3RhcnQsIGNoZWNrSW5kZXhMZW5ndGgpLnRvU3RyaW5nKCk7XFxuXFxuICAgICAgaWYgKGNoZWNrICE9PSBUcmFuc2FjdGlvbi5DSEVDS19WQUxVRSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHRyeXRlcyBiZXR3ZWVuIFxcXCIuY29uY2F0KGNoZWNrSW5kZXhTdGFydCwgXFxcIiBhbmQgXFxcIikuY29uY2F0KGNoZWNrSW5kZXhTdGFydCArIGNoZWNrSW5kZXhMZW5ndGgsIFxcXCIgc2hvdWxkIGJlIGFsbCA5c1xcXCIpLCB7XFxuICAgICAgICAgIGNoZWNrOiBjaGVja1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xcbiAgICAgIHZhciBzdGFydFBvcyA9IDA7XFxuICAgICAgdHguc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ID0gc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50XzEuU2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LkxFTkdUSCkpO1xcbiAgICAgIHN0YXJ0UG9zICs9IHNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudF8xLlNpZ25hdHVyZU1lc3NhZ2VGcmFnbWVudC5MRU5HVEg7XFxuICAgICAgdHguYWRkcmVzcyA9IGFkZHJlc3NfMS5BZGRyZXNzLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgYWRkcmVzc18xLkFkZHJlc3MuTEVOR1RIKSk7XFxuICAgICAgc3RhcnRQb3MgKz0gYWRkcmVzc18xLkFkZHJlc3MuTEVOR1RIO1xcbiAgICAgIHR4LnZhbHVlID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIDExKSwgMTEpO1xcbiAgICAgIHN0YXJ0UG9zICs9IDExO1xcbiAgICAgIHN0YXJ0UG9zICs9IFRyYW5zYWN0aW9uLkNIRUNLX1ZBTFVFX0xFTkdUSDtcXG4gICAgICB0eC5vYnNvbGV0ZVRhZyA9IHRhZ18xLlRhZy5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRhZ18xLlRhZy5MRU5HVEgpKTtcXG4gICAgICBzdGFydFBvcyArPSB0YWdfMS5UYWcuTEVOR1RIO1xcbiAgICAgIHR4LnRpbWVzdGFtcCA9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85KSk7XFxuICAgICAgc3RhcnRQb3MgKz0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOTtcXG4gICAgICB0eC5jdXJyZW50SW5kZXggPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xcbiAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XFxuICAgICAgdHgubGFzdEluZGV4ID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzkpKTtcXG4gICAgICBzdGFydFBvcyArPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLkxFTkdUSF85O1xcbiAgICAgIHR4LmJ1bmRsZSA9IGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgaGFzaF8xLkhhc2guTEVOR1RIKSk7XFxuICAgICAgc3RhcnRQb3MgKz0gaGFzaF8xLkhhc2guTEVOR1RIO1xcbiAgICAgIHR4LnRydW5rVHJhbnNhY3Rpb24gPSBoYXNoXzEuSGFzaC5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIGhhc2hfMS5IYXNoLkxFTkdUSCkpO1xcbiAgICAgIHN0YXJ0UG9zICs9IGhhc2hfMS5IYXNoLkxFTkdUSDtcXG4gICAgICB0eC5icmFuY2hUcmFuc2FjdGlvbiA9IGhhc2hfMS5IYXNoLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgaGFzaF8xLkhhc2guTEVOR1RIKSk7XFxuICAgICAgc3RhcnRQb3MgKz0gaGFzaF8xLkhhc2guTEVOR1RIO1xcbiAgICAgIHR4LnRhZyA9IHRhZ18xLlRhZy5mcm9tVHJ5dGVzKHRyeXRlcy5zdWIoc3RhcnRQb3MsIHRhZ18xLlRhZy5MRU5HVEgpKTtcXG4gICAgICBzdGFydFBvcyArPSB0YWdfMS5UYWcuTEVOR1RIO1xcbiAgICAgIHR4LmF0dGFjaG1lbnRUaW1lc3RhbXAgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xcbiAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XFxuICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcExvd2VyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xcbiAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XFxuICAgICAgdHguYXR0YWNobWVudFRpbWVzdGFtcFVwcGVyQm91bmQgPSB0cnl0ZU51bWJlcl8xLlRyeXRlTnVtYmVyLmZyb21Ucnl0ZXModHJ5dGVzLnN1YihzdGFydFBvcywgdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5MRU5HVEhfOSkpO1xcbiAgICAgIHN0YXJ0UG9zICs9IHRyeXRlTnVtYmVyXzEuVHJ5dGVOdW1iZXIuTEVOR1RIXzk7XFxuICAgICAgdHgubm9uY2UgPSB0YWdfMS5UYWcuZnJvbVRyeXRlcyh0cnl0ZXMuc3ViKHN0YXJ0UG9zLCB0YWdfMS5UYWcuTEVOR1RIKSk7XFxuICAgICAgcmV0dXJuIHR4O1xcbiAgICB9XFxuICB9XSk7XFxuXFxuICByZXR1cm4gVHJhbnNhY3Rpb247XFxufSgpO1xcbi8qKlxcclxcbiAqIFRoZSBsZW5ndGggb2YgYSB2YWxpZCB0cmFuc2FjdGlvbiAoMjY3MykuXFxyXFxuICovXFxuXFxuXFxuVHJhbnNhY3Rpb24uTEVOR1RIID0gMjY3MztcXG4vKipcXHJcXG4gKiBUaGUgbGVuZ3RoIG9mIGEgdmFsaWQgY2hlY2sgdmFsdWUgKDE2KS5cXHJcXG4gKi9cXG5cXG5UcmFuc2FjdGlvbi5DSEVDS19WQUxVRV9MRU5HVEggPSAxNjtcXG4vKipcXHJcXG4gKiBUaGUgY2hlY2sgdmFsdWUgZm9yIGJ1bmRsZXMgYWxsIDlzLlxcclxcbiAqL1xcblxcblRyYW5zYWN0aW9uLkNIRUNLX1ZBTFVFID0gXFxcIjlcXFwiLnJlcGVhdChUcmFuc2FjdGlvbi5DSEVDS19WQUxVRV9MRU5HVEgpO1xcbi8qIEBpbnRlcm5hbCAqL1xcblxcblRyYW5zYWN0aW9uLkVNUFRZXzExID0gdHJ5dGVOdW1iZXJfMS5Ucnl0ZU51bWJlci5mcm9tTnVtYmVyKDAsIDExKTtcXG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJhbnNmZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cmFuc2Zlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBudW1iZXJIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgZGF0YUVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lcnJvci9kYXRhRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZXJyb3IvZGF0YUVycm9yLmpzXFxcIik7XFxuXFxudmFyIGFkZHJlc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWRkcmVzcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2FkZHJlc3MuanNcXFwiKTtcXG5cXG52YXIgdGFnXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RhZyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RhZy5qc1xcXCIpO1xcblxcbnZhciB0cnl0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJ5dGVzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVzLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgdHJhbnNmZXJzLlxcclxcbiAqL1xcblxcblxcbnZhciBUcmFuc2ZlciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qIEBpbnRlcm5hbCAqL1xcbiAgZnVuY3Rpb24gVHJhbnNmZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2Zlcik7XFxuICB9XFxuICAvKipcXHJcXG4gICAqIENyZWF0ZSBpbnN0YW5jZSBvZiB0cmFuc2ZlciBmcm9tIHBhcmFtZXRlcnMuXFxyXFxuICAgKiBAcGFyYW0gYWRkcmVzcyBUaGUgYWRkcmVzcy5cXHJcXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUuXFxyXFxuICAgKiBAcGFyYW0gbWVzc3NhZ2UgVGhlIG1lc3NhZ2UgZm9yIHRoZSB0cmFuc2Zlci5cXHJcXG4gICAqIEBwYXJhbSB0YWcgVGhlIHRhZy5cXHJcXG4gICAqIEByZXR1cm4gTmV3IGluc3RhbmNlIG9mIFRyYW5zZmVyLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoVHJhbnNmZXIsIG51bGwsIFt7XFxuICAgIGtleTogXFxcImZyb21QYXJhbXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVBhcmFtcyhhZGRyZXNzLCB2YWx1ZSwgbWVzc2FnZSwgdGFnKSB7XFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGFkZHJlc3MsIGFkZHJlc3NfMS5BZGRyZXNzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIGFkZHJlc3Mgc2hvdWxkIGJlIGEgdmFsaWQgQWRkcmVzcyBvYmplY3RcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSB2YWx1ZSBzaG91bGQgYmUgYSBudW1iZXIgPj0gMFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KG1lc3NhZ2UpICYmICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKG1lc3NhZ2UsIHRyeXRlc18xLlRyeXRlcykpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBtZXNzYWdlIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh0YWcpICYmICFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRhZywgdGFnXzEuVGFnKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHRhZyBzaG91bGQgYmUgYSB2YWxpZCBUYWcgb2JqZWN0XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0cmFuc2ZlciA9IG5ldyBUcmFuc2ZlcigpO1xcbiAgICAgIHRyYW5zZmVyLmFkZHJlc3MgPSBhZGRyZXNzO1xcbiAgICAgIHRyYW5zZmVyLnZhbHVlID0gdmFsdWU7XFxuICAgICAgdHJhbnNmZXIubWVzc2FnZSA9IG1lc3NhZ2U7XFxuICAgICAgdHJhbnNmZXIudGFnID0gdGFnO1xcbiAgICAgIHJldHVybiB0cmFuc2ZlcjtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFRyYW5zZmVyO1xcbn0oKTtcXG5cXG5leHBvcnRzLlRyYW5zZmVyID0gVHJhbnNmZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJhbnNmZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJpdHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cml0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBhcnJheUhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG51bWJlckhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBkYXRhRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2RhdGFFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanNcXFwiKTtcXG5cXG52YXIgdHJ5dGVzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyeXRlcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIEEgY2xhc3MgZm9yIGhhbmRsaW5nIHRyaXRzLlxcclxcbiAqL1xcblxcblxcbnZhciBUcml0cyA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qIEBpbnRlcm5hbCAqL1xcbiAgZnVuY3Rpb24gVHJpdHModHJpdHMpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaXRzKTtcXG5cXG4gICAgdGhpcy5fdHJpdHMgPSB0cml0cztcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogQ3JlYXRlIGluc3RhbmNlIG9mIHRyaXRzIGZyb20gSW50OEFycmF5IGFycmF5LlxcclxcbiAgICogQHBhcmFtIHZhbHVlIFRyeXRlcyB1c2VkIHRvIGNyZWF0ZSB0cml0cy5cXHJcXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyaXRzLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoVHJpdHMsIFt7XFxuICAgIGtleTogXFxcInRvQXJyYXlcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgdHJpdHMgYXJyYXkuXFxyXFxuICAgICAqIEByZXR1cm5zIEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cml0cy5cXHJcXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl90cml0cztcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgdHJpdHMgYXJyYXkgYXMgYSBudW1iZXIgYXJyYXkuXFxyXFxuICAgICAqIEByZXR1cm5zIEFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cml0cy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInRvTnVtYmVyQXJyYXlcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9OdW1iZXJBcnJheSgpIHtcXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl90cml0cyk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0aGUgdHJpdHMgYXMgdHJ5dGVzLlxcclxcbiAgICAgKiBAcmV0dXJucyBJbnN0YW5jZSBvZiBUcnl0ZXMuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b1RyeXRlc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1RyeXRlcygpIHtcXG4gICAgICB2YXIgdHJ5dGVzID0gXFxcIlxcXCI7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90cml0cy5sZW5ndGg7IGkgKz0gMykge1xcbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBwb3NzaWJsZSB0cnl0ZSB2YWx1ZXMgdG8gZmluZCBjb3JyZWN0IHRyaXQgcmVwcmVzZW50YXRpb25cXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdHJ5dGVzXzEuVHJ5dGVzLkFMUEhBQkVULmxlbmd0aDsgaisrKSB7XFxuICAgICAgICAgIGlmIChUcml0cy5UUllURVNfVFJJVFNbal1bMF0gPT09IHRoaXMuX3RyaXRzW2ldICYmIFRyaXRzLlRSWVRFU19UUklUU1tqXVsxXSA9PT0gdGhpcy5fdHJpdHNbaSArIDFdICYmIFRyaXRzLlRSWVRFU19UUklUU1tqXVsyXSA9PT0gdGhpcy5fdHJpdHNbaSArIDJdKSB7XFxuICAgICAgICAgICAgdHJ5dGVzICs9IHRyeXRlc18xLlRyeXRlcy5BTFBIQUJFVC5jaGFyQXQoaik7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyeXRlcyk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0aGUgdHJpdHMgYXMgYSBudW1iZXIuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSB0cml0cyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ0b051bWJlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b051bWJlcigpIHtcXG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSAwO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLl90cml0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgICAgcmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZSAqIDMgKyB0aGlzLl90cml0c1tpXTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBXaGF0IGlzIHRoZSBsZW5ndGggb2YgdGhlIHRyaXRzLlxcclxcbiAgICAgKiBAcmV0dXJucyBMZW5ndGggb2YgdGhlIHRyaXRzLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwibGVuZ3RoXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fdHJpdHMubGVuZ3RoO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBHZXQgYSBzdWIgb2YgdGhlIHRyaXRzLlxcclxcbiAgICAgKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uIHRvIGdldCB0aGUgc3ViLlxcclxcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSBsZW5ndGggb2YgdGhlIHN1Yi5cXHJcXG4gICAgICogQHJldHVybnMgVGhlIHRyaXRzIHN1Yi5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInN1YlxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdWIoc3RhcnQsIGxlbmd0aCkge1xcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihzdGFydCkgfHwgc3RhcnQgPCAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgc3RhcnQgbXVzdCBiZSBhIG51bWJlciA+PSAwXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IHN0YXJ0ICsgbGVuZ3RoID4gdGhpcy5fdHJpdHMubGVuZ3RoKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgc3RhcnQgKyBsZW5ndGggbXVzdCA8PSBcXFwiLmNvbmNhdCh0aGlzLl90cml0cy5sZW5ndGgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIFRyaXRzLmZyb21BcnJheSh0aGlzLl90cml0cy5zbGljZShzdGFydCwgc3RhcnQgKyBsZW5ndGgpKTtcXG4gICAgfVxcbiAgfV0sIFt7XFxuICAgIGtleTogXFxcImZyb21BcnJheVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkodmFsdWUpIHtcXG4gICAgICBpZiAoIW9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc1R5cGUodmFsdWUsIEludDhBcnJheSkpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSB2YWx1ZSBkb2VzIG5vdCBjb250YWluIHZhbGlkIHRyaXRzXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBuZXcgVHJpdHModmFsdWUpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2YgdHJpdHMgZnJvbSBudW1iZXIgYXJyYXkuXFxyXFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUcnl0ZXMgdXNlZCB0byBjcmVhdGUgdHJpdHMuXFxyXFxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyaXRzLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZnJvbU51bWJlckFycmF5XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21OdW1iZXJBcnJheSh2YWx1ZSkge1xcbiAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHZhbHVlLCBOdW1iZXIpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgdmFsdWUgZG9lcyBub3QgY29udGFpbiB2YWxpZCB0cml0c1xcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbmV3IFRyaXRzKG5ldyBJbnQ4QXJyYXkodmFsdWUpKTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogQ3JlYXRlIGluc3RhbmNlIG9mIHRyaXRzIGZyb20gdHJ5dGVzLlxcclxcbiAgICAgKiBAcGFyYW0gdmFsdWUgVHJ5dGVzIHVzZWQgdG8gY3JlYXRlIHRyaXRzLlxcclxcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcml0cy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZyb21Ucnl0ZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVRyeXRlcyh2YWx1ZSkge1xcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh2YWx1ZSwgdHJ5dGVzXzEuVHJ5dGVzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRyeXRlc1N0cmluZyA9IHZhbHVlLnRvU3RyaW5nKCk7XFxuICAgICAgdmFyIHRyaXRzID0gbmV3IEludDhBcnJheSh0cnl0ZXNTdHJpbmcubGVuZ3RoICogMyk7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cnl0ZXNTdHJpbmcubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBpZHggPSB0cnl0ZXNfMS5Ucnl0ZXMuQUxQSEFCRVQuaW5kZXhPZih0cnl0ZXNTdHJpbmcuY2hhckF0KGkpKTtcXG4gICAgICAgIHRyaXRzW2kgKiAzXSA9IFRyaXRzLlRSWVRFU19UUklUU1tpZHhdWzBdO1xcbiAgICAgICAgdHJpdHNbaSAqIDMgKyAxXSA9IFRyaXRzLlRSWVRFU19UUklUU1tpZHhdWzFdO1xcbiAgICAgICAgdHJpdHNbaSAqIDMgKyAyXSA9IFRyaXRzLlRSWVRFU19UUklUU1tpZHhdWzJdO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbmV3IFRyaXRzKHRyaXRzKTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogQ3JlYXRlIGluc3RhbmNlIG9mIHRyaXRzIGZyb20gbnVtYmVyXFxyXFxuICAgICAqIEBwYXJhbSB2YWx1ZSBOdW1iZXIgdXNlZCB0byBjcmVhdGUgdHJpdHMuXFxyXFxuICAgICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyaXRzLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZnJvbU51bWJlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHZhbHVlKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHZhbHVlIGlzIG5vdCBhbiBpbnRlZ2VyXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0cml0cyA9IFtdO1xcbiAgICAgIHZhciBhYnNvbHV0ZVZhbHVlID0gdmFsdWUgPCAwID8gLXZhbHVlIDogdmFsdWU7XFxuXFxuICAgICAgd2hpbGUgKGFic29sdXRlVmFsdWUgPiAwKSB7XFxuICAgICAgICB2YXIgcmVtYWluZGVyID0gYWJzb2x1dGVWYWx1ZSAlIDM7XFxuICAgICAgICBhYnNvbHV0ZVZhbHVlID0gTWF0aC5mbG9vcihhYnNvbHV0ZVZhbHVlIC8gMyk7XFxuXFxuICAgICAgICBpZiAocmVtYWluZGVyID4gMSkge1xcbiAgICAgICAgICByZW1haW5kZXIgPSAtMTtcXG4gICAgICAgICAgYWJzb2x1dGVWYWx1ZSsrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdHJpdHNbdHJpdHMubGVuZ3RoXSA9IHJlbWFpbmRlcjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHZhbHVlIDwgMCkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cml0cy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICB0cml0c1tpXSA9IC10cml0c1tpXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5ldyBUcml0cyhuZXcgSW50OEFycmF5KHRyaXRzKSk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEFkZCB0d28gdHJpdHMgdG9nZXRoZXIuXFxyXFxuICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgdHJpdC5cXHJcXG4gICAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIHRyaXQuXFxyXFxuICAgICAqIEByZXR1cm4gTmV3IHRyaXQgd2hpY2ggaXMgdGhlIGFkZGl0aW9uIG9mIHRoZSBhICsgYi5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFkZFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoZmlyc3QsIHNlY29uZCkge1xcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShmaXJzdCwgVHJpdHMpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgZmlyc3Qgc2hvdWxkIGJlIGEgdmFsaWQgVHJpdHMgb2JqZWN0XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZShzZWNvbmQsIFRyaXRzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHNlY29uZHMgc2hvdWxkIGJlIGEgdmFsaWQgVHJpdHMgb2JqZWN0XFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBvdXQgPSBuZXcgSW50OEFycmF5KE1hdGgubWF4KGZpcnN0Ll90cml0cy5sZW5ndGgsIHNlY29uZC5fdHJpdHMubGVuZ3RoKSk7XFxuICAgICAgdmFyIGNhcnJ5ID0gMDtcXG4gICAgICB2YXIgaUE7XFxuICAgICAgdmFyIGlCO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpQSA9IGkgPCBmaXJzdC5fdHJpdHMubGVuZ3RoID8gZmlyc3QuX3RyaXRzW2ldIDogMDtcXG4gICAgICAgIGlCID0gaSA8IHNlY29uZC5fdHJpdHMubGVuZ3RoID8gc2Vjb25kLl90cml0c1tpXSA6IDA7XFxuICAgICAgICB2YXIgZkEgPSBUcml0cy5mdWxsQWRkKGlBLCBpQiwgY2FycnkpO1xcbiAgICAgICAgb3V0W2ldID0gZkFbMF07XFxuICAgICAgICBjYXJyeSA9IGZBWzFdO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gVHJpdHMuZnJvbUFycmF5KG91dCk7XFxuICAgIH1cXG4gICAgLyogQGludGVybmFsICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZ1bGxBZGRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnVsbEFkZChhLCBiLCBjKSB7XFxuICAgICAgdmFyIHNBID0gVHJpdHMuc3VtKGEsIGIpO1xcbiAgICAgIHZhciBjQSA9IFRyaXRzLmNvbnMoYSwgYik7XFxuICAgICAgdmFyIGNCID0gVHJpdHMuY29ucyhzQSwgYyk7XFxuICAgICAgdmFyIGNPdXQgPSBUcml0cy5hbnkoY0EsIGNCKTtcXG4gICAgICB2YXIgc09VdCA9IFRyaXRzLnN1bShzQSwgYyk7XFxuICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoW3NPVXQsIGNPdXRdKTtcXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic3VtXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1bShhLCBiKSB7XFxuICAgICAgdmFyIHMgPSBhICsgYjtcXG5cXG4gICAgICBzd2l0Y2ggKHMpIHtcXG4gICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgcmV0dXJuIC0xO1xcblxcbiAgICAgICAgY2FzZSAtMjpcXG4gICAgICAgICAgcmV0dXJuIDE7XFxuXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gcztcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyogQGludGVybmFsICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImNvbnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ucyhhLCBiKSB7XFxuICAgICAgaWYgKGEgPT09IGIpIHtcXG4gICAgICAgIHJldHVybiBhO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gMDtcXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiYW55XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFueShhLCBiKSB7XFxuICAgICAgdmFyIHMgPSBhICsgYjtcXG5cXG4gICAgICBpZiAocyA+IDApIHtcXG4gICAgICAgIHJldHVybiAxO1xcbiAgICAgIH0gZWxzZSBpZiAocyA8IDApIHtcXG4gICAgICAgIHJldHVybiAtMTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBUcml0cztcXG59KCk7XFxuLyogQGludGVybmFsICovXFxuXFxuXFxuVHJpdHMuVFJZVEVTX1RSSVRTID0gW25ldyBJbnQ4QXJyYXkoWzAsIDAsIDBdKSwgbmV3IEludDhBcnJheShbMSwgMCwgMF0pLCBuZXcgSW50OEFycmF5KFstMSwgMSwgMF0pLCBuZXcgSW50OEFycmF5KFswLCAxLCAwXSksIG5ldyBJbnQ4QXJyYXkoWzEsIDEsIDBdKSwgbmV3IEludDhBcnJheShbLTEsIC0xLCAxXSksIG5ldyBJbnQ4QXJyYXkoWzAsIC0xLCAxXSksIG5ldyBJbnQ4QXJyYXkoWzEsIC0xLCAxXSksIG5ldyBJbnQ4QXJyYXkoWy0xLCAwLCAxXSksIG5ldyBJbnQ4QXJyYXkoWzAsIDAsIDFdKSwgbmV3IEludDhBcnJheShbMSwgMCwgMV0pLCBuZXcgSW50OEFycmF5KFstMSwgMSwgMV0pLCBuZXcgSW50OEFycmF5KFswLCAxLCAxXSksIG5ldyBJbnQ4QXJyYXkoWzEsIDEsIDFdKSwgbmV3IEludDhBcnJheShbLTEsIC0xLCAtMV0pLCBuZXcgSW50OEFycmF5KFswLCAtMSwgLTFdKSwgbmV3IEludDhBcnJheShbMSwgLTEsIC0xXSksIG5ldyBJbnQ4QXJyYXkoWy0xLCAwLCAtMV0pLCBuZXcgSW50OEFycmF5KFswLCAwLCAtMV0pLCBuZXcgSW50OEFycmF5KFsxLCAwLCAtMV0pLCBuZXcgSW50OEFycmF5KFstMSwgMSwgLTFdKSwgbmV3IEludDhBcnJheShbMCwgMSwgLTFdKSwgbmV3IEludDhBcnJheShbMSwgMSwgLTFdKSwgbmV3IEludDhBcnJheShbLTEsIC0xLCAwXSksIG5ldyBJbnQ4QXJyYXkoWzAsIC0xLCAwXSksIG5ldyBJbnQ4QXJyYXkoWzEsIC0xLCAwXSksIG5ldyBJbnQ4QXJyYXkoWy0xLCAwLCAwXSldO1xcbmV4cG9ydHMuVHJpdHMgPSBUcml0cztcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cml0cy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cnl0ZU51bWJlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlTnVtYmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIG51bWJlckhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBkYXRhRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2RhdGFFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanNcXFwiKTtcXG5cXG52YXIgdHJpdHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJpdHMgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cml0cy5qc1xcXCIpO1xcblxcbnZhciB0cnl0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJ5dGVzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVzLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQSBjbGFzcyBmb3IgaGFuZGxpbmcgdHJ5dGUgbnVtYmVyLlxcclxcbiAqL1xcblxcblxcbnZhciBUcnl0ZU51bWJlciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qIEBpbnRlcm5hbCAqL1xcbiAgZnVuY3Rpb24gVHJ5dGVOdW1iZXIodHJ5dGVzKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcnl0ZU51bWJlcik7XFxuXFxuICAgIHRoaXMuX3RyeXRlcyA9IHRyeXRlcztcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogQ3JlYXRlIHRyeXRlIG51bWJlciBmcm9tIG51bWJlci5cXHJcXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgbnVtYmVyIHZhbHVlIHRvIGNyZWF0ZSB0aGUgb2JqZWN0IGZyb20uXFxyXFxuICAgKiBAcGFyYW0gbGVuZ3RoIFRoZSB0cnl0ZSBsZW5ndGggdG8gcGFkIHRoZSBudW1iZXIgd2l0aC5cXHJcXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyeXRlTnVtYmVyLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoVHJ5dGVOdW1iZXIsIFt7XFxuICAgIGtleTogXFxcInRvVHJ5dGVzXFxcIixcXG5cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgdGhlIHRyeXRlIG51bWJlciB0byB0cnl0ZXMuXFxyXFxuICAgICAqIEByZXR1cm5zIFRyeXRlcyB2ZXJzaW9uIG9mIHRoZSB0cnl0ZSBudW1iZXIuXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9Ucnl0ZXMoKSB7XFxuICAgICAgcmV0dXJuIHRyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRoaXMuX3RyeXRlcyk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIENvbnZlcnQgdGhlIHRyeXRlIG51bWJlciB0byBudW1iZXIuXFxyXFxuICAgICAqIEByZXR1cm5zIG51bWJlciB2YWx1ZSBvZiB0aGUgdHJ5dGUgbnVtYmVyLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9OdW1iZXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9OdW1iZXIoKSB7XFxuICAgICAgcmV0dXJuIHRyaXRzXzEuVHJpdHMuZnJvbVRyeXRlcyh0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0aGlzLl90cnl0ZXMpKS50b051bWJlcigpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBHZXQgdGhlIHN0cmluZyB2aWV3IG9mIHRoZSBvYmplY3QuXFxyXFxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidG9TdHJpbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMudG9OdW1iZXIoKS50b1N0cmluZygpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBvYmplY3QuXFxyXFxuICAgICAqIEByZXR1cm5zIHN0cmluZyBvZiB0aGUgdHJ5dGVzLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwidmFsdWVPZlxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnRvTnVtYmVyKCk7XFxuICAgIH1cXG4gIH1dLCBbe1xcbiAgICBrZXk6IFxcXCJmcm9tTnVtYmVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcXG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBUcnl0ZU51bWJlci5MRU5HVEhfOTtcXG4gICAgICB2YXIgdHJ5dGVzO1xcblxcbiAgICAgIGlmICghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihsZW5ndGgpIHx8IGxlbmd0aCA8PSAwKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgbGVuZ3RoIHNob3VsZCBiZSBhIG51bWJlciA+IDBcXFwiLCB7XFxuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KHZhbHVlKSkge1xcbiAgICAgICAgdHJ5dGVzID0gXFxcIjlcXFwiLnJlcGVhdChsZW5ndGgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIodmFsdWUpKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSB2YWx1ZSBpcyBub3QgYW4gaW50ZWdlclxcXCIsIHtcXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgdHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21OdW1iZXIodmFsdWUpLnRvTnVtYmVyQXJyYXkoKTtcXG5cXG4gICAgICAgIHdoaWxlICh0cml0cy5sZW5ndGggPCBsZW5ndGggKiAzKSB7XFxuICAgICAgICAgIHRyaXRzLnB1c2goMCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0cnl0ZXMgPSB0cml0c18xLlRyaXRzLmZyb21OdW1iZXJBcnJheSh0cml0cykudG9Ucnl0ZXMoKS50b1N0cmluZygpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbmV3IFRyeXRlTnVtYmVyKHRyeXRlcyk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIENyZWF0ZSB0cnl0ZSBudW1iZXIgZnJvbSB0cnl0ZXMuXFxyXFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgbnVtYmVyIHZhbHVlIHRvIGNyZWF0ZSB0aGUgb2JqZWN0IGZyb20uXFxyXFxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIHRyeXRlIGxlbmd0aCB0byBwYWQgdGhlIG51bWJlciB3aXRoLlxcclxcbiAgICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBUcnl0ZU51bWJlci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZyb21Ucnl0ZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVRyeXRlcyh2YWx1ZSkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFRyeXRlTnVtYmVyLkxFTkdUSF85O1xcblxcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzVHlwZSh2YWx1ZSwgdHJ5dGVzXzEuVHJ5dGVzKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHZhbHVlIHNob3VsZCBiZSBhIHZhbGlkIFRyeXRlcyBvYmplY3RcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRyeXRlU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcXG5cXG4gICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobGVuZ3RoKSB8fCBsZW5ndGggPD0gMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIGxlbmd0aCBzaG91bGQgYmUgYSBudW1iZXIgPiAwXFxcIiwge1xcbiAgICAgICAgICBsZW5ndGg6IGxlbmd0aFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0cnl0ZVN0cmluZy5sZW5ndGggPiBsZW5ndGgpIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSB2YWx1ZSBjb250YWlucyB0b28gbWFueSBjaGFyYWN0ZXJzXFxcIiwge1xcbiAgICAgICAgICBsZW5ndGg6IHRyeXRlU3RyaW5nLmxlbmd0aFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHdoaWxlICh0cnl0ZVN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcXG4gICAgICAgIHRyeXRlU3RyaW5nICs9IFxcXCI5XFxcIjtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5ldyBUcnl0ZU51bWJlcih0cnl0ZVN0cmluZyk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBUcnl0ZU51bWJlcjtcXG59KCk7XFxuLyoqXFxyXFxuICogTGVuZ3RoIG9mIGEgbnVtYmVyIHRoYXQgdXNlcyA5IHRyeXRlcy5cXHJcXG4gKi9cXG5cXG5cXG5Ucnl0ZU51bWJlci5MRU5HVEhfOSA9IDk7XFxuLyoqXFxyXFxuICogQW4gZW1ucHR5IDkgbGVuZ3RoIHRyeXRlIG51bWJlci5cXHJcXG4gKi9cXG5cXG5Ucnl0ZU51bWJlci5FTVBUWV85ID0gVHJ5dGVOdW1iZXIuZnJvbU51bWJlcigwLCBUcnl0ZU51bWJlci5MRU5HVEhfOSk7XFxuZXhwb3J0cy5Ucnl0ZU51bWJlciA9IFRyeXRlTnVtYmVyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlTnVtYmVyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cnl0ZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIG51bWJlckhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgc3RyaW5nSGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL3N0cmluZ0hlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL3N0cmluZ0hlbHBlci5qc1xcXCIpO1xcblxcbnZhciBkYXRhRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2Vycm9yL2RhdGFFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBBIGNsYXNzIGZvciBoYW5kbGluZyB0cnl0ZXMuXFxyXFxuICovXFxuXFxuXFxudmFyIFRyeXRlcyA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qIEBpbnRlcm5hbCAqL1xcbiAgZnVuY3Rpb24gVHJ5dGVzKHRyeXRlcykge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJ5dGVzKTtcXG5cXG4gICAgdGhpcy5fdHJ5dGVzID0gdHJ5dGVzO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgdHJ5dGVzIGZyb20gYSBzdHJpbmcuXFxyXFxuICAgKiBAcGFyYW0gdmFsdWUgQSBzdHJpbmcgdG8gY3JlYXRlIHRoZSB0cnl0ZXMgZnJvbS5cXHJcXG4gICAqIEBwYXJhbSBsZW5ndGggQW4gb3B0aW9uYWwgdmFsaWRhdGlvbiBsZW5ndGggZm9yIHRoZSB0cnl0ZXMsIDAgbWVhbnMgaWdub3JlIGxlbmd0aC5cXHJcXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIFRyeXRlcy5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKFRyeXRlcywgW3tcXG4gICAga2V5OiBcXFwidG9TdHJpbmdcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQ29udmVydCB0aGUgdHJ5dGVzIHRvIGEgc3RyaW5nLlxcclxcbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyeXRlcy5cXHJcXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fdHJ5dGVzO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgdHJ5dGVzLlxcclxcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVuZ3RoIG9mIHRoZSB0cnl0ZXMuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJsZW5ndGhcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGVuZ3RoKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl90cnl0ZXMubGVuZ3RoO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBHZXQgYSBzdWIgb2YgdGhlIHRyeXRlcy5cXHJcXG4gICAgICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbiB0byBnZXQgdGhlIHN1Yi5cXHJcXG4gICAgICogQHBhcmFtIGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBzdWIuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgc3ViLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic3ViXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YihzdGFydCwgbGVuZ3RoKSB7XFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHN0YXJ0KSB8fCBzdGFydCA8IDApIHtcXG4gICAgICAgIHRocm93IG5ldyBkYXRhRXJyb3JfMS5EYXRhRXJyb3IoXFxcIlRoZSBzdGFydCBtdXN0IGJlIGEgbnVtYmVyID49IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgc3RhcnQgKyBsZW5ndGggPiB0aGlzLl90cnl0ZXMubGVuZ3RoKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgc3RhcnQgKyBsZW5ndGggbXVzdCA8PSBcXFwiLmNvbmNhdCh0aGlzLl90cnl0ZXMubGVuZ3RoKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBUcnl0ZXMuZnJvbVN0cmluZyh0aGlzLl90cnl0ZXMuc3Vic3RyKHN0YXJ0LCBsZW5ndGgpKTtcXG4gICAgfVxcbiAgfV0sIFt7XFxuICAgIGtleTogXFxcImZyb21TdHJpbmdcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XFxuXFxuICAgICAgaWYgKCFzdHJpbmdIZWxwZXJfMS5TdHJpbmdIZWxwZXIuaXNTdHJpbmcodmFsdWUpKSB7XFxuICAgICAgICB0aHJvdyBuZXcgZGF0YUVycm9yXzEuRGF0YUVycm9yKFxcXCJUaGUgdmFsdWUgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmdcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKGxlbmd0aCkgfHwgbGVuZ3RoIDwgMCkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIGxlbmd0aCBtdXN0IGJlID49IDBcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFUcnl0ZXMuaXNWYWxpZCh2YWx1ZSwgbGVuZ3RoKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGRhdGFFcnJvcl8xLkRhdGFFcnJvcihcXFwiVGhlIHZhbHVlIGFuZCBsZW5ndGggZG8gbm90IGNvbnRhaW4gdmFsaWQgdHJ5dGVzXFxcIiwge1xcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXFxuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG5ldyBUcnl0ZXModmFsdWUpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBEb2VzIHRoZSB2YWx1ZSBjb250YWluIHZhbGlkIHRyeXRlcy5cXHJcXG4gICAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHRvIHZhbGlkYXRlIGFzIHRyeXRlcy5cXHJcXG4gICAgICogQHBhcmFtIGxlbmd0aCBBbiBvcHRpb25hbCB2YWxpZGF0aW9uIGxlbmd0aCBmb3IgdGhlIHRyeXRlcywgMCBtZWFucyBpZ25vcmUgbGVuZ3RoLlxcclxcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBpbnB1dCB3YXMgdmFsaWQgdHJ5dGVzLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiaXNWYWxpZFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbGlkKHZhbHVlKSB7XFxuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcXG5cXG4gICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc1N0cmluZyh2YWx1ZSkpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXFxcIl5bOUEtWl17XFxcIi5jb25jYXQobGVuZ3RoID8gbGVuZ3RoIDogXFxcIjAsXFxcIiwgXFxcIn0kXFxcIikpLnRlc3QodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFRyeXRlcztcXG59KCk7XFxuLyoqXFxyXFxuICogQWxsIHRoZSBjaGFyYWN0ZXJzIHRoYXQgY2FuIGJlIHVzZWQgaW4gdHJ5dGVzLlxcclxcbiAqL1xcblxcblxcblRyeXRlcy5BTFBIQUJFVCA9IFxcXCI5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcXFwiO1xcbmV4cG9ydHMuVHJ5dGVzID0gVHJ5dGVzO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZXJyb3IvZGF0YUVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZXJyb3IvZGF0YUVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcXFwib2JqZWN0XFxcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXFxcImZ1bmN0aW9uXFxcIikpIHsgcmV0dXJuIGNhbGw7IH0gaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgY29yZUVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvZXJyb3IvY29yZUVycm9yLmpzXFxcIik7XFxuLyoqXFxyXFxuICogQSBkYXRhIGltcGxlbWVudGF0aW9uIG9mIGFuIGVycm9yLlxcclxcbiAqL1xcblxcblxcbnZhciBEYXRhRXJyb3IgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoX2NvcmVFcnJvcl8xJENvcmVFcnJvKSB7XFxuICBfaW5oZXJpdHMoRGF0YUVycm9yLCBfY29yZUVycm9yXzEkQ29yZUVycm8pO1xcblxcbiAgZnVuY3Rpb24gRGF0YUVycm9yKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YUVycm9yKTtcXG5cXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEYXRhRXJyb3IuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEYXRhRXJyb3IpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcXG4gIH1cXG5cXG4gIHJldHVybiBEYXRhRXJyb3I7XFxufShjb3JlRXJyb3JfMS5Db3JlRXJyb3IpO1xcblxcbmV4cG9ydHMuRGF0YUVycm9yID0gRGF0YUVycm9yO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLWRhdGEvZGlzdC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfX2V4cG9ydChtKSB7XFxuICBmb3IgKHZhciBwIGluIG0pIHtcXG4gICAgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcXG4gIH1cXG59XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG4vKipcXHJcXG4gKiBDb21iaW5lZCBpbmRleCBvZiBhbGwgdGhlIG1vZHVsZXMuXFxyXFxuICovXFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb252ZXJ0ZXJzL2FzY2lpVHJ5dGVzQ29udmVydGVyICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2NvbnZlcnRlcnMvYXNjaWlUcnl0ZXNDb252ZXJ0ZXIuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb252ZXJ0ZXJzL29iamVjdFRyeXRlc0NvbnZlcnRlciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9jb252ZXJ0ZXJzL29iamVjdFRyeXRlc0NvbnZlcnRlci5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RhdGEvYWRkcmVzcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2FkZHJlc3MuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kYXRhL2FkZHJlc3NTZWN1cml0eSAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL2FkZHJlc3NTZWN1cml0eS5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RhdGEvYnVuZGxlICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvYnVuZGxlLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGF0YS9oYXNoICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvaGFzaC5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RhdGEvaW5wdXQgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS9pbnB1dC5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50ICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvc2lnbmF0dXJlTWVzc2FnZUZyYWdtZW50LmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGF0YS90YWcgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90YWcuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kYXRhL3RyYW5zYWN0aW9uICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJhbnNhY3Rpb24uanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kYXRhL3RyYW5zZmVyICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJhbnNmZXIuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kYXRhL3RyaXRzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJpdHMuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kYXRhL3RyeXRlTnVtYmVyICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVOdW1iZXIuanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kYXRhL3RyeXRlcyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyeXRlcy5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Vycm9yL2RhdGFFcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9lcnJvci9kYXRhRXJyb3IuanNcXFwiKSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tZGF0YS9kaXN0L2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBhbC1icm93c2VyL2Rpc3QvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBhbC1icm93c2VyL2Rpc3QvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcXG4gIGZvciAodmFyIHAgaW4gbSkge1xcbiAgICBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xcbiAgfVxcbn1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIENvbWJpbmVkIGluZGV4IG9mIGFsbCB0aGUgbW9kdWxlcy5cXHJcXG4gKi9cXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhbCAqLyBcXFwiLi4vaW90YS1waWNvLXBhbC1icm93c2VyL2Rpc3QvcGFsLmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbmV0d29yay9uZXR3b3JrQ2xpZW50ICovIFxcXCIuLi9pb3RhLXBpY28tcGFsLWJyb3dzZXIvZGlzdC9uZXR3b3JrL25ldHdvcmtDbGllbnQuanNcXFwiKSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcGFsLWJyb3dzZXIvZGlzdC9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9kaXN0L25ldHdvcmsvbmV0d29ya0NsaWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBhbC1icm93c2VyL2Rpc3QvbmV0d29yay9uZXR3b3JrQ2xpZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvciAqLyBcXFwiLi4vaW90YS1waWNvLXBhbC1icm93c2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IHN0ZXAoXFxcIm5leHRcXFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBzdGVwKFxcXCJ0aHJvd1xcXCIsIGVycik7IH0gX25leHQoKTsgfSk7IH07IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgY29yZUVycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9lcnJvci9jb3JlRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvZXJyb3IvY29yZUVycm9yLmpzXFxcIik7XFxuXFxudmFyIG51bWJlckhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBzdHJpbmdIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvc3RyaW5nSGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvc3RyaW5nSGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG51bGxMb2dnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2xvZ2dlcnMvbnVsbExvZ2dlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9sb2dnZXJzL251bGxMb2dnZXIuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBhIG5vZGUgY2xpZW50IGZvciB1c2UgaW4gdGhlIGJyb3dzZXIuXFxyXFxuICovXFxuXFxuXFxudmFyIE5ldHdvcmtDbGllbnQgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICAvKipcXHJcXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBOZXR3b3JrQ2xpZW50LlxcclxcbiAgICogQHBhcmFtIG5ldHdvcmtFbmRQb2ludCBUaGUgZW5kcG9pbnQgdG8gdXNlIGZvciB0aGUgY2xpZW50LlxcclxcbiAgICogQHBhcmFtIGxvZ2dlciBMb2dnZXIgdG8gc2VuZCBjb21tdW5pY2F0aW9uIGluZm8gdG8uXFxyXFxuICAgKiBAcGFyYW0gdGltZW91dE1zIFRoZSB0aW1lb3V0IGluIG1zIGJlZm9yZSBhYm9ydGluZy5cXHJcXG4gICAqL1xcbiAgZnVuY3Rpb24gTmV0d29ya0NsaWVudChuZXR3b3JrRW5kUG9pbnQsIGxvZ2dlcikge1xcbiAgICB2YXIgdGltZW91dE1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xcblxcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmV0d29ya0NsaWVudCk7XFxuXFxuICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShuZXR3b3JrRW5kUG9pbnQpKSB7XFxuICAgICAgdGhyb3cgbmV3IGNvcmVFcnJvcl8xLkNvcmVFcnJvcihcXFwiVGhlIG5ldHdvcmtFbmRQb2ludCBtdXN0IGJlIGRlZmluZWRcXFwiKTtcXG4gICAgfVxcblxcbiAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIodGltZW91dE1zKSB8fCB0aW1lb3V0TXMgPCAwKSB7XFxuICAgICAgdGhyb3cgbmV3IGNvcmVFcnJvcl8xLkNvcmVFcnJvcihcXFwiVGhlIHRpbWVvdXRNcyBtdXN0IGJlID49IDBcXFwiKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9uZXR3b3JrRW5kUG9pbnQgPSBuZXR3b3JrRW5kUG9pbnQ7XFxuICAgIHRoaXMuX3RpbWVvdXRNcyA9IHRpbWVvdXRNcztcXG4gICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyIHx8IG5ldyBudWxsTG9nZ2VyXzEuTnVsbExvZ2dlcigpO1xcblxcbiAgICB0aGlzLl9sb2dnZXIuYmFubmVyKFxcXCJOZXR3b3JrIENsaWVudFxcXCIsIHtcXG4gICAgICBlbmRQb2ludDogdGhpcy5fbmV0d29ya0VuZFBvaW50XFxuICAgIH0pO1xcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBHZXQgZGF0YSBhc3luY2hyb25vdXNseS5cXHJcXG4gICAqIEBwYXJhbSBhZGRpdGlvbmFsUGF0aCBBbiBhZGRpdGlvbmFsIHBhdGggYXBwZW5kIHRvIHRoZSBlbmRwb2ludCBwYXRoLlxcclxcbiAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXJzIEV4dHJhIGhlYWRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0LlxcclxcbiAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgb2JqZWN0IHJldHVybmVkIG9yIHJlamVjdHMgd2l0aCBlcnJvci5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKE5ldHdvcmtDbGllbnQsIFt7XFxuICAgIGtleTogXFxcImdldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9nZXQgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoYWRkaXRpb25hbFBhdGgsIGFkZGl0aW9uYWxIZWFkZXJzKSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCB0aGlzLmRvUmVxdWVzdChcXFwiR0VUXFxcIiwgdW5kZWZpbmVkLCBhZGRpdGlvbmFsUGF0aCwgYWRkaXRpb25hbEhlYWRlcnMpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldChfeCwgX3gyKSB7XFxuICAgICAgICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogUG9zdCBkYXRhIGFzeW5jaHJvbm91c2x5LlxcclxcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbFBhdGggQW4gYWRkaXRpb25hbCBwYXRoIGFwcGVuZCB0byB0aGUgZW5kcG9pbnQgcGF0aC5cXHJcXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gc2VuZC5cXHJcXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXJzIEV4dHJhIGhlYWRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBvYmplY3QgcmV0dXJuZWQgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicG9zdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9wb3N0ID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihkYXRhLCBhZGRpdGlvbmFsUGF0aCwgYWRkaXRpb25hbEhlYWRlcnMpIHtcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5kb1JlcXVlc3QoXFxcIlBPU1RcXFwiLCBkYXRhLCBhZGRpdGlvbmFsUGF0aCwgYWRkaXRpb25hbEhlYWRlcnMpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcG9zdChfeDMsIF94NCwgX3g1KSB7XFxuICAgICAgICByZXR1cm4gX3Bvc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCBkYXRhIGFzIEpTT04gYXN5bmNocm9ub3VzbHkuXFxyXFxuICAgICAqIEB0eXBlcGFyYW0gVSBUaGUgZ2VuZXJpYyB0eXBlIGZvciB0aGUgcmV0dXJuZWQgb2JqZWN0LlxcclxcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbFBhdGggQW4gYWRkaXRpb25hbCBwYXRoIGFwcGVuZCB0byB0aGUgZW5kcG9pbnQgcGF0aC5cXHJcXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXJzIEV4dHJhIGhlYWRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBvYmplY3QgcmV0dXJuZWQgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0SnNvblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9nZXRKc29uID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhhZGRpdGlvbmFsUGF0aCwgYWRkaXRpb25hbEhlYWRlcnMpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMuZG9SZXF1ZXN0KFxcXCJHRVRcXFwiLCB1bmRlZmluZWQsIGFkZGl0aW9uYWxQYXRoLCBhZGRpdGlvbmFsSGVhZGVycykudGhlbihmdW5jdGlvbiAocmVzcG9uc2VEYXRhKSB7XFxuICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2VEYXRhKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcXG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlRXJyb3JfMS5Db3JlRXJyb3IoXFxcIkZhaWxlZCBHRVQgcmVxdWVzdCwgdW5hYmxlIHRvIHBhcnNlIHJlc3BvbnNlXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgICAgICBlbmRQb2ludDogX3RoaXMuX25ldHdvcmtFbmRQb2ludC5nZXRVcmkoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YVxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGdldEpzb24oX3g2LCBfeDcpIHtcXG4gICAgICAgIHJldHVybiBfZ2V0SnNvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogUG9zdCBkYXRhIGFzIEpTT04gYXN5bmNocm9ub3VzbHkuXFxyXFxuICAgICAqIEB0eXBlcGFyYW0gVCBUaGUgZ2VuZXJpYyB0eXBlIGZvciB0aGUgb2JqZWN0IHRvIHNlbmQuXFxyXFxuICAgICAqIEB0eXBlcGFyYW0gVSBUaGUgZ2VuZXJpYyB0eXBlIGZvciB0aGUgcmV0dXJuZWQgb2JqZWN0LlxcclxcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBzZW5kLlxcclxcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbFBhdGggQW4gYWRkaXRpb25hbCBwYXRoIGFwcGVuZCB0byB0aGUgZW5kcG9pbnQgcGF0aC5cXHJcXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWxIZWFkZXJzIEV4dHJhIGhlYWRlcnMgdG8gc2VuZCB3aXRoIHRoZSByZXF1ZXN0LlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBvYmplY3QgcmV0dXJuZWQgb3IgcmVqZWN0cyB3aXRoIGVycm9yLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicG9zdEpzb25cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfcG9zdEpzb24gPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGRhdGEsIGFkZGl0aW9uYWxQYXRoLCBhZGRpdGlvbmFsSGVhZGVycykge1xcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgICB2YXIgaGVhZGVycztcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBoZWFkZXJzID0gYWRkaXRpb25hbEhlYWRlcnMgfHwge307XFxuICAgICAgICAgICAgICAgIGhlYWRlcnNbXFxcIkNvbnRlbnQtVHlwZVxcXCJdID0gXFxcImFwcGxpY2F0aW9uL2pzb25cXFwiO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5kb1JlcXVlc3QoXFxcIlBPU1RcXFwiLCBKU09OLnN0cmluZ2lmeShkYXRhKSwgYWRkaXRpb25hbFBhdGgsIGhlYWRlcnMpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSkge1xcbiAgICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlRGF0YSk7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XFxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZUVycm9yXzEuQ29yZUVycm9yKFxcXCJGYWlsZWQgUE9TVCByZXF1ZXN0LCB1bmFibGUgdG8gcGFyc2UgcmVzcG9uc2VcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgICAgIGVuZFBvaW50OiBfdGhpczIuX25ldHdvcmtFbmRQb2ludC5nZXRVcmkoKSxcXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YVxcbiAgICAgICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDM6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBvc3RKc29uKF94OCwgX3g5LCBfeDEwKSB7XFxuICAgICAgICByZXR1cm4gX3Bvc3RKc29uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJkb1JlcXVlc3RcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfZG9SZXF1ZXN0ID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNShtZXRob2QsIGRhdGEsIGFkZGl0aW9uYWxQYXRoLCBhZGRpdGlvbmFsSGVhZGVycykge1xcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXFxcInJldHVyblxcXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IGFkZGl0aW9uYWxIZWFkZXJzIHx8IHt9O1xcblxcbiAgICAgICAgICAgICAgICAgIHZhciB1cmkgPSBfdGhpczMuX25ldHdvcmtFbmRQb2ludC5nZXRVcmkoKTtcXG5cXG4gICAgICAgICAgICAgICAgICBpZiAoIXN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KGFkZGl0aW9uYWxQYXRoKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmlwcGVkID0gXFxcIi9cXFwiLmNvbmNhdChhZGRpdGlvbmFsUGF0aC5yZXBsYWNlKC9eXFxcXC8qLywgXFxcIlxcXCIpKTtcXG4gICAgICAgICAgICAgICAgICAgIHVyaSArPSBzdHJpcHBlZDtcXG4gICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xcblxcbiAgICAgICAgICAgICAgICAgIGlmIChfdGhpczMuX3RpbWVvdXRNcyA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgIHJlcS50aW1lb3V0ID0gX3RoaXMzLl90aW1lb3V0TXM7XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIHJlcS5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgICBfdGhpczMuX2xvZ2dlci5lcnJvcihcXFwiPD09PSBUaW1lZCBPdXRcXFwiKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgY29yZUVycm9yXzEuQ29yZUVycm9yKFxcXCJGYWlsZWQgXFxcIi5jb25jYXQobWV0aG9kLCBcXFwiIHJlcXVlc3QsIHRpbWVkIG91dFxcXCIpLCB7XFxuICAgICAgICAgICAgICAgICAgICAgIGVuZFBvaW50OiB1cmksXFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yUmVzcG9uc2VDb2RlOiByZXEuc3RhdHVzLFxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlOiByZXEucmVzcG9uc2VUZXh0IHx8IHJlcS5zdGF0dXNUZXh0XFxuICAgICAgICAgICAgICAgICAgICB9KSk7XFxuICAgICAgICAgICAgICAgICAgfTtcXG5cXG4gICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICAgICAgICAgICAgICAgIF90aGlzMy5fbG9nZ2VyLmVycm9yKFxcXCI8PT09IEVycm9yZWRcXFwiKTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgY29yZUVycm9yXzEuQ29yZUVycm9yKFxcXCJGYWlsZWQgXFxcIi5jb25jYXQobWV0aG9kLCBcXFwiIHJlcXVlc3RcXFwiKSwge1xcbiAgICAgICAgICAgICAgICAgICAgICBlbmRQb2ludDogdXJpLFxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlQ29kZTogcmVxLnN0YXR1cyxcXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXNwb25zZTogcmVxLnJlc3BvbnNlVGV4dCB8fCByZXEuc3RhdHVzVGV4dFxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xcbiAgICAgICAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgICAgICAgcmVxLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLl9sb2dnZXIuaW5mbyhcXFwiPD09PSBSZWNlaXZlZFxcXCIsIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXEucmVzcG9uc2VUZXh0XFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXNwb25zZVRleHQpO1xcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMzLl9sb2dnZXIuaW5mbyhcXFwiPD09PSBSZWNlaXZlZCBGYWlsXFxcIiwge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IHJlcS5zdGF0dXMsXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVxLnJlc3BvbnNlVGV4dFxcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBjb3JlRXJyb3JfMS5Db3JlRXJyb3IoXFxcIkZhaWxlZCBcXFwiLmNvbmNhdChtZXRob2QsIFxcXCIgcmVxdWVzdFxcXCIpLCB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9pbnQ6IHVyaSxcXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlQ29kZTogcmVxLnN0YXR1cyxcXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3BvbnNlOiByZXEucmVzcG9uc2VUZXh0IHx8IHJlcS5zdGF0dXNUZXh0XFxuICAgICAgICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICB9O1xcblxcbiAgICAgICAgICAgICAgICAgIHJlcS5vcGVuKG1ldGhvZCwgdXJpLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGVhZGVycykge1xcbiAgICAgICAgICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICBfdGhpczMuX2xvZ2dlci5pbmZvKFxcXCI9PT0+IFNlbmRcXFwiLCB7XFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXFxuICAgICAgICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgICAgICAgcmVxLnNlbmQoZGF0YSk7XFxuICAgICAgICAgICAgICAgIH0pKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gZG9SZXF1ZXN0KF94MTEsIF94MTIsIF94MTMsIF94MTQpIHtcXG4gICAgICAgIHJldHVybiBfZG9SZXF1ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICB9XSk7XFxuXFxuICByZXR1cm4gTmV0d29ya0NsaWVudDtcXG59KCk7XFxuXFxuZXhwb3J0cy5OZXR3b3JrQ2xpZW50ID0gTmV0d29ya0NsaWVudDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9kaXN0L25ldHdvcmsvbmV0d29ya0NsaWVudC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9kaXN0L3BhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBhbC1icm93c2VyL2Rpc3QvcGFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvciAqLyBcXFwiLi4vaW90YS1waWNvLXBhbC1icm93c2VyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IHN0ZXAoXFxcIm5leHRcXFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBzdGVwKFxcXCJ0aHJvd1xcXCIsIGVycik7IH0gX25leHQoKTsgfSk7IH07IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgbmV0d29ya0NsaWVudEZhY3RvcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2ZhY3Rvcmllcy9uZXR3b3JrQ2xpZW50RmFjdG9yeSAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9mYWN0b3JpZXMvbmV0d29ya0NsaWVudEZhY3RvcnkuanNcXFwiKTtcXG5cXG52YXIgbmV0d29ya0NsaWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9uZXR3b3JrL25ldHdvcmtDbGllbnQgKi8gXFxcIi4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9kaXN0L25ldHdvcmsvbmV0d29ya0NsaWVudC5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIFBsYXRmb3JtIGFic3RyYWN0aW9uIGxheWVyIGZvciBCcm93c2VyLlxcclxcbiAqL1xcblxcblxcbnZhciBQQUwgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBQQUwoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQQUwpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFBBTCwgbnVsbCwgW3tcXG4gICAga2V5OiBcXFwiaW5pdGlhbGl6ZVxcXCIsXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBQZXJmb3JtIGFueSBpbml0aWFsaXphdGlvbiBmb3IgdGhlIFBBTC5cXHJcXG4gICAgICovXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9pbml0aWFsaXplID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKCFQQUwuX2lzSW5pdGlhbGl6ZWQpIHtcXG4gICAgICAgICAgICAgICAgICBQQUwuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICAgIG5ldHdvcmtDbGllbnRGYWN0b3J5XzEuTmV0d29ya0NsaWVudEZhY3RvcnkuaW5zdGFuY2UoKS5yZWdpc3RlcihcXFwiZGVmYXVsdFxcXCIsIGZ1bmN0aW9uIChuZXR3b3JrRW5kcG9pbnQpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbmV0d29ya0NsaWVudF8xLk5ldHdvcmtDbGllbnQobmV0d29ya0VuZHBvaW50KTtcXG4gICAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBQcm9taXNlLnJlc29sdmUoKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xcbiAgICAgICAgcmV0dXJuIF9pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICB9XSk7XFxuXFxuICByZXR1cm4gUEFMO1xcbn0oKTtcXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5cXG5QQUwuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcXG5leHBvcnRzLlBBTCA9IFBBTDtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9kaXN0L3BhbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcGFsLWJyb3dzZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAqLyBcXFwiLi4vaW90YS1waWNvLXBhbC1icm93c2VyL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXFxcIik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcGFsLWJyb3dzZXIvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBhbC1icm93c2VyL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcGFsLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCIvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKi9cXG5cXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcXFwicmV0dXJuIHRoaXNcXFwiKSgpO1xcblxcbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXFxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFxcXCJyZWdlbmVyYXRvclJ1bnRpbWVcXFwiKSA+PSAwO1xcblxcbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuXFxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxcbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xcblxcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ydW50aW1lICovIFxcXCIuLi9pb3RhLXBpY28tcGFsLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xcXCIpO1xcblxcbmlmIChoYWRSdW50aW1lKSB7XFxuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxcbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xcbn0gZWxzZSB7XFxuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxcbiAgdHJ5IHtcXG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xcbiAgfSBjYXRjaChlKSB7XFxuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xcbiAgfVxcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCIvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKi9cXG5cXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcXG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcXG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxcbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiID8gU3ltYm9sIDoge307XFxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFxcXCJAQGl0ZXJhdG9yXFxcIjtcXG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFxcXCJAQGFzeW5jSXRlcmF0b3JcXFwiO1xcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcXFwiQEB0b1N0cmluZ1RhZ1xcXCI7XFxuXFxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcXFwib2JqZWN0XFxcIjtcXG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcXG4gIGlmIChydW50aW1lKSB7XFxuICAgIGlmIChpbk1vZHVsZSkge1xcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcXG4gICAgfVxcbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXFxuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXFxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXFxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcXG5cXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcXG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXFxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcXG5cXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXFxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcXG5cXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcXG4gIH1cXG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XFxuXFxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXFxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXFxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXFxuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXFxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXFxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4geyB0eXBlOiBcXFwibm9ybWFsXFxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICByZXR1cm4geyB0eXBlOiBcXFwidGhyb3dcXFwiLCBhcmc6IGVyciB9O1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFxcXCJzdXNwZW5kZWRTdGFydFxcXCI7XFxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFxcXCJzdXNwZW5kZWRZaWVsZFxcXCI7XFxuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcXFwiZXhlY3V0aW5nXFxcIjtcXG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFxcXCJjb21wbGV0ZWRcXFwiO1xcblxcbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcXG5cXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXFxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XFxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XFxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XFxuXFxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxcbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XFxuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG5cXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcXG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcXG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcXG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xcbiAgfVxcblxcbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cXG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcXG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XFxuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCI7XFxuXFxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcXG4gICAgW1xcXCJuZXh0XFxcIiwgXFxcInRocm93XFxcIiwgXFxcInJldHVyblxcXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XFxuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XFxuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XFxuICAgIHJldHVybiBjdG9yXFxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxcbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxcbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIlxcbiAgICAgIDogZmFsc2U7XFxuICB9O1xcblxcbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XFxuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcXG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcXG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XFxuICAgIHJldHVybiBnZW5GdW47XFxuICB9O1xcblxcbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXFxuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcXFwiX19hd2FpdFxcXCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXFxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XFxuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XFxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XFxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xcbiAgICAgICAgaWYgKHZhbHVlICYmXFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcXFwib2JqZWN0XFxcIiAmJlxcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcXFwiX19hd2FpdFxcXCIpKSB7XFxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgICAgICAgIGludm9rZShcXFwibmV4dFxcXCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcXG4gICAgICAgICAgICBpbnZva2UoXFxcInRocm93XFxcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XFxuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXFxuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXFxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXFxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XFxuICAgICAgICB9LCByZWplY3QpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xcblxcbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XFxuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cXG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcXG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXFxuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XFxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXFxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXFxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xcbiAgICB9XFxuXFxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxcbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xcbiAgfVxcblxcbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcXG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xcblxcbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXFxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXFxuICAgICk7XFxuXFxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxcbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XFxuICAgICAgICB9KTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcXG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcXG5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1xcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XFxuICAgICAgICBpZiAobWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgIHRocm93IGFyZztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XFxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXFxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcXG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcXG5cXG4gICAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcXG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcXG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XFxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcIm5leHRcXFwiKSB7XFxuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxcbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XFxuXFxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XFxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XFxuXFxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgY29udGV4dC5hcmcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcXG5cXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcIm5vcm1hbFxcXCIpIHtcXG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxcbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXFxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXFxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcXG5cXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxcbiAgICAgICAgICB9O1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXFxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXFxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcXG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcXG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XFxuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG5cXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcXG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXFxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInJldHVyblxcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcXG5cXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cXG4gICAgICAgICAgICAvLyBcXFwicmV0dXJuXFxcIiB0byBcXFwidGhyb3dcXFwiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxcbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXFxuICAgICAgICAgIFxcXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XFxuXFxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xcblxcbiAgICBpZiAoISBpbmZvKSB7XFxuICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcXFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcXFwiKTtcXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICBpZiAoaW5mby5kb25lKSB7XFxuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcXG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxcbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xcblxcbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xcblxcbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcXFwidGhyb3dcXFwiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXFxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFxcXCJuZXh0XFxcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXFxuICAgICAgLy8gXFxcImNvbnN1bWVkXFxcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xcbiAgICAgIC8vIFxcXCJyZXR1cm5cXFwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFxcXCJyZXR1cm5cXFwiKSB7XFxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG5cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXFxuICAgICAgcmV0dXJuIGluZm87XFxuICAgIH1cXG5cXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgfVxcblxcbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XFxuXFxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcXFwiR2VuZXJhdG9yXFxcIjtcXG5cXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXFxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXFxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcblxcbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIFxcXCJbb2JqZWN0IEdlbmVyYXRvcl1cXFwiO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XFxuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XFxuXFxuICAgIGlmICgxIGluIGxvY3MpIHtcXG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XFxuICAgIH1cXG5cXG4gICAgaWYgKDIgaW4gbG9jcykge1xcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcXG4gICAgfVxcblxcbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XFxuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xcbiAgICByZWNvcmQudHlwZSA9IFxcXCJub3JtYWxcXFwiO1xcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcXG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcXG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFxcXCJyb290XFxcIiB9XTtcXG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xcbiAgfVxcblxcbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgIHZhciBrZXlzID0gW107XFxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcXG4gICAgICBrZXlzLnB1c2goa2V5KTtcXG4gICAgfVxcbiAgICBrZXlzLnJldmVyc2UoKTtcXG5cXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XFxuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcXG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XFxuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XFxuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xcbiAgICAgICAgICByZXR1cm4gbmV4dDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXFxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xcbiAgICAgIHJldHVybiBuZXh0O1xcbiAgICB9O1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xcbiAgICBpZiAoaXRlcmFibGUpIHtcXG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XFxuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XFxuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcXG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XFxuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XFxuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xcbiAgfVxcbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XFxuXFxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XFxuICB9XFxuXFxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcXG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXFxuXFxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XFxuICAgICAgdGhpcy5wcmV2ID0gMDtcXG4gICAgICB0aGlzLm5leHQgPSAwO1xcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXFxuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xcblxcbiAgICAgIHRoaXMubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xcblxcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xcblxcbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XFxuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XFxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXFxcInRcXFwiICYmXFxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XFxuXFxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcXG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xcbiAgICB9LFxcblxcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XFxuICAgICAgaWYgKHRoaXMuZG9uZSkge1xcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XFxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XFxuICAgICAgICByZWNvcmQudHlwZSA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xcblxcbiAgICAgICAgaWYgKGNhdWdodCkge1xcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcXG5cXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFxcXCJyb290XFxcIikge1xcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcXFwiZW5kXFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXFxcImNhdGNoTG9jXFxcIik7XFxuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFxcXCJmaW5hbGx5TG9jXFxcIik7XFxuXFxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXFxcImZpbmFsbHlMb2NcXFwiKSAmJlxcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxcbiAgICAgICAgICAodHlwZSA9PT0gXFxcImJyZWFrXFxcIiB8fFxcbiAgICAgICAgICAgdHlwZSA9PT0gXFxcImNvbnRpbnVlXFxcIikgJiZcXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXFxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXFxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcXG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XFxuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcXG5cXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XFxuICAgICAgICB0aGlzLm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XFxuICAgIH0sXFxuXFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XFxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJicmVha1xcXCIgfHxcXG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFxcXCJjb250aW51ZVxcXCIpIHtcXG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XFxuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICAgIHRoaXMubWV0aG9kID0gXFxcInJldHVyblxcXCI7XFxuICAgICAgICB0aGlzLm5leHQgPSBcXFwiZW5kXFxcIjtcXG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcXFwibm9ybWFsXFxcIiAmJiBhZnRlckxvYykge1xcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9LFxcblxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcXG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XFxuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgXFxcImNhdGNoXFxcIjogZnVuY3Rpb24odHJ5TG9jKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XFxuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcXG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcXFwiKTtcXG4gICAgfSxcXG5cXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcXG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcXFwibmV4dFxcXCIpIHtcXG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXFxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG4gIH07XFxufSkoXFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xcbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxcbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcXFwicmV0dXJuIHRoaXNcXFwiKSgpXFxuKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy1ib3gvZGlzdC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctYm94L2Rpc3QvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX19leHBvcnQobSkge1xcbiAgZm9yICh2YXIgcCBpbiBtKSB7XFxuICAgIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XFxuICB9XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogQ29tYmluZWQgaW5kZXggb2YgYWxsIHRoZSBtb2R1bGVzLlxcclxcbiAqL1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcHJvb2ZPZldvcmtCb3ggKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctYm94L2Rpc3QvcHJvb2ZPZldvcmtCb3guanNcXFwiKSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LWJveC9kaXN0L2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy1ib3gvZGlzdC9wcm9vZk9mV29ya0JveC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctYm94L2Rpc3QvcHJvb2ZPZldvcmtCb3guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvciAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy1ib3gvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIHN0ZXAoa2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH0gZnVuY3Rpb24gX25leHQodmFsdWUpIHsgc3RlcChcXFwibmV4dFxcXCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IHN0ZXAoXFxcInRocm93XFxcIiwgZXJyKTsgfSBfbmV4dCgpOyB9KTsgfTsgfVxcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBhcnJheUhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG51bWJlckhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9udW1iZXJIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBzdHJpbmdIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvc3RyaW5nSGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvc3RyaW5nSGVscGVyLmpzXFxcIik7XFxuXFxudmFyIGNyeXB0b0Vycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3IuanNcXFwiKTtcXG5cXG52YXIgaGFzaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS9oYXNoICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvaGFzaC5qc1xcXCIpO1xcblxcbnZhciB0cnl0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVzLmpzXFxcIik7XFxuLyoqXFxyXFxuICogUHJvb2ZPZldvcmsgaW1wbGVtZW50YXRpb24gdXNpbmcgUmVtb3RlIFBvd0JveC5cXHJcXG4gKi9cXG5cXG5cXG52YXIgUHJvb2ZPZldvcmtCb3ggPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICAvKipcXHJcXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBQcm9vZk9mV29yay5cXHJcXG4gICAqIEBwYXJhbSBuZXR3b3JrQ2xpZW50IFRoZSBuZXR3b3JrIGNsaWVudCB0byBjb21tdW5pY2F0ZSB0aHJvdWdoLlxcclxcbiAgICogQHBhcmFtIGFwaUtleSBUaGUgQVBJIGtleSB0byBhY2Nlc3MgdGhlIHBvdyBib3guXFxyXFxuICAgKi9cXG4gIGZ1bmN0aW9uIFByb29mT2ZXb3JrQm94KG5ldHdvcmtDbGllbnQsIGFwaUtleSkge1xcbiAgICB2YXIgcG9sbEludGVydmFsTXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDEwMDA7XFxuXFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9vZk9mV29ya0JveCk7XFxuXFxuICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShuZXR3b3JrQ2xpZW50KSkge1xcbiAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJUaGUgbmV0d29ya0NsaWVudCBtdXN0IGJlIGRlZmluZWRcXFwiKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3RyaW5nSGVscGVyXzEuU3RyaW5nSGVscGVyLmlzRW1wdHkoYXBpS2V5KSkge1xcbiAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJUaGUgYXBpS2V5IG11c3Qgbm90IGJlIGVtcHR5XFxcIik7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKHBvbGxJbnRlcnZhbE1zKSB8fCBwb2xsSW50ZXJ2YWxNcyA8PSAwKSB7XFxuICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBwb2xsSW50ZXJ2YWxNcyBtdXN0IGJlID4gMFxcXCIpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX25ldHdvcmtDbGllbnQgPSBuZXR3b3JrQ2xpZW50O1xcbiAgICB0aGlzLl9hcGlLZXkgPSBhcGlLZXk7XFxuICAgIHRoaXMuX3BvbGxJbnRlcnZhbE1zID0gcG9sbEludGVydmFsTXM7XFxuICB9XFxuICAvKipcXHJcXG4gICAqIEFsbG93IHRoZSBwcm9vZiBvZiB3b3JrIHRvIHBlcmZvcm0gYW55IGluaXRpYWxpemF0aW9uLlxcclxcbiAgICogV2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIGltcGxlbWVudGF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuXFxyXFxuICAgKi9cXG5cXG5cXG4gIF9jcmVhdGVDbGFzcyhQcm9vZk9mV29ya0JveCwgW3tcXG4gICAga2V5OiBcXFwiaW5pdGlhbGl6ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9pbml0aWFsaXplID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgUHJvbWlzZS5yZXNvbHZlKCkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcXG4gICAgICAgIHJldHVybiBfaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgICAvKipcXHJcXG4gICAgICogUGVyZm9ybXMgc2luZ2xlIGNvbnZlcnNpb24gcGVyIHBvdyBjYWxsLlxcclxcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHBvdyBvbmx5IGRvZXMgb25lIGNvbnZlcnNpb24uXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwZXJmb3Jtc1NpbmdsZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJmb3Jtc1NpbmdsZSgpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIFBlcmZvcm0gYSBwcm9vZiBvZiB3b3JrIG9uIHRoZSBkYXRhLlxcclxcbiAgICAgKiBAcGFyYW0gdHJ1bmtUcmFuc2FjdGlvbiBUaGUgdHJ1bmtUcmFuc2FjdGlvbiB0byB1c2UgZm9yIHRoZSBwb3cuXFxyXFxuICAgICAqIEBwYXJhbSBicmFuY2hUcmFuc2FjdGlvbiBUaGUgYnJhbmNoVHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcG93LlxcclxcbiAgICAgKiBAcGFyYW0gdHJ5dGVzIFRoZSB0cnl0ZXMgdG8gcGVyZm9ybSB0aGUgcG93IG9uLlxcclxcbiAgICAgKiBAcGFyYW0gbWluV2VpZ2h0TWFnbml0dWRlIFRoZSBtaW5pbXVtIHdlaWdodCBtYWduaXR1ZGUuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgcHJvZHVjZWQgYnkgdGhlIHByb29mIG9mIHdvcmsuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwb3dcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfcG93ID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMih0cnVua1RyYW5zYWN0aW9uLCBicmFuY2hUcmFuc2FjdGlvbiwgdHJ5dGVzLCBtaW5XZWlnaHRNYWduaXR1ZGUpIHtcXG4gICAgICAgIHZhciBhdHRhY2hUb1RhbmdsZVJlcXVlc3QsIGFkZGl0aW9uYWxIZWFkZXJzLCBhdHRhY2hUb1RhbmdsZVJlc3BvbnNlO1xcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKHRydW5rVHJhbnNhY3Rpb24sIGhhc2hfMS5IYXNoKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIHRydW5rVHJhbnNhY3Rpb24gbXVzdCBiZSBhbiBvYmplY3Qgb2YgdHlwZSBIYXNoXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNUeXBlKGJyYW5jaFRyYW5zYWN0aW9uLCBoYXNoXzEuSGFzaCkpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBicmFuY2hUcmFuc2FjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCBvZiB0eXBlIEhhc2hcXFwiKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgNDpcXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZCh0cnl0ZXMsIHRyeXRlc18xLlRyeXRlcykpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSB0cnl0ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyeXRlc1xcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA2OlxcbiAgICAgICAgICAgICAgICBpZiAoISghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihtaW5XZWlnaHRNYWduaXR1ZGUpIHx8IG1pbldlaWdodE1hZ25pdHVkZSA8PSAwKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIG1pbldlaWdodE1hZ25pdHVkZSBtdXN0IGJlID4gMFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA4OlxcbiAgICAgICAgICAgICAgICBhdHRhY2hUb1RhbmdsZVJlcXVlc3QgPSB7XFxuICAgICAgICAgICAgICAgICAgY29tbWFuZDogXFxcImF0dGFjaFRvVGFuZ2xlXFxcIixcXG4gICAgICAgICAgICAgICAgICB0cnVua1RyYW5zYWN0aW9uOiB0cnVua1RyYW5zYWN0aW9uLnRvVHJ5dGVzKCkudG9TdHJpbmcoKSxcXG4gICAgICAgICAgICAgICAgICBicmFuY2hUcmFuc2FjdGlvbjogYnJhbmNoVHJhbnNhY3Rpb24udG9Ucnl0ZXMoKS50b1N0cmluZygpLFxcbiAgICAgICAgICAgICAgICAgIG1pbldlaWdodE1hZ25pdHVkZTogbWluV2VpZ2h0TWFnbml0dWRlLFxcbiAgICAgICAgICAgICAgICAgIHRyeXRlczogdHJ5dGVzLm1hcChmdW5jdGlvbiAodCkge1xcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQudG9TdHJpbmcoKTtcXG4gICAgICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgICB9O1xcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsSGVhZGVycyA9IHtcXG4gICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiB0aGlzLl9hcGlLZXlcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMjtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcmtDbGllbnQucG9zdEpzb24oYXR0YWNoVG9UYW5nbGVSZXF1ZXN0LCBcXFwiY29tbWFuZHNcXFwiLCBhZGRpdGlvbmFsSGVhZGVycyk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDEyOlxcbiAgICAgICAgICAgICAgICBhdHRhY2hUb1RhbmdsZVJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XFxuXFxuICAgICAgICAgICAgICAgIGlmICghKG9iamVjdEhlbHBlcl8xLk9iamVjdEhlbHBlci5pc0VtcHR5KGF0dGFjaFRvVGFuZ2xlUmVzcG9uc2UpIHx8IHN0cmluZ0hlbHBlcl8xLlN0cmluZ0hlbHBlci5pc0VtcHR5KGF0dGFjaFRvVGFuZ2xlUmVzcG9uc2Uuam9iSWQpKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBhdHRhY2hUb1RhbmdsZVJlcXVlc3QgZGlkIG5vdCByZXR1cm4gYSBqb2JJZFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxNzpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXFxcInJldHVyblxcXCIsIHRoaXMud2FpdEZvckpvYkNvbXBsZXRpb24oYXR0YWNoVG9UYW5nbGVSZXNwb25zZS5qb2JJZCwgdHJ5dGVzKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE4OlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwb3coX3gsIF94MiwgX3gzLCBfeDQpIHtcXG4gICAgICAgIHJldHVybiBfcG93LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ3YWl0Rm9ySm9iQ29tcGxldGlvblxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF93YWl0Rm9ySm9iQ29tcGxldGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoam9iSWQsIHNvdXJjZVRyeXRlcykge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgICAgICAgICAgIHZhciBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoXFxuICAgICAgICAgICAgICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgICAgICAgICAgICAgIF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgICAgICAgICAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICAgICAgICAgICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YXIgam9iUmVzcG9uc2U7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAwO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbmV0d29ya0NsaWVudC5nZXRKc29uKFxcXCJqb2JzL1xcXCIuY29uY2F0KGpvYklkKSk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvYlJlc3BvbnNlID0gX2NvbnRleHQzLnNlbnQ7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqb2JSZXNwb25zZS5lcnJvcikge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihqb2JSZXNwb25zZS5lcnJvck1lc3NhZ2UpKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqb2JSZXNwb25zZS5wcm9ncmVzcyA9PT0gXFxcIjEwMFxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqb2JSZXNwb25zZSAmJiBqb2JSZXNwb25zZS5yZXNwb25zZSAmJiBqb2JSZXNwb25zZS5yZXNwb25zZS50cnl0ZXMgJiYgam9iUmVzcG9uc2UucmVzcG9uc2UudHJ5dGVzLmxlbmd0aCA9PT0gc291cmNlVHJ5dGVzLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShqb2JSZXNwb25zZS5yZXNwb25zZS50cnl0ZXMubWFwKGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnl0ZXNfMS5Ucnl0ZXMuZnJvbVN0cmluZyh0KTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJUaGUgcmVzcG9uc2UgZGlkIG5vdCBjb250YWluIGVub3VnaCB0cnl0ZXNcXFwiKSk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTE7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMucHJldiA9IDc7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My50MCA9IF9jb250ZXh0M1tcXFwiY2F0Y2hcXFwiXSgwKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF9jb250ZXh0My50MCk7XFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMywgdGhpcywgW1swLCA3XV0pO1xcbiAgICAgICAgICAgICAgICAgIH0pKSwgX3RoaXMuX3BvbGxJbnRlcnZhbE1zKTtcXG4gICAgICAgICAgICAgICAgfSkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiB3YWl0Rm9ySm9iQ29tcGxldGlvbihfeDUsIF94Nikge1xcbiAgICAgICAgcmV0dXJuIF93YWl0Rm9ySm9iQ29tcGxldGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFByb29mT2ZXb3JrQm94O1xcbn0oKTtcXG5cXG5leHBvcnRzLlByb29mT2ZXb3JrQm94ID0gUHJvb2ZPZldvcmtCb3g7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LWJveC9kaXN0L3Byb29mT2ZXb3JrQm94LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy1ib3gvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LWJveC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctYm94L25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXFxcIik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LWJveC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LWJveC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LWJveC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXFxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXFxudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKTtcXG5cXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXFxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcXFwicmVnZW5lcmF0b3JSdW50aW1lXFxcIikgPj0gMDtcXG5cXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXFxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xcblxcbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcnVudGltZSAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy1ib3gvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1xcXCIpO1xcblxcbmlmIChoYWRSdW50aW1lKSB7XFxuICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBydW50aW1lLlxcbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xcbn0gZWxzZSB7XFxuICAvLyBSZW1vdmUgdGhlIGdsb2JhbCBwcm9wZXJ0eSBhZGRlZCBieSBydW50aW1lLmpzLlxcbiAgdHJ5IHtcXG4gICAgZGVsZXRlIGcucmVnZW5lcmF0b3JSdW50aW1lO1xcbiAgfSBjYXRjaChlKSB7XFxuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xcbiAgfVxcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctYm94L25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy1ib3gvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctYm94L25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuIShmdW5jdGlvbihnbG9iYWwpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XFxuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XFxuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IFN5bWJvbCA6IHt9O1xcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcXFwiQEBpdGVyYXRvclxcXCI7XFxuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcXFwiQEBhc3luY0l0ZXJhdG9yXFxcIjtcXG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXFxcIkBAdG9TdHJpbmdUYWdcXFwiO1xcblxcbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXFxcIm9iamVjdFxcXCI7XFxuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuICBpZiAocnVudGltZSkge1xcbiAgICBpZiAoaW5Nb2R1bGUpIHtcXG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XFxuICAgIH1cXG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxcbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XFxuXFxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XFxuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxcbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XFxuXFxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxcbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XFxuXFxuICAgIHJldHVybiBnZW5lcmF0b3I7XFxuICB9XFxuICBydW50aW1lLndyYXAgPSB3cmFwO1xcblxcbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXFxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxcbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIHsgdHlwZTogXFxcIm5vcm1hbFxcXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgcmV0dXJuIHsgdHlwZTogXFxcInRocm93XFxcIiwgYXJnOiBlcnIgfTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcXFwic3VzcGVuZGVkU3RhcnRcXFwiO1xcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcXFwic3VzcGVuZGVkWWllbGRcXFwiO1xcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXFxcImV4ZWN1dGluZ1xcXCI7XFxuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcXFwiY29tcGxldGVkXFxcIjtcXG5cXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XFxuXFxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXFxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxcblxcbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XFxuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XFxuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XFxuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcXG4gIH1cXG5cXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XFxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcXG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XFxuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cXG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiO1xcblxcbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXFxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XFxuICAgIFtcXFwibmV4dFxcXCIsIFxcXCJ0aHJvd1xcXCIsIFxcXCJyZXR1cm5cXFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xcbiAgICByZXR1cm4gY3RvclxcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcXG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCJcXG4gICAgICA6IGZhbHNlO1xcbiAgfTtcXG5cXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XFxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcXG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XFxuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIjtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xcbiAgICByZXR1cm4gZ2VuRnVuO1xcbiAgfTtcXG5cXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xcbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcXG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXFxcIl9fYXdhaXRcXFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXFxuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxcbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcXG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcXG4gICAgICAgIGlmICh2YWx1ZSAmJlxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXFxcIm9iamVjdFxcXCIgJiZcXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXFxcIl9fYXdhaXRcXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICAgICAgICBpbnZva2UoXFxcIm5leHRcXFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgICAgICAgaW52b2tlKFxcXCJ0aHJvd1xcXCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcXG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXFxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXFxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xcbiAgICAgICAgfSwgcmVqZWN0KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcXG5cXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XFxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXFxuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXFxuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XFxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcXG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXFxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxcbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXFxuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcXG4gICAgfVxcblxcbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcXG4gIH1cXG5cXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XFxuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcXG5cXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXFxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxcbiAgICApO1xcblxcbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXFxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xcbiAgICAgICAgfSk7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XFxuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XFxuXFxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICB0aHJvdyBhcmc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XFxuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XFxuXFxuICAgICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XFxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcXG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XFxuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XFxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJuZXh0XFxcIikge1xcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcXG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIGNvbnRleHQuYXJnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XFxuXFxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XFxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJub3JtYWxcXFwiKSB7XFxuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cXG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxcbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XFxuXFxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcXG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXFxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XFxuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XFxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuXFxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XFxuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJyZXR1cm5cXFwiO1xcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XFxuXFxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXFxuICAgICAgICAgICAgLy8gXFxcInJldHVyblxcXCIgdG8gXFxcInRocm93XFxcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxcbiAgICAgICAgICBcXFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xcblxcbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcXG5cXG4gICAgaWYgKCEgaW5mbykge1xcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXFxcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XFxcIik7XFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgaWYgKGluZm8uZG9uZSkge1xcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XFxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcXG5cXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXFxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcXG5cXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXFxcInRocm93XFxcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXFxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcXFwibmV4dFxcXCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxcbiAgICAgIC8vIFxcXCJjb25zdW1lZFxcXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcXG4gICAgICAvLyBcXFwicmV0dXJuXFxcIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXFxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxcbiAgICAgIHJldHVybiBpbmZvO1xcbiAgICB9XFxuXFxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXFxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gIH1cXG5cXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXFxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXFxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xcblxcbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXFxcIkdlbmVyYXRvclxcXCI7XFxuXFxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXFxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG5cXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBcXFwiW29iamVjdCBHZW5lcmF0b3JdXFxcIjtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xcblxcbiAgICBpZiAoMSBpbiBsb2NzKSB7XFxuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xcbiAgICB9XFxuXFxuICAgIGlmICgyIGluIGxvY3MpIHtcXG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcXG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XFxuICAgIH1cXG5cXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcXG4gICAgcmVjb3JkLnR5cGUgPSBcXFwibm9ybWFsXFxcIjtcXG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XFxuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XFxuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXFxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcXFwicm9vdFxcXCIgfV07XFxuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcXG4gICAgdGhpcy5yZXNldCh0cnVlKTtcXG4gIH1cXG5cXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICB2YXIga2V5cyA9IFtdO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XFxuICAgICAga2V5cy5wdXNoKGtleSk7XFxuICAgIH1cXG4gICAga2V5cy5yZXZlcnNlKCk7XFxuXFxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXFxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XFxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXFxuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXFxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gbmV4dDtcXG4gICAgfTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcXG4gICAgaWYgKGl0ZXJhYmxlKSB7XFxuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XFxuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcXG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcXG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XFxuXFxuICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXFxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcXG4gIH1cXG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xcblxcbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcXG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xcbiAgfVxcblxcbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XFxuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxcblxcbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xcbiAgICAgIHRoaXMucHJldiA9IDA7XFxuICAgICAgdGhpcy5uZXh0ID0gMDtcXG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXFxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcXG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcXG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcXG5cXG4gICAgICB0aGlzLm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcXG5cXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcXG5cXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFxcXCJ0XFxcIiAmJlxcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcXG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcXG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xcblxcbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XFxuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcXG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcXG4gICAgfSxcXG5cXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcXG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcXG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcXG5cXG4gICAgICAgIGlmIChjYXVnaHQpIHtcXG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XFxuXFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcXFwicm9vdFxcXCIpIHtcXG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXFxuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXFxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXFxcImVuZFxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcXG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFxcXCJjYXRjaExvY1xcXCIpO1xcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcXFwiZmluYWxseUxvY1xcXCIpO1xcblxcbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXFxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFxcXCJmaW5hbGx5TG9jXFxcIikgJiZcXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcXG4gICAgICAgICAgKHR5cGUgPT09IFxcXCJicmVha1xcXCIgfHxcXG4gICAgICAgICAgIHR5cGUgPT09IFxcXCJjb250aW51ZVxcXCIpICYmXFxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXFxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxcbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XFxuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XFxuXFxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xcbiAgICB9LFxcblxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwiYnJlYWtcXFwiIHx8XFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcXFwiY29udGludWVcXFwiKSB7XFxuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJyZXR1cm5cXFwiKSB7XFxuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XFxuICAgICAgICB0aGlzLm1ldGhvZCA9IFxcXCJyZXR1cm5cXFwiO1xcbiAgICAgICAgdGhpcy5uZXh0ID0gXFxcImVuZFxcXCI7XFxuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcIm5vcm1hbFxcXCIgJiYgYWZ0ZXJMb2MpIHtcXG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfSxcXG5cXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XFxuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIFxcXCJjYXRjaFxcXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XFxuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXFxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XFxcIik7XFxuICAgIH0sXFxuXFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XFxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcXG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcXG4gICAgICB9O1xcblxcbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXFxcIm5leHRcXFwiKSB7XFxuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuICB9O1xcbn0pKFxcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXFxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKVxcbik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LWJveC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy1qcy9kaXN0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LWpzL2Rpc3QvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfX2V4cG9ydChtKSB7XFxuICBmb3IgKHZhciBwIGluIG0pIHtcXG4gICAgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcXG4gIH1cXG59XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG4vKipcXHJcXG4gKiBDb21iaW5lZCBpbmRleCBvZiBhbGwgdGhlIG1vZHVsZXMuXFxyXFxuICovXFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcm9vZk9mV29ya0pzICovIFxcXCIuLi9pb3RhLXBpY28tcG93LWpzL2Rpc3QvcHJvb2ZPZldvcmtKcy5qc1xcXCIpKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctanMvZGlzdC9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wb3ctanMvZGlzdC9wZWFybERpdmVyL3BlYXJsRGl2ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LWpzL2Rpc3QvcGVhcmxEaXZlci9wZWFybERpdmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XFxuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xcbiAgICBcXFwiZGVmYXVsdFxcXCI6IG1vZFxcbiAgfTtcXG59O1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIHNwb25nZUZhY3RvcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnkgKi8gXFxcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9mYWN0b3JpZXMvc3BvbmdlRmFjdG9yeS5qc1xcXCIpO1xcblxcbnZhciB0cml0c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0cyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyaXRzLmpzXFxcIik7IC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTppbXBvcnQtbmFtZVxcblxcblxcbnZhciBiaWdfaW50ZWdlcl8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIGJpZy1pbnRlZ2VyICovIFxcXCJiaWctaW50ZWdlclxcXCIpKTtcXG4vKipcXHJcXG4gKiBQZWFybERpdmVyIGltcGxlbWVudGF0aW9uIGluIHBsYWluIEphdmFTY3JpcHQuXFxyXFxuICovXFxuXFxuXFxudmFyIFBlYXJsRGl2ZXIgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICAvKipcXHJcXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBQZWFybERpdmVyLlxcclxcbiAgICovXFxuICBmdW5jdGlvbiBQZWFybERpdmVyKCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVhcmxEaXZlcik7XFxuXFxuICAgIHZhciBjdXJsID0gc3BvbmdlRmFjdG9yeV8xLlNwb25nZUZhY3RvcnkuaW5zdGFuY2UoKS5jcmVhdGUoXFxcImN1cmxcXFwiKTtcXG4gICAgdmFyIGN1cmxDb25zdGFudHMgPSBjdXJsLmdldENvbnN0YW50cygpO1xcbiAgICB0aGlzLl9oYXNoTGVuZ3RoID0gY3VybENvbnN0YW50cy5IQVNIX0xFTkdUSDtcXG4gICAgdGhpcy5fc3RhdGVMZW5ndGggPSBjdXJsQ29uc3RhbnRzLlNUQVRFX0xFTkdUSDtcXG4gICAgdGhpcy5fbnVtYmVyUm91bmRzID0gY3VybENvbnN0YW50cy5OVU1CRVJfT0ZfUk9VTkRTO1xcbiAgICB0aGlzLl90cmFuc2FjdGlvbkxlbmd0aCA9IHRoaXMuX2hhc2hMZW5ndGggKiAzMztcXG4gICAgdGhpcy5fbm9uY2VMZW5ndGggPSB0aGlzLl9oYXNoTGVuZ3RoIC8gMztcXG4gICAgdGhpcy5fbm9uY2VTdGFydCA9IHRoaXMuX2hhc2hMZW5ndGggLSB0aGlzLl9ub25jZUxlbmd0aDtcXG4gICAgdmFyIE9GRlNFVF9MRU5HVEggPSA0O1xcbiAgICB0aGlzLl9ub25jZUluaXRTdGFydCA9IHRoaXMuX25vbmNlU3RhcnQgKyBPRkZTRVRfTEVOR1RIO1xcbiAgICB2YXIgSU5UX0xFTkdUSCA9IHRoaXMuX25vbmNlTGVuZ3RoIC8gMztcXG4gICAgdGhpcy5fbm9uY2VJbmNyZW1lbnRTdGFydCA9IHRoaXMuX25vbmNlSW5pdFN0YXJ0ICsgSU5UX0xFTkdUSDtcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogUGVyZm9ybSBhIHByb29mIG9mIHdvcmsgb24gdGhlIGRhdGEuXFxyXFxuICAgKiBAcGFyYW0gdHJ5dGVzIFRoZSB0cnl0ZXMgdG8gcGVyZm9ybSB0aGUgcG93IG9uLlxcclxcbiAgICogQHBhcmFtIG1pbldlaWdodE1hZ25pdHVkZSBUaGUgbWluaW11bSB3ZWlnaHQgbWFnbml0dWRlLlxcclxcbiAgICogQHJldHVybnMgVGhlIHRyeXRlcyBwcm9kdWNlZCBieSB0aGUgcHJvb2Ygb2Ygd29yay5cXHJcXG4gICAqL1xcblxcblxcbiAgX2NyZWF0ZUNsYXNzKFBlYXJsRGl2ZXIsIFt7XFxuICAgIGtleTogXFxcInNlYXJjaFdpdGhUcnl0ZXNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoV2l0aFRyeXRlcyh0cnl0ZXMsIG1pbldlaWdodE1hZ25pdHVkZSkge1xcbiAgICAgIHZhciBjdXJsU3RhdGUgPSB0aGlzLnByZXBhcmUodHJ5dGVzKTtcXG4gICAgICB2YXIgc2VhcmNoU3RhdGVzID0gdGhpcy5zZWFyY2hJbml0KGN1cmxTdGF0ZSk7XFxuICAgICAgcmV0dXJuIHRoaXMuc2VhcmNoKHNlYXJjaFN0YXRlcywgbWluV2VpZ2h0TWFnbml0dWRlKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZWFyY2hcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoKHNlYXJjaFN0YXRlcywgbWluV2VpZ2h0TWFnbml0dWRlKSB7XFxuICAgICAgdmFyIHNlYXJjaGluZyA9IHRydWU7XFxuICAgICAgdmFyIHRyaXRzID0gbmV3IEludDhBcnJheSh0aGlzLl9oYXNoTGVuZ3RoKTtcXG4gICAgICB2YXIgbWlkU3RhdGVDb3B5ID0ge1xcbiAgICAgICAgbG93OiBzZWFyY2hTdGF0ZXMubG93LnNsaWNlKCksXFxuICAgICAgICBoaWdoOiBzZWFyY2hTdGF0ZXMuaGlnaC5zbGljZSgpXFxuICAgICAgfTtcXG5cXG4gICAgICB3aGlsZSAoc2VhcmNoaW5nKSB7XFxuICAgICAgICB0aGlzLmluY3JlbWVudChtaWRTdGF0ZUNvcHksIHRoaXMuX25vbmNlSW5jcmVtZW50U3RhcnQsIHRoaXMuX2hhc2hMZW5ndGgpO1xcbiAgICAgICAgdmFyIHN0YXRlID0ge1xcbiAgICAgICAgICBsb3c6IG1pZFN0YXRlQ29weS5sb3cuc2xpY2UoKSxcXG4gICAgICAgICAgaGlnaDogbWlkU3RhdGVDb3B5LmhpZ2guc2xpY2UoKVxcbiAgICAgICAgfTtcXG4gICAgICAgIHRoaXMudHJhbnNmb3JtKHN0YXRlKTtcXG4gICAgICAgIHZhciBub25jZVByb2JlID0gdGhpcy5pc0ZvdW5kRmFzdChzdGF0ZSwgbWluV2VpZ2h0TWFnbml0dWRlKTtcXG5cXG4gICAgICAgIGlmIChub25jZVByb2JlLnRvSlNOdW1iZXIoKSA9PT0gMCkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBub25jZU91dHB1dCA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCgxKTsgLy8gQml0IHNjYW4gZm9yd2FyZFxcblxcbiAgICAgICAgd2hpbGUgKG5vbmNlT3V0cHV0LmFuZChub25jZVByb2JlKS50b0pTTnVtYmVyKCkgPT09IDApIHtcXG4gICAgICAgICAgbm9uY2VPdXRwdXQgPSBub25jZU91dHB1dC5zaGlmdExlZnQoMSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZWFyY2hpbmcgPSBmYWxzZTtcXG5cXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faGFzaExlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgIHRyaXRzW2ldID0gbWlkU3RhdGVDb3B5Lmxvd1tpXS5hbmQobm9uY2VPdXRwdXQpLnRvSlNOdW1iZXIoKSA9PT0gMCA/IDEgOiBtaWRTdGF0ZUNvcHkuaGlnaFtpXS5hbmQobm9uY2VPdXRwdXQpLnRvSlNOdW1iZXIoKSA9PT0gMCA/IC0xIDogMDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRyaXRzXzEuVHJpdHMuZnJvbUFycmF5KHRyaXRzKS50b1RyeXRlcygpO1xcbiAgICB9XFxuICB9LCB7XFxuICAgIGtleTogXFxcInRyYW5zZm9ybVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm0oc2VhcmNoU3RhdGVzKSB7XFxuICAgICAgdmFyIGN1cmxTY3JhdGNocGFkSW5kZXggPSAwO1xcblxcbiAgICAgIGZvciAodmFyIHJvdW5kID0gMDsgcm91bmQgPCB0aGlzLl9udW1iZXJSb3VuZHM7IHJvdW5kKyspIHtcXG4gICAgICAgIHZhciBjdXJsU2NyYXRjaHBhZCA9IHtcXG4gICAgICAgICAgbG93OiBzZWFyY2hTdGF0ZXMubG93LnNsaWNlKCksXFxuICAgICAgICAgIGhpZ2g6IHNlYXJjaFN0YXRlcy5oaWdoLnNsaWNlKClcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBmb3IgKHZhciBzdGF0ZUluZGV4ID0gMDsgc3RhdGVJbmRleCA8IHRoaXMuX3N0YXRlTGVuZ3RoOyBzdGF0ZUluZGV4KyspIHtcXG4gICAgICAgICAgdmFyIGFscGhhID0gY3VybFNjcmF0Y2hwYWQubG93W2N1cmxTY3JhdGNocGFkSW5kZXhdO1xcbiAgICAgICAgICB2YXIgYmV0YSA9IGN1cmxTY3JhdGNocGFkLmhpZ2hbY3VybFNjcmF0Y2hwYWRJbmRleF07XFxuXFxuICAgICAgICAgIGlmIChjdXJsU2NyYXRjaHBhZEluZGV4IDwgMzY1KSB7XFxuICAgICAgICAgICAgY3VybFNjcmF0Y2hwYWRJbmRleCArPSAzNjQ7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY3VybFNjcmF0Y2hwYWRJbmRleCArPSAtMzY1O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhciBnYW1tYSA9IGN1cmxTY3JhdGNocGFkLmhpZ2hbY3VybFNjcmF0Y2hwYWRJbmRleF07XFxuICAgICAgICAgIHZhciBsb3dYb3JCZXRhID0gY3VybFNjcmF0Y2hwYWQubG93W2N1cmxTY3JhdGNocGFkSW5kZXhdLnhvcihiZXRhKTtcXG4gICAgICAgICAgdmFyIG5vdEdhbW1hID0gZ2FtbWEubm90KCk7XFxuICAgICAgICAgIHZhciBhbHBoYU9yTm90R2FtbWEgPSBhbHBoYS5vcihub3RHYW1tYSk7XFxuICAgICAgICAgIHZhciBkZWx0YSA9IGFscGhhT3JOb3RHYW1tYS5hbmQobG93WG9yQmV0YSk7XFxuICAgICAgICAgIHNlYXJjaFN0YXRlcy5sb3dbc3RhdGVJbmRleF0gPSBkZWx0YS5ub3QoKTtcXG4gICAgICAgICAgdmFyIGFscGhhWG9yR2FtbWEgPSBhbHBoYS54b3IoZ2FtbWEpO1xcbiAgICAgICAgICBzZWFyY2hTdGF0ZXMuaGlnaFtzdGF0ZUluZGV4XSA9IGFscGhhWG9yR2FtbWEub3IoZGVsdGEpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpbmNyZW1lbnRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5jcmVtZW50KHNlYXJjaFN0YXRlcywgZnJvbUluZGV4LCB0b0luZGV4KSB7XFxuICAgICAgZm9yICh2YXIgaSA9IGZyb21JbmRleDsgaSA8IHRvSW5kZXg7IGkrKykge1xcbiAgICAgICAgaWYgKHNlYXJjaFN0YXRlcy5sb3dbaV0udG9KU051bWJlcigpID09PSBQZWFybERpdmVyLkxPV19CSVRTKSB7XFxuICAgICAgICAgIHNlYXJjaFN0YXRlcy5sb3dbaV0gPSBiaWdfaW50ZWdlcl8xLmRlZmF1bHQoUGVhcmxEaXZlci5ISUdIX0JJVFMpO1xcbiAgICAgICAgICBzZWFyY2hTdGF0ZXMuaGlnaFtpXSA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdChQZWFybERpdmVyLkxPV19CSVRTKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlmIChzZWFyY2hTdGF0ZXMuaGlnaFtpXS50b0pTTnVtYmVyKCkgPT09IFBlYXJsRGl2ZXIuTE9XX0JJVFMpIHtcXG4gICAgICAgICAgICBzZWFyY2hTdGF0ZXMuaGlnaFtpXSA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdChQZWFybERpdmVyLkhJR0hfQklUUyk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2VhcmNoU3RhdGVzLmxvd1tpXSA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdChQZWFybERpdmVyLkxPV19CSVRTKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicHJlcGFyZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJlKHRyYW5zYWN0aW9uVHJ5dGVzKSB7XFxuICAgICAgdmFyIGN1cmwgPSBzcG9uZ2VGYWN0b3J5XzEuU3BvbmdlRmFjdG9yeS5pbnN0YW5jZSgpLmNyZWF0ZShcXFwiY3VybFxcXCIpO1xcbiAgICAgIGN1cmwuaW5pdGlhbGl6ZSgpO1xcbiAgICAgIHZhciB0cmFuc2FjdGlvblRyaXRzID0gdHJpdHNfMS5Ucml0cy5mcm9tVHJ5dGVzKHRyYW5zYWN0aW9uVHJ5dGVzKS50b0FycmF5KCk7XFxuICAgICAgY3VybC5hYnNvcmIodHJhbnNhY3Rpb25Ucml0cywgMCwgdGhpcy5fdHJhbnNhY3Rpb25MZW5ndGggLSB0aGlzLl9oYXNoTGVuZ3RoKTtcXG4gICAgICB2YXIgY3VybFN0YXRlID0gY3VybC5nZXRTdGF0ZSgpO1xcbiAgICAgIHRyYW5zYWN0aW9uVHJpdHMuc2xpY2UodGhpcy5fdHJhbnNhY3Rpb25MZW5ndGggLSB0aGlzLl9oYXNoTGVuZ3RoLCB0aGlzLl90cmFuc2FjdGlvbkxlbmd0aCkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XFxuICAgICAgICBjdXJsU3RhdGVbaW5kZXhdID0gdmFsdWU7XFxuICAgICAgfSk7XFxuICAgICAgcmV0dXJuIGN1cmxTdGF0ZTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZWFyY2hJbml0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlYXJjaEluaXQoY3VybFN0YXRlKSB7XFxuICAgICAgdmFyIHN0YXRlcyA9IHtcXG4gICAgICAgIGxvdzogW10sXFxuICAgICAgICBoaWdoOiBbXVxcbiAgICAgIH07XFxuICAgICAgY3VybFN0YXRlLmZvckVhY2goZnVuY3Rpb24gKHRyaXQsIGluZGV4KSB7XFxuICAgICAgICBzd2l0Y2ggKHRyaXQpIHtcXG4gICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgIHN0YXRlcy5sb3dbaW5kZXhdID0gYmlnX2ludGVnZXJfMS5kZWZhdWx0KFBlYXJsRGl2ZXIuSElHSF9CSVRTKTtcXG4gICAgICAgICAgICBzdGF0ZXMuaGlnaFtpbmRleF0gPSBiaWdfaW50ZWdlcl8xLmRlZmF1bHQoUGVhcmxEaXZlci5ISUdIX0JJVFMpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgc3RhdGVzLmxvd1tpbmRleF0gPSBiaWdfaW50ZWdlcl8xLmRlZmF1bHQoUGVhcmxEaXZlci5MT1dfQklUUyk7XFxuICAgICAgICAgICAgc3RhdGVzLmhpZ2hbaW5kZXhdID0gYmlnX2ludGVnZXJfMS5kZWZhdWx0KFBlYXJsRGl2ZXIuSElHSF9CSVRTKTtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICBzdGF0ZXMubG93W2luZGV4XSA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdChQZWFybERpdmVyLkhJR0hfQklUUyk7XFxuICAgICAgICAgICAgc3RhdGVzLmhpZ2hbaW5kZXhdID0gYmlnX2ludGVnZXJfMS5kZWZhdWx0KFBlYXJsRGl2ZXIuTE9XX0JJVFMpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICAgIHRoaXMuc2VhcmNoT2Zmc2V0KHN0YXRlcywgdGhpcy5fbm9uY2VTdGFydCk7XFxuICAgICAgcmV0dXJuIHN0YXRlcztcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZWFyY2hPZmZzZXRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoT2Zmc2V0KHN0YXRlcywgb2Zmc2V0KSB7XFxuICAgICAgc3RhdGVzLmxvd1tvZmZzZXQgKyAwXSA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdChcXFwiLTI2MzUyNDkxNTMzODcwNzg4MDNcXFwiLCAxMCk7XFxuICAgICAgc3RhdGVzLmhpZ2hbb2Zmc2V0ICsgMF0gPSBiaWdfaW50ZWdlcl8xLmRlZmF1bHQoXFxcIi01MjcwNDk4MzA2Nzc0MTU3NjA1XFxcIiwgMTApO1xcbiAgICAgIHN0YXRlcy5sb3dbb2Zmc2V0ICsgMV0gPSBiaWdfaW50ZWdlcl8xLmRlZmF1bHQoXFxcIi0xMDEwNzgwNDk3MTg5NTY0NDczXFxcIiwgMTApO1xcbiAgICAgIHN0YXRlcy5oaWdoW29mZnNldCArIDFdID0gYmlnX2ludGVnZXJfMS5kZWZhdWx0KFxcXCItODA4NjI0Mzk3NzUxNjUxNTc3N1xcXCIsIDEwKTtcXG4gICAgICBzdGF0ZXMubG93W29mZnNldCArIDJdID0gYmlnX2ludGVnZXJfMS5kZWZhdWx0KFxcXCI5MjIzMzM2OTIxMjAxOTAyMDc5XFxcIiwgMTApO1xcbiAgICAgIHN0YXRlcy5oaWdoW29mZnNldCArIDJdID0gYmlnX2ludGVnZXJfMS5kZWZhdWx0KFxcXCItMTc5NzkyMTQyNzEzNDg3MzdcXFwiLCAxMCk7XFxuICAgICAgc3RhdGVzLmxvd1tvZmZzZXQgKyAzXSA9IGJpZ19pbnRlZ2VyXzEuZGVmYXVsdChcXFwiLTE4MDE0Mzk4Mzc1MjY0MjU3XFxcIiwgMTApO1xcbiAgICAgIHN0YXRlcy5oaWdoW29mZnNldCArIDNdID0gYmlnX2ludGVnZXJfMS5kZWZhdWx0KFxcXCIxODAxNDM5ODUwOTQ4MTk4M1xcXCIsIDEwKTtcXG4gICAgfVxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJpc0ZvdW5kRmFzdFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ZvdW5kRmFzdChzZWFyY2hTdGF0ZXMsIG1pbldlaWdodE1hZ25pdHVkZSkge1xcbiAgICAgIHZhciBsYXN0TWVhc3VyZW1lbnQgPSBiaWdfaW50ZWdlcl8xLmRlZmF1bHQoUGVhcmxEaXZlci5ISUdIX0JJVFMpO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSBtaW5XZWlnaHRNYWduaXR1ZGUgLSAxOyBpID49IDA7IGktLSkge1xcbiAgICAgICAgdmFyIGxvdyA9IHNlYXJjaFN0YXRlcy5sb3dbdGhpcy5faGFzaExlbmd0aCAtIDEgLSBpXTtcXG4gICAgICAgIHZhciBoaWdoID0gc2VhcmNoU3RhdGVzLmhpZ2hbdGhpcy5faGFzaExlbmd0aCAtIDEgLSBpXTtcXG4gICAgICAgIHZhciBsb3dYb3JIaWdoID0gbG93LnhvcihoaWdoKTtcXG4gICAgICAgIHZhciBub3RMb3dYb3JIaWdoID0gbG93WG9ySGlnaC5ub3QoKTtcXG4gICAgICAgIGxhc3RNZWFzdXJlbWVudCA9IGxhc3RNZWFzdXJlbWVudC5hbmQobm90TG93WG9ySGlnaCk7XFxuXFxuICAgICAgICBpZiAobGFzdE1lYXN1cmVtZW50LnRvSlNOdW1iZXIoKSA9PT0gMCkge1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGxhc3RNZWFzdXJlbWVudDtcXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFBlYXJsRGl2ZXI7XFxufSgpO1xcbi8qIEBpbnRlcm5hbCAqL1xcblxcblxcblBlYXJsRGl2ZXIuSElHSF9CSVRTID0gLTE7XFxuLyogQGludGVybmFsICovXFxuXFxuUGVhcmxEaXZlci5MT1dfQklUUyA9IDA7XFxuZXhwb3J0cy5QZWFybERpdmVyID0gUGVhcmxEaXZlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctanMvZGlzdC9wZWFybERpdmVyL3BlYXJsRGl2ZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LWpzL2Rpc3QvcHJvb2ZPZldvcmtKcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LWpzL2Rpc3QvcHJvb2ZPZldvcmtKcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvciAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy1qcy9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcXFwiKTtcXG5cXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gc3RlcChrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfSBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBzdGVwKFxcXCJuZXh0XFxcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgc3RlcChcXFwidGhyb3dcXFwiLCBlcnIpOyB9IF9uZXh0KCk7IH0pOyB9OyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cXG5cXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIGFycmF5SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL2FycmF5SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgbnVtYmVySGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL251bWJlckhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBjcnlwdG9FcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jcnlwdG8vZGlzdC9lcnJvci9jcnlwdG9FcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yLmpzXFxcIik7XFxuXFxudmFyIHRyeXRlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cnl0ZXMgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvZGF0YS90cnl0ZXMuanNcXFwiKTtcXG5cXG52YXIgcGVhcmxEaXZlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wZWFybERpdmVyL3BlYXJsRGl2ZXIgKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctanMvZGlzdC9wZWFybERpdmVyL3BlYXJsRGl2ZXIuanNcXFwiKTtcXG4vKipcXHJcXG4gKiBQcm9vZk9mV29yayBpbXBsZW1lbnRhdGlvbiB1c2luZyBKYXZhU2NyaXB0LlxcclxcbiAqL1xcblxcblxcbnZhciBQcm9vZk9mV29ya0pzID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gUHJvb2ZPZldvcmtKcygpIHtcXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb29mT2ZXb3JrSnMpO1xcbiAgfVxcblxcbiAgX2NyZWF0ZUNsYXNzKFByb29mT2ZXb3JrSnMsIFt7XFxuICAgIGtleTogXFxcImluaXRpYWxpemVcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQWxsb3cgdGhlIHByb29mIG9mIHdvcmsgdG8gcGVyZm9ybSBhbnkgaW5pdGlhbGl6YXRpb24uXFxyXFxuICAgICAqIFdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxcclxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2luaXRpYWxpemUgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBQcm9taXNlLnJlc29sdmUoKSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xcbiAgICAgICAgcmV0dXJuIF9pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBQZXJmb3JtcyBzaW5nbGUgY29udmVyc2lvbiBwZXIgcG93IGNhbGwuXFxyXFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgcG93IG9ubHkgZG9lcyBvbmUgY29udmVyc2lvbi5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInBlcmZvcm1zU2luZ2xlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1zU2luZ2xlKCkge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBQZXJmb3JtIGEgcHJvb2Ygb2Ygd29yayBvbiB0aGUgZGF0YS5cXHJcXG4gICAgICogQHBhcmFtIHRydW5rVHJhbnNhY3Rpb24gVGhlIHRydW5rVHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcG93LlxcclxcbiAgICAgKiBAcGFyYW0gYnJhbmNoVHJhbnNhY3Rpb24gVGhlIGJyYW5jaFRyYW5zYWN0aW9uIHRvIHVzZSBmb3IgdGhlIHBvdy5cXHJcXG4gICAgICogQHBhcmFtIHRyeXRlcyBUaGUgdHJ5dGVzIHRvIHBlcmZvcm0gdGhlIHBvdyBvbi5cXHJcXG4gICAgICogQHBhcmFtIG1pbldlaWdodE1hZ25pdHVkZSBUaGUgbWluaW11bSB3ZWlnaHQgbWFnbml0dWRlLlxcclxcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJ5dGVzIHByb2R1Y2VkIGJ5IHRoZSBwcm9vZiBvZiB3b3JrLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicG93XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3BvdyA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIodHJ1bmtUcmFuc2FjdGlvbiwgYnJhbmNoVHJhbnNhY3Rpb24sIHRyeXRlcywgbWluV2VpZ2h0TWFnbml0dWRlKSB7XFxuICAgICAgICB2YXIgbm9uY2UsIG5vbmNlU3RyaW5nLCB0cnl0ZXNTdHJpbmc7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgaWYgKGFycmF5SGVscGVyXzEuQXJyYXlIZWxwZXIuaXNUeXBlZCh0cnl0ZXMsIHRyeXRlc18xLlRyeXRlcykpIHtcXG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XFxuICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSB0cnl0ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyeXRlc1xcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICBpZiAoISghbnVtYmVySGVscGVyXzEuTnVtYmVySGVscGVyLmlzSW50ZWdlcihtaW5XZWlnaHRNYWduaXR1ZGUpIHx8IG1pbldlaWdodE1hZ25pdHVkZSA8PSAwKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIG1pbldlaWdodE1hZ25pdHVkZSBtdXN0IGJlID4gMFxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICAgICAgICBub25jZSA9IG5ldyBwZWFybERpdmVyXzEuUGVhcmxEaXZlcigpLnNlYXJjaFdpdGhUcnl0ZXModHJ5dGVzWzBdLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xcbiAgICAgICAgICAgICAgICBub25jZVN0cmluZyA9IG5vbmNlLnRvU3RyaW5nKCk7XFxuICAgICAgICAgICAgICAgIHRyeXRlc1N0cmluZyA9IHRyeXRlcy50b1N0cmluZygpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcXFwicmV0dXJuXFxcIiwgW3RyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyeXRlc1N0cmluZy5zdWJzdHIoMCwgdHJ5dGVzU3RyaW5nLmxlbmd0aCAtIG5vbmNlU3RyaW5nLmxlbmd0aCkgKyBub25jZVN0cmluZyldKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgODpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xcbiAgICAgIH0pKTtcXG5cXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcG93KF94LCBfeDIsIF94MywgX3g0KSB7XFxuICAgICAgICByZXR1cm4gX3Bvdy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH0oKVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFByb29mT2ZXb3JrSnM7XFxufSgpO1xcblxcbmV4cG9ydHMuUHJvb2ZPZldvcmtKcyA9IFByb29mT2ZXb3JrSnM7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LWpzL2Rpc3QvcHJvb2ZPZldvcmtKcy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wb3ctanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctanMvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcXFwiKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctanMvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy1qcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctanMvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuLy8gVGhpcyBtZXRob2Qgb2Ygb2J0YWluaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0IG5lZWRzIHRvIGJlXFxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXFxudmFyIGcgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKTtcXG5cXG4vLyBVc2UgYGdldE93blByb3BlcnR5TmFtZXNgIGJlY2F1c2Ugbm90IGFsbCBicm93c2VycyBzdXBwb3J0IGNhbGxpbmdcXG4vLyBgaGFzT3duUHJvcGVydHlgIG9uIHRoZSBnbG9iYWwgYHNlbGZgIG9iamVjdCBpbiBhIHdvcmtlci4gU2VlICMxODMuXFxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxcbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZykuaW5kZXhPZihcXFwicmVnZW5lcmF0b3JSdW50aW1lXFxcIikgPj0gMDtcXG5cXG4vLyBTYXZlIHRoZSBvbGQgcmVnZW5lcmF0b3JSdW50aW1lIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVzdG9yZWQgbGF0ZXIuXFxudmFyIG9sZFJ1bnRpbWUgPSBoYWRSdW50aW1lICYmIGcucmVnZW5lcmF0b3JSdW50aW1lO1xcblxcbi8vIEZvcmNlIHJlZXZhbHV0YXRpb24gb2YgcnVudGltZS5qcy5cXG5nLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcnVudGltZSAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy1qcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXFxcIik7XFxuXFxuaWYgKGhhZFJ1bnRpbWUpIHtcXG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXFxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XFxufSBlbHNlIHtcXG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXFxuICB0cnkge1xcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuICB9IGNhdGNoKGUpIHtcXG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XFxuICB9XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy1qcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wb3ctanMvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy1qcy9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiLyoqXFxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXFxuICpcXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXFxuICovXFxuXFxuIShmdW5jdGlvbihnbG9iYWwpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XFxuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XFxuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiA/IFN5bWJvbCA6IHt9O1xcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcXFwiQEBpdGVyYXRvclxcXCI7XFxuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcXFwiQEBhc3luY0l0ZXJhdG9yXFxcIjtcXG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXFxcIkBAdG9TdHJpbmdUYWdcXFwiO1xcblxcbiAgdmFyIGluTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PT0gXFxcIm9iamVjdFxcXCI7XFxuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuICBpZiAocnVudGltZSkge1xcbiAgICBpZiAoaW5Nb2R1bGUpIHtcXG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXFxuICAgICAgLy8gbWFrZSB0aGUgZXhwb3J0cyBvYmplY3QgaWRlbnRpY2FsIHRvIHJlZ2VuZXJhdG9yUnVudGltZS5cXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IHJ1bnRpbWU7XFxuICAgIH1cXG4gICAgLy8gRG9uJ3QgYm90aGVyIGV2YWx1YXRpbmcgdGhlIHJlc3Qgb2YgdGhpcyBmaWxlIGlmIHRoZSBydW50aW1lIHdhc1xcbiAgICAvLyBhbHJlYWR5IGRlZmluZWQgZ2xvYmFsbHkuXFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxcbiAgLy8gbW9kdWxlLmV4cG9ydHMgKGlmIHdlJ3JlIGluIGEgbW9kdWxlKSBvciBhIG5ldywgZW1wdHkgb2JqZWN0LlxcbiAgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWUgPSBpbk1vZHVsZSA/IG1vZHVsZS5leHBvcnRzIDoge307XFxuXFxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XFxuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxcbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcXG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcXG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XFxuXFxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxcbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XFxuXFxuICAgIHJldHVybiBnZW5lcmF0b3I7XFxuICB9XFxuICBydW50aW1lLndyYXAgPSB3cmFwO1xcblxcbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXFxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxcbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIHsgdHlwZTogXFxcIm5vcm1hbFxcXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgcmV0dXJuIHsgdHlwZTogXFxcInRocm93XFxcIiwgYXJnOiBlcnIgfTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcXFwic3VzcGVuZGVkU3RhcnRcXFwiO1xcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcXFwic3VzcGVuZGVkWWllbGRcXFwiO1xcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXFxcImV4ZWN1dGluZ1xcXCI7XFxuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcXFwiY29tcGxldGVkXFxcIjtcXG5cXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XFxuXFxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXFxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxcblxcbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XFxuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XFxuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XFxuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcXG4gIH1cXG5cXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XFxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcXG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XFxuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cXG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiO1xcblxcbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXFxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XFxuICAgIFtcXFwibmV4dFxcXCIsIFxcXCJ0aHJvd1xcXCIsIFxcXCJyZXR1cm5cXFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xcbiAgICByZXR1cm4gY3RvclxcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcXG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCJcXG4gICAgICA6IGZhbHNlO1xcbiAgfTtcXG5cXG4gIHJ1bnRpbWUubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XFxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcXG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XFxuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIjtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xcbiAgICByZXR1cm4gZ2VuRnVuO1xcbiAgfTtcXG5cXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xcbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcXG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXFxcIl9fYXdhaXRcXFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXFxuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxcbiAgcnVudGltZS5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcXG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcXG4gICAgICAgIGlmICh2YWx1ZSAmJlxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXFxcIm9iamVjdFxcXCIgJiZcXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXFxcIl9fYXdhaXRcXFwiKSkge1xcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICAgICAgICBpbnZva2UoXFxcIm5leHRcXFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XFxuICAgICAgICAgICAgaW52b2tlKFxcXCJ0aHJvd1xcXCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uIElmIHRoZSBQcm9taXNlIGlzIHJlamVjdGVkLCBob3dldmVyLCB0aGVcXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcXG4gICAgICAgICAgLy8gcmVhc29uLiBOb3RlIHRoYXQgcmVqZWN0aW9ucyBvZiB5aWVsZGVkIFByb21pc2VzIGFyZSBub3RcXG4gICAgICAgICAgLy8gdGhyb3duIGJhY2sgaW50byB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBhcyBpcyB0aGUgY2FzZVxcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXFxuICAgICAgICAgIC8vIGJlaGF2aW9yIGJldHdlZW4geWllbGQgYW5kIGF3YWl0IGlzIGltcG9ydGFudCwgYmVjYXVzZSBpdFxcbiAgICAgICAgICAvLyBhbGxvd3MgdGhlIGNvbnN1bWVyIHRvIGRlY2lkZSB3aGF0IHRvIGRvIHdpdGggdGhlIHlpZWxkZWRcXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcXG4gICAgICAgICAgLy8gaW50byB0aGUgZ2VuZXJhdG9yLCBhYmFuZG9uIGl0ZXJhdGlvbiwgd2hhdGV2ZXIpLiBXaXRoXFxuICAgICAgICAgIC8vIGF3YWl0LCBieSBjb250cmFzdCwgdGhlcmUgaXMgbm8gb3Bwb3J0dW5pdHkgdG8gZXhhbWluZSB0aGVcXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxcbiAgICAgICAgICAvLyBvbmx5IG9wdGlvbiBpcyB0byB0aHJvdyBpdCBmcm9tIHRoZSBhd2FpdCBleHByZXNzaW9uLCBhbmRcXG4gICAgICAgICAgLy8gbGV0IHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gaGFuZGxlIHRoZSBleGNlcHRpb24uXFxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xcbiAgICAgICAgfSwgcmVqZWN0KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcXG5cXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XFxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXFxuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXFxuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XFxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcXG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXFxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxcbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXFxuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcXG4gICAgfVxcblxcbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcXG4gIH1cXG5cXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XFxuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcXG5cXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXFxuICBydW50aW1lLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxcbiAgICApO1xcblxcbiAgICByZXR1cm4gcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXFxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XFxuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xcbiAgICAgICAgfSk7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XFxuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XFxuXFxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICB0aHJvdyBhcmc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XFxuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XFxuXFxuICAgICAgd2hpbGUgKHRydWUpIHtcXG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XFxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcXG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XFxuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XFxuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJuZXh0XFxcIikge1xcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcXG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIGNvbnRleHQuYXJnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XFxuXFxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XFxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJub3JtYWxcXFwiKSB7XFxuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cXG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxcbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XFxuXFxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcXG4gICAgICAgICAgfTtcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcXG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXFxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XFxuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XFxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuXFxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XFxuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJyZXR1cm5cXFwiO1xcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XFxuXFxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXFxuICAgICAgICAgICAgLy8gXFxcInJldHVyblxcXCIgdG8gXFxcInRocm93XFxcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxcbiAgICAgICAgICBcXFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFxcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xcblxcbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcXG5cXG4gICAgaWYgKCEgaW5mbykge1xcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXFxcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XFxcIik7XFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgaWYgKGluZm8uZG9uZSkge1xcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XFxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcXG5cXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXFxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcXG5cXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXFxcInRocm93XFxcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXFxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcXFwibmV4dFxcXCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxcbiAgICAgIC8vIFxcXCJjb25zdW1lZFxcXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcXG4gICAgICAvLyBcXFwicmV0dXJuXFxcIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXFxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxcbiAgICAgIHJldHVybiBpbmZvO1xcbiAgICB9XFxuXFxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXFxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gIH1cXG5cXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXFxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXFxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xcblxcbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXFxcIkdlbmVyYXRvclxcXCI7XFxuXFxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXFxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxcbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG5cXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XFxuICAgIHJldHVybiBcXFwiW29iamVjdCBHZW5lcmF0b3JdXFxcIjtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xcblxcbiAgICBpZiAoMSBpbiBsb2NzKSB7XFxuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xcbiAgICB9XFxuXFxuICAgIGlmICgyIGluIGxvY3MpIHtcXG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcXG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XFxuICAgIH1cXG5cXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcXG4gICAgcmVjb3JkLnR5cGUgPSBcXFwibm9ybWFsXFxcIjtcXG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XFxuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XFxuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXFxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcXFwicm9vdFxcXCIgfV07XFxuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcXG4gICAgdGhpcy5yZXNldCh0cnVlKTtcXG4gIH1cXG5cXG4gIHJ1bnRpbWUua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICB2YXIga2V5cyA9IFtdO1xcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XFxuICAgICAga2V5cy5wdXNoKGtleSk7XFxuICAgIH1cXG4gICAga2V5cy5yZXZlcnNlKCk7XFxuXFxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXFxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XFxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXFxuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXFxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcXG4gICAgICByZXR1cm4gbmV4dDtcXG4gICAgfTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcXG4gICAgaWYgKGl0ZXJhYmxlKSB7XFxuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XFxuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcXG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcXG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XFxuXFxuICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXFxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcXG4gIH1cXG4gIHJ1bnRpbWUudmFsdWVzID0gdmFsdWVzO1xcblxcbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcXG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xcbiAgfVxcblxcbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XFxuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxcblxcbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xcbiAgICAgIHRoaXMucHJldiA9IDA7XFxuICAgICAgdGhpcy5uZXh0ID0gMDtcXG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXFxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcXG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcXG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcXG5cXG4gICAgICB0aGlzLm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcXG5cXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcXG5cXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFxcXCJ0XFxcIiAmJlxcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcXG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcXG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xcblxcbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XFxuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcXG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcXG4gICAgfSxcXG5cXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcXG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcXG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcXG5cXG4gICAgICAgIGlmIChjYXVnaHQpIHtcXG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XFxuXFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcXFwicm9vdFxcXCIpIHtcXG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXFxuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXFxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXFxcImVuZFxcXCIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcXG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFxcXCJjYXRjaExvY1xcXCIpO1xcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcXFwiZmluYWxseUxvY1xcXCIpO1xcblxcbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXFxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFxcXCJmaW5hbGx5TG9jXFxcIikgJiZcXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcXG4gICAgICAgICAgKHR5cGUgPT09IFxcXCJicmVha1xcXCIgfHxcXG4gICAgICAgICAgIHR5cGUgPT09IFxcXCJjb250aW51ZVxcXCIpICYmXFxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXFxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxcbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XFxuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XFxuXFxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcXG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xcbiAgICB9LFxcblxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwiYnJlYWtcXFwiIHx8XFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcXFwiY29udGludWVcXFwiKSB7XFxuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJyZXR1cm5cXFwiKSB7XFxuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XFxuICAgICAgICB0aGlzLm1ldGhvZCA9IFxcXCJyZXR1cm5cXFwiO1xcbiAgICAgICAgdGhpcy5uZXh0ID0gXFxcImVuZFxcXCI7XFxuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcIm5vcm1hbFxcXCIgJiYgYWZ0ZXJMb2MpIHtcXG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfSxcXG5cXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XFxuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIFxcXCJjYXRjaFxcXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XFxuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXFxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XFxcIik7XFxuICAgIH0sXFxuXFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XFxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcXG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcXG4gICAgICB9O1xcblxcbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXFxcIm5leHRcXFwiKSB7XFxuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxcbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuICB9O1xcbn0pKFxcbiAgLy8gSW4gc2xvcHB5IG1vZGUsIHVuYm91bmQgYHRoaXNgIHJlZmVycyB0byB0aGUgZ2xvYmFsIG9iamVjdCwgZmFsbGJhY2sgdG9cXG4gIC8vIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGlmIHdlJ3JlIGluIGdsb2JhbCBzdHJpY3QgbW9kZS4gVGhhdCBpcyBzYWRseSBhIGZvcm1cXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXFxuICAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzIH0pKCkgfHwgRnVuY3Rpb24oXFxcInJldHVybiB0aGlzXFxcIikoKVxcbik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LWpzL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdhc20vZGlzdC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LXdhc20vZGlzdC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX19leHBvcnQobSkge1xcbiAgZm9yICh2YXIgcCBpbiBtKSB7XFxuICAgIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XFxuICB9XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogQ29tYmluZWQgaW5kZXggb2YgYWxsIHRoZSBtb2R1bGVzLlxcclxcbiAqL1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcHJvb2ZPZldvcmtXYXNtICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdhc20vZGlzdC9wcm9vZk9mV29ya1dhc20uanNcXFwiKSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LXdhc20vZGlzdC9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wb3ctd2FzbS9kaXN0L3Byb29mT2ZXb3JrV2FzbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13YXNtL2Rpc3QvcHJvb2ZPZldvcmtXYXNtLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwidmFyIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvciAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IHN0ZXAoXFxcIm5leHRcXFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBzdGVwKFxcXCJ0aHJvd1xcXCIsIGVycik7IH0gX25leHQoKTsgfSk7IH07IH1cXG5cXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcXG4gICAgXFxcImRlZmF1bHRcXFwiOiBtb2RcXG4gIH07XFxufTtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pOyAvLy8gPHJlZmVyZW5jZSB0eXBlcz1cXFwiZW1zY3JpcHRlblxcXCIgLz5cXG5cXG52YXIgYXJyYXlIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBudW1iZXJIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgY3J5cHRvRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9lcnJvci9jcnlwdG9FcnJvci5qc1xcXCIpO1xcblxcbnZhciB0cnl0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVzLmpzXFxcIik7IC8vIEB0cy1pZ25vcmVcXG5cXG5cXG52YXIgaW90YV9waWNvX3Bvd193YXNtXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vd2FzbS9pb3RhLXBpY28tcG93LXdhc20gKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctd2FzbS93YXNtL2lvdGEtcGljby1wb3ctd2FzbS5qc1xcXCIpKTtcXG4vKipcXHJcXG4gKiBQcm9vZk9mV29yayBpbXBsZW1lbnRhdGlvbiB1c2luZyBXZWJBc3NlbWJseS5cXHJcXG4gKi9cXG5cXG5cXG52YXIgUHJvb2ZPZldvcmtXYXNtID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgLyoqXFxyXFxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgUHJvb2ZPZldvcmsuXFxyXFxuICAgKiBAcGFyYW0gd2ViUGxhdGZvcm0gUHJvdmlkZXMgcGxhdGZvcm0gc3BlY2lmaWMgZnVuY3Rpb25zLCBvcHRpb25hbCBtb3N0bHkgdXNlZCBmb3IgdGVzdGluZy5cXHJcXG4gICAqL1xcbiAgZnVuY3Rpb24gUHJvb2ZPZldvcmtXYXNtKHdlYlBsYXRmb3JtKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9vZk9mV29ya1dhc20pO1xcblxcbiAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkod2ViUGxhdGZvcm0pKSB7XFxuICAgICAgdGhpcy5fd2ViUGxhdGZvcm0gPSB7XFxuICAgICAgICB3ZWJBc3NlbWJseVR5cGU6IHR5cGVvZiBXZWJBc3NlbWJseSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoV2ViQXNzZW1ibHkpLFxcbiAgICAgICAgd2FzbU1vZHVsZUxvYWRlcjogaW90YV9waWNvX3Bvd193YXNtXzEuZGVmYXVsdFxcbiAgICAgIH07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5fd2ViUGxhdGZvcm0gPSB3ZWJQbGF0Zm9ybTtcXG4gICAgfVxcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBBbGxvdyB0aGUgcHJvb2Ygb2Ygd29yayB0byBwZXJmb3JtIGFueSBpbml0aWFsaXphdGlvbi5cXHJcXG4gICAqIFdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoUHJvb2ZPZldvcmtXYXNtLCBbe1xcbiAgICBrZXk6IFxcXCJpbml0aWFsaXplXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX2luaXRpYWxpemUgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShfdGhpcy5fd2ViUGxhdGZvcm0ud2ViQXNzZW1ibHlUeXBlKSB8fCBfdGhpcy5fd2ViUGxhdGZvcm0ud2ViQXNzZW1ibHlUeXBlID09PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJObyBXZWJBc3NlbWJseSBzdXBwb3J0IGRldGVjdGVkXFxcIikpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICB2YXIgbW9kdWxlID0ge307XFxuXFxuICAgICAgICAgICAgICAgICAgbW9kdWxlLm9uUnVudGltZUluaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NjdXJsUG93ID0gbW9kdWxlLmN3cmFwKFxcXCJjY3VybF9wb3dcXFwiLCBcXFwic3RyaW5nXFxcIiwgW1xcXCJzdHJpbmdcXFwiLCBcXFwibnVtYmVyXFxcIl0pO1xcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xcbiAgICAgICAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl93ZWJQbGF0Zm9ybS53YXNtTW9kdWxlTG9hZGVyKG1vZHVsZSk7XFxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZXJlIHdhcyBhIHByb2JsZW0gaW50aWFsaXppbmcgdGhlIFdlYkFzc2VtYmx5IE1vZHVsZVxcXCIsIHVuZGVmaW5lZCwgZXJyKSk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xcbiAgICAgICAgcmV0dXJuIF9pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qKlxcclxcbiAgICAgKiBQZXJmb3JtcyBzaW5nbGUgY29udmVyc2lvbiBwZXIgcG93IGNhbGwuXFxyXFxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgcG93IG9ubHkgZG9lcyBvbmUgY29udmVyc2lvbi5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInBlcmZvcm1zU2luZ2xlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1zU2luZ2xlKCkge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBQZXJmb3JtIGEgcHJvb2Ygb2Ygd29yayBvbiB0aGUgZGF0YS5cXHJcXG4gICAgICogQHBhcmFtIHRydW5rVHJhbnNhY3Rpb24gVGhlIHRydW5rVHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcG93LlxcclxcbiAgICAgKiBAcGFyYW0gYnJhbmNoVHJhbnNhY3Rpb24gVGhlIGJyYW5jaFRyYW5zYWN0aW9uIHRvIHVzZSBmb3IgdGhlIHBvdy5cXHJcXG4gICAgICogQHBhcmFtIHRyeXRlcyBUaGUgdHJ5dGVzIHRvIHBlcmZvcm0gdGhlIHBvdyBvbi5cXHJcXG4gICAgICogQHBhcmFtIG1pbldlaWdodE1hZ25pdHVkZSBUaGUgbWluaW11bSB3ZWlnaHQgbWFnbml0dWRlLlxcclxcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJ5dGVzIHByb2R1Y2VkIGJ5IHRoZSBwcm9vZiBvZiB3b3JrLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicG93XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3BvdyA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIodHJ1bmtUcmFuc2FjdGlvbiwgYnJhbmNoVHJhbnNhY3Rpb24sIHRyeXRlcywgbWluV2VpZ2h0TWFnbml0dWRlKSB7XFxuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcXFwicmV0dXJuXFxcIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xcbiAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShfdGhpczIuX2NjdXJsUG93KSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIldlYkFzc2VtYmx5IG5vdCBsb2FkZWQsIGhhdmUgeW91IGNhbGxlZCBpbml0aWFsaXplXFxcIik7XFxuICAgICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAgIGlmICghYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyeXRlcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSB0cnl0ZXMgbXVzdCBiZSBhbiBhcnJheSBvZiB0eXBlIFRyeXRlc1xcXCIpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgICBpZiAoIW51bWJlckhlbHBlcl8xLk51bWJlckhlbHBlci5pc0ludGVnZXIobWluV2VpZ2h0TWFnbml0dWRlKSB8fCBtaW5XZWlnaHRNYWduaXR1ZGUgPD0gMCkge1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIlRoZSBtaW5XZWlnaHRNYWduaXR1ZGUgbXVzdCBiZSA+IDBcXFwiKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpczIuX2NjdXJsUG93KHRyeXRlc1swXS50b1N0cmluZygpLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xcblxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbdHJ5dGVzXzEuVHJ5dGVzLmZyb21TdHJpbmcocmVzdWx0KV0pO1xcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KSk7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBvdyhfeCwgX3gyLCBfeDMsIF94NCkge1xcbiAgICAgICAgcmV0dXJuIF9wb3cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gIH1dKTtcXG5cXG4gIHJldHVybiBQcm9vZk9mV29ya1dhc207XFxufSgpO1xcblxcbmV4cG9ydHMuUHJvb2ZPZldvcmtXYXNtID0gUHJvb2ZPZldvcmtXYXNtO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy13YXNtL2Rpc3QvcHJvb2ZPZldvcmtXYXNtLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2FzbS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWdlbmVyYXRvci1ydW50aW1lICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdhc20vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcXFwiKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2FzbS9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdhc20vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2FzbS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxcbi8vIGtlcHQgaWRlbnRpY2FsIHRvIHRoZSB3YXkgaXQgaXMgb2J0YWluZWQgaW4gcnVudGltZS5qc1xcbnZhciBnID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFxcXCJyZXR1cm4gdGhpc1xcXCIpKCk7XFxuXFxuLy8gVXNlIGBnZXRPd25Qcm9wZXJ0eU5hbWVzYCBiZWNhdXNlIG5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCBjYWxsaW5nXFxuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxcbnZhciBoYWRSdW50aW1lID0gZy5yZWdlbmVyYXRvclJ1bnRpbWUgJiZcXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGcpLmluZGV4T2YoXFxcInJlZ2VuZXJhdG9yUnVudGltZVxcXCIpID49IDA7XFxuXFxuLy8gU2F2ZSB0aGUgb2xkIHJlZ2VuZXJhdG9yUnVudGltZSBpbiBjYXNlIGl0IG5lZWRzIHRvIGJlIHJlc3RvcmVkIGxhdGVyLlxcbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcXG5cXG4vLyBGb3JjZSByZWV2YWx1dGF0aW9uIG9mIHJ1bnRpbWUuanMuXFxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3J1bnRpbWUgKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctd2FzbS9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXFxcIik7XFxuXFxuaWYgKGhhZFJ1bnRpbWUpIHtcXG4gIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHJ1bnRpbWUuXFxuICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IG9sZFJ1bnRpbWU7XFxufSBlbHNlIHtcXG4gIC8vIFJlbW92ZSB0aGUgZ2xvYmFsIHByb3BlcnR5IGFkZGVkIGJ5IHJ1bnRpbWUuanMuXFxuICB0cnkge1xcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuICB9IGNhdGNoKGUpIHtcXG4gICAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XFxuICB9XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIi8qKlxcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxcbiAqXFxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXFxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxcbiAqL1xcblxcbiEoZnVuY3Rpb24oZ2xvYmFsKSB7XFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXFxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgPyBTeW1ib2wgOiB7fTtcXG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXFxcIkBAaXRlcmF0b3JcXFwiO1xcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXFxcIkBAYXN5bmNJdGVyYXRvclxcXCI7XFxuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFxcXCJAQHRvU3RyaW5nVGFnXFxcIjtcXG5cXG4gIHZhciBpbk1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT09IFxcXCJvYmplY3RcXFwiO1xcbiAgdmFyIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lO1xcbiAgaWYgKHJ1bnRpbWUpIHtcXG4gICAgaWYgKGluTW9kdWxlKSB7XFxuICAgICAgLy8gSWYgcmVnZW5lcmF0b3JSdW50aW1lIGlzIGRlZmluZWQgZ2xvYmFsbHkgYW5kIHdlJ3JlIGluIGEgbW9kdWxlLFxcbiAgICAgIC8vIG1ha2UgdGhlIGV4cG9ydHMgb2JqZWN0IGlkZW50aWNhbCB0byByZWdlbmVyYXRvclJ1bnRpbWUuXFxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xcbiAgICB9XFxuICAgIC8vIERvbid0IGJvdGhlciBldmFsdWF0aW5nIHRoZSByZXN0IG9mIHRoaXMgZmlsZSBpZiB0aGUgcnVudGltZSB3YXNcXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICAvLyBEZWZpbmUgdGhlIHJ1bnRpbWUgZ2xvYmFsbHkgKGFzIGV4cGVjdGVkIGJ5IGdlbmVyYXRlZCBjb2RlKSBhcyBlaXRoZXJcXG4gIC8vIG1vZHVsZS5leHBvcnRzIChpZiB3ZSdyZSBpbiBhIG1vZHVsZSkgb3IgYSBuZXcsIGVtcHR5IG9iamVjdC5cXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xcblxcbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XFxuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XFxuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xcblxcbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xcblxcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xcbiAgfVxcbiAgcnVudGltZS53cmFwID0gd3JhcDtcXG5cXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxcbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXFxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiB7IHR5cGU6IFxcXCJub3JtYWxcXFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIHJldHVybiB7IHR5cGU6IFxcXCJ0aHJvd1xcXCIsIGFyZzogZXJyIH07XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXFxcInN1c3BlbmRlZFN0YXJ0XFxcIjtcXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXFxcInN1c3BlbmRlZFlpZWxkXFxcIjtcXG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFxcXCJleGVjdXRpbmdcXFwiO1xcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXFxcImNvbXBsZXRlZFxcXCI7XFxuXFxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXFxuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXFxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xcblxcbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXFxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxcbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cXG5cXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcXG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXFxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcXG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcblxcbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXFxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXFxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXFxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XFxuICB9XFxuXFxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxcbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XFxuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcXG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIjtcXG5cXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXFxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxcbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xcbiAgICBbXFxcIm5leHRcXFwiLCBcXFwidGhyb3dcXFwiLCBcXFwicmV0dXJuXFxcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcXG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcXG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcXG4gICAgcmV0dXJuIGN0b3JcXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXFxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXFxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiXFxuICAgICAgOiBmYWxzZTtcXG4gIH07XFxuXFxuICBydW50aW1lLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcXG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XFxuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCI7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcXG4gICAgcmV0dXJuIGdlbkZ1bjtcXG4gIH07XFxuXFxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFxcXCJfX2F3YWl0XFxcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcXG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcXG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XFxuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XFxuICAgICAgICBpZiAodmFsdWUgJiZcXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFxcXCJvYmplY3RcXFwiICYmXFxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFxcXCJfX2F3YWl0XFxcIikpIHtcXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XFxuICAgICAgICAgICAgaW52b2tlKFxcXCJuZXh0XFxcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xcbiAgICAgICAgICAgIGludm9rZShcXFwidGhyb3dcXFwiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcXG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXFxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXFxuICAgICAgICAgIC8vIHJlc3VsdCBmb3IgdGhpcyBpdGVyYXRpb24gd2lsbCBiZSByZWplY3RlZCB3aXRoIHRoZSBzYW1lXFxuICAgICAgICAgIC8vIHJlYXNvbi4gTm90ZSB0aGF0IHJlamVjdGlvbnMgb2YgeWllbGRlZCBQcm9taXNlcyBhcmUgbm90XFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcXG4gICAgICAgICAgLy8gd2hlbiBhbiBhd2FpdGVkIFByb21pc2UgaXMgcmVqZWN0ZWQuIFRoaXMgZGlmZmVyZW5jZSBpblxcbiAgICAgICAgICAvLyBiZWhhdmlvciBiZXR3ZWVuIHlpZWxkIGFuZCBhd2FpdCBpcyBpbXBvcnRhbnQsIGJlY2F1c2UgaXRcXG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXFxuICAgICAgICAgIC8vIHJlamVjdGlvbiAoc3dhbGxvdyBpdCBhbmQgY29udGludWUsIG1hbnVhbGx5IC50aHJvdyBpdCBiYWNrXFxuICAgICAgICAgIC8vIGludG8gdGhlIGdlbmVyYXRvciwgYWJhbmRvbiBpdGVyYXRpb24sIHdoYXRldmVyKS4gV2l0aFxcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXFxuICAgICAgICAgIC8vIHJlamVjdGlvbiByZWFzb24gb3V0c2lkZSB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uLCBzbyB0aGVcXG4gICAgICAgICAgLy8gb25seSBvcHRpb24gaXMgdG8gdGhyb3cgaXQgZnJvbSB0aGUgYXdhaXQgZXhwcmVzc2lvbiwgYW5kXFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XFxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcXG4gICAgICAgIH0sIHJlamVjdCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XFxuXFxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcXG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxcbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXFxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xcbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xcbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XFxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcXG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XFxuICAgIH1cXG5cXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXFxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XFxuICB9XFxuXFxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG4gIHJ1bnRpbWUuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XFxuXFxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXFxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxcbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XFxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcXG4gICAgKTtcXG5cXG4gICAgcmV0dXJuIHJ1bnRpbWUuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXFxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcXG4gICAgICAgIH0pO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xcblxcbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XFxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcXG4gICAgICAgIGlmIChtZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgdGhyb3cgYXJnO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcXG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xcblxcbiAgICAgIHdoaWxlICh0cnVlKSB7XFxuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XFxuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwibmV4dFxcXCIpIHtcXG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXFxuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXFxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XFxuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcXG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcXG5cXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJyZXR1cm5cXFwiKSB7XFxuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFxcXCJyZXR1cm5cXFwiLCBjb250ZXh0LmFyZyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xcblxcbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwibm9ybWFsXFxcIikge1xcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XFxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xcblxcbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XFxuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXFxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXFxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxcbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcXG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcblxcbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yLnJldHVybikge1xcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXFxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwicmV0dXJuXFxcIjtcXG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xcblxcbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxcbiAgICAgICAgICAgIC8vIFxcXCJyZXR1cm5cXFwiIHRvIFxcXCJ0aHJvd1xcXCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXFxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcXG4gICAgICAgICAgXFxcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcXFwiKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcXG5cXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XFxuXFxuICAgIGlmICghIGluZm8pIHtcXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxcXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFxcXCIpO1xcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIGlmIChpbmZvLmRvbmUpIHtcXG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXFxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XFxuXFxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxcbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XFxuXFxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFxcXCJ0aHJvd1xcXCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXFxcIm5leHRcXFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cXG4gICAgICAvLyBcXFwiY29uc3VtZWRcXFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXFxuICAgICAgLy8gXFxcInJldHVyblxcXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXFxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxcbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgfVxcblxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cXG4gICAgICByZXR1cm4gaW5mbztcXG4gICAgfVxcblxcbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxcbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICB9XFxuXFxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxcbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcXG5cXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFxcXCJHZW5lcmF0b3JcXFwiO1xcblxcbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXFxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXFxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xcbiAgICByZXR1cm4gXFxcIltvYmplY3QgR2VuZXJhdG9yXVxcXCI7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcXG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcXG5cXG4gICAgaWYgKDEgaW4gbG9jcykge1xcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcXG4gICAgfVxcblxcbiAgICBpZiAoMiBpbiBsb2NzKSB7XFxuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XFxuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xcbiAgICB9XFxuXFxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcXG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XFxuICAgIHJlY29yZC50eXBlID0gXFxcIm5vcm1hbFxcXCI7XFxuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxcbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXFxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXFxcInJvb3RcXFwiIH1dO1xcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XFxuICAgIHRoaXMucmVzZXQodHJ1ZSk7XFxuICB9XFxuXFxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcXG4gICAgdmFyIGtleXMgPSBbXTtcXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xcbiAgICAgIGtleXMucHVzaChrZXkpO1xcbiAgICB9XFxuICAgIGtleXMucmV2ZXJzZSgpO1xcblxcbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcXG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcXG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XFxuICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxcbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XFxuICAgICAgcmV0dXJuIG5leHQ7XFxuICAgIH07XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XFxuICAgIGlmIChpdGVyYWJsZSkge1xcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcXG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcXG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuICAgICAgICByZXR1cm4gaXRlcmFibGU7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XFxuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XFxuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcXG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xcblxcbiAgICAgICAgICByZXR1cm4gbmV4dDtcXG4gICAgICAgIH07XFxuXFxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxcbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XFxuICB9XFxuICBydW50aW1lLnZhbHVlcyA9IHZhbHVlcztcXG5cXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XFxuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcXG4gIH1cXG5cXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcXG5cXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcXG4gICAgICB0aGlzLnByZXYgPSAwO1xcbiAgICAgIHRoaXMubmV4dCA9IDA7XFxuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxcbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XFxuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XFxuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5tZXRob2QgPSBcXFwibmV4dFxcXCI7XFxuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XFxuXFxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XFxuXFxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XFxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcXG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcXG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcXFwidFxcXCIgJiZcXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXFxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XFxuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XFxuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcXG5cXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XFxuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XFxuICAgIH0sXFxuXFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcXG4gICAgICBpZiAodGhpcy5kb25lKSB7XFxuICAgICAgICB0aHJvdyBleGNlcHRpb247XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcXG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcXG4gICAgICAgIHJlY29yZC50eXBlID0gXFxcInRocm93XFxcIjtcXG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XFxuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XFxuXFxuICAgICAgICBpZiAoY2F1Z2h0KSB7XFxuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXFxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xcblxcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXFxcInJvb3RcXFwiKSB7XFxuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXFxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xcbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxcbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFxcXCJlbmRcXFwiKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XFxuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcXFwiY2F0Y2hMb2NcXFwiKTtcXG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXFxcImZpbmFsbHlMb2NcXFwiKTtcXG5cXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcXFwiKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcXFwiZmluYWxseUxvY1xcXCIpICYmXFxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XFxuICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXFxuICAgICAgICAgICh0eXBlID09PSBcXFwiYnJlYWtcXFwiIHx8XFxuICAgICAgICAgICB0eXBlID09PSBcXFwiY29udGludWVcXFwiKSAmJlxcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcXG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xcblxcbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcXG4gICAgICAgIHRoaXMubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XFxuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcXG4gICAgfSxcXG5cXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcImJyZWFrXFxcIiB8fFxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXFxcImNvbnRpbnVlXFxcIikge1xcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcXG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcXFwicmV0dXJuXFxcIjtcXG4gICAgICAgIHRoaXMubmV4dCA9IFxcXCJlbmRcXFwiO1xcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJub3JtYWxcXFwiICYmIGFmdGVyTG9jKSB7XFxuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH0sXFxuXFxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XFxuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcXG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBcXFwiY2F0Y2hcXFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcXG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XFxuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHJldHVybiB0aHJvd247XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxcbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFxcXCIpO1xcbiAgICB9LFxcblxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XFxuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXFxuICAgICAgfTtcXG5cXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFxcXCJuZXh0XFxcIikge1xcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcXG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcbiAgfTtcXG59KShcXG4gIC8vIEluIHNsb3BweSBtb2RlLCB1bmJvdW5kIGB0aGlzYCByZWZlcnMgdG8gdGhlIGdsb2JhbCBvYmplY3QsIGZhbGxiYWNrIHRvXFxuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXFxuICAvLyBvZiBpbmRpcmVjdCBldmFsIHdoaWNoIHZpb2xhdGVzIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxcbiAgKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcyB9KSgpIHx8IEZ1bmN0aW9uKFxcXCJyZXR1cm4gdGhpc1xcXCIpKClcXG4pO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy13YXNtL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdhc20vd2FzbS9pb3RhLXBpY28tcG93LXdhc20uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2FzbS93YXNtL2lvdGEtcGljby1wb3ctd2FzbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHt2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187ZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XFxuXFxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZShfTW9kdWxlKSB7XFxuICBfTW9kdWxlID0gX01vZHVsZSB8fCB7fTsgLy8gVGhlIE1vZHVsZSBvYmplY3Q6IE91ciBpbnRlcmZhY2UgdG8gdGhlIG91dHNpZGUgd29ybGQuIFdlIGltcG9ydFxcbiAgLy8gYW5kIGV4cG9ydCB2YWx1ZXMgb24gaXQuIFRoZXJlIGFyZSB2YXJpb3VzIHdheXMgTW9kdWxlIGNhbiBiZSB1c2VkOlxcbiAgLy8gMS4gTm90IGRlZmluZWQuIFdlIGNyZWF0ZSBpdCBoZXJlXFxuICAvLyAyLiBBIGZ1bmN0aW9uIHBhcmFtZXRlciwgZnVuY3Rpb24oTW9kdWxlKSB7IC4uZ2VuZXJhdGVkIGNvZGUuLiB9XFxuICAvLyAzLiBwcmUtcnVuIGFwcGVuZGVkIGl0LCB2YXIgTW9kdWxlID0ge307IC4uZ2VuZXJhdGVkIGNvZGUuLlxcbiAgLy8gNC4gRXh0ZXJuYWwgc2NyaXB0IHRhZyBkZWZpbmVzIHZhciBNb2R1bGUuXFxuICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIE1vZHVsZSBhbHJlYWR5IGV4aXN0cyAoZS5nLiBjYXNlIDMgYWJvdmUpLlxcbiAgLy8gU3Vic3RpdHV0aW9uIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhY3R1YWwgY29kZSBvbiBsYXRlciBzdGFnZSBvZiB0aGUgYnVpbGQsXFxuICAvLyB0aGlzIHdheSBDbG9zdXJlIENvbXBpbGVyIHdpbGwgbm90IG1hbmdsZSBpdCAoZS5nLiBjYXNlIDQuIGFib3ZlKS5cXG4gIC8vIE5vdGUgdGhhdCBpZiB5b3Ugd2FudCB0byBydW4gY2xvc3VyZSwgYW5kIGFsc28gdG8gdXNlIE1vZHVsZVxcbiAgLy8gYWZ0ZXIgdGhlIGdlbmVyYXRlZCBjb2RlLCB5b3Ugd2lsbCBuZWVkIHRvIGRlZmluZSAgIHZhciBNb2R1bGUgPSB7fTtcXG4gIC8vIGJlZm9yZSB0aGUgY29kZS4gVGhlbiB0aGF0IG9iamVjdCB3aWxsIGJlIHVzZWQgaW4gdGhlIGNvZGUsIGFuZCB5b3VcXG4gIC8vIGNhbiBjb250aW51ZSB0byB1c2UgTW9kdWxlIGFmdGVyd2FyZHMgYXMgd2VsbC5cXG5cXG4gIHZhciBfTW9kdWxlID0gdHlwZW9mIF9Nb2R1bGUgIT09ICd1bmRlZmluZWQnID8gX01vZHVsZSA6IHt9OyAvLyAtLXByZS1qc2VzIGFyZSBlbWl0dGVkIGFmdGVyIHRoZSBNb2R1bGUgaW50ZWdyYXRpb24gY29kZSwgc28gdGhhdCB0aGV5IGNhblxcbiAgLy8gcmVmZXIgdG8gTW9kdWxlIChpZiB0aGV5IGNob29zZTsgdGhleSBjYW4gYWxzbyBkZWZpbmUgTW9kdWxlKVxcbiAgLy8ge3tQUkVfSlNFU319XFxuICAvLyBTb21ldGltZXMgYW4gZXhpc3RpbmcgTW9kdWxlIG9iamVjdCBleGlzdHMgd2l0aCBwcm9wZXJ0aWVzXFxuICAvLyBtZWFudCB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgbW9kdWxlIGZ1bmN0aW9uYWxpdHkuIEhlcmVcXG4gIC8vIHdlIGNvbGxlY3QgdGhvc2UgcHJvcGVydGllcyBhbmQgcmVhcHBseSBfYWZ0ZXJfIHdlIGNvbmZpZ3VyZVxcbiAgLy8gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBkZWZhdWx0cyB0byBhdm9pZCBoYXZpbmcgdG8gYmUgc29cXG4gIC8vIGRlZmVuc2l2ZSBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXFxuXFxuXFxuICB2YXIgbW9kdWxlT3ZlcnJpZGVzID0ge307XFxuICB2YXIga2V5O1xcblxcbiAgZm9yIChrZXkgaW4gX01vZHVsZSkge1xcbiAgICBpZiAoX01vZHVsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgICAgbW9kdWxlT3ZlcnJpZGVzW2tleV0gPSBfTW9kdWxlW2tleV07XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9Nb2R1bGVbJ2FyZ3VtZW50cyddID0gW107XFxuICBfTW9kdWxlWyd0aGlzUHJvZ3JhbSddID0gJy4vdGhpcy5wcm9ncmFtJztcXG5cXG4gIF9Nb2R1bGVbJ3F1aXQnXSA9IGZ1bmN0aW9uIChzdGF0dXMsIHRvVGhyb3cpIHtcXG4gICAgdGhyb3cgdG9UaHJvdztcXG4gIH07XFxuXFxuICBfTW9kdWxlWydwcmVSdW4nXSA9IFtdO1xcbiAgX01vZHVsZVsncG9zdFJ1biddID0gW107IC8vIFRoZSBlbnZpcm9ubWVudCBzZXR1cCBjb2RlIGJlbG93IGlzIGN1c3RvbWl6ZWQgdG8gdXNlIE1vZHVsZS5cXG4gIC8vICoqKiBFbnZpcm9ubWVudCBzZXR1cCBjb2RlICoqKlxcblxcbiAgdmFyIEVOVklST05NRU5UX0lTX1dFQiA9IGZhbHNlO1xcbiAgdmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IGZhbHNlO1xcbiAgdmFyIEVOVklST05NRU5UX0lTX05PREUgPSBmYWxzZTtcXG4gIHZhciBFTlZJUk9OTUVOVF9JU19TSEVMTCA9IGZhbHNlOyAvLyBUaHJlZSBjb25maWd1cmF0aW9ucyB3ZSBjYW4gYmUgcnVubmluZyBpbjpcXG4gIC8vIDEpIFdlIGNvdWxkIGJlIHRoZSBhcHBsaWNhdGlvbiBtYWluKCkgdGhyZWFkIHJ1bm5pbmcgaW4gdGhlIG1haW4gSlMgVUkgdGhyZWFkLiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSID09IGZhbHNlIGFuZCBFTlZJUk9OTUVOVF9JU19QVEhSRUFEID09IGZhbHNlKVxcbiAgLy8gMikgV2UgY291bGQgYmUgdGhlIGFwcGxpY2F0aW9uIG1haW4oKSB0aHJlYWQgcHJveGllZCB0byB3b3JrZXIuICh3aXRoIEVtc2NyaXB0ZW4gLXMgUFJPWFlfVE9fV09SS0VSPTEpIChFTlZJUk9OTUVOVF9JU19XT1JLRVIgPT0gdHJ1ZSwgRU5WSVJPTk1FTlRfSVNfUFRIUkVBRCA9PSBmYWxzZSlcXG4gIC8vIDMpIFdlIGNvdWxkIGJlIGFuIGFwcGxpY2F0aW9uIHB0aHJlYWQgcnVubmluZyBpbiBhIHdvcmtlci4gKEVOVklST05NRU5UX0lTX1dPUktFUiA9PSB0cnVlIGFuZCBFTlZJUk9OTUVOVF9JU19QVEhSRUFEID09IHRydWUpXFxuXFxuICBpZiAoX01vZHVsZVsnRU5WSVJPTk1FTlQnXSkge1xcbiAgICBpZiAoX01vZHVsZVsnRU5WSVJPTk1FTlQnXSA9PT0gJ1dFQicpIHtcXG4gICAgICBFTlZJUk9OTUVOVF9JU19XRUIgPSB0cnVlO1xcbiAgICB9IGVsc2UgaWYgKF9Nb2R1bGVbJ0VOVklST05NRU5UJ10gPT09ICdXT1JLRVInKSB7XFxuICAgICAgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gdHJ1ZTtcXG4gICAgfSBlbHNlIGlmIChfTW9kdWxlWydFTlZJUk9OTUVOVCddID09PSAnTk9ERScpIHtcXG4gICAgICBFTlZJUk9OTUVOVF9JU19OT0RFID0gdHJ1ZTtcXG4gICAgfSBlbHNlIGlmIChfTW9kdWxlWydFTlZJUk9OTUVOVCddID09PSAnU0hFTEwnKSB7XFxuICAgICAgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSB0cnVlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignTW9kdWxlW1xcXFwnRU5WSVJPTk1FTlRcXFxcJ10gdmFsdWUgaXMgbm90IHZhbGlkLiBtdXN0IGJlIG9uZSBvZjogV0VCfFdPUktFUnxOT0RFfFNIRUxMLicpO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBFTlZJUk9OTUVOVF9JU19XRUIgPSAodHlwZW9mIHdpbmRvdyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2Yod2luZG93KSkgPT09ICdvYmplY3QnO1xcbiAgICBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJztcXG4gICAgRU5WSVJPTk1FTlRfSVNfTk9ERSA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YocHJvY2VzcykpID09PSAnb2JqZWN0JyAmJiBcXFwiZnVuY3Rpb25cXFwiID09PSAnZnVuY3Rpb24nICYmICFFTlZJUk9OTUVOVF9JU19XRUIgJiYgIUVOVklST05NRU5UX0lTX1dPUktFUjtcXG4gICAgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XFxuICB9XFxuXFxuICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xcbiAgICAvLyBFeHBvc2UgZnVuY3Rpb25hbGl0eSBpbiB0aGUgc2FtZSBzaW1wbGUgd2F5IHRoYXQgdGhlIHNoZWxscyB3b3JrXFxuICAgIC8vIE5vdGUgdGhhdCB3ZSBwb2xsdXRlIHRoZSBnbG9iYWwgbmFtZXNwYWNlIGhlcmUsIG90aGVyd2lzZSB3ZSBicmVhayBpbiBub2RlXFxuICAgIHZhciBub2RlRlM7XFxuICAgIHZhciBub2RlUGF0aDtcXG5cXG4gICAgX01vZHVsZVsncmVhZCddID0gZnVuY3Rpb24gc2hlbGxfcmVhZChmaWxlbmFtZSwgYmluYXJ5KSB7XFxuICAgICAgdmFyIHJldDtcXG4gICAgICByZXQgPSB0cnlQYXJzZUFzRGF0YVVSSShmaWxlbmFtZSk7XFxuXFxuICAgICAgaWYgKCFyZXQpIHtcXG4gICAgICAgIGlmICghbm9kZUZTKSBub2RlRlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmcyAqLyBcXFwiLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbW9jay9lbXB0eS5qc1xcXCIpO1xcbiAgICAgICAgaWYgKCFub2RlUGF0aCkgbm9kZVBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwYXRoICovIFxcXCIuL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrL2VtcHR5LmpzXFxcIik7XFxuICAgICAgICBmaWxlbmFtZSA9IG5vZGVQYXRoWydub3JtYWxpemUnXShmaWxlbmFtZSk7XFxuICAgICAgICByZXQgPSBub2RlRlNbJ3JlYWRGaWxlU3luYyddKGZpbGVuYW1lKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGJpbmFyeSA/IHJldCA6IHJldC50b1N0cmluZygpO1xcbiAgICB9O1xcblxcbiAgICBfTW9kdWxlWydyZWFkQmluYXJ5J10gPSBmdW5jdGlvbiByZWFkQmluYXJ5KGZpbGVuYW1lKSB7XFxuICAgICAgdmFyIHJldCA9IF9Nb2R1bGVbJ3JlYWQnXShmaWxlbmFtZSwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKCFyZXQuYnVmZmVyKSB7XFxuICAgICAgICByZXQgPSBuZXcgVWludDhBcnJheShyZXQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBhc3NlcnQocmV0LmJ1ZmZlcik7XFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfTtcXG5cXG4gICAgaWYgKHByb2Nlc3NbJ2FyZ3YnXS5sZW5ndGggPiAxKSB7XFxuICAgICAgX01vZHVsZVsndGhpc1Byb2dyYW0nXSA9IHByb2Nlc3NbJ2FyZ3YnXVsxXS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnLycpO1xcbiAgICB9XFxuXFxuICAgIF9Nb2R1bGVbJ2FyZ3VtZW50cyddID0gcHJvY2Vzc1snYXJndiddLnNsaWNlKDIpOyAvLyBNT0RVTEFSSVpFIHdpbGwgZXhwb3J0IHRoZSBtb2R1bGUgaW4gdGhlIHByb3BlciBwbGFjZSBvdXRzaWRlLCB3ZSBkb24ndCBuZWVkIHRvIGV4cG9ydCBoZXJlXFxuXFxuICAgIHByb2Nlc3NbJ29uJ10oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgZnVuY3Rpb24gKGV4KSB7XFxuICAgICAgLy8gc3VwcHJlc3MgRXhpdFN0YXR1cyBleGNlcHRpb25zIGZyb20gc2hvd2luZyBhbiBlcnJvclxcbiAgICAgIGlmICghKGV4IGluc3RhbmNlb2YgRXhpdFN0YXR1cykpIHtcXG4gICAgICAgIHRocm93IGV4O1xcbiAgICAgIH1cXG4gICAgfSk7IC8vIEN1cnJlbnRseSBub2RlIHdpbGwgc3dhbGxvdyB1bmhhbmRsZWQgcmVqZWN0aW9ucywgYnV0IHRoaXMgYmVoYXZpb3IgaXNcXG4gICAgLy8gZGVwcmVjYXRlZCwgYW5kIGluIHRoZSBmdXR1cmUgaXQgd2lsbCBleGl0IHdpdGggZXJyb3Igc3RhdHVzLlxcblxcbiAgICBwcm9jZXNzWydvbiddKCd1bmhhbmRsZWRSZWplY3Rpb24nLCBmdW5jdGlvbiAocmVhc29uLCBwKSB7XFxuICAgICAgX01vZHVsZVsncHJpbnRFcnInXSgnbm9kZS5qcyBleGl0aW5nIGR1ZSB0byB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nKTtcXG5cXG4gICAgICBwcm9jZXNzWydleGl0J10oMSk7XFxuICAgIH0pO1xcblxcbiAgICBfTW9kdWxlWydpbnNwZWN0J10gPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuICdbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XSc7XFxuICAgIH07XFxuICB9IGVsc2UgaWYgKEVOVklST05NRU5UX0lTX1NIRUxMKSB7XFxuICAgIGlmICh0eXBlb2YgcmVhZCAhPSAndW5kZWZpbmVkJykge1xcbiAgICAgIF9Nb2R1bGVbJ3JlYWQnXSA9IGZ1bmN0aW9uIHNoZWxsX3JlYWQoZikge1xcbiAgICAgICAgdmFyIGRhdGEgPSB0cnlQYXJzZUFzRGF0YVVSSShmKTtcXG5cXG4gICAgICAgIGlmIChkYXRhKSB7XFxuICAgICAgICAgIHJldHVybiBpbnRBcnJheVRvU3RyaW5nKGRhdGEpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIHJlYWQoZik7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBfTW9kdWxlWydyZWFkQmluYXJ5J10gPSBmdW5jdGlvbiByZWFkQmluYXJ5KGYpIHtcXG4gICAgICB2YXIgZGF0YTtcXG4gICAgICBkYXRhID0gdHJ5UGFyc2VBc0RhdGFVUkkoZik7XFxuXFxuICAgICAgaWYgKGRhdGEpIHtcXG4gICAgICAgIHJldHVybiBkYXRhO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIHJlYWRidWZmZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZWFkYnVmZmVyKGYpKTtcXG4gICAgICB9XFxuXFxuICAgICAgZGF0YSA9IHJlYWQoZiwgJ2JpbmFyeScpO1xcbiAgICAgIGFzc2VydChfdHlwZW9mKGRhdGEpID09PSAnb2JqZWN0Jyk7XFxuICAgICAgcmV0dXJuIGRhdGE7XFxuICAgIH07XFxuXFxuICAgIGlmICh0eXBlb2Ygc2NyaXB0QXJncyAhPSAndW5kZWZpbmVkJykge1xcbiAgICAgIF9Nb2R1bGVbJ2FyZ3VtZW50cyddID0gc2NyaXB0QXJncztcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzICE9ICd1bmRlZmluZWQnKSB7XFxuICAgICAgX01vZHVsZVsnYXJndW1lbnRzJ10gPSBhcmd1bWVudHM7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBxdWl0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgX01vZHVsZVsncXVpdCddID0gZnVuY3Rpb24gKHN0YXR1cywgdG9UaHJvdykge1xcbiAgICAgICAgcXVpdChzdGF0dXMpO1xcbiAgICAgIH07XFxuICAgIH1cXG4gIH0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikge1xcbiAgICBfTW9kdWxlWydyZWFkJ10gPSBmdW5jdGlvbiBzaGVsbF9yZWFkKHVybCkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XFxuICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7XFxuICAgICAgICB4aHIuc2VuZChudWxsKTtcXG4gICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgdmFyIGRhdGEgPSB0cnlQYXJzZUFzRGF0YVVSSSh1cmwpO1xcblxcbiAgICAgICAgaWYgKGRhdGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGludEFycmF5VG9TdHJpbmcoZGF0YSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XFxuICAgICAgX01vZHVsZVsncmVhZEJpbmFyeSddID0gZnVuY3Rpb24gcmVhZEJpbmFyeSh1cmwpIHtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcXG4gICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcXG4gICAgICAgICAgeGhyLnNlbmQobnVsbCk7XFxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgIHZhciBkYXRhID0gdHJ5UGFyc2VBc0RhdGFVUkkodXJsKTtcXG5cXG4gICAgICAgICAgaWYgKGRhdGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBfTW9kdWxlWydyZWFkQXN5bmMnXSA9IGZ1bmN0aW9uIHJlYWRBc3luYyh1cmwsIG9ubG9hZCwgb25lcnJvcikge1xcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKTtcXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcXG5cXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24geGhyX29ubG9hZCgpIHtcXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCB8fCB4aHIuc3RhdHVzID09IDAgJiYgeGhyLnJlc3BvbnNlKSB7XFxuICAgICAgICAgIC8vIGZpbGUgVVJMcyBjYW4gcmV0dXJuIDBcXG4gICAgICAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBkYXRhID0gdHJ5UGFyc2VBc0RhdGFVUkkodXJsKTtcXG5cXG4gICAgICAgIGlmIChkYXRhKSB7XFxuICAgICAgICAgIG9ubG9hZChkYXRhLmJ1ZmZlcik7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG9uZXJyb3IoKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHhoci5vbmVycm9yID0gb25lcnJvcjtcXG4gICAgICB4aHIuc2VuZChudWxsKTtcXG4gICAgfTtcXG5cXG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHMgIT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICBfTW9kdWxlWydhcmd1bWVudHMnXSA9IGFyZ3VtZW50cztcXG4gICAgfVxcblxcbiAgICBfTW9kdWxlWydzZXRXaW5kb3dUaXRsZSddID0gZnVuY3Rpb24gKHRpdGxlKSB7XFxuICAgICAgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcXG4gICAgfTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIFVucmVhY2hhYmxlIGJlY2F1c2UgU0hFTEwgaXMgZGVwZW5kZW50IG9uIHRoZSBvdGhlcnNcXG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIHJ1bnRpbWUgZW52aXJvbm1lbnQnKTtcXG4gIH0gLy8gY29uc29sZS5sb2cgaXMgY2hlY2tlZCBmaXJzdCwgYXMgJ3ByaW50JyBvbiB0aGUgd2ViIHdpbGwgb3BlbiBhIHByaW50IGRpYWxvZ3VlXFxuICAvLyBwcmludEVyciBpcyBwcmVmZXJhYmxlIHRvIGNvbnNvbGUud2FybiAod29ya3MgYmV0dGVyIGluIHNoZWxscylcXG5cXG5cXG4gIF9Nb2R1bGVbJ3ByaW50J10gPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgPyBjb25zb2xlLmxvZyA6IHR5cGVvZiBwcmludCAhPT0gJ3VuZGVmaW5lZCcgPyBwcmludCA6IG51bGw7XFxuICBfTW9kdWxlWydwcmludEVyciddID0gdHlwZW9mIHByaW50RXJyICE9PSAndW5kZWZpbmVkJyA/IHByaW50RXJyIDogdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybiB8fCBfTW9kdWxlWydwcmludCddOyAvLyAqKiogRW52aXJvbm1lbnQgc2V0dXAgY29kZSAqKipcXG4gIC8vIENsb3N1cmUgaGVscGVyc1xcblxcbiAgX01vZHVsZS5wcmludCA9IF9Nb2R1bGVbJ3ByaW50J107XFxuICBfTW9kdWxlLnByaW50RXJyID0gX01vZHVsZVsncHJpbnRFcnInXTsgLy8gTWVyZ2UgYmFjayBpbiB0aGUgb3ZlcnJpZGVzXFxuXFxuICBmb3IgKGtleSBpbiBtb2R1bGVPdmVycmlkZXMpIHtcXG4gICAgaWYgKG1vZHVsZU92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XFxuICAgICAgX01vZHVsZVtrZXldID0gbW9kdWxlT3ZlcnJpZGVzW2tleV07XFxuICAgIH1cXG4gIH0gLy8gRnJlZSB0aGUgb2JqZWN0IGhpZXJhcmNoeSBjb250YWluZWQgaW4gdGhlIG92ZXJyaWRlcywgdGhpcyBsZXRzIHRoZSBHQ1xcbiAgLy8gcmVjbGFpbSBkYXRhIHVzZWQgZS5nLiBpbiBtZW1vcnlJbml0aWFsaXplclJlcXVlc3QsIHdoaWNoIGlzIGEgbGFyZ2UgdHlwZWQgYXJyYXkuXFxuXFxuXFxuICBtb2R1bGVPdmVycmlkZXMgPSB1bmRlZmluZWQ7IC8vIHt7UFJFQU1CTEVfQURESVRJT05TfX1cXG5cXG4gIHZhciBTVEFDS19BTElHTiA9IDE2OyAvLyBzdGFjayBtYW5hZ2VtZW50LCBhbmQgb3RoZXIgZnVuY3Rpb25hbGl0eSB0aGF0IGlzIHByb3ZpZGVkIGJ5IHRoZSBjb21waWxlZCBjb2RlLFxcbiAgLy8gc2hvdWxkIG5vdCBiZSB1c2VkIGJlZm9yZSBpdCBpcyByZWFkeVxcblxcbiAgX3N0YWNrU2F2ZSA9IF9zdGFja1Jlc3RvcmUgPSBzdGFja0FsbG9jID0gc2V0VGVtcFJldDAgPSBnZXRUZW1wUmV0MCA9IGZ1bmN0aW9uIGdldFRlbXBSZXQwKCkge1xcbiAgICBhYm9ydCgnY2Fubm90IHVzZSB0aGUgc3RhY2sgYmVmb3JlIGNvbXBpbGVkIGNvZGUgaXMgcmVhZHkgdG8gcnVuLCBhbmQgaGFzIHByb3ZpZGVkIHN0YWNrIGFjY2VzcycpO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIHN0YXRpY0FsbG9jKHNpemUpIHtcXG4gICAgYXNzZXJ0KCFzdGF0aWNTZWFsZWQpO1xcbiAgICB2YXIgcmV0ID0gU1RBVElDVE9QO1xcbiAgICBTVEFUSUNUT1AgPSBTVEFUSUNUT1AgKyBzaXplICsgMTUgJiAtMTY7XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkeW5hbWljQWxsb2Moc2l6ZSkge1xcbiAgICBhc3NlcnQoRFlOQU1JQ1RPUF9QVFIpO1xcbiAgICB2YXIgcmV0ID0gSEVBUDMyW0RZTkFNSUNUT1BfUFRSID4+IDJdO1xcbiAgICB2YXIgZW5kID0gcmV0ICsgc2l6ZSArIDE1ICYgLTE2O1xcbiAgICBIRUFQMzJbRFlOQU1JQ1RPUF9QVFIgPj4gMl0gPSBlbmQ7XFxuXFxuICAgIGlmIChlbmQgPj0gVE9UQUxfTUVNT1JZKSB7XFxuICAgICAgdmFyIHN1Y2Nlc3MgPSBlbmxhcmdlTWVtb3J5KCk7XFxuXFxuICAgICAgaWYgKCFzdWNjZXNzKSB7XFxuICAgICAgICBIRUFQMzJbRFlOQU1JQ1RPUF9QVFIgPj4gMl0gPSByZXQ7XFxuICAgICAgICByZXR1cm4gMDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFsaWduTWVtb3J5KHNpemUsIGZhY3Rvcikge1xcbiAgICBpZiAoIWZhY3RvcikgZmFjdG9yID0gU1RBQ0tfQUxJR047IC8vIHN0YWNrIGFsaWdubWVudCAoMTYtYnl0ZSkgYnkgZGVmYXVsdFxcblxcbiAgICB2YXIgcmV0ID0gc2l6ZSA9IE1hdGguY2VpbChzaXplIC8gZmFjdG9yKSAqIGZhY3RvcjtcXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldE5hdGl2ZVR5cGVTaXplKHR5cGUpIHtcXG4gICAgc3dpdGNoICh0eXBlKSB7XFxuICAgICAgY2FzZSAnaTEnOlxcbiAgICAgIGNhc2UgJ2k4JzpcXG4gICAgICAgIHJldHVybiAxO1xcblxcbiAgICAgIGNhc2UgJ2kxNic6XFxuICAgICAgICByZXR1cm4gMjtcXG5cXG4gICAgICBjYXNlICdpMzInOlxcbiAgICAgICAgcmV0dXJuIDQ7XFxuXFxuICAgICAgY2FzZSAnaTY0JzpcXG4gICAgICAgIHJldHVybiA4O1xcblxcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcXG4gICAgICAgIHJldHVybiA0O1xcblxcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XFxuICAgICAgICByZXR1cm4gODtcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAge1xcbiAgICAgICAgICBpZiAodHlwZVt0eXBlLmxlbmd0aCAtIDFdID09PSAnKicpIHtcXG4gICAgICAgICAgICByZXR1cm4gNDsgLy8gQSBwb2ludGVyXFxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZVswXSA9PT0gJ2knKSB7XFxuICAgICAgICAgICAgdmFyIGJpdHMgPSBwYXJzZUludCh0eXBlLnN1YnN0cigxKSk7XFxuICAgICAgICAgICAgYXNzZXJ0KGJpdHMgJSA4ID09PSAwKTtcXG4gICAgICAgICAgICByZXR1cm4gYml0cyAvIDg7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuIDA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gd2Fybk9uY2UodGV4dCkge1xcbiAgICBpZiAoIXdhcm5PbmNlLnNob3duKSB3YXJuT25jZS5zaG93biA9IHt9O1xcblxcbiAgICBpZiAoIXdhcm5PbmNlLnNob3duW3RleHRdKSB7XFxuICAgICAgd2Fybk9uY2Uuc2hvd25bdGV4dF0gPSAxO1xcblxcbiAgICAgIF9Nb2R1bGUucHJpbnRFcnIodGV4dCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBmdW5jdGlvblBvaW50ZXJzID0gbmV3IEFycmF5KDApO1xcblxcbiAgZnVuY3Rpb24gYWRkRnVuY3Rpb24oZnVuYykge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmN0aW9uUG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcXG4gICAgICBpZiAoIWZ1bmN0aW9uUG9pbnRlcnNbaV0pIHtcXG4gICAgICAgIGZ1bmN0aW9uUG9pbnRlcnNbaV0gPSBmdW5jO1xcbiAgICAgICAgcmV0dXJuIDEgKyBpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB0aHJvdyAnRmluaXNoZWQgdXAgYWxsIHJlc2VydmVkIGZ1bmN0aW9uIHBvaW50ZXJzLiBVc2UgYSBoaWdoZXIgdmFsdWUgZm9yIFJFU0VSVkVEX0ZVTkNUSU9OX1BPSU5URVJTLic7XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZW1vdmVGdW5jdGlvbihpbmRleCkge1xcbiAgICBmdW5jdGlvblBvaW50ZXJzW2luZGV4IC0gMV0gPSBudWxsO1xcbiAgfVxcblxcbiAgdmFyIGZ1bmNXcmFwcGVycyA9IHt9O1xcblxcbiAgZnVuY3Rpb24gZ2V0RnVuY1dyYXBwZXIoZnVuYywgc2lnKSB7XFxuICAgIGlmICghZnVuYykgcmV0dXJuOyAvLyBvbiBudWxsIHBvaW50ZXIsIHJldHVybiB1bmRlZmluZWRcXG5cXG4gICAgYXNzZXJ0KHNpZyk7XFxuXFxuICAgIGlmICghZnVuY1dyYXBwZXJzW3NpZ10pIHtcXG4gICAgICBmdW5jV3JhcHBlcnNbc2lnXSA9IHt9O1xcbiAgICB9XFxuXFxuICAgIHZhciBzaWdDYWNoZSA9IGZ1bmNXcmFwcGVyc1tzaWddO1xcblxcbiAgICBpZiAoIXNpZ0NhY2hlW2Z1bmNdKSB7XFxuICAgICAgLy8gb3B0aW1pemUgYXdheSBhcmd1bWVudHMgdXNhZ2UgaW4gY29tbW9uIGNhc2VzXFxuICAgICAgaWYgKHNpZy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgIHNpZ0NhY2hlW2Z1bmNdID0gZnVuY3Rpb24gZHluQ2FsbF93cmFwcGVyKCkge1xcbiAgICAgICAgICByZXR1cm4gZHluQ2FsbChzaWcsIGZ1bmMpO1xcbiAgICAgICAgfTtcXG4gICAgICB9IGVsc2UgaWYgKHNpZy5sZW5ndGggPT09IDIpIHtcXG4gICAgICAgIHNpZ0NhY2hlW2Z1bmNdID0gZnVuY3Rpb24gZHluQ2FsbF93cmFwcGVyKGFyZykge1xcbiAgICAgICAgICByZXR1cm4gZHluQ2FsbChzaWcsIGZ1bmMsIFthcmddKTtcXG4gICAgICAgIH07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIGdlbmVyYWwgY2FzZVxcbiAgICAgICAgc2lnQ2FjaGVbZnVuY10gPSBmdW5jdGlvbiBkeW5DYWxsX3dyYXBwZXIoKSB7XFxuICAgICAgICAgIHJldHVybiBkeW5DYWxsKHNpZywgZnVuYywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gc2lnQ2FjaGVbZnVuY107XFxuICB9XFxuXFxuICBmdW5jdGlvbiBtYWtlQmlnSW50KGxvdywgaGlnaCwgdW5zaWduZWQpIHtcXG4gICAgcmV0dXJuIHVuc2lnbmVkID8gKyhsb3cgPj4+IDApICsgKyhoaWdoID4+PiAwKSAqIDQyOTQ5NjcyOTYuMCA6ICsobG93ID4+PiAwKSArICsoaGlnaCB8IDApICogNDI5NDk2NzI5Ni4wO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZHluQ2FsbChzaWcsIHB0ciwgYXJncykge1xcbiAgICBpZiAoYXJncyAmJiBhcmdzLmxlbmd0aCkge1xcbiAgICAgIGFzc2VydChhcmdzLmxlbmd0aCA9PSBzaWcubGVuZ3RoIC0gMSk7XFxuICAgICAgYXNzZXJ0KCdkeW5DYWxsXycgKyBzaWcgaW4gX01vZHVsZSwgJ2JhZCBmdW5jdGlvbiBwb2ludGVyIHR5cGUgLSBubyB0YWJsZSBmb3Igc2lnIFxcXFwnJyArIHNpZyArICdcXFxcJycpO1xcbiAgICAgIHJldHVybiBfTW9kdWxlWydkeW5DYWxsXycgKyBzaWddLmFwcGx5KG51bGwsIFtwdHJdLmNvbmNhdChhcmdzKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgYXNzZXJ0KHNpZy5sZW5ndGggPT0gMSk7XFxuICAgICAgYXNzZXJ0KCdkeW5DYWxsXycgKyBzaWcgaW4gX01vZHVsZSwgJ2JhZCBmdW5jdGlvbiBwb2ludGVyIHR5cGUgLSBubyB0YWJsZSBmb3Igc2lnIFxcXFwnJyArIHNpZyArICdcXFxcJycpO1xcbiAgICAgIHJldHVybiBfTW9kdWxlWydkeW5DYWxsXycgKyBzaWddLmNhbGwobnVsbCwgcHRyKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0Q29tcGlsZXJTZXR0aW5nKG5hbWUpIHtcXG4gICAgdGhyb3cgJ1lvdSBtdXN0IGJ1aWxkIHdpdGggLXMgUkVUQUlOX0NPTVBJTEVSX1NFVFRJTkdTPTEgZm9yIGdldENvbXBpbGVyU2V0dGluZyBvciBlbXNjcmlwdGVuX2dldF9jb21waWxlcl9zZXR0aW5nIHRvIHdvcmsnO1xcbiAgfVxcblxcbiAgdmFyIFJ1bnRpbWUgPSB7XFxuICAgIC8vIEZJWE1FIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGxheWVyIGZvciBwb3J0cy4gU3VwcG9ydCBzb21lIFJ1bnRpbWUuKlxcbiAgICAvLyAgICAgICBmb3Igbm93LCBmaXggaXQgdGhlcmUsIHRoZW4gcmVtb3ZlIGl0IGZyb20gaGVyZS4gVGhhdCB3YXkgd2VcXG4gICAgLy8gICAgICAgY2FuIG1pbmltaXplIGFueSBwZXJpb2Qgb2YgYnJlYWthZ2UuXFxuICAgIGR5bkNhbGw6IGR5bkNhbGwsXFxuICAgIC8vIGZvciBTREwyIHBvcnRcXG4gICAgLy8gaGVscGZ1bCBlcnJvcnNcXG4gICAgZ2V0VGVtcFJldDA6IGZ1bmN0aW9uIGdldFRlbXBSZXQwKCkge1xcbiAgICAgIGFib3J0KCdnZXRUZW1wUmV0MCgpIGlzIG5vdyBhIHRvcC1sZXZlbCBmdW5jdGlvbiwgYWZ0ZXIgcmVtb3ZpbmcgdGhlIFJ1bnRpbWUgb2JqZWN0LiBSZW1vdmUgXFxcIlJ1bnRpbWUuXFxcIicpO1xcbiAgICB9LFxcbiAgICBzdGF0aWNBbGxvYzogZnVuY3Rpb24gc3RhdGljQWxsb2MoKSB7XFxuICAgICAgYWJvcnQoJ3N0YXRpY0FsbG9jKCkgaXMgbm93IGEgdG9wLWxldmVsIGZ1bmN0aW9uLCBhZnRlciByZW1vdmluZyB0aGUgUnVudGltZSBvYmplY3QuIFJlbW92ZSBcXFwiUnVudGltZS5cXFwiJyk7XFxuICAgIH0sXFxuICAgIHN0YWNrQWxsb2M6IGZ1bmN0aW9uIHN0YWNrQWxsb2MoKSB7XFxuICAgICAgYWJvcnQoJ3N0YWNrQWxsb2MoKSBpcyBub3cgYSB0b3AtbGV2ZWwgZnVuY3Rpb24sIGFmdGVyIHJlbW92aW5nIHRoZSBSdW50aW1lIG9iamVjdC4gUmVtb3ZlIFxcXCJSdW50aW1lLlxcXCInKTtcXG4gICAgfVxcbiAgfTsgLy8gVGhlIGFkZHJlc3MgZ2xvYmFscyBiZWdpbiBhdC4gVmVyeSBsb3cgaW4gbWVtb3J5LCBmb3IgY29kZSBzaXplIGFuZCBvcHRpbWl6YXRpb24gb3Bwb3J0dW5pdGllcy5cXG4gIC8vIEFib3ZlIDAgaXMgc3RhdGljIG1lbW9yeSwgc3RhcnRpbmcgd2l0aCBnbG9iYWxzLlxcbiAgLy8gVGhlbiB0aGUgc3RhY2suXFxuICAvLyBUaGVuICdkeW5hbWljJyBtZW1vcnkgZm9yIHNicmsuXFxuXFxuICB2YXIgR0xPQkFMX0JBU0UgPSAxMDI0OyAvLyA9PT0gUHJlYW1ibGUgbGlicmFyeSBzdHVmZiA9PT1cXG4gIC8vIERvY3VtZW50YXRpb24gZm9yIHRoZSBwdWJsaWMgQVBJcyBkZWZpbmVkIGluIHRoaXMgZmlsZSBtdXN0IGJlIHVwZGF0ZWQgaW46XFxuICAvLyAgICBzaXRlL3NvdXJjZS9kb2NzL2FwaV9yZWZlcmVuY2UvcHJlYW1ibGUuanMucnN0XFxuICAvLyBBIHByZWJ1aWx0IGxvY2FsIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50YXRpb24gaXMgYXZhaWxhYmxlIGF0OlxcbiAgLy8gICAgc2l0ZS9idWlsZC90ZXh0L2RvY3MvYXBpX3JlZmVyZW5jZS9wcmVhbWJsZS5qcy50eHRcXG4gIC8vIFlvdSBjYW4gYWxzbyBidWlsZCBkb2NzIGxvY2FsbHkgYXMgSFRNTCBvciBvdGhlciBmb3JtYXRzIGluIHNpdGUvXFxuICAvLyBBbiBvbmxpbmUgSFRNTCB2ZXJzaW9uICh3aGljaCBtYXkgYmUgb2YgYSBkaWZmZXJlbnQgdmVyc2lvbiBvZiBFbXNjcmlwdGVuKVxcbiAgLy8gICAgaXMgdXAgYXQgaHR0cDovL2tyaXBrZW4uZ2l0aHViLmlvL2Vtc2NyaXB0ZW4tc2l0ZS9kb2NzL2FwaV9yZWZlcmVuY2UvcHJlYW1ibGUuanMuaHRtbFxcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuICAvLyBSdW50aW1lIGVzc2VudGlhbHNcXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblxcbiAgdmFyIEFCT1JUID0gMDsgLy8gd2hldGhlciB3ZSBhcmUgcXVpdHRpbmcgdGhlIGFwcGxpY2F0aW9uLiBubyBjb2RlIHNob3VsZCBydW4gYWZ0ZXIgdGhpcy4gc2V0IGluIGV4aXQoKSBhbmQgYWJvcnQoKVxcblxcbiAgdmFyIEVYSVRTVEFUVVMgPSAwO1xcbiAgLyoqIEB0eXBlIHtmdW5jdGlvbigqLCBzdHJpbmc9KX0gKi9cXG5cXG4gIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcXG4gICAgaWYgKCFjb25kaXRpb24pIHtcXG4gICAgICBhYm9ydCgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIHRleHQpO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgZ2xvYmFsU2NvcGUgPSB0aGlzOyAvLyBSZXR1cm5zIHRoZSBDIGZ1bmN0aW9uIHdpdGggYSBzcGVjaWZpZWQgaWRlbnRpZmllciAoZm9yIEMrKywgeW91IG5lZWQgdG8gZG8gbWFudWFsIG5hbWUgbWFuZ2xpbmcpXFxuXFxuICBmdW5jdGlvbiBnZXRDRnVuYyhpZGVudCkge1xcbiAgICB2YXIgZnVuYyA9IF9Nb2R1bGVbJ18nICsgaWRlbnRdOyAvLyBjbG9zdXJlIGV4cG9ydGVkIGZ1bmN0aW9uXFxuXFxuICAgIGFzc2VydChmdW5jLCAnQ2Fubm90IGNhbGwgdW5rbm93biBmdW5jdGlvbiAnICsgaWRlbnQgKyAnLCBtYWtlIHN1cmUgaXQgaXMgZXhwb3J0ZWQnKTtcXG4gICAgcmV0dXJuIGZ1bmM7XFxuICB9XFxuXFxuICB2YXIgSlNmdW5jcyA9IHtcXG4gICAgLy8gSGVscGVycyBmb3IgY3dyYXAgLS0gaXQgY2FuJ3QgcmVmZXIgdG8gUnVudGltZSBkaXJlY3RseSBiZWNhdXNlIGl0IG1pZ2h0XFxuICAgIC8vIGJlIHJlbmFtZWQgYnkgY2xvc3VyZSwgaW5zdGVhZCBpdCBjYWxscyBKU2Z1bmNzWydzdGFja1NhdmUnXS5ib2R5IHRvIGZpbmRcXG4gICAgLy8gb3V0IHdoYXQgdGhlIG1pbmlmaWVkIGZ1bmN0aW9uIG5hbWUgaXMuXFxuICAgICdzdGFja1NhdmUnOiBmdW5jdGlvbiBzdGFja1NhdmUoKSB7XFxuICAgICAgX3N0YWNrU2F2ZSgpO1xcbiAgICB9LFxcbiAgICAnc3RhY2tSZXN0b3JlJzogZnVuY3Rpb24gc3RhY2tSZXN0b3JlKCkge1xcbiAgICAgIF9zdGFja1Jlc3RvcmUoKTtcXG4gICAgfSxcXG4gICAgLy8gdHlwZSBjb252ZXJzaW9uIGZyb20ganMgdG8gY1xcbiAgICAnYXJyYXlUb0MnOiBmdW5jdGlvbiBhcnJheVRvQyhhcnIpIHtcXG4gICAgICB2YXIgcmV0ID0gc3RhY2tBbGxvYyhhcnIubGVuZ3RoKTtcXG4gICAgICB3cml0ZUFycmF5VG9NZW1vcnkoYXJyLCByZXQpO1xcbiAgICAgIHJldHVybiByZXQ7XFxuICAgIH0sXFxuICAgICdzdHJpbmdUb0MnOiBmdW5jdGlvbiBzdHJpbmdUb0Moc3RyKSB7XFxuICAgICAgdmFyIHJldCA9IDA7XFxuXFxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCAmJiBzdHIgIT09IHVuZGVmaW5lZCAmJiBzdHIgIT09IDApIHtcXG4gICAgICAgIC8vIG51bGwgc3RyaW5nXFxuICAgICAgICAvLyBhdCBtb3N0IDQgYnl0ZXMgcGVyIFVURi04IGNvZGUgcG9pbnQsICsxIGZvciB0aGUgdHJhaWxpbmcgJ1xcXFwwJ1xcbiAgICAgICAgdmFyIGxlbiA9IChzdHIubGVuZ3RoIDw8IDIpICsgMTtcXG4gICAgICAgIHJldCA9IHN0YWNrQWxsb2MobGVuKTtcXG4gICAgICAgIHN0cmluZ1RvVVRGOChzdHIsIHJldCwgbGVuKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfVxcbiAgfTsgLy8gRm9yIGZhc3QgbG9va3VwIG9mIGNvbnZlcnNpb24gZnVuY3Rpb25zXFxuXFxuICB2YXIgdG9DID0ge1xcbiAgICAnc3RyaW5nJzogSlNmdW5jc1snc3RyaW5nVG9DJ10sXFxuICAgICdhcnJheSc6IEpTZnVuY3NbJ2FycmF5VG9DJ11cXG4gIH07IC8vIEMgY2FsbGluZyBpbnRlcmZhY2UuXFxuXFxuICBmdW5jdGlvbiBjY2FsbChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMsIGFyZ3MsIG9wdHMpIHtcXG4gICAgdmFyIGZ1bmMgPSBnZXRDRnVuYyhpZGVudCk7XFxuICAgIHZhciBjQXJncyA9IFtdO1xcbiAgICB2YXIgc3RhY2sgPSAwO1xcbiAgICBhc3NlcnQocmV0dXJuVHlwZSAhPT0gJ2FycmF5JywgJ1JldHVybiB0eXBlIHNob3VsZCBub3QgYmUgXFxcImFycmF5XFxcIi4nKTtcXG5cXG4gICAgaWYgKGFyZ3MpIHtcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhciBjb252ZXJ0ZXIgPSB0b0NbYXJnVHlwZXNbaV1dO1xcblxcbiAgICAgICAgaWYgKGNvbnZlcnRlcikge1xcbiAgICAgICAgICBpZiAoc3RhY2sgPT09IDApIHN0YWNrID0gX3N0YWNrU2F2ZSgpO1xcbiAgICAgICAgICBjQXJnc1tpXSA9IGNvbnZlcnRlcihhcmdzW2ldKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGNBcmdzW2ldID0gYXJnc1tpXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyIHJldCA9IGZ1bmMuYXBwbHkobnVsbCwgY0FyZ3MpO1xcbiAgICBpZiAocmV0dXJuVHlwZSA9PT0gJ3N0cmluZycpIHJldCA9IFBvaW50ZXJfc3RyaW5naWZ5KHJldCk7XFxuXFxuICAgIGlmIChzdGFjayAhPT0gMCkge1xcbiAgICAgIF9zdGFja1Jlc3RvcmUoc3RhY2spO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjd3JhcChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMpIHtcXG4gICAgYXJnVHlwZXMgPSBhcmdUeXBlcyB8fCBbXTtcXG4gICAgdmFyIGNmdW5jID0gZ2V0Q0Z1bmMoaWRlbnQpOyAvLyBXaGVuIHRoZSBmdW5jdGlvbiB0YWtlcyBudW1iZXJzIGFuZCByZXR1cm5zIGEgbnVtYmVyLCB3ZSBjYW4ganVzdCByZXR1cm5cXG4gICAgLy8gdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXFxuXFxuICAgIHZhciBudW1lcmljQXJncyA9IGFyZ1R5cGVzLmV2ZXJ5KGZ1bmN0aW9uICh0eXBlKSB7XFxuICAgICAgcmV0dXJuIHR5cGUgPT09ICdudW1iZXInO1xcbiAgICB9KTtcXG4gICAgdmFyIG51bWVyaWNSZXQgPSByZXR1cm5UeXBlICE9PSAnc3RyaW5nJztcXG5cXG4gICAgaWYgKG51bWVyaWNSZXQgJiYgbnVtZXJpY0FyZ3MpIHtcXG4gICAgICByZXR1cm4gY2Z1bmM7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gY2NhbGwoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzLCBhcmd1bWVudHMpO1xcbiAgICB9O1xcbiAgfVxcbiAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIG51bWJlciwgc3RyaW5nLCBib29sZWFuPSl9ICovXFxuXFxuXFxuICBmdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlLCBub1NhZmUpIHtcXG4gICAgdHlwZSA9IHR5cGUgfHwgJ2k4JztcXG4gICAgaWYgKHR5cGUuY2hhckF0KHR5cGUubGVuZ3RoIC0gMSkgPT09ICcqJykgdHlwZSA9ICdpMzInOyAvLyBwb2ludGVycyBhcmUgMzItYml0XFxuXFxuICAgIHN3aXRjaCAodHlwZSkge1xcbiAgICAgIGNhc2UgJ2kxJzpcXG4gICAgICAgIEhFQVA4W3B0ciA+PiAwXSA9IHZhbHVlO1xcbiAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgY2FzZSAnaTgnOlxcbiAgICAgICAgSEVBUDhbcHRyID4+IDBdID0gdmFsdWU7XFxuICAgICAgICBicmVhaztcXG5cXG4gICAgICBjYXNlICdpMTYnOlxcbiAgICAgICAgSEVBUDE2W3B0ciA+PiAxXSA9IHZhbHVlO1xcbiAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgY2FzZSAnaTMyJzpcXG4gICAgICAgIEhFQVAzMltwdHIgPj4gMl0gPSB2YWx1ZTtcXG4gICAgICAgIGJyZWFrO1xcblxcbiAgICAgIGNhc2UgJ2k2NCc6XFxuICAgICAgICB0ZW1wSTY0ID0gW3ZhbHVlID4+PiAwLCAodGVtcERvdWJsZSA9IHZhbHVlLCArTWF0aF9hYnModGVtcERvdWJsZSkgPj0gMS4wID8gdGVtcERvdWJsZSA+IDAuMCA/IChNYXRoX21pbigrTWF0aF9mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5Ni4wKSwgNDI5NDk2NzI5NS4wKSB8IDApID4+PiAwIDogfn4rTWF0aF9jZWlsKCh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYuMCkgPj4+IDAgOiAwKV0sIEhFQVAzMltwdHIgPj4gMl0gPSB0ZW1wSTY0WzBdLCBIRUFQMzJbcHRyICsgNCA+PiAyXSA9IHRlbXBJNjRbMV07XFxuICAgICAgICBicmVhaztcXG5cXG4gICAgICBjYXNlICdmbG9hdCc6XFxuICAgICAgICBIRUFQRjMyW3B0ciA+PiAyXSA9IHZhbHVlO1xcbiAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgY2FzZSAnZG91YmxlJzpcXG4gICAgICAgIEhFQVBGNjRbcHRyID4+IDNdID0gdmFsdWU7XFxuICAgICAgICBicmVhaztcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgYWJvcnQoJ2ludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICcgKyB0eXBlKTtcXG4gICAgfVxcbiAgfVxcbiAgLyoqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIsIHN0cmluZywgYm9vbGVhbj0pfSAqL1xcblxcblxcbiAgZnVuY3Rpb24gZ2V0VmFsdWUocHRyLCB0eXBlLCBub1NhZmUpIHtcXG4gICAgdHlwZSA9IHR5cGUgfHwgJ2k4JztcXG4gICAgaWYgKHR5cGUuY2hhckF0KHR5cGUubGVuZ3RoIC0gMSkgPT09ICcqJykgdHlwZSA9ICdpMzInOyAvLyBwb2ludGVycyBhcmUgMzItYml0XFxuXFxuICAgIHN3aXRjaCAodHlwZSkge1xcbiAgICAgIGNhc2UgJ2kxJzpcXG4gICAgICAgIHJldHVybiBIRUFQOFtwdHIgPj4gMF07XFxuXFxuICAgICAgY2FzZSAnaTgnOlxcbiAgICAgICAgcmV0dXJuIEhFQVA4W3B0ciA+PiAwXTtcXG5cXG4gICAgICBjYXNlICdpMTYnOlxcbiAgICAgICAgcmV0dXJuIEhFQVAxNltwdHIgPj4gMV07XFxuXFxuICAgICAgY2FzZSAnaTMyJzpcXG4gICAgICAgIHJldHVybiBIRUFQMzJbcHRyID4+IDJdO1xcblxcbiAgICAgIGNhc2UgJ2k2NCc6XFxuICAgICAgICByZXR1cm4gSEVBUDMyW3B0ciA+PiAyXTtcXG5cXG4gICAgICBjYXNlICdmbG9hdCc6XFxuICAgICAgICByZXR1cm4gSEVBUEYzMltwdHIgPj4gMl07XFxuXFxuICAgICAgY2FzZSAnZG91YmxlJzpcXG4gICAgICAgIHJldHVybiBIRUFQRjY0W3B0ciA+PiAzXTtcXG5cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgYWJvcnQoJ2ludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6ICcgKyB0eXBlKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gbnVsbDtcXG4gIH1cXG5cXG4gIHZhciBBTExPQ19OT1JNQUwgPSAwOyAvLyBUcmllcyB0byB1c2UgX21hbGxvYygpXFxuXFxuICB2YXIgQUxMT0NfU1RBQ0sgPSAxOyAvLyBMaXZlcyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBjdXJyZW50IGZ1bmN0aW9uIGNhbGxcXG5cXG4gIHZhciBBTExPQ19TVEFUSUMgPSAyOyAvLyBDYW5ub3QgYmUgZnJlZWRcXG5cXG4gIHZhciBBTExPQ19EWU5BTUlDID0gMzsgLy8gQ2Fubm90IGJlIGZyZWVkIGV4Y2VwdCB0aHJvdWdoIHNicmtcXG5cXG4gIHZhciBBTExPQ19OT05FID0gNDsgLy8gRG8gbm90IGFsbG9jYXRlXFxuICAvLyBhbGxvY2F0ZSgpOiBUaGlzIGlzIGZvciBpbnRlcm5hbCB1c2UuIFlvdSBjYW4gdXNlIGl0IHlvdXJzZWxmIGFzIHdlbGwsIGJ1dCB0aGUgaW50ZXJmYWNlXFxuICAvLyAgICAgICAgICAgICBpcyBhIGxpdHRsZSB0cmlja3kgKHNlZSBkb2NzIHJpZ2h0IGJlbG93KS4gVGhlIHJlYXNvbiBpcyB0aGF0IGl0IGlzIG9wdGltaXplZFxcbiAgLy8gICAgICAgICAgICAgZm9yIG11bHRpcGxlIHN5bnRheGVzIHRvIHNhdmUgc3BhY2UgaW4gZ2VuZXJhdGVkIGNvZGUuIFNvIHlvdSBzaG91bGRcXG4gIC8vICAgICAgICAgICAgIG5vcm1hbGx5IG5vdCB1c2UgYWxsb2NhdGUoKSwgYW5kIGluc3RlYWQgYWxsb2NhdGUgbWVtb3J5IHVzaW5nIF9tYWxsb2MoKSxcXG4gIC8vICAgICAgICAgICAgIGluaXRpYWxpemUgaXQgd2l0aCBzZXRWYWx1ZSgpLCBhbmQgc28gZm9ydGguXFxuICAvLyBAc2xhYjogQW4gYXJyYXkgb2YgZGF0YSwgb3IgYSBudW1iZXIuIElmIGEgbnVtYmVyLCB0aGVuIHRoZSBzaXplIG9mIHRoZSBibG9jayB0byBhbGxvY2F0ZSxcXG4gIC8vICAgICAgICBpbiAqYnl0ZXMqIChub3RlIHRoYXQgdGhpcyBpcyBzb21ldGltZXMgY29uZnVzaW5nOiB0aGUgbmV4dCBwYXJhbWV0ZXIgZG9lcyBub3RcXG4gIC8vICAgICAgICBhZmZlY3QgdGhpcyEpXFxuICAvLyBAdHlwZXM6IEVpdGhlciBhbiBhcnJheSBvZiB0eXBlcywgb25lIGZvciBlYWNoIGJ5dGUgKG9yIDAgaWYgbm8gdHlwZSBhdCB0aGF0IHBvc2l0aW9uKSxcXG4gIC8vICAgICAgICAgb3IgYSBzaW5nbGUgdHlwZSB3aGljaCBpcyB1c2VkIGZvciB0aGUgZW50aXJlIGJsb2NrLiBUaGlzIG9ubHkgbWF0dGVycyBpZiB0aGVyZVxcbiAgLy8gICAgICAgICBpcyBpbml0aWFsIGRhdGEgLSBpZiBAc2xhYiBpcyBhIG51bWJlciwgdGhlbiB0aGlzIGRvZXMgbm90IG1hdHRlciBhdCBhbGwgYW5kIGlzXFxuICAvLyAgICAgICAgIGlnbm9yZWQuXFxuICAvLyBAYWxsb2NhdG9yOiBIb3cgdG8gYWxsb2NhdGUgbWVtb3J5LCBzZWUgQUxMT0NfKlxcblxcbiAgLyoqIEB0eXBlIHtmdW5jdGlvbigoVHlwZWRBcnJheXxBcnJheTxudW1iZXI+fG51bWJlciksIHN0cmluZywgbnVtYmVyLCBudW1iZXI9KX0gKi9cXG5cXG4gIGZ1bmN0aW9uIGFsbG9jYXRlKHNsYWIsIHR5cGVzLCBhbGxvY2F0b3IsIHB0cikge1xcbiAgICB2YXIgemVyb2luaXQsIHNpemU7XFxuXFxuICAgIGlmICh0eXBlb2Ygc2xhYiA9PT0gJ251bWJlcicpIHtcXG4gICAgICB6ZXJvaW5pdCA9IHRydWU7XFxuICAgICAgc2l6ZSA9IHNsYWI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgemVyb2luaXQgPSBmYWxzZTtcXG4gICAgICBzaXplID0gc2xhYi5sZW5ndGg7XFxuICAgIH1cXG5cXG4gICAgdmFyIHNpbmdsZVR5cGUgPSB0eXBlb2YgdHlwZXMgPT09ICdzdHJpbmcnID8gdHlwZXMgOiBudWxsO1xcbiAgICB2YXIgcmV0O1xcblxcbiAgICBpZiAoYWxsb2NhdG9yID09IEFMTE9DX05PTkUpIHtcXG4gICAgICByZXQgPSBwdHI7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0ID0gW3R5cGVvZiBfbWFsbG9jID09PSAnZnVuY3Rpb24nID8gX21hbGxvYyA6IHN0YXRpY0FsbG9jLCBzdGFja0FsbG9jLCBzdGF0aWNBbGxvYywgZHluYW1pY0FsbG9jXVthbGxvY2F0b3IgPT09IHVuZGVmaW5lZCA/IEFMTE9DX1NUQVRJQyA6IGFsbG9jYXRvcl0oTWF0aC5tYXgoc2l6ZSwgc2luZ2xlVHlwZSA/IDEgOiB0eXBlcy5sZW5ndGgpKTtcXG4gICAgfVxcblxcbiAgICBpZiAoemVyb2luaXQpIHtcXG4gICAgICB2YXIgc3RvcDtcXG4gICAgICBwdHIgPSByZXQ7XFxuICAgICAgYXNzZXJ0KChyZXQgJiAzKSA9PSAwKTtcXG4gICAgICBzdG9wID0gcmV0ICsgKHNpemUgJiB+Myk7XFxuXFxuICAgICAgZm9yICg7IHB0ciA8IHN0b3A7IHB0ciArPSA0KSB7XFxuICAgICAgICBIRUFQMzJbcHRyID4+IDJdID0gMDtcXG4gICAgICB9XFxuXFxuICAgICAgc3RvcCA9IHJldCArIHNpemU7XFxuXFxuICAgICAgd2hpbGUgKHB0ciA8IHN0b3ApIHtcXG4gICAgICAgIEhFQVA4W3B0cisrID4+IDBdID0gMDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfVxcblxcbiAgICBpZiAoc2luZ2xlVHlwZSA9PT0gJ2k4Jykge1xcbiAgICAgIGlmIChzbGFiLnN1YmFycmF5IHx8IHNsYWIuc2xpY2UpIHtcXG4gICAgICAgIEhFQVBVOC5zZXQoXFxuICAgICAgICAvKiogQHR5cGUgeyFVaW50OEFycmF5fSAqL1xcbiAgICAgICAgc2xhYiwgcmV0KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgSEVBUFU4LnNldChuZXcgVWludDhBcnJheShzbGFiKSwgcmV0KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfVxcblxcbiAgICB2YXIgaSA9IDAsXFxuICAgICAgICB0eXBlLFxcbiAgICAgICAgdHlwZVNpemUsXFxuICAgICAgICBwcmV2aW91c1R5cGU7XFxuXFxuICAgIHdoaWxlIChpIDwgc2l6ZSkge1xcbiAgICAgIHZhciBjdXJyID0gc2xhYltpXTtcXG4gICAgICB0eXBlID0gc2luZ2xlVHlwZSB8fCB0eXBlc1tpXTtcXG5cXG4gICAgICBpZiAodHlwZSA9PT0gMCkge1xcbiAgICAgICAgaSsrO1xcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcblxcbiAgICAgIGFzc2VydCh0eXBlLCAnTXVzdCBrbm93IHdoYXQgdHlwZSB0byBzdG9yZSBpbiBhbGxvY2F0ZSEnKTtcXG4gICAgICBpZiAodHlwZSA9PSAnaTY0JykgdHlwZSA9ICdpMzInOyAvLyBzcGVjaWFsIGNhc2U6IHdlIGhhdmUgb25lIGkzMiBoZXJlLCBhbmQgb25lIGkzMiBsYXRlclxcblxcbiAgICAgIHNldFZhbHVlKHJldCArIGksIGN1cnIsIHR5cGUpOyAvLyBubyBuZWVkIHRvIGxvb2sgdXAgc2l6ZSB1bmxlc3MgdHlwZSBjaGFuZ2VzLCBzbyBjYWNoZSBpdFxcblxcbiAgICAgIGlmIChwcmV2aW91c1R5cGUgIT09IHR5cGUpIHtcXG4gICAgICAgIHR5cGVTaXplID0gZ2V0TmF0aXZlVHlwZVNpemUodHlwZSk7XFxuICAgICAgICBwcmV2aW91c1R5cGUgPSB0eXBlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpICs9IHR5cGVTaXplO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXQ7XFxuICB9IC8vIEFsbG9jYXRlIG1lbW9yeSBkdXJpbmcgYW55IHN0YWdlIG9mIHN0YXJ0dXAgLSBzdGF0aWMgbWVtb3J5IGVhcmx5IG9uLCBkeW5hbWljIG1lbW9yeSBsYXRlciwgbWFsbG9jIHdoZW4gcmVhZHlcXG5cXG5cXG4gIGZ1bmN0aW9uIGdldE1lbW9yeShzaXplKSB7XFxuICAgIGlmICghc3RhdGljU2VhbGVkKSByZXR1cm4gc3RhdGljQWxsb2Moc2l6ZSk7XFxuICAgIGlmICghcnVudGltZUluaXRpYWxpemVkKSByZXR1cm4gZHluYW1pY0FsbG9jKHNpemUpO1xcbiAgICByZXR1cm4gX21hbGxvYyhzaXplKTtcXG4gIH1cXG4gIC8qKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXI9KX0gKi9cXG5cXG5cXG4gIGZ1bmN0aW9uIFBvaW50ZXJfc3RyaW5naWZ5KHB0ciwgbGVuZ3RoKSB7XFxuICAgIGlmIChsZW5ndGggPT09IDAgfHwgIXB0cikgcmV0dXJuICcnOyAvLyBUT0RPOiB1c2UgVGV4dERlY29kZXJcXG4gICAgLy8gRmluZCB0aGUgbGVuZ3RoLCBhbmQgY2hlY2sgZm9yIFVURiB3aGlsZSBkb2luZyBzb1xcblxcbiAgICB2YXIgaGFzVXRmID0gMDtcXG4gICAgdmFyIHQ7XFxuICAgIHZhciBpID0gMDtcXG5cXG4gICAgd2hpbGUgKDEpIHtcXG4gICAgICBhc3NlcnQocHRyICsgaSA8IFRPVEFMX01FTU9SWSk7XFxuICAgICAgdCA9IEhFQVBVOFtwdHIgKyBpID4+IDBdO1xcbiAgICAgIGhhc1V0ZiB8PSB0O1xcbiAgICAgIGlmICh0ID09IDAgJiYgIWxlbmd0aCkgYnJlYWs7XFxuICAgICAgaSsrO1xcbiAgICAgIGlmIChsZW5ndGggJiYgaSA9PSBsZW5ndGgpIGJyZWFrO1xcbiAgICB9XFxuXFxuICAgIGlmICghbGVuZ3RoKSBsZW5ndGggPSBpO1xcbiAgICB2YXIgcmV0ID0gJyc7XFxuXFxuICAgIGlmIChoYXNVdGYgPCAxMjgpIHtcXG4gICAgICB2YXIgTUFYX0NIVU5LID0gMTAyNDsgLy8gc3BsaXQgdXAgaW50byBjaHVua3MsIGJlY2F1c2UgLmFwcGx5IG9uIGEgaHVnZSBzdHJpbmcgY2FuIG92ZXJmbG93IHRoZSBzdGFja1xcblxcbiAgICAgIHZhciBjdXJyO1xcblxcbiAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XFxuICAgICAgICBjdXJyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIEhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIE1hdGgubWluKGxlbmd0aCwgTUFYX0NIVU5LKSkpO1xcbiAgICAgICAgcmV0ID0gcmV0ID8gcmV0ICsgY3VyciA6IGN1cnI7XFxuICAgICAgICBwdHIgKz0gTUFYX0NIVU5LO1xcbiAgICAgICAgbGVuZ3RoIC09IE1BWF9DSFVOSztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gVVRGOFRvU3RyaW5nKHB0cik7XFxuICB9IC8vIEdpdmVuIGEgcG9pbnRlciAncHRyJyB0byBhIG51bGwtdGVybWluYXRlZCBBU0NJSS1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZW1zY3JpcHRlbiBIRUFQLCByZXR1cm5zXFxuICAvLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXFxuXFxuXFxuICBmdW5jdGlvbiBBc2NpaVRvU3RyaW5nKHB0cikge1xcbiAgICB2YXIgc3RyID0gJyc7XFxuXFxuICAgIHdoaWxlICgxKSB7XFxuICAgICAgdmFyIGNoID0gSEVBUDhbcHRyKysgPj4gMF07XFxuICAgICAgaWYgKCFjaCkgcmV0dXJuIHN0cjtcXG4gICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XFxuICAgIH1cXG4gIH0gLy8gQ29waWVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QgJ3N0cicgdG8gdGhlIGVtc2NyaXB0ZW4gSEVBUCBhdCBhZGRyZXNzICdvdXRQdHInLFxcbiAgLy8gbnVsbC10ZXJtaW5hdGVkIGFuZCBlbmNvZGVkIGluIEFTQ0lJIGZvcm0uIFRoZSBjb3B5IHdpbGwgcmVxdWlyZSBhdCBtb3N0IHN0ci5sZW5ndGgrMSBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cXG5cXG5cXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXNjaWkoc3RyLCBvdXRQdHIpIHtcXG4gICAgcmV0dXJuIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIG91dFB0ciwgZmFsc2UpO1xcbiAgfSAvLyBHaXZlbiBhIHBvaW50ZXIgJ3B0cicgdG8gYSBudWxsLXRlcm1pbmF0ZWQgVVRGOC1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBjb250YWlucyB1aW50OCB2YWx1ZXMsIHJldHVybnNcXG4gIC8vIGEgY29weSBvZiB0aGF0IHN0cmluZyBhcyBhIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdC5cXG5cXG5cXG4gIHZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcXG5cXG4gIGZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKHU4QXJyYXksIGlkeCkge1xcbiAgICB2YXIgZW5kUHRyID0gaWR4OyAvLyBUZXh0RGVjb2RlciBuZWVkcyB0byBrbm93IHRoZSBieXRlIGxlbmd0aCBpbiBhZHZhbmNlLCBpdCBkb2Vzbid0IHN0b3Agb24gbnVsbCB0ZXJtaW5hdG9yIGJ5IGl0c2VsZi5cXG4gICAgLy8gQWxzbywgdXNlIHRoZSBsZW5ndGggaW5mbyB0byBhdm9pZCBydW5uaW5nIHRpbnkgc3RyaW5ncyB0aHJvdWdoIFRleHREZWNvZGVyLCBzaW5jZSAuc3ViYXJyYXkoKSBhbGxvY2F0ZXMgZ2FyYmFnZS5cXG5cXG4gICAgd2hpbGUgKHU4QXJyYXlbZW5kUHRyXSkge1xcbiAgICAgICsrZW5kUHRyO1xcbiAgICB9XFxuXFxuICAgIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiB1OEFycmF5LnN1YmFycmF5ICYmIFVURjhEZWNvZGVyKSB7XFxuICAgICAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZSh1OEFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIHUwLCB1MSwgdTIsIHUzLCB1NCwgdTU7XFxuICAgICAgdmFyIHN0ciA9ICcnO1xcblxcbiAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAvLyBGb3IgVVRGOCBieXRlIHN0cnVjdHVyZSwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb24gYW5kIGh0dHBzOi8vd3d3LmlldGYub3JnL3JmYy9yZmMyMjc5LnR4dCBhbmQgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2MjlcXG4gICAgICAgIHUwID0gdThBcnJheVtpZHgrK107XFxuICAgICAgICBpZiAoIXUwKSByZXR1cm4gc3RyO1xcblxcbiAgICAgICAgaWYgKCEodTAgJiAweDgwKSkge1xcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdTEgPSB1OEFycmF5W2lkeCsrXSAmIDYzO1xcblxcbiAgICAgICAgaWYgKCh1MCAmIDB4RTApID09IDB4QzApIHtcXG4gICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHUwICYgMzEpIDw8IDYgfCB1MSk7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdTIgPSB1OEFycmF5W2lkeCsrXSAmIDYzO1xcblxcbiAgICAgICAgaWYgKCh1MCAmIDB4RjApID09IDB4RTApIHtcXG4gICAgICAgICAgdTAgPSAodTAgJiAxNSkgPDwgMTIgfCB1MSA8PCA2IHwgdTI7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB1MyA9IHU4QXJyYXlbaWR4KytdICYgNjM7XFxuXFxuICAgICAgICAgIGlmICgodTAgJiAweEY4KSA9PSAweEYwKSB7XFxuICAgICAgICAgICAgdTAgPSAodTAgJiA3KSA8PCAxOCB8IHUxIDw8IDEyIHwgdTIgPDwgNiB8IHUzO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHU0ID0gdThBcnJheVtpZHgrK10gJiA2MztcXG5cXG4gICAgICAgICAgICBpZiAoKHUwICYgMHhGQykgPT0gMHhGOCkge1xcbiAgICAgICAgICAgICAgdTAgPSAodTAgJiAzKSA8PCAyNCB8IHUxIDw8IDE4IHwgdTIgPDwgMTIgfCB1MyA8PCA2IHwgdTQ7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHU1ID0gdThBcnJheVtpZHgrK10gJiA2MztcXG4gICAgICAgICAgICAgIHUwID0gKHUwICYgMSkgPDwgMzAgfCB1MSA8PCAyNCB8IHUyIDw8IDE4IHwgdTMgPDwgMTIgfCB1NCA8PCA2IHwgdTU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodTAgPCAweDEwMDAwKSB7XFxuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciBjaCA9IHUwIC0gMHgxMDAwMDtcXG4gICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhEODAwIHwgY2ggPj4gMTAsIDB4REMwMCB8IGNoICYgMHgzRkYpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSAvLyBHaXZlbiBhIHBvaW50ZXIgJ3B0cicgdG8gYSBudWxsLXRlcm1pbmF0ZWQgVVRGOC1lbmNvZGVkIHN0cmluZyBpbiB0aGUgZW1zY3JpcHRlbiBIRUFQLCByZXR1cm5zXFxuICAvLyBhIGNvcHkgb2YgdGhhdCBzdHJpbmcgYXMgYSBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QuXFxuXFxuXFxuICBmdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyKSB7XFxuICAgIHJldHVybiBVVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgsIHB0cik7XFxuICB9IC8vIENvcGllcyB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0ICdzdHInIHRvIHRoZSBnaXZlbiBieXRlIGFycmF5IGF0IGFkZHJlc3MgJ291dElkeCcsXFxuICAvLyBlbmNvZGVkIGluIFVURjggZm9ybSBhbmQgbnVsbC10ZXJtaW5hdGVkLiBUaGUgY29weSB3aWxsIHJlcXVpcmUgYXQgbW9zdCBzdHIubGVuZ3RoKjQrMSBieXRlcyBvZiBzcGFjZSBpbiB0aGUgSEVBUC5cXG4gIC8vIFVzZSB0aGUgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4IHRvIGNvbXB1dGUgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyAoZXhjbHVkaW5nIG51bGwgdGVybWluYXRvcikgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgd3JpdGUuXFxuICAvLyBQYXJhbWV0ZXJzOlxcbiAgLy8gICBzdHI6IHRoZSBKYXZhc2NyaXB0IHN0cmluZyB0byBjb3B5LlxcbiAgLy8gICBvdXRVOEFycmF5OiB0aGUgYXJyYXkgdG8gY29weSB0by4gRWFjaCBpbmRleCBpbiB0aGlzIGFycmF5IGlzIGFzc3VtZWQgdG8gYmUgb25lIDgtYnl0ZSBlbGVtZW50LlxcbiAgLy8gICBvdXRJZHg6IFRoZSBzdGFydGluZyBvZmZzZXQgaW4gdGhlIGFycmF5IHRvIGJlZ2luIHRoZSBjb3B5aW5nLlxcbiAgLy8gICBtYXhCeXRlc1RvV3JpdGU6IFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyB0aGlzIGZ1bmN0aW9uIGNhbiB3cml0ZSB0byB0aGUgYXJyYXkuIFRoaXMgY291bnQgc2hvdWxkIGluY2x1ZGUgdGhlIG51bGxcXG4gIC8vICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hdG9yLCBpLmUuIGlmIG1heEJ5dGVzVG9Xcml0ZT0xLCBvbmx5IHRoZSBudWxsIHRlcm1pbmF0b3Igd2lsbCBiZSB3cml0dGVuIGFuZCBub3RoaW5nIGVsc2UuXFxuICAvLyAgICAgICAgICAgICAgICAgICAgbWF4Qnl0ZXNUb1dyaXRlPTAgZG9lcyBub3Qgd3JpdGUgYW55IGJ5dGVzIHRvIHRoZSBvdXRwdXQsIG5vdCBldmVuIHRoZSBudWxsIHRlcm1pbmF0b3IuXFxuICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgd3JpdHRlbiwgRVhDTFVESU5HIHRoZSBudWxsIHRlcm1pbmF0b3IuXFxuXFxuXFxuICBmdW5jdGlvbiBzdHJpbmdUb1VURjhBcnJheShzdHIsIG91dFU4QXJyYXksIG91dElkeCwgbWF4Qnl0ZXNUb1dyaXRlKSB7XFxuICAgIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKSAvLyBQYXJhbWV0ZXIgbWF4Qnl0ZXNUb1dyaXRlIGlzIG5vdCBvcHRpb25hbC4gTmVnYXRpdmUgdmFsdWVzLCAwLCBudWxsLCB1bmRlZmluZWQgYW5kIGZhbHNlIGVhY2ggZG9uJ3Qgd3JpdGUgb3V0IGFueSBieXRlcy5cXG4gICAgICByZXR1cm4gMDtcXG4gICAgdmFyIHN0YXJ0SWR4ID0gb3V0SWR4O1xcbiAgICB2YXIgZW5kSWR4ID0gb3V0SWR4ICsgbWF4Qnl0ZXNUb1dyaXRlIC0gMTsgLy8gLTEgZm9yIHN0cmluZyBudWxsIHRlcm1pbmF0b3IuXFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XFxuICAgICAgLy8gR290Y2hhOiBjaGFyQ29kZUF0IHJldHVybnMgYSAxNi1iaXQgd29yZCB0aGF0IGlzIGEgVVRGLTE2IGVuY29kZWQgY29kZSB1bml0LCBub3QgYSBVbmljb2RlIGNvZGUgcG9pbnQgb2YgdGhlIGNoYXJhY3RlciEgU28gZGVjb2RlIFVURjE2LT5VVEYzMi0+VVRGOC5cXG4gICAgICAvLyBTZWUgaHR0cDovL3VuaWNvZGUub3JnL2ZhcS91dGZfYm9tLmh0bWwjdXRmMTYtM1xcbiAgICAgIC8vIEZvciBVVEY4IGJ5dGUgc3RydWN0dXJlLCBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvbiBhbmQgaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIyNzkudHh0IGFuZCBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzYyOVxcbiAgICAgIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7IC8vIHBvc3NpYmx5IGEgbGVhZCBzdXJyb2dhdGVcXG5cXG4gICAgICBpZiAodSA+PSAweEQ4MDAgJiYgdSA8PSAweERGRkYpIHUgPSAweDEwMDAwICsgKCh1ICYgMHgzRkYpIDw8IDEwKSB8IHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNGRjtcXG5cXG4gICAgICBpZiAodSA8PSAweDdGKSB7XFxuICAgICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XFxuICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IHU7XFxuICAgICAgfSBlbHNlIGlmICh1IDw9IDB4N0ZGKSB7XFxuICAgICAgICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweEMwIHwgdSA+PiA2O1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSAmIDYzO1xcbiAgICAgIH0gZWxzZSBpZiAodSA8PSAweEZGRkYpIHtcXG4gICAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWs7XFxuICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4RTAgfCB1ID4+IDEyO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSA+PiA2ICYgNjM7XFxuICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCB1ICYgNjM7XFxuICAgICAgfSBlbHNlIGlmICh1IDw9IDB4MUZGRkZGKSB7XFxuICAgICAgICBpZiAob3V0SWR4ICsgMyA+PSBlbmRJZHgpIGJyZWFrO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweEYwIHwgdSA+PiAxODtcXG4gICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8IHUgPj4gMTIgJiA2MztcXG4gICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMHg4MCB8IHUgPj4gNiAmIDYzO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSAmIDYzO1xcbiAgICAgIH0gZWxzZSBpZiAodSA8PSAweDNGRkZGRkYpIHtcXG4gICAgICAgIGlmIChvdXRJZHggKyA0ID49IGVuZElkeCkgYnJlYWs7XFxuICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4RjggfCB1ID4+IDI0O1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSA+PiAxOCAmIDYzO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSA+PiAxMiAmIDYzO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSA+PiA2ICYgNjM7XFxuICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCB1ICYgNjM7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChvdXRJZHggKyA1ID49IGVuZElkeCkgYnJlYWs7XFxuICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4RkMgfCB1ID4+IDMwO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSA+PiAyNCAmIDYzO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSA+PiAxOCAmIDYzO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSA+PiAxMiAmIDYzO1xcbiAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAweDgwIHwgdSA+PiA2ICYgNjM7XFxuICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDB4ODAgfCB1ICYgNjM7XFxuICAgICAgfVxcbiAgICB9IC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBidWZmZXIuXFxuXFxuXFxuICAgIG91dFU4QXJyYXlbb3V0SWR4XSA9IDA7XFxuICAgIHJldHVybiBvdXRJZHggLSBzdGFydElkeDtcXG4gIH0gLy8gQ29waWVzIHRoZSBnaXZlbiBKYXZhc2NyaXB0IFN0cmluZyBvYmplY3QgJ3N0cicgdG8gdGhlIGVtc2NyaXB0ZW4gSEVBUCBhdCBhZGRyZXNzICdvdXRQdHInLFxcbiAgLy8gbnVsbC10ZXJtaW5hdGVkIGFuZCBlbmNvZGVkIGluIFVURjggZm9ybS4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCo0KzEgYnl0ZXMgb2Ygc3BhY2UgaW4gdGhlIEhFQVAuXFxuICAvLyBVc2UgdGhlIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOCB0byBjb21wdXRlIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgKGV4Y2x1ZGluZyBudWxsIHRlcm1pbmF0b3IpIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHdyaXRlLlxcbiAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW4sIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yLlxcblxcblxcbiAgZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIHtcXG4gICAgYXNzZXJ0KHR5cGVvZiBtYXhCeXRlc1RvV3JpdGUgPT0gJ251bWJlcicsICdzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgaXMgbWlzc2luZyB0aGUgdGhpcmQgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dCBidWZmZXIhJyk7XFxuICAgIHJldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVBVOCwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xcbiAgfSAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgc3RyaW5nIHRha2VzIGlmIGVuY29kZWQgYXMgYSBVVEY4IGJ5dGUgYXJyYXksIEVYQ0xVRElORyB0aGUgbnVsbCB0ZXJtaW5hdG9yIGJ5dGUuXFxuXFxuXFxuICBmdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKSB7XFxuICAgIHZhciBsZW4gPSAwO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xcbiAgICAgIC8vIEdvdGNoYTogY2hhckNvZGVBdCByZXR1cm5zIGEgMTYtYml0IHdvcmQgdGhhdCBpcyBhIFVURi0xNiBlbmNvZGVkIGNvZGUgdW5pdCwgbm90IGEgVW5pY29kZSBjb2RlIHBvaW50IG9mIHRoZSBjaGFyYWN0ZXIhIFNvIGRlY29kZSBVVEYxNi0+VVRGMzItPlVURjguXFxuICAgICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcXG4gICAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXFxuXFxuICAgICAgaWYgKHUgPj0gMHhEODAwICYmIHUgPD0gMHhERkZGKSB1ID0gMHgxMDAwMCArICgodSAmIDB4M0ZGKSA8PCAxMCkgfCBzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzRkY7XFxuXFxuICAgICAgaWYgKHUgPD0gMHg3Rikge1xcbiAgICAgICAgKytsZW47XFxuICAgICAgfSBlbHNlIGlmICh1IDw9IDB4N0ZGKSB7XFxuICAgICAgICBsZW4gKz0gMjtcXG4gICAgICB9IGVsc2UgaWYgKHUgPD0gMHhGRkZGKSB7XFxuICAgICAgICBsZW4gKz0gMztcXG4gICAgICB9IGVsc2UgaWYgKHUgPD0gMHgxRkZGRkYpIHtcXG4gICAgICAgIGxlbiArPSA0O1xcbiAgICAgIH0gZWxzZSBpZiAodSA8PSAweDNGRkZGRkYpIHtcXG4gICAgICAgIGxlbiArPSA1O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsZW4gKz0gNjtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGxlbjtcXG4gIH0gLy8gR2l2ZW4gYSBwb2ludGVyICdwdHInIHRvIGEgbnVsbC10ZXJtaW5hdGVkIFVURjE2TEUtZW5jb2RlZCBzdHJpbmcgaW4gdGhlIGVtc2NyaXB0ZW4gSEVBUCwgcmV0dXJuc1xcbiAgLy8gYSBjb3B5IG9mIHRoYXQgc3RyaW5nIGFzIGEgSmF2YXNjcmlwdCBTdHJpbmcgb2JqZWN0LlxcblxcblxcbiAgdmFyIFVURjE2RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0Zi0xNmxlJykgOiB1bmRlZmluZWQ7XFxuXFxuICBmdW5jdGlvbiBVVEYxNlRvU3RyaW5nKHB0cikge1xcbiAgICBhc3NlcnQocHRyICUgMiA9PSAwLCAnUG9pbnRlciBwYXNzZWQgdG8gVVRGMTZUb1N0cmluZyBtdXN0IGJlIGFsaWduZWQgdG8gdHdvIGJ5dGVzIScpO1xcbiAgICB2YXIgZW5kUHRyID0gcHRyOyAvLyBUZXh0RGVjb2RlciBuZWVkcyB0byBrbm93IHRoZSBieXRlIGxlbmd0aCBpbiBhZHZhbmNlLCBpdCBkb2Vzbid0IHN0b3Agb24gbnVsbCB0ZXJtaW5hdG9yIGJ5IGl0c2VsZi5cXG4gICAgLy8gQWxzbywgdXNlIHRoZSBsZW5ndGggaW5mbyB0byBhdm9pZCBydW5uaW5nIHRpbnkgc3RyaW5ncyB0aHJvdWdoIFRleHREZWNvZGVyLCBzaW5jZSAuc3ViYXJyYXkoKSBhbGxvY2F0ZXMgZ2FyYmFnZS5cXG5cXG4gICAgdmFyIGlkeCA9IGVuZFB0ciA+PiAxO1xcblxcbiAgICB3aGlsZSAoSEVBUDE2W2lkeF0pIHtcXG4gICAgICArK2lkeDtcXG4gICAgfVxcblxcbiAgICBlbmRQdHIgPSBpZHggPDwgMTtcXG5cXG4gICAgaWYgKGVuZFB0ciAtIHB0ciA+IDMyICYmIFVURjE2RGVjb2Rlcikge1xcbiAgICAgIHJldHVybiBVVEYxNkRlY29kZXIuZGVjb2RlKEhFQVBVOC5zdWJhcnJheShwdHIsIGVuZFB0cikpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBpID0gMDtcXG4gICAgICB2YXIgc3RyID0gJyc7XFxuXFxuICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgIHZhciBjb2RlVW5pdCA9IEhFQVAxNltwdHIgKyBpICogMiA+PiAxXTtcXG4gICAgICAgIGlmIChjb2RlVW5pdCA9PSAwKSByZXR1cm4gc3RyO1xcbiAgICAgICAgKytpOyAvLyBmcm9tQ2hhckNvZGUgY29uc3RydWN0cyBhIGNoYXJhY3RlciBmcm9tIGEgVVRGLTE2IGNvZGUgdW5pdCwgc28gd2UgY2FuIHBhc3MgdGhlIFVURjE2IHN0cmluZyByaWdodCB0aHJvdWdoLlxcblxcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVVuaXQpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSAvLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZW1zY3JpcHRlbiBIRUFQIGF0IGFkZHJlc3MgJ291dFB0cicsXFxuICAvLyBudWxsLXRlcm1pbmF0ZWQgYW5kIGVuY29kZWQgaW4gVVRGMTYgZm9ybS4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCo0KzIgYnl0ZXMgb2Ygc3BhY2UgaW4gdGhlIEhFQVAuXFxuICAvLyBVc2UgdGhlIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGMTYoKSB0byBjb21wdXRlIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgKGV4Y2x1ZGluZyBudWxsIHRlcm1pbmF0b3IpIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHdyaXRlLlxcbiAgLy8gUGFyYW1ldGVyczpcXG4gIC8vICAgc3RyOiB0aGUgSmF2YXNjcmlwdCBzdHJpbmcgdG8gY29weS5cXG4gIC8vICAgb3V0UHRyOiBCeXRlIGFkZHJlc3MgaW4gRW1zY3JpcHRlbiBIRUFQIHdoZXJlIHRvIHdyaXRlIHRoZSBzdHJpbmcgdG8uXFxuICAvLyAgIG1heEJ5dGVzVG9Xcml0ZTogVGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRoaXMgZnVuY3Rpb24gY2FuIHdyaXRlIHRvIHRoZSBhcnJheS4gVGhpcyBjb3VudCBzaG91bGQgaW5jbHVkZSB0aGUgbnVsbFxcbiAgLy8gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0b3IsIGkuZS4gaWYgbWF4Qnl0ZXNUb1dyaXRlPTIsIG9ubHkgdGhlIG51bGwgdGVybWluYXRvciB3aWxsIGJlIHdyaXR0ZW4gYW5kIG5vdGhpbmcgZWxzZS5cXG4gIC8vICAgICAgICAgICAgICAgICAgICBtYXhCeXRlc1RvV3JpdGU8MiBkb2VzIG5vdCB3cml0ZSBhbnkgYnl0ZXMgdG8gdGhlIG91dHB1dCwgbm90IGV2ZW4gdGhlIG51bGwgdGVybWluYXRvci5cXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvci5cXG5cXG5cXG4gIGZ1bmN0aW9uIHN0cmluZ1RvVVRGMTYoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xcbiAgICBhc3NlcnQob3V0UHRyICUgMiA9PSAwLCAnUG9pbnRlciBwYXNzZWQgdG8gc3RyaW5nVG9VVEYxNiBtdXN0IGJlIGFsaWduZWQgdG8gdHdvIGJ5dGVzIScpO1xcbiAgICBhc3NlcnQodHlwZW9mIG1heEJ5dGVzVG9Xcml0ZSA9PSAnbnVtYmVyJywgJ3N0cmluZ1RvVVRGMTYoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgaXMgbWlzc2luZyB0aGUgdGhpcmQgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dCBidWZmZXIhJyk7IC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBpZiBtYXggYnl0ZXMgaXMgbm90IHNwZWNpZmllZCwgYXNzdW1lIHVuc2FmZSB1bmJvdW5kZWQgd3JpdGUgaXMgYWxsb3dlZC5cXG5cXG4gICAgaWYgKG1heEJ5dGVzVG9Xcml0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgbWF4Qnl0ZXNUb1dyaXRlID0gMHg3RkZGRkZGRjtcXG4gICAgfVxcblxcbiAgICBpZiAobWF4Qnl0ZXNUb1dyaXRlIDwgMikgcmV0dXJuIDA7XFxuICAgIG1heEJ5dGVzVG9Xcml0ZSAtPSAyOyAvLyBOdWxsIHRlcm1pbmF0b3IuXFxuXFxuICAgIHZhciBzdGFydFB0ciA9IG91dFB0cjtcXG4gICAgdmFyIG51bUNoYXJzVG9Xcml0ZSA9IG1heEJ5dGVzVG9Xcml0ZSA8IHN0ci5sZW5ndGggKiAyID8gbWF4Qnl0ZXNUb1dyaXRlIC8gMiA6IHN0ci5sZW5ndGg7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ2hhcnNUb1dyaXRlOyArK2kpIHtcXG4gICAgICAvLyBjaGFyQ29kZUF0IHJldHVybnMgYSBVVEYtMTYgZW5jb2RlZCBjb2RlIHVuaXQsIHNvIGl0IGNhbiBiZSBkaXJlY3RseSB3cml0dGVuIHRvIHRoZSBIRUFQLlxcbiAgICAgIHZhciBjb2RlVW5pdCA9IHN0ci5jaGFyQ29kZUF0KGkpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlXFxuXFxuICAgICAgSEVBUDE2W291dFB0ciA+PiAxXSA9IGNvZGVVbml0O1xcbiAgICAgIG91dFB0ciArPSAyO1xcbiAgICB9IC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBIRUFQLlxcblxcblxcbiAgICBIRUFQMTZbb3V0UHRyID4+IDFdID0gMDtcXG4gICAgcmV0dXJuIG91dFB0ciAtIHN0YXJ0UHRyO1xcbiAgfSAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgc3RyaW5nIHRha2VzIGlmIGVuY29kZWQgYXMgYSBVVEYxNiBieXRlIGFycmF5LCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvciBieXRlLlxcblxcblxcbiAgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYxNihzdHIpIHtcXG4gICAgcmV0dXJuIHN0ci5sZW5ndGggKiAyO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gVVRGMzJUb1N0cmluZyhwdHIpIHtcXG4gICAgYXNzZXJ0KHB0ciAlIDQgPT0gMCwgJ1BvaW50ZXIgcGFzc2VkIHRvIFVURjMyVG9TdHJpbmcgbXVzdCBiZSBhbGlnbmVkIHRvIGZvdXIgYnl0ZXMhJyk7XFxuICAgIHZhciBpID0gMDtcXG4gICAgdmFyIHN0ciA9ICcnO1xcblxcbiAgICB3aGlsZSAoMSkge1xcbiAgICAgIHZhciB1dGYzMiA9IEhFQVAzMltwdHIgKyBpICogNCA+PiAyXTtcXG4gICAgICBpZiAodXRmMzIgPT0gMCkgcmV0dXJuIHN0cjtcXG4gICAgICArK2k7IC8vIEdvdGNoYTogZnJvbUNoYXJDb2RlIGNvbnN0cnVjdHMgYSBjaGFyYWN0ZXIgZnJvbSBhIFVURi0xNiBlbmNvZGVkIGNvZGUgKHBhaXIpLCBub3QgZnJvbSBhIFVuaWNvZGUgY29kZSBwb2ludCEgU28gZW5jb2RlIHRoZSBjb2RlIHBvaW50IHRvIFVURi0xNiBmb3IgY29uc3RydWN0aW5nLlxcbiAgICAgIC8vIFNlZSBodHRwOi8vdW5pY29kZS5vcmcvZmFxL3V0Zl9ib20uaHRtbCN1dGYxNi0zXFxuXFxuICAgICAgaWYgKHV0ZjMyID49IDB4MTAwMDApIHtcXG4gICAgICAgIHZhciBjaCA9IHV0ZjMyIC0gMHgxMDAwMDtcXG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCB8IGNoID4+IDEwLCAweERDMDAgfCBjaCAmIDB4M0ZGKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodXRmMzIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSAvLyBDb3BpZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgU3RyaW5nIG9iamVjdCAnc3RyJyB0byB0aGUgZW1zY3JpcHRlbiBIRUFQIGF0IGFkZHJlc3MgJ291dFB0cicsXFxuICAvLyBudWxsLXRlcm1pbmF0ZWQgYW5kIGVuY29kZWQgaW4gVVRGMzIgZm9ybS4gVGhlIGNvcHkgd2lsbCByZXF1aXJlIGF0IG1vc3Qgc3RyLmxlbmd0aCo0KzQgYnl0ZXMgb2Ygc3BhY2UgaW4gdGhlIEhFQVAuXFxuICAvLyBVc2UgdGhlIGZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGMzIoKSB0byBjb21wdXRlIHRoZSBleGFjdCBudW1iZXIgb2YgYnl0ZXMgKGV4Y2x1ZGluZyBudWxsIHRlcm1pbmF0b3IpIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIHdyaXRlLlxcbiAgLy8gUGFyYW1ldGVyczpcXG4gIC8vICAgc3RyOiB0aGUgSmF2YXNjcmlwdCBzdHJpbmcgdG8gY29weS5cXG4gIC8vICAgb3V0UHRyOiBCeXRlIGFkZHJlc3MgaW4gRW1zY3JpcHRlbiBIRUFQIHdoZXJlIHRvIHdyaXRlIHRoZSBzdHJpbmcgdG8uXFxuICAvLyAgIG1heEJ5dGVzVG9Xcml0ZTogVGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRoaXMgZnVuY3Rpb24gY2FuIHdyaXRlIHRvIHRoZSBhcnJheS4gVGhpcyBjb3VudCBzaG91bGQgaW5jbHVkZSB0aGUgbnVsbFxcbiAgLy8gICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0b3IsIGkuZS4gaWYgbWF4Qnl0ZXNUb1dyaXRlPTQsIG9ubHkgdGhlIG51bGwgdGVybWluYXRvciB3aWxsIGJlIHdyaXR0ZW4gYW5kIG5vdGhpbmcgZWxzZS5cXG4gIC8vICAgICAgICAgICAgICAgICAgICBtYXhCeXRlc1RvV3JpdGU8NCBkb2VzIG5vdCB3cml0ZSBhbnkgYnl0ZXMgdG8gdGhlIG91dHB1dCwgbm90IGV2ZW4gdGhlIG51bGwgdGVybWluYXRvci5cXG4gIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvci5cXG5cXG5cXG4gIGZ1bmN0aW9uIHN0cmluZ1RvVVRGMzIoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xcbiAgICBhc3NlcnQob3V0UHRyICUgNCA9PSAwLCAnUG9pbnRlciBwYXNzZWQgdG8gc3RyaW5nVG9VVEYzMiBtdXN0IGJlIGFsaWduZWQgdG8gZm91ciBieXRlcyEnKTtcXG4gICAgYXNzZXJ0KHR5cGVvZiBtYXhCeXRlc1RvV3JpdGUgPT0gJ251bWJlcicsICdzdHJpbmdUb1VURjMyKHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIScpOyAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogaWYgbWF4IGJ5dGVzIGlzIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSB1bnNhZmUgdW5ib3VuZGVkIHdyaXRlIGlzIGFsbG93ZWQuXFxuXFxuICAgIGlmIChtYXhCeXRlc1RvV3JpdGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIG1heEJ5dGVzVG9Xcml0ZSA9IDB4N0ZGRkZGRkY7XFxuICAgIH1cXG5cXG4gICAgaWYgKG1heEJ5dGVzVG9Xcml0ZSA8IDQpIHJldHVybiAwO1xcbiAgICB2YXIgc3RhcnRQdHIgPSBvdXRQdHI7XFxuICAgIHZhciBlbmRQdHIgPSBzdGFydFB0ciArIG1heEJ5dGVzVG9Xcml0ZSAtIDQ7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XFxuICAgICAgLy8gR290Y2hhOiBjaGFyQ29kZUF0IHJldHVybnMgYSAxNi1iaXQgd29yZCB0aGF0IGlzIGEgVVRGLTE2IGVuY29kZWQgY29kZSB1bml0LCBub3QgYSBVbmljb2RlIGNvZGUgcG9pbnQgb2YgdGhlIGNoYXJhY3RlciEgV2UgbXVzdCBkZWNvZGUgdGhlIHN0cmluZyB0byBVVEYtMzIgdG8gdGhlIGhlYXAuXFxuICAgICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcXG4gICAgICB2YXIgY29kZVVuaXQgPSBzdHIuY2hhckNvZGVBdChpKTsgLy8gcG9zc2libHkgYSBsZWFkIHN1cnJvZ2F0ZVxcblxcbiAgICAgIGlmIChjb2RlVW5pdCA+PSAweEQ4MDAgJiYgY29kZVVuaXQgPD0gMHhERkZGKSB7XFxuICAgICAgICB2YXIgdHJhaWxTdXJyb2dhdGUgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xcbiAgICAgICAgY29kZVVuaXQgPSAweDEwMDAwICsgKChjb2RlVW5pdCAmIDB4M0ZGKSA8PCAxMCkgfCB0cmFpbFN1cnJvZ2F0ZSAmIDB4M0ZGO1xcbiAgICAgIH1cXG5cXG4gICAgICBIRUFQMzJbb3V0UHRyID4+IDJdID0gY29kZVVuaXQ7XFxuICAgICAgb3V0UHRyICs9IDQ7XFxuICAgICAgaWYgKG91dFB0ciArIDQgPiBlbmRQdHIpIGJyZWFrO1xcbiAgICB9IC8vIE51bGwtdGVybWluYXRlIHRoZSBwb2ludGVyIHRvIHRoZSBIRUFQLlxcblxcblxcbiAgICBIRUFQMzJbb3V0UHRyID4+IDJdID0gMDtcXG4gICAgcmV0dXJuIG91dFB0ciAtIHN0YXJ0UHRyO1xcbiAgfSAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGdpdmVuIEphdmFzY3JpcHQgc3RyaW5nIHRha2VzIGlmIGVuY29kZWQgYXMgYSBVVEYxNiBieXRlIGFycmF5LCBFWENMVURJTkcgdGhlIG51bGwgdGVybWluYXRvciBieXRlLlxcblxcblxcbiAgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEYzMihzdHIpIHtcXG4gICAgdmFyIGxlbiA9IDA7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XFxuICAgICAgLy8gR290Y2hhOiBjaGFyQ29kZUF0IHJldHVybnMgYSAxNi1iaXQgd29yZCB0aGF0IGlzIGEgVVRGLTE2IGVuY29kZWQgY29kZSB1bml0LCBub3QgYSBVbmljb2RlIGNvZGUgcG9pbnQgb2YgdGhlIGNoYXJhY3RlciEgV2UgbXVzdCBkZWNvZGUgdGhlIHN0cmluZyB0byBVVEYtMzIgdG8gdGhlIGhlYXAuXFxuICAgICAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9mYXEvdXRmX2JvbS5odG1sI3V0ZjE2LTNcXG4gICAgICB2YXIgY29kZVVuaXQgPSBzdHIuY2hhckNvZGVBdChpKTtcXG4gICAgICBpZiAoY29kZVVuaXQgPj0gMHhEODAwICYmIGNvZGVVbml0IDw9IDB4REZGRikgKytpOyAvLyBwb3NzaWJseSBhIGxlYWQgc3Vycm9nYXRlLCBzbyBza2lwIG92ZXIgdGhlIHRhaWwgc3Vycm9nYXRlLlxcblxcbiAgICAgIGxlbiArPSA0O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBsZW47XFxuICB9IC8vIEFsbG9jYXRlIGhlYXAgc3BhY2UgZm9yIGEgSlMgc3RyaW5nLCBhbmQgd3JpdGUgaXQgdGhlcmUuXFxuICAvLyBJdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxlciB0byBmcmVlKCkgdGhhdCBtZW1vcnkuXFxuXFxuXFxuICBmdW5jdGlvbiBhbGxvY2F0ZVVURjgoc3RyKSB7XFxuICAgIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxO1xcblxcbiAgICB2YXIgcmV0ID0gX21hbGxvYyhzaXplKTtcXG5cXG4gICAgaWYgKHJldCkgc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQOCwgcmV0LCBzaXplKTtcXG4gICAgcmV0dXJuIHJldDtcXG4gIH0gLy8gQWxsb2NhdGUgc3RhY2sgc3BhY2UgZm9yIGEgSlMgc3RyaW5nLCBhbmQgd3JpdGUgaXQgdGhlcmUuXFxuXFxuXFxuICBmdW5jdGlvbiBhbGxvY2F0ZVVURjhPblN0YWNrKHN0cikge1xcbiAgICB2YXIgc2l6ZSA9IGxlbmd0aEJ5dGVzVVRGOChzdHIpICsgMTtcXG4gICAgdmFyIHJldCA9IHN0YWNrQWxsb2Moc2l6ZSk7XFxuICAgIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgSEVBUDgsIHJldCwgc2l6ZSk7XFxuICAgIHJldHVybiByZXQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkZW1hbmdsZShmdW5jKSB7XFxuICAgIHdhcm5PbmNlKCd3YXJuaW5nOiBidWlsZCB3aXRoICAtcyBERU1BTkdMRV9TVVBQT1JUPTEgIHRvIGxpbmsgaW4gbGliY3h4YWJpIGRlbWFuZ2xpbmcnKTtcXG4gICAgcmV0dXJuIGZ1bmM7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBkZW1hbmdsZUFsbCh0ZXh0KSB7XFxuICAgIHZhciByZWdleCA9IC9fX1pbXFxcXHdcXFxcZF9dKy9nO1xcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbiAoeCkge1xcbiAgICAgIHZhciB5ID0gZGVtYW5nbGUoeCk7XFxuICAgICAgcmV0dXJuIHggPT09IHkgPyB4IDogeCArICcgWycgKyB5ICsgJ10nO1xcbiAgICB9KTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGpzU3RhY2tUcmFjZSgpIHtcXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcigpO1xcblxcbiAgICBpZiAoIWVyci5zdGFjaykge1xcbiAgICAgIC8vIElFMTArIHNwZWNpYWwgY2FzZXM6IEl0IGRvZXMgaGF2ZSBjYWxsc3RhY2sgaW5mbywgYnV0IGl0IGlzIG9ubHkgcG9wdWxhdGVkIGlmIGFuIEVycm9yIG9iamVjdCBpcyB0aHJvd24sXFxuICAgICAgLy8gc28gdHJ5IHRoYXQgYXMgYSBzcGVjaWFsLWNhc2UuXFxuICAgICAgdHJ5IHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigwKTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBlcnIgPSBlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWVyci5zdGFjaykge1xcbiAgICAgICAgcmV0dXJuICcobm8gc3RhY2sgdHJhY2UgYXZhaWxhYmxlKSc7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBlcnIuc3RhY2sudG9TdHJpbmcoKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHN0YWNrVHJhY2UoKSB7XFxuICAgIHZhciBqcyA9IGpzU3RhY2tUcmFjZSgpO1xcbiAgICBpZiAoX01vZHVsZVsnZXh0cmFTdGFja1RyYWNlJ10pIGpzICs9ICdcXFxcbicgKyBfTW9kdWxlWydleHRyYVN0YWNrVHJhY2UnXSgpO1xcbiAgICByZXR1cm4gZGVtYW5nbGVBbGwoanMpO1xcbiAgfSAvLyBNZW1vcnkgbWFuYWdlbWVudFxcblxcblxcbiAgdmFyIFBBR0VfU0laRSA9IDE2Mzg0O1xcbiAgdmFyIFdBU01fUEFHRV9TSVpFID0gNjU1MzY7XFxuICB2YXIgQVNNSlNfUEFHRV9TSVpFID0gMTY3NzcyMTY7XFxuICB2YXIgTUlOX1RPVEFMX01FTU9SWSA9IDE2Nzc3MjE2O1xcblxcbiAgZnVuY3Rpb24gYWxpZ25VcCh4LCBtdWx0aXBsZSkge1xcbiAgICBpZiAoeCAlIG11bHRpcGxlID4gMCkge1xcbiAgICAgIHggKz0gbXVsdGlwbGUgLSB4ICUgbXVsdGlwbGU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHg7XFxuICB9XFxuXFxuICB2YXIgSEVBUCxcXG4gIC8qKiBAdHlwZSB7QXJyYXlCdWZmZXJ9ICovXFxuICBidWZmZXIsXFxuICAvKiogQHR5cGUge0ludDhBcnJheX0gKi9cXG4gIEhFQVA4LFxcbiAgLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqL1xcbiAgSEVBUFU4LFxcbiAgLyoqIEB0eXBlIHtJbnQxNkFycmF5fSAqL1xcbiAgSEVBUDE2LFxcbiAgLyoqIEB0eXBlIHtVaW50MTZBcnJheX0gKi9cXG4gIEhFQVBVMTYsXFxuICAvKiogQHR5cGUge0ludDMyQXJyYXl9ICovXFxuICBIRUFQMzIsXFxuICAvKiogQHR5cGUge1VpbnQzMkFycmF5fSAqL1xcbiAgSEVBUFUzMixcXG4gIC8qKiBAdHlwZSB7RmxvYXQzMkFycmF5fSAqL1xcbiAgSEVBUEYzMixcXG4gIC8qKiBAdHlwZSB7RmxvYXQ2NEFycmF5fSAqL1xcbiAgSEVBUEY2NDtcXG5cXG4gIGZ1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlcihidWYpIHtcXG4gICAgX01vZHVsZVsnYnVmZmVyJ10gPSBidWZmZXIgPSBidWY7XFxuICB9XFxuXFxuICBmdW5jdGlvbiB1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpIHtcXG4gICAgX01vZHVsZVsnSEVBUDgnXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShidWZmZXIpO1xcbiAgICBfTW9kdWxlWydIRUFQMTYnXSA9IEhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGJ1ZmZlcik7XFxuICAgIF9Nb2R1bGVbJ0hFQVAzMiddID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYnVmZmVyKTtcXG4gICAgX01vZHVsZVsnSEVBUFU4J10gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xcbiAgICBfTW9kdWxlWydIRUFQVTE2J10gPSBIRUFQVTE2ID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XFxuICAgIF9Nb2R1bGVbJ0hFQVBVMzInXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcXG4gICAgX01vZHVsZVsnSEVBUEYzMiddID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcXG4gICAgX01vZHVsZVsnSEVBUEY2NCddID0gSEVBUEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyKTtcXG4gIH1cXG5cXG4gIHZhciBTVEFUSUNfQkFTRSwgU1RBVElDVE9QLCBzdGF0aWNTZWFsZWQ7IC8vIHN0YXRpYyBhcmVhXFxuXFxuICB2YXIgU1RBQ0tfQkFTRSwgU1RBQ0tUT1AsIFNUQUNLX01BWDsgLy8gc3RhY2sgYXJlYVxcblxcbiAgdmFyIERZTkFNSUNfQkFTRSwgRFlOQU1JQ1RPUF9QVFI7IC8vIGR5bmFtaWMgYXJlYSBoYW5kbGVkIGJ5IHNicmtcXG5cXG4gIFNUQVRJQ19CQVNFID0gU1RBVElDVE9QID0gU1RBQ0tfQkFTRSA9IFNUQUNLVE9QID0gU1RBQ0tfTUFYID0gRFlOQU1JQ19CQVNFID0gRFlOQU1JQ1RPUF9QVFIgPSAwO1xcbiAgc3RhdGljU2VhbGVkID0gZmFsc2U7IC8vIEluaXRpYWxpemVzIHRoZSBzdGFjayBjb29raWUuIENhbGxlZCBhdCB0aGUgc3RhcnR1cCBvZiBtYWluIGFuZCBhdCB0aGUgc3RhcnR1cCBvZiBlYWNoIHRocmVhZCBpbiBwdGhyZWFkcyBtb2RlLlxcblxcbiAgZnVuY3Rpb24gd3JpdGVTdGFja0Nvb2tpZSgpIHtcXG4gICAgYXNzZXJ0KChTVEFDS19NQVggJiAzKSA9PSAwKTtcXG4gICAgSEVBUFUzMlsoU1RBQ0tfTUFYID4+IDIpIC0gMV0gPSAweDAyMTM1NDY3O1xcbiAgICBIRUFQVTMyWyhTVEFDS19NQVggPj4gMikgLSAyXSA9IDB4ODlCQUNERkU7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjaGVja1N0YWNrQ29va2llKCkge1xcbiAgICBpZiAoSEVBUFUzMlsoU1RBQ0tfTUFYID4+IDIpIC0gMV0gIT0gMHgwMjEzNTQ2NyB8fCBIRUFQVTMyWyhTVEFDS19NQVggPj4gMikgLSAyXSAhPSAweDg5QkFDREZFKSB7XFxuICAgICAgYWJvcnQoJ1N0YWNrIG92ZXJmbG93ISBTdGFjayBjb29raWUgaGFzIGJlZW4gb3ZlcndyaXR0ZW4sIGV4cGVjdGVkIGhleCBkd29yZHMgMHg4OUJBQ0RGRSBhbmQgMHgwMjEzNTQ2NywgYnV0IHJlY2VpdmVkIDB4JyArIEhFQVBVMzJbKFNUQUNLX01BWCA+PiAyKSAtIDJdLnRvU3RyaW5nKDE2KSArICcgJyArIEhFQVBVMzJbKFNUQUNLX01BWCA+PiAyKSAtIDFdLnRvU3RyaW5nKDE2KSk7XFxuICAgIH0gLy8gQWxzbyB0ZXN0IHRoZSBnbG9iYWwgYWRkcmVzcyAwIGZvciBpbnRlZ3JpdHkuIFRoaXMgY2hlY2sgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBTQUZFX1NQTElUX01FTU9SWSB0aG91Z2gsIHNpbmNlIHRoYXQgbW9kZSBhbHJlYWR5IHRlc3RzIGFsbCBhZGRyZXNzIDAgYWNjZXNzZXMgb24gaXRzIG93bi5cXG5cXG5cXG4gICAgaWYgKEhFQVAzMlswXSAhPT0gMHg2MzczNmQ2NVxcbiAgICAvKiAnZW1zYycgKi9cXG4gICAgKSB0aHJvdyAnUnVudGltZSBlcnJvcjogVGhlIGFwcGxpY2F0aW9uIGhhcyBjb3JydXB0ZWQgaXRzIGhlYXAgbWVtb3J5IGFyZWEgKGFkZHJlc3MgemVybykhJztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFib3J0U3RhY2tPdmVyZmxvdyhhbGxvY1NpemUpIHtcXG4gICAgYWJvcnQoJ1N0YWNrIG92ZXJmbG93ISBBdHRlbXB0ZWQgdG8gYWxsb2NhdGUgJyArIGFsbG9jU2l6ZSArICcgYnl0ZXMgb24gdGhlIHN0YWNrLCBidXQgc3RhY2sgaGFzIG9ubHkgJyArIChTVEFDS19NQVggLSBfc3RhY2tTYXZlKCkgKyBhbGxvY1NpemUpICsgJyBieXRlcyBhdmFpbGFibGUhJyk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeSgpIHtcXG4gICAgYWJvcnQoJ0Nhbm5vdCBlbmxhcmdlIG1lbW9yeSBhcnJheXMuIEVpdGhlciAoMSkgY29tcGlsZSB3aXRoICAtcyBUT1RBTF9NRU1PUlk9WCAgd2l0aCBYIGhpZ2hlciB0aGFuIHRoZSBjdXJyZW50IHZhbHVlICcgKyBUT1RBTF9NRU1PUlkgKyAnLCAoMikgY29tcGlsZSB3aXRoICAtcyBBTExPV19NRU1PUllfR1JPV1RIPTEgIHdoaWNoIGFsbG93cyBpbmNyZWFzaW5nIHRoZSBzaXplIGF0IHJ1bnRpbWUsIG9yICgzKSBpZiB5b3Ugd2FudCBtYWxsb2MgdG8gcmV0dXJuIE5VTEwgKDApIGluc3RlYWQgb2YgdGhpcyBhYm9ydCwgY29tcGlsZSB3aXRoICAtcyBBQk9SVElOR19NQUxMT0M9MCAnKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGVubGFyZ2VNZW1vcnkoKSB7XFxuICAgIGFib3J0T25DYW5ub3RHcm93TWVtb3J5KCk7XFxuICB9XFxuXFxuICB2YXIgVE9UQUxfU1RBQ0sgPSBfTW9kdWxlWydUT1RBTF9TVEFDSyddIHx8IDUyNDI4ODA7XFxuICB2YXIgVE9UQUxfTUVNT1JZID0gX01vZHVsZVsnVE9UQUxfTUVNT1JZJ10gfHwgMTY3NzcyMTY7XFxuICBpZiAoVE9UQUxfTUVNT1JZIDwgVE9UQUxfU1RBQ0spIF9Nb2R1bGUucHJpbnRFcnIoJ1RPVEFMX01FTU9SWSBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gVE9UQUxfU1RBQ0ssIHdhcyAnICsgVE9UQUxfTUVNT1JZICsgJyEgKFRPVEFMX1NUQUNLPScgKyBUT1RBTF9TVEFDSyArICcpJyk7IC8vIEluaXRpYWxpemUgdGhlIHJ1bnRpbWUncyBtZW1vcnlcXG4gIC8vIGNoZWNrIGZvciBmdWxsIGVuZ2luZSBzdXBwb3J0ICh1c2Ugc3RyaW5nICdzdWJhcnJheScgdG8gYXZvaWQgY2xvc3VyZSBjb21waWxlciBjb25mdXNpb24pXFxuXFxuICBhc3NlcnQodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEludDMyQXJyYXkucHJvdG90eXBlLnN1YmFycmF5ICE9PSB1bmRlZmluZWQgJiYgSW50MzJBcnJheS5wcm90b3R5cGUuc2V0ICE9PSB1bmRlZmluZWQsICdKUyBlbmdpbmUgZG9lcyBub3QgcHJvdmlkZSBmdWxsIHR5cGVkIGFycmF5IHN1cHBvcnQnKTsgLy8gVXNlIGEgcHJvdmlkZWQgYnVmZmVyLCBpZiB0aGVyZSBpcyBvbmUsIG9yIGVsc2UgYWxsb2NhdGUgYSBuZXcgb25lXFxuXFxuICBpZiAoX01vZHVsZVsnYnVmZmVyJ10pIHtcXG4gICAgYnVmZmVyID0gX01vZHVsZVsnYnVmZmVyJ107XFxuICAgIGFzc2VydChidWZmZXIuYnl0ZUxlbmd0aCA9PT0gVE9UQUxfTUVNT1JZLCAncHJvdmlkZWQgYnVmZmVyIHNob3VsZCBiZSAnICsgVE9UQUxfTUVNT1JZICsgJyBieXRlcywgYnV0IGl0IGlzICcgKyBidWZmZXIuYnl0ZUxlbmd0aCk7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBVc2UgYSBXZWJBc3NlbWJseSBtZW1vcnkgd2hlcmUgYXZhaWxhYmxlXFxuICAgIGlmICgodHlwZW9mIFdlYkFzc2VtYmx5ID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihXZWJBc3NlbWJseSkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgV2ViQXNzZW1ibHkuTWVtb3J5ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgYXNzZXJ0KFRPVEFMX01FTU9SWSAlIFdBU01fUEFHRV9TSVpFID09PSAwKTtcXG4gICAgICBfTW9kdWxlWyd3YXNtTWVtb3J5J10gPSBuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtcXG4gICAgICAgICdpbml0aWFsJzogVE9UQUxfTUVNT1JZIC8gV0FTTV9QQUdFX1NJWkUsXFxuICAgICAgICAnbWF4aW11bSc6IFRPVEFMX01FTU9SWSAvIFdBU01fUEFHRV9TSVpFXFxuICAgICAgfSk7XFxuICAgICAgYnVmZmVyID0gX01vZHVsZVsnd2FzbU1lbW9yeSddLmJ1ZmZlcjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoVE9UQUxfTUVNT1JZKTtcXG4gICAgfVxcblxcbiAgICBhc3NlcnQoYnVmZmVyLmJ5dGVMZW5ndGggPT09IFRPVEFMX01FTU9SWSk7XFxuICAgIF9Nb2R1bGVbJ2J1ZmZlciddID0gYnVmZmVyO1xcbiAgfVxcblxcbiAgdXBkYXRlR2xvYmFsQnVmZmVyVmlld3MoKTtcXG5cXG4gIGZ1bmN0aW9uIGdldFRvdGFsTWVtb3J5KCkge1xcbiAgICByZXR1cm4gVE9UQUxfTUVNT1JZO1xcbiAgfSAvLyBFbmRpYW5uZXNzIGNoZWNrIChub3RlOiBhc3N1bWVzIGNvbXBpbGVyIGFyY2ggd2FzIGxpdHRsZS1lbmRpYW4pXFxuXFxuXFxuICBIRUFQMzJbMF0gPSAweDYzNzM2ZDY1O1xcbiAgLyogJ2Vtc2MnICovXFxuXFxuICBIRUFQMTZbMV0gPSAweDYzNzM7XFxuICBpZiAoSEVBUFU4WzJdICE9PSAweDczIHx8IEhFQVBVOFszXSAhPT0gMHg2MykgdGhyb3cgJ1J1bnRpbWUgZXJyb3I6IGV4cGVjdGVkIHRoZSBzeXN0ZW0gdG8gYmUgbGl0dGxlLWVuZGlhbiEnO1xcblxcbiAgZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKSB7XFxuICAgIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xcbiAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrcy5zaGlmdCgpO1xcblxcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgY2FsbGJhY2soKTtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrLmZ1bmM7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBmdW5jID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgaWYgKGNhbGxiYWNrLmFyZyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgIF9Nb2R1bGVbJ2R5bkNhbGxfdiddKGZ1bmMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgX01vZHVsZVsnZHluQ2FsbF92aSddKGZ1bmMsIGNhbGxiYWNrLmFyZyk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGZ1bmMoY2FsbGJhY2suYXJnID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2suYXJnKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBfX0FUUFJFUlVOX18gPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBiZWZvcmUgdGhlIHJ1bnRpbWUgaXMgaW5pdGlhbGl6ZWRcXG5cXG4gIHZhciBfX0FUSU5JVF9fID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgZHVyaW5nIHN0YXJ0dXBcXG5cXG4gIHZhciBfX0FUTUFJTl9fID0gW107IC8vIGZ1bmN0aW9ucyBjYWxsZWQgd2hlbiBtYWluKCkgaXMgdG8gYmUgcnVuXFxuXFxuICB2YXIgX19BVEVYSVRfXyA9IFtdOyAvLyBmdW5jdGlvbnMgY2FsbGVkIGR1cmluZyBzaHV0ZG93blxcblxcbiAgdmFyIF9fQVRQT1NUUlVOX18gPSBbXTsgLy8gZnVuY3Rpb25zIGNhbGxlZCBhZnRlciB0aGUgcnVudGltZSBoYXMgZXhpdGVkXFxuXFxuICB2YXIgcnVudGltZUluaXRpYWxpemVkID0gZmFsc2U7XFxuICB2YXIgcnVudGltZUV4aXRlZCA9IGZhbHNlO1xcblxcbiAgZnVuY3Rpb24gcHJlUnVuKCkge1xcbiAgICAvLyBjb21wYXRpYmlsaXR5IC0gbWVyZ2UgaW4gYW55dGhpbmcgZnJvbSBNb2R1bGVbJ3ByZVJ1biddIGF0IHRoaXMgdGltZVxcbiAgICBpZiAoX01vZHVsZVsncHJlUnVuJ10pIHtcXG4gICAgICBpZiAodHlwZW9mIF9Nb2R1bGVbJ3ByZVJ1biddID09ICdmdW5jdGlvbicpIF9Nb2R1bGVbJ3ByZVJ1biddID0gW19Nb2R1bGVbJ3ByZVJ1biddXTtcXG5cXG4gICAgICB3aGlsZSAoX01vZHVsZVsncHJlUnVuJ10ubGVuZ3RoKSB7XFxuICAgICAgICBhZGRPblByZVJ1bihfTW9kdWxlWydwcmVSdW4nXS5zaGlmdCgpKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBSRVJVTl9fKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGVuc3VyZUluaXRSdW50aW1lKCkge1xcbiAgICBjaGVja1N0YWNrQ29va2llKCk7XFxuICAgIGlmIChydW50aW1lSW5pdGlhbGl6ZWQpIHJldHVybjtcXG4gICAgcnVudGltZUluaXRpYWxpemVkID0gdHJ1ZTtcXG4gICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBwcmVNYWluKCkge1xcbiAgICBjaGVja1N0YWNrQ29va2llKCk7XFxuICAgIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZXhpdFJ1bnRpbWUoKSB7XFxuICAgIGNoZWNrU3RhY2tDb29raWUoKTtcXG4gICAgY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVEVYSVRfXyk7XFxuICAgIHJ1bnRpbWVFeGl0ZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcG9zdFJ1bigpIHtcXG4gICAgY2hlY2tTdGFja0Nvb2tpZSgpOyAvLyBjb21wYXRpYmlsaXR5IC0gbWVyZ2UgaW4gYW55dGhpbmcgZnJvbSBNb2R1bGVbJ3Bvc3RSdW4nXSBhdCB0aGlzIHRpbWVcXG5cXG4gICAgaWYgKF9Nb2R1bGVbJ3Bvc3RSdW4nXSkge1xcbiAgICAgIGlmICh0eXBlb2YgX01vZHVsZVsncG9zdFJ1biddID09ICdmdW5jdGlvbicpIF9Nb2R1bGVbJ3Bvc3RSdW4nXSA9IFtfTW9kdWxlWydwb3N0UnVuJ11dO1xcblxcbiAgICAgIHdoaWxlIChfTW9kdWxlWydwb3N0UnVuJ10ubGVuZ3RoKSB7XFxuICAgICAgICBhZGRPblBvc3RSdW4oX01vZHVsZVsncG9zdFJ1biddLnNoaWZ0KCkpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKSB7XFxuICAgIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFkZE9uSW5pdChjYikge1xcbiAgICBfX0FUSU5JVF9fLnVuc2hpZnQoY2IpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYWRkT25QcmVNYWluKGNiKSB7XFxuICAgIF9fQVRNQUlOX18udW5zaGlmdChjYik7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBhZGRPbkV4aXQoY2IpIHtcXG4gICAgX19BVEVYSVRfXy51bnNoaWZ0KGNiKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikge1xcbiAgICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xcbiAgfSAvLyBEZXByZWNhdGVkOiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgY2FsbGVkIGJlY2F1c2UgaXQgaXMgdW5zYWZlIGFuZCBkb2VzIG5vdCBwcm92aWRlXFxuICAvLyBhIG1heGltdW0gbGVuZ3RoIGxpbWl0IG9mIGhvdyBtYW55IGJ5dGVzIGl0IGlzIGFsbG93ZWQgdG8gd3JpdGUuIFByZWZlciBjYWxsaW5nIHRoZVxcbiAgLy8gZnVuY3Rpb24gc3RyaW5nVG9VVEY4QXJyYXkoKSBpbnN0ZWFkLCB3aGljaCB0YWtlcyBpbiBhIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIHVzZWRcXG4gIC8vIHRvIGJlIHNlY3VyZSBmcm9tIG91dCBvZiBib3VuZHMgd3JpdGVzLlxcblxcbiAgLyoqIEBkZXByZWNhdGVkICovXFxuXFxuXFxuICBmdW5jdGlvbiB3cml0ZVN0cmluZ1RvTWVtb3J5KHN0cmluZywgYnVmZmVyLCBkb250QWRkTnVsbCkge1xcbiAgICB3YXJuT25jZSgnd3JpdGVTdHJpbmdUb01lbW9yeSBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIGNhbGxlZCEgVXNlIHN0cmluZ1RvVVRGOCgpIGluc3RlYWQhJyk7XFxuICAgIHZhclxcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cXG4gICAgbGFzdENoYXIsXFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xcbiAgICBlbmQ7XFxuXFxuICAgIGlmIChkb250QWRkTnVsbCkge1xcbiAgICAgIC8vIHN0cmluZ1RvVVRGOEFycmF5IGFsd2F5cyBhcHBlbmRzIG51bGwuIElmIHdlIGRvbid0IHdhbnQgdG8gZG8gdGhhdCwgcmVtZW1iZXIgdGhlXFxuICAgICAgLy8gY2hhcmFjdGVyIHRoYXQgZXhpc3RlZCBhdCB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIG51bGwgd2lsbCBiZSBwbGFjZWQsIGFuZCByZXN0b3JlXFxuICAgICAgLy8gdGhhdCBhZnRlciB0aGUgd3JpdGUgKGJlbG93KS5cXG4gICAgICBlbmQgPSBidWZmZXIgKyBsZW5ndGhCeXRlc1VURjgoc3RyaW5nKTtcXG4gICAgICBsYXN0Q2hhciA9IEhFQVA4W2VuZF07XFxuICAgIH1cXG5cXG4gICAgc3RyaW5nVG9VVEY4KHN0cmluZywgYnVmZmVyLCBJbmZpbml0eSk7XFxuICAgIGlmIChkb250QWRkTnVsbCkgSEVBUDhbZW5kXSA9IGxhc3RDaGFyOyAvLyBSZXN0b3JlIHRoZSB2YWx1ZSB1bmRlciB0aGUgbnVsbCBjaGFyYWN0ZXIuXFxuICB9XFxuXFxuICBmdW5jdGlvbiB3cml0ZUFycmF5VG9NZW1vcnkoYXJyYXksIGJ1ZmZlcikge1xcbiAgICBhc3NlcnQoYXJyYXkubGVuZ3RoID49IDAsICd3cml0ZUFycmF5VG9NZW1vcnkgYXJyYXkgbXVzdCBoYXZlIGEgbGVuZ3RoIChzaG91bGQgYmUgYW4gYXJyYXkgb3IgdHlwZWQgYXJyYXkpJyk7XFxuICAgIEhFQVA4LnNldChhcnJheSwgYnVmZmVyKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHdyaXRlQXNjaWlUb01lbW9yeShzdHIsIGJ1ZmZlciwgZG9udEFkZE51bGwpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcXG4gICAgICBhc3NlcnQoc3RyLmNoYXJDb2RlQXQoaSkgPT09IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZik7XFxuICAgICAgSEVBUDhbYnVmZmVyKysgPj4gMF0gPSBzdHIuY2hhckNvZGVBdChpKTtcXG4gICAgfSAvLyBOdWxsLXRlcm1pbmF0ZSB0aGUgcG9pbnRlciB0byB0aGUgSEVBUC5cXG5cXG5cXG4gICAgaWYgKCFkb250QWRkTnVsbCkgSEVBUDhbYnVmZmVyID4+IDBdID0gMDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHVuU2lnbih2YWx1ZSwgYml0cywgaWdub3JlKSB7XFxuICAgIGlmICh2YWx1ZSA+PSAwKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBiaXRzIDw9IDMyID8gMiAqIE1hdGguYWJzKDEgPDwgYml0cyAtIDEpICsgdmFsdWUgLy8gTmVlZCBzb21lIHRyaWNrZXJ5LCBzaW5jZSBpZiBiaXRzID09IDMyLCB3ZSBhcmUgcmlnaHQgYXQgdGhlIGxpbWl0IG9mIHRoZSBiaXRzIEpTIHVzZXMgaW4gYml0c2hpZnRzXFxuICAgIDogTWF0aC5wb3coMiwgYml0cykgKyB2YWx1ZTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlU2lnbih2YWx1ZSwgYml0cywgaWdub3JlKSB7XFxuICAgIGlmICh2YWx1ZSA8PSAwKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIHZhciBoYWxmID0gYml0cyA8PSAzMiA/IE1hdGguYWJzKDEgPDwgYml0cyAtIDEpIC8vIGFicyBpcyBuZWVkZWQgaWYgYml0cyA9PSAzMlxcbiAgICA6IE1hdGgucG93KDIsIGJpdHMgLSAxKTtcXG5cXG4gICAgaWYgKHZhbHVlID49IGhhbGYgJiYgKGJpdHMgPD0gMzIgfHwgdmFsdWUgPiBoYWxmKSkge1xcbiAgICAgIC8vIGZvciBodWdlIHZhbHVlcywgd2UgY2FuIGhpdCB0aGUgcHJlY2lzaW9uIGxpbWl0IGFuZCBhbHdheXMgZ2V0IHRydWUgaGVyZS4gc28gZG9uJ3QgZG8gdGhhdFxcbiAgICAgIC8vIGJ1dCwgaW4gZ2VuZXJhbCB0aGVyZSBpcyBubyBwZXJmZWN0IHNvbHV0aW9uIGhlcmUuIFdpdGggNjQtYml0IGludHMsIHdlIGdldCByb3VuZGluZyBhbmQgZXJyb3JzXFxuICAgICAgLy8gVE9ETzogSW4gaTY0IG1vZGUgMSwgcmVzaWduIHRoZSB0d28gcGFydHMgc2VwYXJhdGVseSBhbmQgc2FmZWx5XFxuICAgICAgdmFsdWUgPSAtMiAqIGhhbGYgKyB2YWx1ZTsgLy8gQ2Fubm90IGJpdHNoaWZ0IGhhbGYsIGFzIGl0IG1heSBiZSBhdCB0aGUgbGltaXQgb2YgdGhlIGJpdHMgSlMgdXNlcyBpbiBiaXRzaGlmdHNcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdmFsdWU7XFxuICB9XFxuXFxuICBhc3NlcnQoTWF0aFsnaW11bCddICYmIE1hdGhbJ2Zyb3VuZCddICYmIE1hdGhbJ2NsejMyJ10gJiYgTWF0aFsndHJ1bmMnXSwgJ3RoaXMgaXMgYSBsZWdhY3kgYnJvd3NlciwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCcpO1xcbiAgdmFyIE1hdGhfYWJzID0gTWF0aC5hYnM7XFxuICB2YXIgTWF0aF9jb3MgPSBNYXRoLmNvcztcXG4gIHZhciBNYXRoX3NpbiA9IE1hdGguc2luO1xcbiAgdmFyIE1hdGhfdGFuID0gTWF0aC50YW47XFxuICB2YXIgTWF0aF9hY29zID0gTWF0aC5hY29zO1xcbiAgdmFyIE1hdGhfYXNpbiA9IE1hdGguYXNpbjtcXG4gIHZhciBNYXRoX2F0YW4gPSBNYXRoLmF0YW47XFxuICB2YXIgTWF0aF9hdGFuMiA9IE1hdGguYXRhbjI7XFxuICB2YXIgTWF0aF9leHAgPSBNYXRoLmV4cDtcXG4gIHZhciBNYXRoX2xvZyA9IE1hdGgubG9nO1xcbiAgdmFyIE1hdGhfc3FydCA9IE1hdGguc3FydDtcXG4gIHZhciBNYXRoX2NlaWwgPSBNYXRoLmNlaWw7XFxuICB2YXIgTWF0aF9mbG9vciA9IE1hdGguZmxvb3I7XFxuICB2YXIgTWF0aF9wb3cgPSBNYXRoLnBvdztcXG4gIHZhciBNYXRoX2ltdWwgPSBNYXRoLmltdWw7XFxuICB2YXIgTWF0aF9mcm91bmQgPSBNYXRoLmZyb3VuZDtcXG4gIHZhciBNYXRoX3JvdW5kID0gTWF0aC5yb3VuZDtcXG4gIHZhciBNYXRoX21pbiA9IE1hdGgubWluO1xcbiAgdmFyIE1hdGhfbWF4ID0gTWF0aC5tYXg7XFxuICB2YXIgTWF0aF9jbHozMiA9IE1hdGguY2x6MzI7XFxuICB2YXIgTWF0aF90cnVuYyA9IE1hdGgudHJ1bmM7IC8vIEEgY291bnRlciBvZiBkZXBlbmRlbmNpZXMgZm9yIGNhbGxpbmcgcnVuKCkuIElmIHdlIG5lZWQgdG9cXG4gIC8vIGRvIGFzeW5jaHJvbm91cyB3b3JrIGJlZm9yZSBydW5uaW5nLCBpbmNyZW1lbnQgdGhpcyBhbmRcXG4gIC8vIGRlY3JlbWVudCBpdC4gSW5jcmVtZW50aW5nIG11c3QgaGFwcGVuIGluIGEgcGxhY2UgbGlrZVxcbiAgLy8gUFJFX1JVTl9BRERJVElPTlMgKHVzZWQgYnkgZW1jYyB0byBhZGQgZmlsZSBwcmVsb2FkaW5nKS5cXG4gIC8vIE5vdGUgdGhhdCB5b3UgY2FuIGFkZCBkZXBlbmRlbmNpZXMgaW4gcHJlUnVuLCBldmVuIHRob3VnaFxcbiAgLy8gaXQgaGFwcGVucyByaWdodCBiZWZvcmUgcnVuIC0gcnVuIHdpbGwgYmUgcG9zdHBvbmVkIHVudGlsXFxuICAvLyB0aGUgZGVwZW5kZW5jaWVzIGFyZSBtZXQuXFxuXFxuICB2YXIgcnVuRGVwZW5kZW5jaWVzID0gMDtcXG4gIHZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XFxuICB2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDsgLy8gb3ZlcnJpZGRlbiB0byB0YWtlIGRpZmZlcmVudCBhY3Rpb25zIHdoZW4gYWxsIHJ1biBkZXBlbmRlbmNpZXMgYXJlIGZ1bGZpbGxlZFxcblxcbiAgdmFyIHJ1bkRlcGVuZGVuY3lUcmFja2luZyA9IHt9O1xcblxcbiAgZnVuY3Rpb24gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeShpZCkge1xcbiAgICB2YXIgb3JpZyA9IGlkO1xcblxcbiAgICB3aGlsZSAoMSkge1xcbiAgICAgIGlmICghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSkgcmV0dXJuIGlkO1xcbiAgICAgIGlkID0gb3JpZyArIE1hdGgucmFuZG9tKCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGlkO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xcbiAgICBydW5EZXBlbmRlbmNpZXMrKztcXG5cXG4gICAgaWYgKF9Nb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xcbiAgICAgIF9Nb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xcbiAgICB9XFxuXFxuICAgIGlmIChpZCkge1xcbiAgICAgIGFzc2VydCghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XFxuICAgICAgcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSA9IDE7XFxuXFxuICAgICAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyID09PSBudWxsICYmIHR5cGVvZiBzZXRJbnRlcnZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIGRlcGVuZGVuY2llcyBldmVyeSBmZXcgc2Vjb25kc1xcbiAgICAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGlmIChBQk9SVCkge1xcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO1xcbiAgICAgICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdmFyIHNob3duID0gZmFsc2U7XFxuXFxuICAgICAgICAgIGZvciAodmFyIGRlcCBpbiBydW5EZXBlbmRlbmN5VHJhY2tpbmcpIHtcXG4gICAgICAgICAgICBpZiAoIXNob3duKSB7XFxuICAgICAgICAgICAgICBzaG93biA9IHRydWU7XFxuXFxuICAgICAgICAgICAgICBfTW9kdWxlLnByaW50RXJyKCdzdGlsbCB3YWl0aW5nIG9uIHJ1biBkZXBlbmRlbmNpZXM6Jyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIF9Nb2R1bGUucHJpbnRFcnIoJ2RlcGVuZGVuY3k6ICcgKyBkZXApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChzaG93bikge1xcbiAgICAgICAgICAgIF9Nb2R1bGUucHJpbnRFcnIoJyhlbmQgb2YgbGlzdCknKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwgMTAwMDApO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICBfTW9kdWxlLnByaW50RXJyKCd3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSBhZGRlZCB3aXRob3V0IElEJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpIHtcXG4gICAgcnVuRGVwZW5kZW5jaWVzLS07XFxuXFxuICAgIGlmIChfTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcXG4gICAgICBfTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10ocnVuRGVwZW5kZW5jaWVzKTtcXG4gICAgfVxcblxcbiAgICBpZiAoaWQpIHtcXG4gICAgICBhc3NlcnQocnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XFxuICAgICAgZGVsZXRlIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgX01vZHVsZS5wcmludEVycignd2FybmluZzogcnVuIGRlcGVuZGVuY3kgcmVtb3ZlZCB3aXRob3V0IElEJyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XFxuICAgICAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyICE9PSBudWxsKSB7XFxuICAgICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcXG4gICAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCkge1xcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gZGVwZW5kZW5jaWVzRnVsZmlsbGVkO1xcbiAgICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcXG4gICAgICAgIGNhbGxiYWNrKCk7IC8vIGNhbiBhZGQgYW5vdGhlciBkZXBlbmRlbmNpZXNGdWxmaWxsZWRcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIF9Nb2R1bGVbXFxcInByZWxvYWRlZEltYWdlc1xcXCJdID0ge307IC8vIG1hcHMgdXJsIHRvIGltYWdlIGRhdGFcXG5cXG4gIF9Nb2R1bGVbXFxcInByZWxvYWRlZEF1ZGlvc1xcXCJdID0ge307IC8vIG1hcHMgdXJsIHRvIGF1ZGlvIGRhdGFcXG5cXG4gIHZhciBtZW1vcnlJbml0aWFsaXplciA9IG51bGw7XFxuICB2YXJcXG4gIC8qIHNob3cgZXJyb3JzIG9uIGxpa2VseSBjYWxscyB0byBGUyB3aGVuIGl0IHdhcyBub3QgaW5jbHVkZWQgKi9cXG4gIEZTID0ge1xcbiAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoKSB7XFxuICAgICAgYWJvcnQoJ0ZpbGVzeXN0ZW0gc3VwcG9ydCAoRlMpIHdhcyBub3QgaW5jbHVkZWQuIFRoZSBwcm9ibGVtIGlzIHRoYXQgeW91IGFyZSB1c2luZyBmaWxlcyBmcm9tIEpTLCBidXQgZmlsZXMgd2VyZSBub3QgdXNlZCBmcm9tIEMvQysrLCBzbyBmaWxlc3lzdGVtIHN1cHBvcnQgd2FzIG5vdCBhdXRvLWluY2x1ZGVkLiBZb3UgY2FuIGZvcmNlLWluY2x1ZGUgZmlsZXN5c3RlbSBzdXBwb3J0IHdpdGggIC1zIEZPUkNFX0ZJTEVTWVNURU09MScpO1xcbiAgICB9LFxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xcbiAgICAgIEZTLmVycm9yKCk7XFxuICAgIH0sXFxuICAgIGNyZWF0ZURhdGFGaWxlOiBmdW5jdGlvbiBjcmVhdGVEYXRhRmlsZSgpIHtcXG4gICAgICBGUy5lcnJvcigpO1xcbiAgICB9LFxcbiAgICBjcmVhdGVQcmVsb2FkZWRGaWxlOiBmdW5jdGlvbiBjcmVhdGVQcmVsb2FkZWRGaWxlKCkge1xcbiAgICAgIEZTLmVycm9yKCk7XFxuICAgIH0sXFxuICAgIGNyZWF0ZUxhenlGaWxlOiBmdW5jdGlvbiBjcmVhdGVMYXp5RmlsZSgpIHtcXG4gICAgICBGUy5lcnJvcigpO1xcbiAgICB9LFxcbiAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgIEZTLmVycm9yKCk7XFxuICAgIH0sXFxuICAgIG1rZGV2OiBmdW5jdGlvbiBta2RldigpIHtcXG4gICAgICBGUy5lcnJvcigpO1xcbiAgICB9LFxcbiAgICByZWdpc3RlckRldmljZTogZnVuY3Rpb24gcmVnaXN0ZXJEZXZpY2UoKSB7XFxuICAgICAgRlMuZXJyb3IoKTtcXG4gICAgfSxcXG4gICAgYW5hbHl6ZVBhdGg6IGZ1bmN0aW9uIGFuYWx5emVQYXRoKCkge1xcbiAgICAgIEZTLmVycm9yKCk7XFxuICAgIH0sXFxuICAgIGxvYWRGaWxlc0Zyb21EQjogZnVuY3Rpb24gbG9hZEZpbGVzRnJvbURCKCkge1xcbiAgICAgIEZTLmVycm9yKCk7XFxuICAgIH0sXFxuICAgIEVycm5vRXJyb3I6IGZ1bmN0aW9uIEVycm5vRXJyb3IoKSB7XFxuICAgICAgRlMuZXJyb3IoKTtcXG4gICAgfVxcbiAgfTtcXG4gIF9Nb2R1bGVbJ0ZTX2NyZWF0ZURhdGFGaWxlJ10gPSBGUy5jcmVhdGVEYXRhRmlsZTtcXG4gIF9Nb2R1bGVbJ0ZTX2NyZWF0ZVByZWxvYWRlZEZpbGUnXSA9IEZTLmNyZWF0ZVByZWxvYWRlZEZpbGU7IC8vIFByZWZpeCBvZiBkYXRhIFVSSXMgZW1pdHRlZCBieSBTSU5HTEVfRklMRSBhbmQgcmVsYXRlZCBvcHRpb25zLlxcblxcbiAgdmFyIGRhdGFVUklQcmVmaXggPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCc7IC8vIEluZGljYXRlcyB3aGV0aGVyIGZpbGVuYW1lIGlzIGEgYmFzZTY0IGRhdGEgVVJJLlxcblxcbiAgZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKSB7XFxuICAgIHJldHVybiBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPyBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpIDogZmlsZW5hbWUuaW5kZXhPZihkYXRhVVJJUHJlZml4KSA9PT0gMDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGludGVncmF0ZVdhc21KUygpIHtcXG4gICAgLy8gd2FzbS5qcyBoYXMgc2V2ZXJhbCBtZXRob2RzIGZvciBjcmVhdGluZyB0aGUgY29tcGlsZWQgY29kZSBtb2R1bGUgaGVyZTpcXG4gICAgLy8gICogJ25hdGl2ZS13YXNtJyA6IHVzZSBuYXRpdmUgV2ViQXNzZW1ibHkgc3VwcG9ydCBpbiB0aGUgYnJvd3NlclxcbiAgICAvLyAgKiAnaW50ZXJwcmV0LXMtZXhwcic6IGxvYWQgcy1leHByZXNzaW9uIGNvZGUgZnJvbSBhIC53YXN0IGFuZCBpbnRlcnByZXRcXG4gICAgLy8gICogJ2ludGVycHJldC1iaW5hcnknOiBsb2FkIGJpbmFyeSB3YXNtIGFuZCBpbnRlcnByZXRcXG4gICAgLy8gICogJ2ludGVycHJldC1hc20yd2FzbSc6IGxvYWQgYXNtLmpzIGNvZGUsIHRyYW5zbGF0ZSB0byB3YXNtLCBhbmQgaW50ZXJwcmV0XFxuICAgIC8vICAqICdhc21qcyc6IG5vIHdhc20sIGp1c3QgbG9hZCB0aGUgYXNtLmpzIGNvZGUgYW5kIHVzZSB0aGF0IChnb29kIGZvciB0ZXN0aW5nKVxcbiAgICAvLyBUaGUgbWV0aG9kIGlzIHNldCBhdCBjb21waWxlIHRpbWUgKEJJTkFSWUVOX01FVEhPRClcXG4gICAgLy8gVGhlIG1ldGhvZCBjYW4gYmUgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCwgaW4gd2hpY2ggY2FzZSwgd2Ugd2lsbCB0cnkgdGhlXFxuICAgIC8vIG9wdGlvbnMgb25lIGJ5IG9uZS4gU29tZSBvZiB0aGVtIGNhbiBmYWlsIGdyYWNlZnVsbHksIGFuZCB0aGVuIHdlIGNhbiB0cnlcXG4gICAgLy8gdGhlIG5leHQuXFxuICAgIC8vIGlucHV0c1xcbiAgICB2YXIgbWV0aG9kID0gJ25hdGl2ZS13YXNtJztcXG4gICAgdmFyIHdhc21UZXh0RmlsZSA9ICcnO1xcbiAgICB2YXIgd2FzbUJpbmFyeUZpbGUgPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LEFHRnpiUUVBQUFBQmNoSmdBMzkvZndGL1lBRi9BWDlnQUFGL1lBRi9BR0FDZjM4QmYyQUVmMzkvZndGL1lBSi9md0JnQTM5L2Z3QmdCSDkvZjM4QVlBTi9mMzhCZm1BQUFHQUZmMzkvZjM4QmYyQURmbjkvQVg5Z0FuNS9BWDlnQlg5L2YzOS9BR0FHZjN4L2YzOS9BWDlnQVh3QmZtQUNmSDhCZkFLWEJTRURaVzUyQm0xbGJXOXllUUlCZ0FLQUFnTmxibllGZEdGaWJHVUJjQUVRRUFObGJuWUtiV1Z0YjNKNVFtRnpaUU4vQUFObGJuWUpkR0ZpYkdWQ1lYTmxBMzhBQTJWdWRnNUVXVTVCVFVsRFZFOVFYMUJVVWdOL0FBTmxibllOZEdWdGNFUnZkV0pzWlZCMGNnTi9BQU5sYm5ZRlFVSlBVbFFEZndBRFpXNTJDRk5VUVVOTFZFOVFBMzhBQTJWdWRnbFRWRUZEUzE5TlFWZ0Rmd0FEWlc1MkIyTjBkSHBmYVRnRGZ3QUdaMnh2WW1Gc0EwNWhUZ044QUFabmJHOWlZV3dJU1c1bWFXNXBkSGtEZkFBRFpXNTJEV1Z1YkdGeVoyVk5aVzF2Y25rQUFnTmxibllPWjJWMFZHOTBZV3hOWlcxdmNua0FBZ05sYm5ZWFlXSnZjblJQYmtOaGJtNXZkRWR5YjNkTlpXMXZjbmtBQWdObGJuWVNZV0p2Y25SVGRHRmphMDkyWlhKbWJHOTNBQU1EWlc1MkMyNTFiR3hHZFc1algybHBBQU1EWlc1MkRXNTFiR3hHZFc1algybHBhV2tBQXdObGJuWUhYMTlmYkc5amF3QURBMlZ1ZGd0ZlgxOXpaWFJGY25KT2J3QURBMlZ1ZGcxZlgxOXplWE5qWVd4c01UUXdBQVFEWlc1MkRWOWZYM041YzJOaGJHd3hORFlBQkFObGJuWU1YMTlmYzNselkyRnNiRFUwQUFRRFpXNTJDMTlmWDNONWMyTmhiR3cyQUFRRFpXNTJDVjlmWDNWdWJHOWphd0FEQTJWdWRpRmZaVzF6WTNKcGNIUmxibDlvWVhOZmRHaHlaV0ZrYVc1blgzTjFjSEJ2Y25RQUFnTmxibllXWDJWdGMyTnlhWEIwWlc1ZmJXVnRZM0I1WDJKcFp3QUFBMlZ1ZGhKZmJHeDJiVjl6ZEdGamEzSmxjM1J2Y21VQUF3TmxibllQWDJ4c2RtMWZjM1JoWTJ0ellYWmxBQUlEWlc1MkQxOXdkR2h5WldGa1gyTnlaV0YwWlFBRkEyVnVkZzFmY0hSb2NtVmhaRjlxYjJsdUFBUURaVzUyRTE5d2RHaHlaV0ZrWDIxMWRHVjRYMmx1YVhRQUJBTmxibllJWDNONWMyTnZibVlBQVFOU1VRRUNBd1lHQXdJRUF3Y0RDQWNCQ0FBSUNRUUFDZ1lCQXdFQUFBRUNBUUFFQUFzQkF3Y0JCd3dORFFFQURnUVBFQkVSQUFJQ0FnUUVCQUFFQUFFRUFRUUVBZ29CQVFBS0FRQUFBUUVCQkFVQkFBWnlGSDhCSXdJTGZ3RWpBd3QvQVNNRUMzOEJJd1VMZndFakJndC9BU01IQzM4QlFRQUxmd0ZCQUF0L0FVRUFDMzhCUVFBTGZBRWpDQXQ4QVNNSkMzOEJRUUFMZndGQkFBdC9BVUVBQzM4QlFRQUxmQUZFQUFBQUFBQUFBQUFMZndGQkFBdDlBVU1BQUFBQUMzMEJRd0FBQUFBTEI2a0NGUkZmWDE5bGNuSnViMTlzYjJOaGRHbHZiZ0F4Q2w5alkzVnliRjl3YjNjQUhBZGZabVpzZFhOb0FGZ0ZYMlp5WldVQUxBOWZiR3gyYlY5aWMzZGhjRjlwTXpJQVhBZGZiV0ZzYkc5akFDc0hYMjFsYldOd2VRQmRCMTl0WlcxelpYUUFYaE5mY0hSb2NtVmhaRjl0ZFhSbGVGOXNiMk5yQUY4VlgzQjBhSEpsWVdSZmJYVjBaWGhmZFc1c2IyTnJBR0FGWDNOaWNtc0FZUXBrZVc1RFlXeHNYMmxwQUdJTVpIbHVRMkZzYkY5cGFXbHBBR01UWlhOMFlXSnNhWE5vVTNSaFkydFRjR0ZqWlFBWUMyZGxkRlJsYlhCU1pYUXdBQnNMY25WdVVHOXpkRk5sZEhNQVd3dHpaWFJVWlcxd1VtVjBNQUFhQ0hObGRGUm9jbVYzQUJrS2MzUmhZMnRCYkd4dll3QVZESE4wWVdOclVtVnpkRzl5WlFBWENYTjBZV05yVTJGMlpRQVdDUllCQUNNQkN4QmtMV1JrWkNKa1pHVmxMaTh6WldWbENzYjBBbEVvQVFGL0l3MGhBU01OSUFCcUpBMGpEVUVQYWtGd2NTUU5JdzBqRGs0RVFDQUFFQU1MSUFFUEN3VUFJdzBQQ3dZQUlBQWtEUXNLQUNBQUpBMGdBU1FPQ3hJQUl4QkJBRVlFUUNBQUpCQWdBU1FSQ3dzR0FDQUFKQnNMQlFBakd3OEx6QUVCR0g4akRTRVpJdzFCb0FacUpBMGpEU01PVGdSQVFhQUdFQU1MSUJsQk9Hb2hGU0FaSVJZZ0FDRU1JQUVoRVJBcFFRQWhFaUFNSVJjZ0YwSHhGQkJTSVFJZ0FpRVRJQXdoQXlBVElRUWdBeUFFRUNjaEJTQUZJUlFnRlJBZElCUWhCaUFWSUFaQjREd1FIaUFVSVFjZ0IwSGdQR29oQ0NBVklBaEI4d0VRWFJvZ0VTRUpJQllnRlNBSlFYOFFJQ0FVSVFvZ0NrSGdQR29oQ3lBTElCVkI4d0VRWFJvZ0ZDRU5JQTFCQUVIVFBoQW9JUTRnRGlFU0lCUWhEeUFQRUN3Z0VpRVFJQmtrRFNBUUR3c3lBUVIvSXcwaEJDTU5RUkJxSkEwakRTTU9UZ1JBUVJBUUF3c2dBQ0VCSUFFaEFpQUNRUUJCMlFVUVhob2dCQ1FORHd1c0FRRVZmeU1OSVJjakRVRVFhaVFOSXcwakRrNEVRRUVRRUFNTElBQWhEeUFCSVJBZ0FpRVJRUUFoRWdOQUFrQWdEeUVUSUJBaEZDQVNJUlVnRkNBVmFpRURJQkVoQkNBRVFmTUJTQ0VGSUJFaEJpQUZCSDhnQmdWQjh3RUxJUWNnQnlFSUlCTWdBeUFJRUYwYUlBOGhDU0FKRUI4Z0VpRUtJQXBCOHdGcUlRc2dDeUVTSUJFaERDQU1RZk1CYXlFTklBMGhFU0FOUVFCS0lRNGdEa1VFUUF3QkN3d0JDd3NnRnlRTkR3dkJBZ0VsZnlNTklTVWpEVUh3Qldva0RTTU5JdzVPQkVCQjhBVVFBd3NnSlVFTWFpRWVJQUFoQVVFQUlRd0RRQUpBSUF3aEh5QWZRZEVBU0NFZ0lDQkZCRUFNQVFzZ0FTRWhJQjRnSVVIWkJSQmRHa0VBSVJjRFFBSkFJQmNoSWlBaVFka0ZTQ0VqSUNORkJFQU1BUXNnRnlFQ1FZQUlJQUpCQW5ScUlRTWdBeWdDQUNFRUlCNGdCR29oQlNBRkxBQUFJUVlnQmtFWWRFRVlkU0VISUJjaENDQUlRUUZxSVFsQmdBZ2dDVUVDZEdvaENpQUtLQUlBSVFzZ0hpQUxhaUVOSUEwc0FBQWhEaUFPUVJoMFFSaDFJUThnRDBFQ2RDRVFJQWNnRUdvaEVTQVJRUVZxSVJKQjZCNGdFa0VDZEdvaEV5QVRLQUlBSVJRZ0ZFSC9BWEVoRlNBQklSWWdGeUVZSUJZZ0dHb2hHU0FaSUJVNkFBQWdGeUVhSUJwQkFXb2hHeUFiSVJjTUFRc0xJQXdoSENBY1FRRnFJUjBnSFNFTURBRUxDeUFsSkEwUEM5c0dBVlYvSXcwaFdDTU5RZkMyQVdva0RTTU5JdzVPQkVCQjhMWUJFQU1MSUZoQm9MWUJhaUZXSUZnaEJ5QllRYmkyQVdvaENTQllRYVMyQVdvaENpQUFJU1VnQVNFd0lBSWhPeUFESVVZZ095RUxJQXRCQUVnaERDQTdJUTBnRFVIekFVb2hEaUFNSUE1eUlWVWdKU0VQSUZVRVFDQVBRUVUyQWdCQmxCOG9BZ0FoRUNBN0lSRWdWaUFSTmdJQUlCQkJpQ01nVmhCYUdpQllKQTBQQ3lBUFFRRTJBZ0FnTUNFU0lBY2dFa0dpQVJBaEVBMGhFeUFsSVJRZ0ZFRUVhaUVWSUJVZ0V6WUNBQ0FsSVJZZ0ZrRUVhaUVYSUJjb0FnQWhHQ0FZUVFCSElSa2dHVVVFUUNBS0lBYzJBZ0FnTUNGTElBcEJCR29oVENCTUlFczJBZ0FnT3lGTklBcEJDR29oVGlCT0lFMDJBZ0FnVkNGUElBcEJER29oVUNCUUlFODJBZ0FnSlNGU0lBcEJFR29oVXlCVElGSTJBZ0FnQ2hBaUdpQllKQTBQQ3lCR0lSb2dHa0VBVENFYklCc0VRRUhVQUJBVUlSd2dIRUVCYXlFZElCMGhSaUJHSVI0Z0hrRUJTQ0VmSUI4RWYwRUJCU0FkQ3lFRUlBUWhSZ3NnSlNFZ0lDQkJDR29oSVNBaFFRQVFFeG9nUmlFaUVCQWhJeUFqSVFnZ0lrRUNkQ0VGSXcwaEpDTU5RUUVnQld4QkQycEJjSEZxSkEwakRTTU9UZ1JBUVFFZ0JXeEJEMnBCY0hFUUF3c2dSaUVtSUNaQkZHd2hCaU1OSVNjakRVRUJJQVpzUVE5cVFYQnhhaVFOSXcwakRrNEVRRUVCSUFac1FROXFRWEJ4RUFNTFFRQWhWQU5BQWtBZ1ZDRW9JRVloS1NBb0lDbElJU29nS2tVRVFBd0JDeUJVSVNzZ0p5QXJRUlJzYWlFc0lBa2dCellDQUNBSlFRUnFJUzBnTUNFdUlDMGdMallDQUNBSlFRaHFJUzhnT3lFeElDOGdNVFlDQUNBSlFReHFJVElnVkNFeklESWdNellDQUNBSlFSQnFJVFFnSlNFMUlEUWdOVFlDQUNBc0lBa3BBZ0EzQWdBZ0xFRUlhaUFKUVFocUtRSUFOd0lBSUN4QkVHb2dDVUVRYWlnQ0FEWUNBQ0JVSVRZZ0pDQTJRUUowYWlFM0lGUWhPQ0FuSURoQkZHeHFJVGtnTjBFQVFRVWdPUkFSR2lCVUlUb2dPa0VCYWlFOElEd2hWQXdCQ3d0QkFDRlJBMEFDUUNCUklUMGdWQ0UrSUQwZ1BrZ2hQeUEvUlFSQURBRUxJRkVoUUNBa0lFQkJBblJxSVVFZ1FTZ0NBQ0ZDSUVKQkFFY2hReUJEQkVBZ1VTRkVJQ1FnUkVFQ2RHb2hSU0JGS0FJQUlVY2dSMEVBRUJJYUN5QlJJVWdnU0VFQmFpRkpJRWtoVVF3QkN3c2dDQ0ZLSUVvUUR5QllKQTBQQzY0RkFrZC9BWDRqRFNGSkl3MUJFR29rRFNNTkl3NU9CRUJCRUJBREN5QUFJUmdnQVNFaklBSWhMa0VBSVRrRFFBSkFJRGtoUkNCRVFka0ZTQ0ZHSUVaRkJFQU1BUXNnSXlGSElEa2hCQ0JISUFScUlRVWdCU3dBQUNFR0lBWkJHSFJCR0hVaEJ3SkFBa0FDUUFKQUlBZEJBR3NPQWdBQkFnc0NRQ0FZSVFnZ09TRUpJQWdnQ1VFRGRHb2hDaUFLUW44M0F3QWdHQ0VMSUF0QnlDMXFJUXdnT1NFTklBd2dEVUVEZEdvaERrSi9JVW9nRGlFRERBTUFDd0FMQWtBZ0dDRVBJRGtoRUNBUElCQkJBM1JxSVJFZ0VVSUFOd01BSUJnaEVpQVNRY2d0YWlFVElEa2hGQ0FUSUJSQkEzUnFJUlZDZnlGS0lCVWhBd3dDQUFzQUN3SkFJQmdoRmlBNUlSY2dGaUFYUVFOMGFpRVpJQmxDZnpjREFDQVlJUm9nR2tISUxXb2hHeUE1SVJ3Z0d5QWNRUU4wYWlFZFFnQWhTaUFkSVFNTEN5QURJRW8zQXdBZ09TRWVJQjVCQVdvaEh5QWZJVGtNQVFzTElCZ2hJQ0F1SVNFZ0lDQWhRUU4wYWlFaUlDSkM3YmJiN2JiYjdiWmJOd01BSUJnaEpDQWtRY2d0YWlFbElDNGhKaUFsSUNaQkEzUnFJU2NnSjBMYjdiYmI3YmJiN2JaL053TUFJQmdoS0NBdUlTa2dLVUVCYWlFcUlDZ2dLa0VEZEdvaEt5QXJRc2VmL3Zqamo3LzhjVGNEQUNBWUlTd2dMRUhJTFdvaExTQXVJUzhnTDBFQmFpRXdJQzBnTUVFRGRHb2hNU0F4UXIvODhjZWYvdmpqajM4M0F3QWdHQ0V5SUM0aE15QXpRUUpxSVRRZ01pQTBRUU4wYWlFMUlEVkMvNFB3Ly8rQitQLy9BRGNEQUNBWUlUWWdOa0hJTFdvaE55QXVJVGdnT0VFQ2FpRTZJRGNnT2tFRGRHb2hPeUE3UXYvL2o4RC8vNGRnTndNQUlCZ2hQQ0F1SVQwZ1BVRURhaUUrSUR3Z1BrRURkR29oUHlBL1F2Ly8vNytBZ0lCZ053TUFJQmdoUUNCQVFjZ3RhaUZCSUM0aFFpQkNRUU5xSVVNZ1FTQkRRUU4wYWlGRklFVkMvLy8vLy8vLy94ODNBd0FnU1NRTkR3dnJCZ0pTZnd4K0l3MGhVaU1OUWVDUkFtb2tEU01OSXc1T0JFQkI0SkVDRUFNTElGSkIrT01CYWlFb0lGSkJzTFlCYWlFeklGSkIySWdCYWlFRElGSkJrTnNBYWlFRUlGSkJ5QzFxSVFVZ1VpRUdJQUFoQ3lBTElRZ2dDQ0VXSUJZaENTQUpRUkJxSVFvZ0NpZ0NBQ0VNSUF3aElTQVdJUTBnRFVFRWFpRU9JQTRvQWdBaER5QVBJUUlnS0VFQVFjZ3RFRjRhSUROQkFFSElMUkJlR2lBV0lSQWdFQ2dDQUNFUklDZ2dFVUhJTFJCZEdpQVdJUklnRWlnQ0FDRVRJQk5CeUMxcUlSUWdNeUFVUWNndEVGMGFJQlloRlNBVlFReHFJUmNnRnlnQ0FDRVlJQmdoT3dOQUFrQWdPeUVaSUJsQmYyb2hHaUFhSVRzZ0dVRUFTaUViSUJ0RkJFQU1BUXNnS0NBelFhWUJRY0VCRUNNTUFRc0xJQVZCQUVISUxSQmVHaUFHUVFCQnlDMFFYaG9nQTBFQVFjZ3RFRjRhSUFSQkFFSElMUkJlR2tFQUlRY0RRQUpBSUJZaEhDQWhJUjBnSENBZFFRRVFKQ0VlSUI1QkdIUkJHSFZCQUVjaEh5QWZSUVJBUVJJaFVRd0JDeUFvSUROQndRRkI4d0VRSXlBRklDaEJ5QzBRWFJvZ0JpQXpRY2d0RUYwYUlBVWdCaUFESUFRUUpTQVdJU0FnSUVFSWFpRWlJQ0lvQWdBaEl5QUZJQVlnSXhBbUlWUWdWQ0ZlSUZSQ0FGRWhKQ0FrUlFSQURBRUxEQUVMQ3lCUlFSSkdCRUJCQUNFQklBRWhVQ0JTSkEwZ1VBOExJRjRoVlNCVmVpRldJRmFuSVNVZ0pTRkRJRU1oSmtFQklDWjBJU2NnSjZ3aFZ5QlhJVk1nSVNFcElDbEJCR29oS2lBcUtBSUFJU3NnSzBFQVJ5RXNJQ3dFUUNBV0lTMGdMVUVRYWlFdUlDNG9BZ0FoTHlBdlFRaHFJVEFnTUJCZkdnc2dJU0V4SURFb0FnQWhNaUF5UVFOSElUUUNRQ0EwQkVBZ0lTRTFJRFZCQXpZQ0FFRUFJVHNEUUNBN0lUWWdOa0h6QVVnaE55QTNSUVJBREFNTElEc2hPQ0FvSURoQkEzUnFJVGtnT1NrREFDRllJRk1oV1NCWUlGbURJVm9nV2tJQVVTRTZJRG9FUUVFQklVRUZJRHNoUENBeklEeEJBM1JxSVQwZ1BTa0RBQ0ZiSUZNaFhDQmJJRnlESVYwZ1hVSUFVU0UrSUQ0RWYwRi9CVUVBQ3lFL0lEOGhRUXNnUVVIL0FYRWhRQ0FDSVVJZ095RkVJRUlnUkdvaFJTQkZJRUE2QUFBZ095RkdJRVpCQVdvaFJ5QkhJVHNNQUFzQUN3c2dJU0ZJSUVoQkJHb2hTU0JKS0FJQUlVb2dTa0VBUnlGTElFc0VRQ0FXSVV3Z1RFRVFhaUZOSUUwb0FnQWhUaUJPUVFocUlVOGdUeEJnR2d0QkFDRUJJQUVoVUNCU0pBMGdVQThMbkFJQ0czOE9maU1OSVI0akRVRXdhaVFOSXcwakRrNEVRRUV3RUFNTElBQWhGaUFCSVJrZ0FpRWFJQU1oRzBJQklTd2dHaUVFSUFRaEhBTkFBa0FnSENFRklCc2hCaUFGSUFaSklRY2dMQ0VoSUNGQ0FGSWhDQ0FIQkg4Z0NBVkJBQXNoQ1NBSlJRUkFEQUVMSUJZaENpQWNJUXNnQ2lBTFFRTjBhaUVNSUF3cEF3QWhJaUFpSVI4Z0dTRU5JQndoRGlBTklBNUJBM1JxSVE4Z0R5a0RBQ0VqSUNNaElDQWdJU1FnSHlFbElDUWdKWVVoSmlBV0lSQWdIQ0VSSUJBZ0VVRURkR29oRWlBU0lDWTNBd0FnSHlFbklCa2hFeUFjSVJRZ0V5QVVRUU4wYWlFVklCVWdKemNEQUNBZ0lTZ2dIeUVwSUNsQ2Y0VWhLaUFvSUNxRElTc2dLeUVzSUJ3aEZ5QVhRUUZxSVJnZ0dDRWNEQUVMQ3lBZUpBMFBDL1lCQVNGL0l3MGhJeU1OUVJCcUpBMGpEU01PVGdSQVFSQVFBd3NnQUNFY0lBRWhIU0FDSVI0Z0hTRWdJQ0JCQkdvaElTQWhLQUlBSVFNZ0EwRUFSeUVFSUFRRVFDQWNJUVVnQlVFUWFpRUdJQVlvQWdBaEJ5QUhRUWhxSVFnZ0NCQmZHaUFkSVFrZ0NTZ0NBQ0VLSUI0aEN5QUtJQXRHSVF3Z0RFRUJjU0VOSUExQi93RnhJUTRnRGlFZklCd2hEeUFQUVJCcUlSQWdFQ2dDQUNFUklCRkJDR29oRWlBU0VHQWFJQjhoRXlBVElSY2dGeUViSUNNa0RTQWJEd1VnSFNFVUlCUW9BZ0FoRlNBZUlSWWdGU0FXUmlFWUlCaEJBWEVoR1NBWlFmOEJjU0VhSUJvaEZ5QVhJUnNnSXlRTklCc1BDd0JCQUE4THpBTUNLbjhXZmlNTklTMGpEVUhBQUdva0RTTU5JdzVPQkVCQndBQVFBd3NnQUNFYklBRWhIeUFDSVNNZ0F5RXBRUUFoS2tIUkFDRXJBMEFDUUNBcklRVWdCVUYvYWlFR0lBWWhLeUFGUVFCS0lRY2dCMFVFUUF3QkN5QWpJUWdnR3lFSklBZ2dDVUhJTFJCZEdpQXBJUW9nSHlFTElBb2dDMEhJTFJCZEdrRUFJUVFEUUNBRUlRd2dERUhaQlVnaERTQU5SUVJBREFNTElDTWhEaUFxSVE4Z0RpQVBRUU4wYWlFUUlCQXBBd0FoTWlBeUlTNGdLU0VSSUNvaEVpQVJJQkpCQTNScUlSTWdFeWtEQUNFeklETWhMeUFwSVJRZ0tpRVZJQlZCN1FKSUlSWWdGZ1IvUWV3Q0JVR1RmUXNoRnlBcUlSZ2dHQ0FYYWlFWklCa2hLaUFVSUJsQkEzUnFJUm9nR2lrREFDRTBJRFFoTUNBdUlUVWdNQ0UySURaQ2Y0VWhOeUExSURlRUlUZ2dJeUVjSUNvaEhTQWNJQjFCQTNScUlSNGdIaWtEQUNFNUlDOGhPaUE1SURxRklUc2dPQ0E3Z3lFOElEd2hNU0F4SVQwZ1BVSi9oU0UrSUJzaElDQUVJU0VnSUNBaFFRTjBhaUVpSUNJZ1BqY0RBQ0F1SVQ4Z01DRkFJRDhnUUlVaFFTQXhJVUlnUVNCQ2hDRkRJQjhoSkNBRUlTVWdKQ0FsUVFOMGFpRW1JQ1lnUXpjREFDQUVJU2NnSjBFQmFpRW9JQ2doQkF3QUN3QU1BUXNMSUMwa0RROExpZ0lDRTM4TGZpTU5JUlVqRFVFZ2FpUU5JdzBqRGs0RVFFRWdFQU1MSUFBaER5QUJJUkFnQWlFUlFuOGhJQ0FSSVJNZ0V5RVNBMEFDUUNBU0lRTWdBMEYvYWlFRUlBUWhFaUFEUVFCS0lRVWdCVVVFUUVFRklSUU1BUXNnRHlFR0lCSWhCMEh5QVNBSGF5RUlJQVlnQ0VFRGRHb2hDU0FKS1FNQUlSWWdFQ0VLSUJJaEMwSHlBU0FMYXlFTUlBb2dERUVEZEdvaERTQU5LUU1BSVJjZ0ZpQVhoU0VZSUJoQ2Y0VWhHU0FnSVJvZ0dpQVpneUViSUJzaElDQWdJUndnSEVJQVVTRU9JQTRFUUVFRUlSUU1BUXNNQVFzTElCUkJCRVlFUUVJQUlSNGdIaUVmSUJVa0RTQWZEd1VnRkVFRlJnUkFJQ0FoSFNBZElSNGdIaUVmSUJVa0RTQWZEd3NMUWdBUEMrb0JBUjEvSXcwaEhpTU5RUkJxSkEwakRTTU9UZ1JBUVJBUUF3c2dBQ0VNSUFFaEZpQVdJUmtnR1VFRGJDRWFJQm9oR3lBYkVDc2hIQ0FjSVJoQkFDRVhBMEFDUUNBWElRSWdGaUVESUFJZ0EwZ2hCQ0FZSVFVZ0JFVUVRQXdCQ3lBWElRWWdCa0VEYkNFSElBVWdCMm9oQ0NBTUlRa2dGeUVLSUFrZ0Ntb2hDeUFMTEFBQUlRMGdEVUVZZEVFWWRTRU9RYVlqSUE0UVZDRVBJQThoRUVHbUl5RVJJQkFnRVdzaEVrRzd4QUFnRWtFRGJHb2hFeUFJSUJNdUFBQTdBQUFnQ0VFQ2FpQVRRUUpxTEFBQU9nQUFJQmNoRkNBVVFRRnFJUlVnRlNFWERBRUxDeUFlSkEwZ0JROEw3UU1CUjM4akRTRkpJdzFCSUdva0RTTU5JdzVPQkVCQklCQURDeUFBSVJjZ0FTRWlJQUloTFNBdElRTWdBMEVEYWlFRUlBUkJBV3NoQlNBRlFRTnRRWDl4SVFZZ0JpRkRJRU1oQnlBSFFRRnFJUWdnQ0NFSklBa1FLeUVLSUFvaFJpQkdJUXNnUXlFTUlBc2dER29oRFNBTlFRQTZBQUJCQUNFNEEwQUNRQ0E0SVE0Z1F5RVBJQTRnRDBnaEVDQVFSUVJBREFFTElCY2hFU0FpSVJJZ09DRVRJQk5CQTJ3aEZDQVNJQlJxSVJVZ0VTQVZhaUVXSUJZc0FBQWhHQ0FZUVJoMFFSaDFJUmtnRnlFYUlDSWhHeUE0SVJ3Z0hFRURiQ0VkSUJzZ0hXb2hIaUFlUVFGcUlSOGdHaUFmYWlFZ0lDQXNBQUFoSVNBaFFSaDBRUmgxSVNNZ0kwRURiQ0VrSUJrZ0pHb2hKU0FYSVNZZ0lpRW5JRGdoS0NBb1FRTnNJU2tnSnlBcGFpRXFJQ3BCQW1vaEt5QW1JQ3RxSVN3Z0xDd0FBQ0V1SUM1QkdIUkJHSFVoTHlBdlFRbHNJVEFnSlNBd2FpRXhJREZCL3dGeElUSWdNaUZISUVjaE15QXpRUmgwUVJoMUlUUWdORUVBU0NFMUlEVUVRQ0JISVRZZ05rRVlkRUVZZFNFM0lEZEJHMm9oT1NBNVFmOEJjU0U2SURvaFJ3c2dSeUU3SUR0QkdIUkJHSFVoUEVHbUl5QThhaUU5SUQwc0FBQWhQaUJHSVQ4Z09DRkFJRDhnUUdvaFFTQkJJRDQ2QUFBZ09DRkNJRUpCQVdvaFJDQkVJVGdNQVFzTElFWWhSU0JKSkEwZ1JROEw5QUVCRUg4akRTRVBJdzFCRUdva0RTTU5JdzVPQkVCQkVCQURDeUFQUVFScUlRRWdBVUVBTmdBQUlBRkJCR3BCQURvQUFFRUFJUUFEUUFKQUlBQWhCaUFHUWZNQlNDRUhJQWRGQkVBTUFRc2dBQ0VJUWZ3NklBaEJCV3hxSVFrZ0NTQUJLQUFBTmdBQUlBbEJCR29nQVVFRWFpd0FBRG9BQUNBQlFRVVFLaUFBSVFvZ0NrRUJhaUVMSUFzaEFBd0JDd3RCQUNFQUEwQUNRQ0FBSVF3Z0RFRWJTQ0VOSUExRkJFQU1BUXNnQUNFQ1FidkVBQ0FDUVFOc2FpRURJQU1nQVM0QUFEc0FBQ0FEUVFKcUlBRkJBbW9zQUFBNkFBQWdBVUVERUNvZ0FDRUVJQVJCQVdvaEJTQUZJUUFNQVFzTElBOGtEUThMd3dFQkZIOGpEU0VWSXcxQkVHb2tEU01OSXc1T0JFQkJFQkFEQ3lBQUlRd2dBU0VOUVFBaERnTkFBa0FnRGlFUElBMGhFQ0FQSUJCSUlSRWdFVVVFUUVFRklSUU1BUXNnRENFU0lBNGhFeUFTSUJOcUlRSWdBaXdBQUNFRElBTkJBV3BCR0hSQkdIVWhCQ0FDSUFRNkFBQWdCRUVZZEVFWWRTRUZJQVZCQVVvaEJpQUdSUVJBUVFVaEZBd0JDeUFNSVFjZ0RpRUlJQWNnQ0dvaENTQUpRWDg2QUFBZ0RpRUtJQXBCQVdvaEN5QUxJUTRNQVFzTElCUkJCVVlFUUNBVkpBMFBDd3V0YmdHekNIOGpEU0d6Q0NNTlFSQnFKQTBqRFNNT1RnUkFRUkFRQXdzZ3N3Z2hWU0FBUWZVQlNTSEVBUUpBSU1RQkJFQWdBRUVMU1NHekFpQUFRUXRxSWFJRElLSURRWGh4SVpFRUlMTUNCSDlCRUFVZ2tRUUxJWUFGSUlBRlFRTjJJZThGUWJ3MktBSUFJZDRHSU40R0lPOEZkaUhOQnlETkIwRURjU0ZXSUZaQkFFWWhZU0JoUlFSQUlNMEhRUUZ4SVd3Z2JFRUJjeUYzSUhjZzd3VnFJWUlCSUlJQlFRRjBJWTBCUWVRMklJMEJRUUowYWlHWUFTQ1lBVUVJYWlHakFTQ2pBU2dDQUNHdUFTQ3VBVUVJYWlHNUFTQzVBU2dDQUNIRkFTREZBU0NZQVVZaDBBRWcwQUVFUUVFQklJSUJkQ0hiQVNEYkFVRi9jeUhtQVNEZUJpRG1BWEVoOFFGQnZEWWc4UUUyQWdBRklNVUJRUXhxSWZ3QklQd0JJSmdCTmdJQUlLTUJJTVVCTmdJQUN5Q0NBVUVEZENHSEFpQ0hBa0VEY2lHU0FpQ3VBVUVFYWlHZEFpQ2RBaUNTQWpZQ0FDQ3VBU0NIQW1vaHFBSWdxQUpCQkdvaHRBSWd0QUlvQWdBaHZ3SWd2d0pCQVhJaHlnSWd0QUlneWdJMkFnQWd1UUVoQmlDekNDUU5JQVlQQzBIRU5pZ0NBQ0hWQWlDQUJTRFZBa3NoNEFJZzRBSUVRQ0ROQjBFQVJpSHJBaURyQWtVRVFDRE5CeUR2QlhRaDlnSkJBaUR2QlhRaGdRTkJBQ0NCQTJzaGpBTWdnUU1nakFOeUlaY0RJUFlDSUpjRGNTR2pBMEVBSUtNRGF5R3VBeUNqQXlDdUEzRWh1UU1ndVFOQmYyb2h4QU1neEFOQkRIWWh6d01nendOQkVIRWgyZ01neEFNZzJnTjJJZVVESU9VRFFRVjJJZkFESVBBRFFRaHhJZnNESVBzRElOb0RjaUdHQkNEbEF5RDdBM1loa2dRZ2tnUkJBblloblFRZ25RUkJCSEVocUFRZ2hnUWdxQVJ5SWJNRUlKSUVJS2dFZGlHK0JDQytCRUVCZGlISkJDREpCRUVDY1NIVUJDQ3pCQ0RVQkhJaDN3UWd2Z1FnMUFSMkllb0VJT29FUVFGMklmVUVJUFVFUVFGeElZRUZJTjhFSUlFRmNpR01CU0RxQkNDQkJYWWhsd1VnakFVZ2x3VnFJYUlGSUtJRlFRRjBJYTBGUWVRMklLMEZRUUowYWlHNEJTQzRCVUVJYWlIREJTRERCU2dDQUNIT0JTRE9CVUVJYWlIWkJTRFpCU2dDQUNIa0JTRGtCU0M0QlVZaDhBVWc4QVVFUUVFQklLSUZkQ0g3QlNEN0JVRi9jeUdHQmlEZUJpQ0dCbkVoa1FaQnZEWWdrUVkyQWdBZ2tRWWh6Z2NGSU9RRlFReHFJWndHSUp3R0lMZ0ZOZ0lBSU1NRklPUUZOZ0lBSU40R0ljNEhDeUNpQlVFRGRDR25CaUNuQmlDQUJXc2hzZ1lnZ0FWQkEzSWh2UVlnemdWQkJHb2h5QVlneUFZZ3ZRWTJBZ0FnemdVZ2dBVnFJZE1HSUxJR1FRRnlJZDhHSU5NR1FRUnFJZW9HSU9vR0lOOEdOZ0lBSU00RklLY0dhaUgxQmlEMUJpQ3lCallDQUNEVkFrRUFSaUdBQnlDQUIwVUVRRUhRTmlnQ0FDR0xCeURWQWtFRGRpR1dCeUNXQjBFQmRDR2hCMEhrTmlDaEIwRUNkR29ockFkQkFTQ1dCM1FodHdjZ3pnY2d0d2R4SWNJSElNSUhRUUJHSWRrSElOa0hCRUFnemdjZ3R3ZHlJZVFIUWJ3MklPUUhOZ0lBSUt3SFFRaHFJVVFnckFjaEVDQkVJVTRGSUt3SFFRaHFJZThISU84SEtBSUFJZm9ISVBvSElSQWc3d2NoVGdzZ1RpQ0xCellDQUNBUVFReHFJWVVJSUlVSUlJc0hOZ0lBSUlzSFFRaHFJWkFJSUpBSUlCQTJBZ0FnaXdkQkRHb2htd2dnbXdnZ3JBYzJBZ0FMUWNRMklMSUdOZ0lBUWRBMklOTUdOZ0lBSU5rRklRWWdzd2drRFNBR0R3dEJ3RFlvQWdBaG5nZ2duZ2hCQUVZaG53Z2dud2dFUUNDQUJTRVBCVUVBSUo0SWF5RlhJSjRJSUZkeElWZ2dXRUYvYWlGWklGbEJESFloV2lCYVFSQnhJVnNnV1NCYmRpRmNJRnhCQlhZaFhTQmRRUWh4SVY0Z1hpQmJjaUZmSUZ3Z1huWWhZQ0JnUVFKMklXSWdZa0VFY1NGaklGOGdZM0loWkNCZ0lHTjJJV1VnWlVFQmRpRm1JR1pCQW5FaFp5QmtJR2R5SVdnZ1pTQm5kaUZwSUdsQkFYWWhhaUJxUVFGeElXc2dhQ0JyY2lGdElHa2dhM1loYmlCdElHNXFJVzlCN0RnZ2IwRUNkR29oY0NCd0tBSUFJWEVnY1VFRWFpRnlJSElvQWdBaGN5QnpRWGh4SVhRZ2RDQ0FCV3NoZFNCeFFSQnFJWFlnZGlnQ0FDRjRJSGhCQUVZaGVTQjVRUUZ4SVZFZ2NVRVFhaUJSUVFKMGFpRjZJSG9vQWdBaGV5QjdRUUJHSVh3Z2ZBUkFJSEVoQ3lCMUlRMEZJSEVoRENCMUlRNGdleUYrQTBBQ1FDQitRUVJxSVgwZ2ZTZ0NBQ0YvSUg5QmVIRWhnQUVnZ0FFZ2dBVnJJWUVCSUlFQklBNUpJWU1CSUlNQkJIOGdnUUVGSUE0TElRSWdnd0VFZnlCK0JTQU1DeUVCSUg1QkVHb2hoQUVnaEFFb0FnQWhoUUVnaFFGQkFFWWhoZ0VnaGdGQkFYRWhUeUIrUVJCcUlFOUJBblJxSVljQklJY0JLQUlBSVlnQklJZ0JRUUJHSVlrQklJa0JCRUFnQVNFTElBSWhEUXdCQlNBQklRd2dBaUVPSUlnQklYNExEQUVMQ3dzZ0N5Q0FCV29oaWdFZ2lnRWdDMHNoaXdFZ2l3RUVRQ0FMUVJocUlZd0JJSXdCS0FJQUlZNEJJQXRCREdvaGp3RWdqd0VvQWdBaGtBRWdrQUVnQzBZaGtRRUNRQ0NSQVFSQUlBdEJGR29obGdFZ2xnRW9BZ0FobHdFZ2x3RkJBRVlobVFFZ21RRUVRQ0FMUVJCcUlab0JJSm9CS0FJQUlac0JJSnNCUVFCR0lad0JJSndCQkVCQkFDRTBEQU1GSUpzQklTWWdtZ0VoSndzRklKY0JJU1lnbGdFaEp3c0RRQUpBSUNaQkZHb2huUUVnblFFb0FnQWhuZ0VnbmdGQkFFWWhud0VnbndGRkJFQWduZ0VoSmlDZEFTRW5EQUlMSUNaQkVHb2hvQUVnb0FFb0FnQWhvUUVnb1FGQkFFWWhvZ0Vnb2dFRVFBd0JCU0NoQVNFbUlLQUJJU2NMREFFTEN5QW5RUUEyQWdBZ0ppRTBCU0FMUVFocUlaSUJJSklCS0FJQUlaTUJJSk1CUVF4cUlaUUJJSlFCSUpBQk5nSUFJSkFCUVFocUlaVUJJSlVCSUpNQk5nSUFJSkFCSVRRTEN5Q09BVUVBUmlHa0FRSkFJS1FCUlFSQUlBdEJIR29ocFFFZ3BRRW9BZ0FocGdGQjdEZ2dwZ0ZCQW5ScUlhY0JJS2NCS0FJQUlhZ0JJQXNncUFGR0lha0JJS2tCQkVBZ3B3RWdORFlDQUNBMFFRQkdJYUFJSUtBSUJFQkJBU0NtQVhRaHFnRWdxZ0ZCZjNNaHF3RWduZ2dncXdGeElhd0JRY0EySUt3Qk5nSUFEQU1MQlNDT0FVRVFhaUd0QVNDdEFTZ0NBQ0d2QVNDdkFTQUxSeUd3QVNDd0FVRUJjU0ZTSUk0QlFSQnFJRkpCQW5ScUliRUJJTEVCSURRMkFnQWdORUVBUmlHeUFTQ3lBUVJBREFNTEN5QTBRUmhxSWJNQklMTUJJSTRCTmdJQUlBdEJFR29odEFFZ3RBRW9BZ0FodFFFZ3RRRkJBRVlodGdFZ3RnRkZCRUFnTkVFUWFpRzNBU0MzQVNDMUFUWUNBQ0MxQVVFWWFpRzRBU0M0QVNBME5nSUFDeUFMUVJScUlib0JJTG9CS0FJQUlic0JJTHNCUVFCR0lid0JJTHdCUlFSQUlEUkJGR29odlFFZ3ZRRWd1d0UyQWdBZ3V3RkJHR29odmdFZ3ZnRWdORFlDQUFzTEN5QU5RUkJKSWI4QklMOEJCRUFnRFNDQUJXb2h3QUVnd0FGQkEzSWh3UUVnQzBFRWFpSENBU0RDQVNEQkFUWUNBQ0FMSU1BQmFpSERBU0REQVVFRWFpSEdBU0RHQVNnQ0FDSEhBU0RIQVVFQmNpSElBU0RHQVNESUFUWUNBQVVnZ0FWQkEzSWh5UUVnQzBFRWFpSEtBU0RLQVNESkFUWUNBQ0FOUVFGeUljc0JJSW9CUVFScUljd0JJTXdCSU1zQk5nSUFJSW9CSUExcUljMEJJTTBCSUEwMkFnQWcxUUpCQUVZaHpnRWd6Z0ZGQkVCQjBEWW9BZ0FoendFZzFRSkJBM1loMFFFZzBRRkJBWFFoMGdGQjVEWWcwZ0ZCQW5ScUlkTUJRUUVnMFFGMElkUUJJTjRHSU5RQmNTSFZBU0RWQVVFQVJpSFdBU0RXQVFSQUlONEdJTlFCY2lIWEFVRzhOaURYQVRZQ0FDRFRBVUVJYWlGRklOTUJJUWNnUlNGTkJTRFRBVUVJYWlIWUFTRFlBU2dDQUNIWkFTRFpBU0VISU5nQklVMExJRTBnendFMkFnQWdCMEVNYWlIYUFTRGFBU0RQQVRZQ0FDRFBBVUVJYWlIY0FTRGNBU0FITmdJQUlNOEJRUXhxSWQwQklOMEJJTk1CTmdJQUMwSEVOaUFOTmdJQVFkQTJJSW9CTmdJQUN5QUxRUWhxSWQ0QklONEJJUVlnc3dna0RTQUdEd1VnZ0FVaER3c0xCU0NBQlNFUEN3VWdBRUcvZjBzaDN3RWczd0VFUUVGL0lROEZJQUJCQzJvaDRBRWc0QUZCZUhFaDRRRkJ3RFlvQWdBaDRnRWc0Z0ZCQUVZaDR3RWc0d0VFUUNEaEFTRVBCVUVBSU9FQmF5SGtBU0RnQVVFSWRpSGxBU0RsQVVFQVJpSG5BU0RuQVFSQVFRQWhJQVVnNFFGQi8vLy9CMHNoNkFFZzZBRUVRRUVmSVNBRklPVUJRWUQrUDJvaDZRRWc2UUZCRUhZaDZnRWc2Z0ZCQ0hFaDZ3RWc1UUVnNndGMElld0JJT3dCUVlEZ0gyb2g3UUVnN1FGQkVIWWg3Z0VnN2dGQkJIRWg3d0VnN3dFZzZ3RnlJZkFCSU93QklPOEJkQ0h5QVNEeUFVR0FnQTlxSWZNQklQTUJRUkIySWZRQklQUUJRUUp4SWZVQklQQUJJUFVCY2lIMkFVRU9JUFlCYXlIM0FTRHlBU0QxQVhRaCtBRWcrQUZCRDNZaCtRRWc5d0VnK1FGcUlmb0JJUG9CUVFGMElmc0JJUG9CUVFkcUlmMEJJT0VCSVAwQmRpSCtBU0QrQVVFQmNTSC9BU0QvQVNEN0FYSWhnQUlnZ0FJaElBc0xRZXc0SUNCQkFuUnFJWUVDSUlFQ0tBSUFJWUlDSUlJQ1FRQkdJWU1DQWtBZ2d3SUVRRUVBSVROQkFDRTJJT1FCSVRkQk9TR3lDQVVnSUVFZlJpR0VBaUFnUVFGMklZVUNRUmtnaFFKcklZWUNJSVFDQkg5QkFBVWdoZ0lMSVlnQ0lPRUJJSWdDZENHSkFrRUFJUnNnNUFFaEhpQ0NBaUVmSUlrQ0lTSkJBQ0VrQTBBQ1FDQWZRUVJxSVlvQ0lJb0NLQUlBSVlzQ0lJc0NRWGh4SVl3Q0lJd0NJT0VCYXlHTkFpQ05BaUFlU1NHT0FpQ09BZ1JBSUkwQ1FRQkdJWThDSUk4Q0JFQkJBQ0U5SUI4aFFDQWZJVUZCUFNHeUNBd0ZCU0FmSVNzZ2pRSWhMQXNGSUJzaEt5QWVJU3dMSUI5QkZHb2hrQUlna0FJb0FnQWhrUUlnSWtFZmRpR1RBaUFmUVJCcUlKTUNRUUowYWlHVUFpQ1VBaWdDQUNHVkFpQ1JBa0VBUmlHV0FpQ1JBaUNWQWtZaGx3SWdsZ0lnbHdKeUlhZ0lJS2dJQkg4Z0pBVWdrUUlMSVMwZ2xRSkJBRVlobUFJZ21BSkJBWE1ocEFnZ3BBaEJBWEVobVFJZ0lpQ1pBblFoSVNDWUFnUkFJQzBoTXlBcklUWWdMQ0UzUVRraHNnZ01BUVVnS3lFYklDd2hIaUNWQWlFZklDRWhJaUF0SVNRTERBRUxDd3NMSUxJSVFUbEdCRUFnTTBFQVJpR2FBaUEyUVFCR0lac0NJSm9DSUpzQ2NTR21DQ0NtQ0FSQVFRSWdJSFFobkFKQkFDQ2NBbXNobmdJZ25BSWduZ0p5SVo4Q0lPSUJJSjhDY1NHZ0FpQ2dBa0VBUmlHaEFpQ2hBZ1JBSU9FQklROE1CZ3RCQUNDZ0Ftc2hvZ0lnb0FJZ29nSnhJYU1DSUtNQ1FYOXFJYVFDSUtRQ1FReDJJYVVDSUtVQ1FSQnhJYVlDSUtRQ0lLWUNkaUduQWlDbkFrRUZkaUdwQWlDcEFrRUljU0dxQWlDcUFpQ21BbklocXdJZ3B3SWdxZ0oySWF3Q0lLd0NRUUoySWEwQ0lLMENRUVJ4SWE0Q0lLc0NJSzRDY2lHdkFpQ3NBaUN1QW5ZaHNBSWdzQUpCQVhZaHNRSWdzUUpCQW5FaHNnSWdyd0lnc2dKeUliVUNJTEFDSUxJQ2RpRzJBaUMyQWtFQmRpRzNBaUMzQWtFQmNTRzRBaUMxQWlDNEFuSWh1UUlndGdJZ3VBSjJJYm9DSUxrQ0lMb0NhaUc3QWtIc09DQzdBa0VDZEdvaHZBSWd2QUlvQWdBaHZRSkJBQ0U2SUwwQ0lUOEZJRFloT2lBeklUOExJRDlCQUVZaHZnSWd2Z0lFUUNBNklUa2dOeUU4QlNBM0lUMGdQeUZBSURvaFFVRTlJYklJQ3dzZ3NnaEJQVVlFUUFOQUFrQkJBQ0d5Q0NCQVFRUnFJY0FDSU1BQ0tBSUFJY0VDSU1FQ1FYaHhJY0lDSU1JQ0lPRUJheUhEQWlEREFpQTlTU0hFQWlERUFnUi9JTU1DQlNBOUN5RUVJTVFDQkg4Z1FBVWdRUXNoUGlCQVFSQnFJY1VDSU1VQ0tBSUFJY1lDSU1ZQ1FRQkdJY2NDSU1jQ1FRRnhJVk1nUUVFUWFpQlRRUUowYWlISUFpRElBaWdDQUNISkFpREpBa0VBUmlITEFpRExBZ1JBSUQ0aE9TQUVJVHdNQVFVZ0JDRTlJTWtDSVVBZ1BpRkJRVDBoc2dnTERBRUxDd3NnT1VFQVJpSE1BaURNQWdSQUlPRUJJUThGUWNRMktBSUFJYzBDSU0wQ0lPRUJheUhPQWlBOElNNENTU0hQQWlEUEFnUkFJRGtnNFFGcUlkQUNJTkFDSURsTElkRUNJTkVDUlFSQVFRQWhCaUN6Q0NRTklBWVBDeUE1UVJocUlkSUNJTklDS0FJQUlkTUNJRGxCREdvaDFBSWcxQUlvQWdBaDFnSWcxZ0lnT1VZaDF3SUNRQ0RYQWdSQUlEbEJGR29oM0FJZzNBSW9BZ0FoM1FJZzNRSkJBRVloM2dJZzNnSUVRQ0E1UVJCcUlkOENJTjhDS0FJQUllRUNJT0VDUVFCR0llSUNJT0lDQkVCQkFDRTREQU1GSU9FQ0lTNGczd0loTHdzRklOMENJUzRnM0FJaEx3c0RRQUpBSUM1QkZHb2g0d0lnNHdJb0FnQWg1QUlnNUFKQkFFWWg1UUlnNVFKRkJFQWc1QUloTGlEakFpRXZEQUlMSUM1QkVHb2g1Z0lnNWdJb0FnQWg1d0lnNXdKQkFFWWg2QUlnNkFJRVFBd0JCU0RuQWlFdUlPWUNJUzhMREFFTEN5QXZRUUEyQWdBZ0xpRTRCU0E1UVFocUlkZ0NJTmdDS0FJQUlka0NJTmtDUVF4cUlkb0NJTm9DSU5ZQ05nSUFJTllDUVFocUlkc0NJTnNDSU5rQ05nSUFJTllDSVRnTEN5RFRBa0VBUmlIcEFnSkFJT2tDQkVBZzRnRWh4Z01GSURsQkhHb2g2Z0lnNmdJb0FnQWg3QUpCN0RnZzdBSkJBblJxSWUwQ0lPMENLQUlBSWU0Q0lEa2c3Z0pHSWU4Q0lPOENCRUFnN1FJZ09EWUNBQ0E0UVFCR0lhSUlJS0lJQkVCQkFTRHNBblFoOEFJZzhBSkJmM01oOFFJZzRnRWc4UUp4SWZJQ1FjQTJJUElDTmdJQUlQSUNJY1lEREFNTEJTRFRBa0VRYWlIekFpRHpBaWdDQUNIMEFpRDBBaUE1UnlIMUFpRDFBa0VCY1NGVUlOTUNRUkJxSUZSQkFuUnFJZmNDSVBjQ0lEZzJBZ0FnT0VFQVJpSDRBaUQ0QWdSQUlPSUJJY1lEREFNTEN5QTRRUmhxSWZrQ0lQa0NJTk1DTmdJQUlEbEJFR29oK2dJZytnSW9BZ0FoK3dJZyt3SkJBRVloL0FJZy9BSkZCRUFnT0VFUWFpSDlBaUQ5QWlEN0FqWUNBQ0Q3QWtFWWFpSCtBaUQrQWlBNE5nSUFDeUE1UVJScUlmOENJUDhDS0FJQUlZQURJSUFEUVFCR0lZSURJSUlEQkVBZzRnRWh4Z01GSURoQkZHb2hnd01nZ3dNZ2dBTTJBZ0FnZ0FOQkdHb2hoQU1naEFNZ09EWUNBQ0RpQVNIR0F3c0xDeUE4UVJCSklZVURBa0FnaFFNRVFDQThJT0VCYWlHR0F5Q0dBMEVEY2lHSEF5QTVRUVJxSVlnRElJZ0RJSWNETmdJQUlEa2doZ05xSVlrRElJa0RRUVJxSVlvRElJb0RLQUlBSVlzRElJc0RRUUZ5SVkwRElJb0RJSTBETmdJQUJTRGhBVUVEY2lHT0F5QTVRUVJxSVk4RElJOERJSTRETmdJQUlEeEJBWEloa0FNZzBBSkJCR29oa1FNZ2tRTWdrQU0yQWdBZzBBSWdQR29oa2dNZ2tnTWdQRFlDQUNBOFFRTjJJWk1ESUR4QmdBSkpJWlFESUpRREJFQWdrd05CQVhRaGxRTkI1RFlnbFFOQkFuUnFJWllEUWJ3MktBSUFJWmdEUVFFZ2t3TjBJWmtESUpnRElKa0RjU0dhQXlDYUEwRUFSaUdiQXlDYkF3UkFJSmdESUprRGNpR2NBMEc4TmlDY0F6WUNBQ0NXQTBFSWFpRkpJSllESVNVZ1NTRk1CU0NXQTBFSWFpR2RBeUNkQXlnQ0FDR2VBeUNlQXlFbElKMERJVXdMSUV3ZzBBSTJBZ0FnSlVFTWFpR2ZBeUNmQXlEUUFqWUNBQ0RRQWtFSWFpR2dBeUNnQXlBbE5nSUFJTkFDUVF4cUlhRURJS0VESUpZRE5nSUFEQUlMSUR4QkNIWWhwQU1ncEFOQkFFWWhwUU1ncFFNRVFFRUFJU01GSUR4Qi8vLy9CMHNocGdNZ3BnTUVRRUVmSVNNRklLUURRWUQrUDJvaHB3TWdwd05CRUhZaHFBTWdxQU5CQ0hFaHFRTWdwQU1ncVFOMElhb0RJS29EUVlEZ0gyb2hxd01ncXdOQkVIWWhyQU1nckFOQkJIRWhyUU1nclFNZ3FRTnlJYThESUtvRElLMERkQ0d3QXlDd0EwR0FnQTlxSWJFRElMRURRUkIySWJJRElMSURRUUp4SWJNRElLOERJTE1EY2lHMEEwRU9JTFFEYXlHMUF5Q3dBeUN6QTNRaHRnTWd0Z05CRDNZaHR3TWd0UU1ndHdOcUliZ0RJTGdEUVFGMElib0RJTGdEUVFkcUlic0RJRHdndXdOMklid0RJTHdEUVFGeEliMERJTDBESUxvRGNpRytBeUMrQXlFakN3dEI3RGdnSTBFQ2RHb2h2d01nMEFKQkhHb2h3QU1nd0FNZ0l6WUNBQ0RRQWtFUWFpSEJBeURCQTBFRWFpSENBeURDQTBFQU5nSUFJTUVEUVFBMkFnQkJBU0FqZENIREF5REdBeUREQTNFaHhRTWd4UU5CQUVZaHh3TWd4d01FUUNER0F5RERBM0loeUFOQndEWWd5QU0yQWdBZ3Z3TWcwQUkyQWdBZzBBSkJHR29oeVFNZ3lRTWd2d00yQWdBZzBBSkJER29oeWdNZ3lnTWcwQUkyQWdBZzBBSkJDR29oeXdNZ3l3TWcwQUkyQWdBTUFnc2d2d01vQWdBaHpBTWdJMEVmUmlITkF5QWpRUUYySWM0RFFSa2d6Z05ySWRBRElNMERCSDlCQUFVZzBBTUxJZEVESUR3ZzBRTjBJZElESU5JRElSd2d6QU1oSFFOQUFrQWdIVUVFYWlIVEF5RFRBeWdDQUNIVUF5RFVBMEY0Y1NIVkF5RFZBeUE4UmlIV0F5RFdBd1JBUWVFQUliSUlEQUVMSUJ4QkgzWWgxd01nSFVFUWFpRFhBMEVDZEdvaDJBTWdIRUVCZENIWkF5RFlBeWdDQUNIYkF5RGJBMEVBUmlIY0F5RGNBd1JBUWVBQUliSUlEQUVGSU5rRElSd2cyd01oSFFzTUFRc0xJTElJUWVBQVJnUkFJTmdESU5BQ05nSUFJTkFDUVJocUlkMERJTjBESUIwMkFnQWcwQUpCREdvaDNnTWczZ01nMEFJMkFnQWcwQUpCQ0dvaDN3TWczd01nMEFJMkFnQU1BZ1Vnc2doQjRRQkdCRUFnSFVFSWFpSGdBeURnQXlnQ0FDSGhBeURoQTBFTWFpSGlBeURpQXlEUUFqWUNBQ0RnQXlEUUFqWUNBQ0RRQWtFSWFpSGpBeURqQXlEaEF6WUNBQ0RRQWtFTWFpSGtBeURrQXlBZE5nSUFJTkFDUVJocUllWURJT1lEUVFBMkFnQU1Bd3NMQ3dzZ09VRUlhaUhuQXlEbkF5RUdJTE1JSkEwZ0JnOEZJT0VCSVE4TEN3c0xDd3RCeERZb0FnQWg2QU1nNkFNZ0Qwa2g2UU1nNlFORkJFQWc2QU1nRDJzaDZnTkIwRFlvQWdBaDZ3TWc2Z05CRDBzaDdBTWc3QU1FUUNEckF5QVBhaUh0QTBIUU5pRHRBellDQUVIRU5pRHFBellDQUNEcUEwRUJjaUh1QXlEdEEwRUVhaUh2QXlEdkF5RHVBellDQUNEckF5RG9BMm9oOFFNZzhRTWc2Z00yQWdBZ0QwRURjaUh5QXlEckEwRUVhaUh6QXlEekF5RHlBellDQUFWQnhEWkJBRFlDQUVIUU5rRUFOZ0lBSU9nRFFRTnlJZlFESU9zRFFRUnFJZlVESVBVRElQUUROZ0lBSU9zRElPZ0RhaUgyQXlEMkEwRUVhaUgzQXlEM0F5Z0NBQ0g0QXlENEEwRUJjaUg1QXlEM0F5RDVBellDQUFzZzZ3TkJDR29oK2dNZytnTWhCaUN6Q0NRTklBWVBDMEhJTmlnQ0FDSDhBeUQ4QXlBUFN5SDlBeUQ5QXdSQUlQd0RJQTlySWY0RFFjZzJJUDRETmdJQVFkUTJLQUlBSWY4RElQOERJQTlxSVlBRVFkUTJJSUFFTmdJQUlQNERRUUZ5SVlFRUlJQUVRUVJxSVlJRUlJSUVJSUVFTmdJQUlBOUJBM0loZ3dRZy93TkJCR29oaEFRZ2hBUWdnd1EyQWdBZy93TkJDR29oaFFRZ2hRUWhCaUN6Q0NRTklBWVBDMEdVT2lnQ0FDR0hCQ0NIQkVFQVJpR0lCQ0NJQkFSQVFadzZRWUFnTmdJQVFaZzZRWUFnTmdJQVFhQTZRWDgyQWdCQnBEcEJmellDQUVHb09rRUFOZ0lBUWZnNVFRQTJBZ0FnVlNHSkJDQ0pCRUZ3Y1NHS0JDQ0tCRUhZcXRXcUJYTWhpd1JCbERvZ2l3UTJBZ0JCZ0NBaGp3UUZRWnc2S0FJQUlVZ2dTQ0dQQkFzZ0QwRXdhaUdNQkNBUFFTOXFJWTBFSUk4RUlJMEVhaUdPQkVFQUlJOEVheUdRQkNDT0JDQ1FCSEVoa3dRZ2t3UWdEMHNobEFRZ2xBUkZCRUJCQUNFR0lMTUlKQTBnQmc4TFFmUTVLQUlBSVpVRUlKVUVRUUJHSVpZRUlKWUVSUVJBUWV3NUtBSUFJWmNFSUpjRUlKTUVhaUdZQkNDWUJDQ1hCRTBobVFRZ21BUWdsUVJMSVpvRUlKa0VJSm9FY2lHbkNDQ25DQVJBUVFBaEJpQ3pDQ1FOSUFZUEN3dEIrRGtvQWdBaG13UWdtd1JCQkhFaG5BUWduQVJCQUVZaG5nUUNRQ0NlQkFSQVFkUTJLQUlBSVo4RUlKOEVRUUJHSWFBRUFrQWdvQVFFUUVIMkFDR3lDQVZCL0RraENnTkFBa0FnQ2lnQ0FDR2hCQ0NoQkNDZkJFc2hvZ1Fnb2dSRkJFQWdDa0VFYWlHakJDQ2pCQ2dDQUNHa0JDQ2hCQ0NrQkdvaHBRUWdwUVFnbndSTElhWUVJS1lFQkVBTUFnc0xJQXBCQ0dvaHB3UWdwd1FvQWdBaHFRUWdxUVJCQUVZaHFnUWdxZ1FFUUVIMkFDR3lDQXdFQlNDcEJDRUtDd3dCQ3dzZ2pnUWcvQU5ySWNNRUlNTUVJSkFFY1NIRUJDREVCRUgvLy8vL0Iwa2h4UVFneFFRRVFDREVCQkJoSWNZRUlBb29BZ0FoeHdRZ293UW9BZ0FoeUFRZ3h3UWd5QVJxSWNvRUlNWUVJTW9FUmlITEJDRExCQVJBSU1ZRVFYOUdJY3dFSU13RUJFQWd4QVFoTUFVZ3hBUWhRaURHQkNGRFFZY0JJYklJREFZTEJTREdCQ0V4SU1RRUlUSkIvZ0Foc2dnTEJVRUFJVEFMQ3dzQ1FDQ3lDRUgyQUVZRVFFRUFFR0VocXdRZ3F3UkJmMFlockFRZ3JBUUVRRUVBSVRBRklLc0VJYTBFUVpnNktBSUFJYTRFSUs0RVFYOXFJYThFSUs4RUlLMEVjU0d3QkNDd0JFRUFSaUd4QkNDdkJDQ3RCR29oc2dSQkFDQ3VCR3NodEFRZ3NnUWd0QVJ4SWJVRUlMVUVJSzBFYXlHMkJDQ3hCQVIvUVFBRklMWUVDeUczQkNDM0JDQ1RCR29oQlVIc09TZ0NBQ0c0QkNBRklMZ0VhaUc1QkNBRklBOUxJYm9FSUFWQi8vLy8vd2RKSWJzRUlMb0VJTHNFY1NHbENDQ2xDQVJBUWZRNUtBSUFJYndFSUx3RVFRQkdJYjBFSUwwRVJRUkFJTGtFSUxnRVRTRy9CQ0M1QkNDOEJFc2h3QVFndndRZ3dBUnlJYTBJSUswSUJFQkJBQ0V3REFVTEN5QUZFR0Vod1FRZ3dRUWdxd1JHSWNJRUlNSUVCRUFnQlNGQ0lLc0VJVU5CaHdFaHNnZ01CZ1Vnd1FRaE1TQUZJVEpCL2dBaHNnZ0xCVUVBSVRBTEN3c0xBa0Fnc2doQi9nQkdCRUJCQUNBeWF5SE5CQ0F4UVg5SEljNEVJREpCLy8vLy93ZEpJYzhFSU04RUlNNEVjU0d4Q0NDTUJDQXlTeUhRQkNEUUJDQ3hDSEVocVFnZ3FRaEZCRUFnTVVGL1JpSGJCQ0RiQkFSQVFRQWhNQXdEQlNBeUlVSWdNU0ZEUVljQkliSUlEQVVMQUF0Qm5Eb29BZ0FoMFFRZ2pRUWdNbXNoMGdRZzBnUWcwUVJxSWRNRVFRQWcwUVJySWRVRUlOTUVJTlVFY1NIV0JDRFdCRUgvLy8vL0Iwa2gxd1FnMXdSRkJFQWdNaUZDSURFaFEwR0hBU0d5Q0F3RUN5RFdCQkJoSWRnRUlOZ0VRWDlHSWRrRUlOa0VCRUFnelFRUVlScEJBQ0V3REFJRklOWUVJREpxSWRvRUlOb0VJVUlnTVNGRFFZY0JJYklJREFRTEFBc0xRZmc1S0FJQUlkd0VJTndFUVFSeUlkMEVRZmc1SU4wRU5nSUFJREFoTzBHRkFTR3lDQVZCQUNFN1FZVUJJYklJQ3dzZ3NnaEJoUUZHQkVBZ2t3UkIvLy8vL3dkSklkNEVJTjRFQkVBZ2t3UVFZU0hnQkVFQUVHRWg0UVFnNEFSQmYwY2g0Z1FnNFFSQmYwY2g0d1FnNGdRZzR3UnhJYThJSU9BRUlPRUVTU0hrQkNEa0JDQ3ZDSEVocWdnZzRRUWg1UVFnNEFRaDVnUWc1UVFnNWdSckllY0VJQTlCS0dvaDZBUWc1d1FnNkFSTElla0VJT2tFQkg4ZzV3UUZJRHNMSVFNZ3FnaEJBWE1ocXdnZzRBUkJmMFloNndRZzZRUkJBWE1ob3dnZzZ3UWdvd2h5SWV3RUlPd0VJS3NJY2lHdUNDQ3VDRVVFUUNBRElVSWc0QVFoUTBHSEFTR3lDQXNMQ3lDeUNFR0hBVVlFUUVIc09TZ0NBQ0h0QkNEdEJDQkNhaUh1QkVIc09TRHVCRFlDQUVId09TZ0NBQ0h2QkNEdUJDRHZCRXNoOEFRZzhBUUVRRUh3T1NEdUJEWUNBQXRCMURZb0FnQWg4UVFnOFFSQkFFWWg4Z1FDUUNEeUJBUkFRY3cyS0FJQUlmTUVJUE1FUVFCR0lmUUVJRU1nOHdSSklmWUVJUFFFSVBZRWNpR3NDQ0NzQ0FSQVFjdzJJRU0yQWdBTFFmdzVJRU0yQWdCQmdEb2dRallDQUVHSU9rRUFOZ0lBUVpRNktBSUFJZmNFUWVBMklQY0VOZ0lBUWR3MlFYODJBZ0JCOERaQjVEWTJBZ0JCN0RaQjVEWTJBZ0JCK0RaQjdEWTJBZ0JCOURaQjdEWTJBZ0JCZ0RkQjlEWTJBZ0JCL0RaQjlEWTJBZ0JCaURkQi9EWTJBZ0JCaERkQi9EWTJBZ0JCa0RkQmhEYzJBZ0JCakRkQmhEYzJBZ0JCbURkQmpEYzJBZ0JCbERkQmpEYzJBZ0JCb0RkQmxEYzJBZ0JCbkRkQmxEYzJBZ0JCcURkQm5EYzJBZ0JCcERkQm5EYzJBZ0JCc0RkQnBEYzJBZ0JCckRkQnBEYzJBZ0JCdURkQnJEYzJBZ0JCdERkQnJEYzJBZ0JCd0RkQnREYzJBZ0JCdkRkQnREYzJBZ0JCeURkQnZEYzJBZ0JCeERkQnZEYzJBZ0JCMERkQnhEYzJBZ0JCekRkQnhEYzJBZ0JCMkRkQnpEYzJBZ0JCMURkQnpEYzJBZ0JCNERkQjFEYzJBZ0JCM0RkQjFEYzJBZ0JCNkRkQjNEYzJBZ0JCNURkQjNEYzJBZ0JCOERkQjVEYzJBZ0JCN0RkQjVEYzJBZ0JCK0RkQjdEYzJBZ0JCOURkQjdEYzJBZ0JCZ0RoQjlEYzJBZ0JCL0RkQjlEYzJBZ0JCaURoQi9EYzJBZ0JCaERoQi9EYzJBZ0JCa0RoQmhEZzJBZ0JCakRoQmhEZzJBZ0JCbURoQmpEZzJBZ0JCbERoQmpEZzJBZ0JCb0RoQmxEZzJBZ0JCbkRoQmxEZzJBZ0JCcURoQm5EZzJBZ0JCcERoQm5EZzJBZ0JCc0RoQnBEZzJBZ0JCckRoQnBEZzJBZ0JCdURoQnJEZzJBZ0JCdERoQnJEZzJBZ0JCd0RoQnREZzJBZ0JCdkRoQnREZzJBZ0JCeURoQnZEZzJBZ0JCeERoQnZEZzJBZ0JCMERoQnhEZzJBZ0JCekRoQnhEZzJBZ0JCMkRoQnpEZzJBZ0JCMURoQnpEZzJBZ0JCNERoQjFEZzJBZ0JCM0RoQjFEZzJBZ0JCNkRoQjNEZzJBZ0JCNURoQjNEZzJBZ0FnUWtGWWFpSDRCQ0JEUVFocUlma0VJUGtFSWZvRUlQb0VRUWR4SWZzRUlQc0VRUUJHSWZ3RVFRQWcrZ1JySWYwRUlQMEVRUWR4SWY0RUlQd0VCSDlCQUFVZy9nUUxJZjhFSUVNZy93UnFJWUlGSVBnRUlQOEVheUdEQlVIVU5pQ0NCVFlDQUVISU5pQ0RCVFlDQUNDREJVRUJjaUdFQlNDQ0JVRUVhaUdGQlNDRkJTQ0VCVFlDQUNCRElQZ0VhaUdHQlNDR0JVRUVhaUdIQlNDSEJVRW9OZ0lBUWFRNktBSUFJWWdGUWRnMklJZ0ZOZ0lBQlVIOE9TRVZBMEFDUUNBVktBSUFJWWtGSUJWQkJHb2hpZ1VnaWdVb0FnQWhpd1VnaVFVZ2l3VnFJWTBGSUVNZ2pRVkdJWTRGSUk0RkJFQkJqd0Voc2dnTUFRc2dGVUVJYWlHUEJTQ1BCU2dDQUNHUUJTQ1FCVUVBUmlHUkJTQ1JCUVJBREFFRklKQUZJUlVMREFFTEN5Q3lDRUdQQVVZRVFDQVZRUXhxSVpJRklKSUZLQUlBSVpNRklKTUZRUWh4SVpRRklKUUZRUUJHSVpVRklKVUZCRUFnaVFVZzhRUk5JWllGSUVNZzhRUkxJWmdGSUpnRklKWUZjU0d3Q0NDd0NBUkFJSXNGSUVKcUlaa0ZJSW9GSUprRk5nSUFRY2cyS0FJQUlab0ZJSm9GSUVKcUlac0ZJUEVFUVFocUlad0ZJSndGSVowRklKMEZRUWR4SVo0RklKNEZRUUJHSVo4RlFRQWduUVZySWFBRklLQUZRUWR4SWFFRklKOEZCSDlCQUFVZ29RVUxJYU1GSVBFRUlLTUZhaUdrQlNDYkJTQ2pCV3NocFFWQjFEWWdwQVUyQWdCQnlEWWdwUVUyQWdBZ3BRVkJBWElocGdVZ3BBVkJCR29ocHdVZ3B3VWdwZ1UyQWdBZzhRUWdtd1ZxSWFnRklLZ0ZRUVJxSWFrRklLa0ZRU2cyQWdCQnBEb29BZ0FocWdWQjJEWWdxZ1UyQWdBTUJBc0xDMEhNTmlnQ0FDR3JCU0JESUtzRlNTR3NCU0NzQlFSQVFjdzJJRU0yQWdBTElFTWdRbW9ocmdWQi9Ea2hLQU5BQWtBZ0tDZ0NBQ0d2QlNDdkJTQ3VCVVloc0FVZ3NBVUVRRUdYQVNHeUNBd0JDeUFvUVFocUliRUZJTEVGS0FJQUliSUZJTElGUVFCR0liTUZJTE1GQkVCQi9Ea2hDUXdCQlNDeUJTRW9Dd3dCQ3dzZ3NnaEJsd0ZHQkVBZ0tFRU1haUcwQlNDMEJTZ0NBQ0cxQlNDMUJVRUljU0cyQlNDMkJVRUFSaUczQlNDM0JRUkFJQ2dnUXpZQ0FDQW9RUVJxSWJrRklMa0ZLQUlBSWJvRklMb0ZJRUpxSWJzRklMa0ZJTHNGTmdJQUlFTkJDR29odkFVZ3ZBVWh2UVVndlFWQkIzRWh2Z1VndmdWQkFFWWh2d1ZCQUNDOUJXc2h3QVVnd0FWQkIzRWh3UVVndndVRWYwRUFCU0RCQlFzaHdnVWdReURDQldvaHhBVWdyZ1ZCQ0dvaHhRVWd4UVVoeGdVZ3hnVkJCM0VoeHdVZ3h3VkJBRVloeUFWQkFDREdCV3NoeVFVZ3lRVkJCM0VoeWdVZ3lBVUVmMEVBQlNES0JRc2h5d1VncmdVZ3l3VnFJY3dGSU13RkljMEZJTVFGSWM4RklNMEZJTThGYXlIUUJTREVCU0FQYWlIUkJTRFFCU0FQYXlIU0JTQVBRUU55SWRNRklNUUZRUVJxSWRRRklOUUZJTk1GTmdJQUlQRUVJTXdGUmlIVkJRSkFJTlVGQkVCQnlEWW9BZ0FoMWdVZzFnVWcwZ1ZxSWRjRlFjZzJJTmNGTmdJQVFkUTJJTkVGTmdJQUlOY0ZRUUZ5SWRnRklORUZRUVJxSWRvRklOb0ZJTmdGTmdJQUJVSFFOaWdDQUNIYkJTRGJCU0RNQlVZaDNBVWczQVVFUUVIRU5pZ0NBQ0hkQlNEZEJTRFNCV29oM2dWQnhEWWczZ1UyQWdCQjBEWWcwUVUyQWdBZzNnVkJBWEloM3dVZzBRVkJCR29oNEFVZzRBVWczd1UyQWdBZzBRVWczZ1ZxSWVFRklPRUZJTjRGTmdJQURBSUxJTXdGUVFScUllSUZJT0lGS0FJQUllTUZJT01GUVFOeEllVUZJT1VGUVFGR0llWUZJT1lGQkVBZzR3VkJlSEVoNXdVZzR3VkJBM1loNkFVZzR3VkJnQUpKSWVrRkFrQWc2UVVFUUNETUJVRUlhaUhxQlNEcUJTZ0NBQ0hyQlNETUJVRU1haUhzQlNEc0JTZ0NBQ0h0QlNEdEJTRHJCVVloN2dVZzdnVUVRRUVCSU9nRmRDSHhCU0R4QlVGL2N5SHlCVUc4TmlnQ0FDSHpCU0R6QlNEeUJYRWg5QVZCdkRZZzlBVTJBZ0FNQWdVZzZ3VkJER29oOVFVZzlRVWc3UVUyQWdBZzdRVkJDR29oOWdVZzlnVWc2d1UyQWdBTUFnc0FCU0RNQlVFWWFpSDNCU0QzQlNnQ0FDSDRCU0RNQlVFTWFpSDVCU0Q1QlNnQ0FDSDZCU0Q2QlNETUJVWWgvQVVDUUNEOEJRUkFJTXdGUVJCcUlZRUdJSUVHUVFScUlZSUdJSUlHS0FJQUlZTUdJSU1HUVFCR0lZUUdJSVFHQkVBZ2dRWW9BZ0FoaFFZZ2hRWkJBRVloaHdZZ2h3WUVRRUVBSVRVTUF3VWdoUVloS1NDQkJpRXFDd1VnZ3dZaEtTQ0NCaUVxQ3dOQUFrQWdLVUVVYWlHSUJpQ0lCaWdDQUNHSkJpQ0pCa0VBUmlHS0JpQ0tCa1VFUUNDSkJpRXBJSWdHSVNvTUFnc2dLVUVRYWlHTEJpQ0xCaWdDQUNHTUJpQ01Ca0VBUmlHTkJpQ05CZ1JBREFFRklJd0dJU2tnaXdZaEtnc01BUXNMSUNwQkFEWUNBQ0FwSVRVRklNd0ZRUWhxSWYwRklQMEZLQUlBSWY0RklQNEZRUXhxSWY4RklQOEZJUG9GTmdJQUlQb0ZRUWhxSVlBR0lJQUdJUDRGTmdJQUlQb0ZJVFVMQ3lENEJVRUFSaUdPQmlDT0JnUkFEQUlMSU13RlFSeHFJWThHSUk4R0tBSUFJWkFHUWV3NElKQUdRUUowYWlHU0JpQ1NCaWdDQUNHVEJpQ1RCaURNQlVZaGxBWUNRQ0NVQmdSQUlKSUdJRFUyQWdBZ05VRUFSaUdoQ0NDaENFVUVRQXdDQzBFQklKQUdkQ0dWQmlDVkJrRi9jeUdXQmtIQU5pZ0NBQ0dYQmlDWEJpQ1dCbkVobUFaQndEWWdtQVkyQWdBTUF3VWcrQVZCRUdvaG1RWWdtUVlvQWdBaG1nWWdtZ1lnekFWSElac0dJSnNHUVFGeElWQWcrQVZCRUdvZ1VFRUNkR29oblFZZ25RWWdOVFlDQUNBMVFRQkdJWjRHSUo0R0JFQU1CQXNMQ3lBMVFSaHFJWjhHSUo4R0lQZ0ZOZ0lBSU13RlFSQnFJYUFHSUtBR0tBSUFJYUVHSUtFR1FRQkdJYUlHSUtJR1JRUkFJRFZCRUdvaG93WWdvd1lnb1FZMkFnQWdvUVpCR0dvaHBBWWdwQVlnTlRZQ0FBc2dvQVpCQkdvaHBRWWdwUVlvQWdBaHBnWWdwZ1pCQUVZaHFBWWdxQVlFUUF3Q0N5QTFRUlJxSWFrR0lLa0dJS1lHTmdJQUlLWUdRUmhxSWFvR0lLb0dJRFUyQWdBTEN5RE1CU0RuQldvaHF3WWc1d1VnMGdWcUlhd0dJS3NHSVFnZ3JBWWhGZ1VnekFVaENDRFNCU0VXQ3lBSVFRUnFJYTBHSUswR0tBSUFJYTRHSUs0R1FYNXhJYThHSUswR0lLOEdOZ0lBSUJaQkFYSWhzQVlnMFFWQkJHb2hzUVlnc1FZZ3NBWTJBZ0FnMFFVZ0Ztb2hzd1lnc3dZZ0ZqWUNBQ0FXUVFOMkliUUdJQlpCZ0FKSkliVUdJTFVHQkVBZ3RBWkJBWFFodGdaQjVEWWd0Z1pCQW5ScUliY0dRYncyS0FJQUliZ0dRUUVndEFaMElia0dJTGdHSUxrR2NTRzZCaUM2QmtFQVJpRzdCaUM3QmdSQUlMZ0dJTGtHY2lHOEJrRzhOaUM4QmpZQ0FDQzNCa0VJYWlGSElMY0dJUmtnUnlGTEJTQzNCa0VJYWlHK0JpQytCaWdDQUNHL0JpQy9CaUVaSUw0R0lVc0xJRXNnMFFVMkFnQWdHVUVNYWlIQUJpREFCaURSQlRZQ0FDRFJCVUVJYWlIQkJpREJCaUFaTmdJQUlORUZRUXhxSWNJR0lNSUdJTGNHTmdJQURBSUxJQlpCQ0hZaHd3WWd3d1pCQUVZaHhBWUNRQ0RFQmdSQVFRQWhHZ1VnRmtILy8vOEhTeUhGQmlERkJnUkFRUjhoR2d3Q0N5RERCa0dBL2o5cUljWUdJTVlHUVJCMkljY0dJTWNHUVFoeElja0dJTU1HSU1rR2RDSEtCaURLQmtHQTRCOXFJY3NHSU1zR1FSQjJJY3dHSU13R1FRUnhJYzBHSU0wR0lNa0djaUhPQmlES0JpRE5CblFoendZZ3p3WkJnSUFQYWlIUUJpRFFCa0VRZGlIUkJpRFJCa0VDY1NIU0JpRE9CaURTQm5JaDFBWkJEaURVQm1zaDFRWWd6d1lnMGdaMElkWUdJTllHUVE5MklkY0dJTlVHSU5jR2FpSFlCaURZQmtFQmRDSFpCaURZQmtFSGFpSGFCaUFXSU5vR2RpSGJCaURiQmtFQmNTSGNCaURjQmlEWkJuSWgzUVlnM1FZaEdnc0xRZXc0SUJwQkFuUnFJZUFHSU5FRlFSeHFJZUVHSU9FR0lCbzJBZ0FnMFFWQkVHb2g0Z1lnNGdaQkJHb2g0d1lnNHdaQkFEWUNBQ0RpQmtFQU5nSUFRY0EyS0FJQUllUUdRUUVnR25RaDVRWWc1QVlnNVFaeEllWUdJT1lHUVFCR0llY0dJT2NHQkVBZzVBWWc1UVp5SWVnR1FjQTJJT2dHTmdJQUlPQUdJTkVGTmdJQUlORUZRUmhxSWVrR0lPa0dJT0FHTmdJQUlORUZRUXhxSWVzR0lPc0dJTkVGTmdJQUlORUZRUWhxSWV3R0lPd0dJTkVGTmdJQURBSUxJT0FHS0FJQUllMEdJQnBCSDBZaDdnWWdHa0VCZGlIdkJrRVpJTzhHYXlId0JpRHVCZ1IvUVFBRklQQUdDeUh4QmlBV0lQRUdkQ0h5QmlEeUJpRVhJTzBHSVJnRFFBSkFJQmhCQkdvaDh3WWc4d1lvQWdBaDlBWWc5QVpCZUhFaDlnWWc5Z1lnRmtZaDl3WWc5d1lFUUVIQUFTR3lDQXdCQ3lBWFFSOTJJZmdHSUJoQkVHb2crQVpCQW5ScUlma0dJQmRCQVhRaCtnWWcrUVlvQWdBaCt3WWcrd1pCQUVZaC9BWWcvQVlFUUVHL0FTR3lDQXdCQlNENkJpRVhJUHNHSVJnTERBRUxDeUN5Q0VHL0FVWUVRQ0Q1QmlEUkJUWUNBQ0RSQlVFWWFpSDlCaUQ5QmlBWU5nSUFJTkVGUVF4cUlmNEdJUDRHSU5FRk5nSUFJTkVGUVFocUlmOEdJUDhHSU5FRk5nSUFEQUlGSUxJSVFjQUJSZ1JBSUJoQkNHb2hnUWNnZ1Fjb0FnQWhnZ2NnZ2dkQkRHb2hnd2NnZ3djZzBRVTJBZ0FnZ1FjZzBRVTJBZ0FnMFFWQkNHb2hoQWNnaEFjZ2dnYzJBZ0FnMFFWQkRHb2hoUWNnaFFjZ0dEWUNBQ0RSQlVFWWFpR0dCeUNHQjBFQU5nSUFEQU1MQ3dzTElNUUZRUWhxSVpFSUlKRUlJUVlnc3dna0RTQUdEd1ZCL0RraENRc0xBMEFDUUNBSktBSUFJWWNISUljSElQRUVTeUdJQnlDSUIwVUVRQ0FKUVFScUlZa0hJSWtIS0FJQUlZb0hJSWNISUlvSGFpR01CeUNNQnlEeEJFc2hqUWNnalFjRVFBd0NDd3NnQ1VFSWFpR09CeUNPQnlnQ0FDR1BCeUNQQnlFSkRBRUxDeUNNQjBGUmFpR1FCeUNRQjBFSWFpR1JCeUNSQnlHU0J5Q1NCMEVIY1NHVEJ5Q1RCMEVBUmlHVUIwRUFJSklIYXlHVkJ5Q1ZCMEVIY1NHWEJ5Q1VCd1IvUVFBRklKY0hDeUdZQnlDUUJ5Q1lCMm9obVFjZzhRUkJFR29obWdjZ21RY2dtZ2RKSVpzSElKc0hCSDhnOFFRRklKa0hDeUdjQnlDY0IwRUlhaUdkQnlDY0IwRVlhaUdlQnlCQ1FWaHFJWjhISUVOQkNHb2hvQWNnb0FjaG9nY2dvZ2RCQjNFaG93Y2dvd2RCQUVZaHBBZEJBQ0NpQjJzaHBRY2dwUWRCQjNFaHBnY2dwQWNFZjBFQUJTQ21Cd3NocHdjZ1F5Q25CMm9ocUFjZ253Y2dwd2RySWFrSFFkUTJJS2dITmdJQVFjZzJJS2tITmdJQUlLa0hRUUZ5SWFvSElLZ0hRUVJxSWFzSElLc0hJS29ITmdJQUlFTWdud2RxSWEwSElLMEhRUVJxSWE0SElLNEhRU2cyQWdCQnBEb29BZ0FocndkQjJEWWdyd2MyQWdBZ25BZEJCR29oc0FjZ3NBZEJHellDQUNDZEIwSDhPU2tDQURjQ0FDQ2RCMEVJYWtIOE9VRUlhaWtDQURjQ0FFSDhPU0JETmdJQVFZQTZJRUkyQWdCQmlEcEJBRFlDQUVHRU9pQ2RCellDQUNDZUJ5R3lCd05BQWtBZ3NnZEJCR29oc1FjZ3NRZEJCellDQUNDeUIwRUlhaUd6QnlDekJ5Q01CMGtodEFjZ3RBY0VRQ0N4QnlHeUJ3VU1BUXNNQVFzTElKd0hJUEVFUmlHMUJ5QzFCMFVFUUNDY0J5RzJCeUR4QkNHNEJ5QzJCeUM0QjJzaHVRY2dzQWNvQWdBaHVnY2d1Z2RCZm5FaHV3Y2dzQWNndXdjMkFnQWd1UWRCQVhJaHZBY2c4UVJCQkdvaHZRY2d2UWNndkFjMkFnQWduQWNndVFjMkFnQWd1UWRCQTNZaHZnY2d1UWRCZ0FKSkliOEhJTDhIQkVBZ3ZnZEJBWFFod0FkQjVEWWd3QWRCQW5ScUljRUhRYncyS0FJQUljTUhRUUVndmdkMEljUUhJTU1ISU1RSGNTSEZCeURGQjBFQVJpSEdCeURHQndSQUlNTUhJTVFIY2lISEIwRzhOaURIQnpZQ0FDREJCMEVJYWlGR0lNRUhJUk1nUmlGS0JTREJCMEVJYWlISUJ5RElCeWdDQUNISkJ5REpCeUVUSU1nSElVb0xJRW9nOFFRMkFnQWdFMEVNYWlIS0J5REtCeUR4QkRZQ0FDRHhCRUVJYWlITEJ5RExCeUFUTmdJQUlQRUVRUXhxSWN3SElNd0hJTUVITmdJQURBTUxJTGtIUVFoMkljOEhJTThIUVFCR0lkQUhJTkFIQkVCQkFDRVVCU0M1QjBILy8vOEhTeUhSQnlEUkJ3UkFRUjhoRkFVZ3p3ZEJnUDQvYWlIU0J5RFNCMEVRZGlIVEJ5RFRCMEVJY1NIVUJ5RFBCeURVQjNRaDFRY2cxUWRCZ09BZmFpSFdCeURXQjBFUWRpSFhCeURYQjBFRWNTSFlCeURZQnlEVUIzSWgyZ2NnMVFjZzJBZDBJZHNISU5zSFFZQ0FEMm9oM0FjZzNBZEJFSFloM1FjZzNRZEJBbkVoM2djZzJnY2czZ2R5SWQ4SFFRNGczd2RySWVBSElOc0hJTjRIZENIaEJ5RGhCMEVQZGlIaUJ5RGdCeURpQjJvaDR3Y2c0d2RCQVhRaDVRY2c0d2RCQjJvaDVnY2d1UWNnNWdkMkllY0hJT2NIUVFGeEllZ0hJT2dISU9VSGNpSHBCeURwQnlFVUN3dEI3RGdnRkVFQ2RHb2g2Z2NnOFFSQkhHb2g2d2NnNndjZ0ZEWUNBQ0R4QkVFVWFpSHNCeURzQjBFQU5nSUFJSm9IUVFBMkFnQkJ3RFlvQWdBaDdRZEJBU0FVZENIdUJ5RHRCeUR1QjNFaDhBY2c4QWRCQUVZaDhRY2c4UWNFUUNEdEJ5RHVCM0loOGdkQndEWWc4Z2MyQWdBZzZnY2c4UVEyQWdBZzhRUkJHR29oOHdjZzh3Y2c2Z2MyQWdBZzhRUkJER29oOUFjZzlBY2c4UVEyQWdBZzhRUkJDR29oOVFjZzlRY2c4UVEyQWdBTUF3c2c2Z2NvQWdBaDlnY2dGRUVmUmlIM0J5QVVRUUYySWZnSFFSa2crQWRySWZrSElQY0hCSDlCQUFVZytRY0xJZnNISUxrSElQc0hkQ0g4QnlEOEJ5RVJJUFlISVJJRFFBSkFJQkpCQkdvaC9RY2cvUWNvQWdBaC9nY2cvZ2RCZUhFaC93Y2cvd2NndVFkR0lZQUlJSUFJQkVCQjFRRWhzZ2dNQVFzZ0VVRWZkaUdCQ0NBU1FSQnFJSUVJUVFKMGFpR0NDQ0FSUVFGMElZTUlJSUlJS0FJQUlZUUlJSVFJUVFCR0lZWUlJSVlJQkVCQjFBRWhzZ2dNQVFVZ2d3Z2hFU0NFQ0NFU0N3d0JDd3Nnc2doQjFBRkdCRUFnZ2dnZzhRUTJBZ0FnOFFSQkdHb2hod2dnaHdnZ0VqWUNBQ0R4QkVFTWFpR0lDQ0NJQ0NEeEJEWUNBQ0R4QkVFSWFpR0pDQ0NKQ0NEeEJEWUNBQXdEQlNDeUNFSFZBVVlFUUNBU1FRaHFJWW9JSUlvSUtBSUFJWXNJSUlzSVFReHFJWXdJSUl3SUlQRUVOZ0lBSUlvSUlQRUVOZ0lBSVBFRVFRaHFJWTBJSUkwSUlJc0lOZ0lBSVBFRVFReHFJWTRJSUk0SUlCSTJBZ0FnOFFSQkdHb2hqd2dnandoQkFEWUNBQXdFQ3dzTEN3dEJ5RFlvQWdBaGtnZ2drZ2dnRDBzaGt3Z2drd2dFUUNDU0NDQVBheUdVQ0VISU5pQ1VDRFlDQUVIVU5pZ0NBQ0dWQ0NDVkNDQVBhaUdXQ0VIVU5pQ1dDRFlDQUNDVUNFRUJjaUdYQ0NDV0NFRUVhaUdZQ0NDWUNDQ1hDRFlDQUNBUFFRTnlJWmtJSUpVSVFRUnFJWm9JSUpvSUlKa0lOZ0lBSUpVSVFRaHFJWndJSUp3SUlRWWdzd2drRFNBR0R3c0xFREVoblFnZ25RaEJERFlDQUVFQUlRWWdzd2drRFNBR0R3dXdHd0diQW44akRTR2JBaUFBUVFCR0lSUWdGQVJBRHdzZ0FFRjRhaUdEQVVITU5pZ0NBQ0hMQVNBQVFYeHFJZFlCSU5ZQktBSUFJZUVCSU9FQlFYaHhJZXdCSUlNQklPd0JhaUgzQVNEaEFVRUJjU0dDQWlDQ0FrRUFSaUdOQWdKQUlJMENCRUFnZ3dFb0FnQWhGU0RoQVVFRGNTRWdJQ0JCQUVZaEt5QXJCRUFQQzBFQUlCVnJJVFlnZ3dFZ05tb2hRU0FWSU93QmFpRk1JRUVneXdGSklWY2dWd1JBRHd0QjBEWW9BZ0FoWWlCaUlFRkdJVzBnYlFSQUlQY0JRUVJxSVlFQ0lJRUNLQUlBSVlNQ0lJTUNRUU54SVlRQ0lJUUNRUU5HSVlVQ0lJVUNSUVJBSUVFaEJ5Qk1JUWdnUVNHTEFnd0RDMEhFTmlCTU5nSUFJSU1DUVg1eElZWUNJSUVDSUlZQ05nSUFJRXhCQVhJaGh3SWdRVUVFYWlHSUFpQ0lBaUNIQWpZQ0FDQkJJRXhxSVlrQ0lJa0NJRXcyQWdBUEN5QVZRUU4ySVhnZ0ZVR0FBa2toaEFFZ2hBRUVRQ0JCUVFocUlZOEJJSThCS0FJQUlab0JJRUZCREdvaHBRRWdwUUVvQWdBaHNBRWdzQUVnbWdGR0lic0JJTHNCQkVCQkFTQjRkQ0hHQVNER0FVRi9jeUhJQVVHOE5pZ0NBQ0hKQVNESkFTRElBWEVoeWdGQnZEWWd5Z0UyQWdBZ1FTRUhJRXdoQ0NCQklZc0NEQU1GSUpvQlFReHFJY3dCSU13QklMQUJOZ0lBSUxBQlFRaHFJYzBCSU0wQklKb0JOZ0lBSUVFaEJ5Qk1JUWdnUVNHTEFnd0RDd0FMSUVGQkdHb2h6Z0VnemdFb0FnQWh6d0VnUVVFTWFpSFFBU0RRQVNnQ0FDSFJBU0RSQVNCQlJpSFNBUUpBSU5JQkJFQWdRVUVRYWlIWUFTRFlBVUVFYWlIWkFTRFpBU2dDQUNIYUFTRGFBVUVBUmlIYkFTRGJBUVJBSU5nQktBSUFJZHdCSU53QlFRQkdJZDBCSU4wQkJFQkJBQ0VPREFNRklOd0JJUWtnMkFFaENnc0ZJTm9CSVFrZzJRRWhDZ3NEUUFKQUlBbEJGR29oM2dFZzNnRW9BZ0FoM3dFZzN3RkJBRVloNEFFZzRBRkZCRUFnM3dFaENTRGVBU0VLREFJTElBbEJFR29oNGdFZzRnRW9BZ0FoNHdFZzR3RkJBRVloNUFFZzVBRUVRQXdCQlNEakFTRUpJT0lCSVFvTERBRUxDeUFLUVFBMkFnQWdDU0VPQlNCQlFRaHFJZE1CSU5NQktBSUFJZFFCSU5RQlFReHFJZFVCSU5VQklORUJOZ0lBSU5FQlFRaHFJZGNCSU5jQklOUUJOZ0lBSU5FQklRNExDeURQQVVFQVJpSGxBU0RsQVFSQUlFRWhCeUJNSVFnZ1FTR0xBZ1VnUVVFY2FpSG1BU0RtQVNnQ0FDSG5BVUhzT0NEbkFVRUNkR29oNkFFZzZBRW9BZ0FoNlFFZzZRRWdRVVloNmdFZzZnRUVRQ0RvQVNBT05nSUFJQTVCQUVZaG1BSWdtQUlFUUVFQklPY0JkQ0hyQVNEckFVRi9jeUh0QVVIQU5pZ0NBQ0h1QVNEdUFTRHRBWEVoN3dGQndEWWc3d0UyQWdBZ1FTRUhJRXdoQ0NCQklZc0NEQVFMQlNEUEFVRVFhaUh3QVNEd0FTZ0NBQ0h4QVNEeEFTQkJSeUh5QVNEeUFVRUJjU0VTSU04QlFSQnFJQkpCQW5ScUlmTUJJUE1CSUE0MkFnQWdEa0VBUmlIMEFTRDBBUVJBSUVFaEJ5Qk1JUWdnUVNHTEFnd0VDd3NnRGtFWWFpSDFBU0QxQVNEUEFUWUNBQ0JCUVJCcUlmWUJJUFlCS0FJQUlmZ0JJUGdCUVFCR0lma0JJUGtCUlFSQUlBNUJFR29oK2dFZytnRWcrQUUyQWdBZytBRkJHR29oK3dFZyt3RWdEallDQUFzZzlnRkJCR29oL0FFZy9BRW9BZ0FoL1FFZy9RRkJBRVloL2dFZy9nRUVRQ0JCSVFjZ1RDRUlJRUVoaXdJRklBNUJGR29oL3dFZy93RWcvUUUyQWdBZy9RRkJHR29oZ0FJZ2dBSWdEallDQUNCQklRY2dUQ0VJSUVFaGl3SUxDd1VnZ3dFaEJ5RHNBU0VJSUlNQklZc0NDd3NnaXdJZzl3RkpJWW9DSUlvQ1JRUkFEd3NnOXdGQkJHb2hqQUlnakFJb0FnQWhqZ0lnamdKQkFYRWhqd0lnandKQkFFWWhrQUlna0FJRVFBOExJSTRDUVFKeElaRUNJSkVDUVFCR0laSUNJSklDQkVCQjFEWW9BZ0Foa3dJZ2t3SWc5d0ZHSVpRQ0lKUUNCRUJCeURZb0FnQWhsUUlnbFFJZ0NHb2hsZ0pCeURZZ2xnSTJBZ0JCMURZZ0J6WUNBQ0NXQWtFQmNpR1hBaUFIUVFScUlSWWdGaUNYQWpZQ0FFSFFOaWdDQUNFWElBY2dGMFloR0NBWVJRUkFEd3RCMERaQkFEWUNBRUhFTmtFQU5nSUFEd3RCMERZb0FnQWhHU0FaSVBjQlJpRWFJQm9FUUVIRU5pZ0NBQ0ViSUJzZ0NHb2hIRUhFTmlBY05nSUFRZEEySUlzQ05nSUFJQnhCQVhJaEhTQUhRUVJxSVI0Z0hpQWROZ0lBSUlzQ0lCeHFJUjhnSHlBY05nSUFEd3NnamdKQmVIRWhJU0FoSUFocUlTSWdqZ0pCQTNZaEl5Q09Ba0dBQWtraEpBSkFJQ1FFUUNEM0FVRUlhaUVsSUNVb0FnQWhKaUQzQVVFTWFpRW5JQ2NvQWdBaEtDQW9JQ1pHSVNrZ0tRUkFRUUVnSTNRaEtpQXFRWDl6SVN4QnZEWW9BZ0FoTFNBdElDeHhJUzVCdkRZZ0xqWUNBQXdDQlNBbVFReHFJUzhnTHlBb05nSUFJQ2hCQ0dvaE1DQXdJQ1kyQWdBTUFnc0FCU0QzQVVFWWFpRXhJREVvQWdBaE1pRDNBVUVNYWlFeklETW9BZ0FoTkNBMElQY0JSaUUxQWtBZ05RUkFJUGNCUVJCcUlUc2dPMEVFYWlFOElEd29BZ0FoUFNBOVFRQkdJVDRnUGdSQUlEc29BZ0FoUHlBL1FRQkdJVUFnUUFSQVFRQWhEd3dEQlNBL0lRc2dPeUVNQ3dVZ1BTRUxJRHdoREFzRFFBSkFJQXRCRkdvaFFpQkNLQUlBSVVNZ1EwRUFSaUZFSUVSRkJFQWdReUVMSUVJaERBd0NDeUFMUVJCcUlVVWdSU2dDQUNGR0lFWkJBRVloUnlCSEJFQU1BUVVnUmlFTElFVWhEQXNNQVFzTElBeEJBRFlDQUNBTElROEZJUGNCUVFocUlUY2dOeWdDQUNFNElEaEJER29oT1NBNUlEUTJBZ0FnTkVFSWFpRTZJRG9nT0RZQ0FDQTBJUThMQ3lBeVFRQkdJVWdnU0VVRVFDRDNBVUVjYWlGSklFa29BZ0FoU2tIc09DQktRUUowYWlGTElFc29BZ0FoVFNCTklQY0JSaUZPSUU0RVFDQkxJQTgyQWdBZ0QwRUFSaUdaQWlDWkFnUkFRUUVnU25RaFR5QlBRWDl6SVZCQndEWW9BZ0FoVVNCUklGQnhJVkpCd0RZZ1VqWUNBQXdFQ3dVZ01rRVFhaUZUSUZNb0FnQWhWQ0JVSVBjQlJ5RlZJRlZCQVhFaEV5QXlRUkJxSUJOQkFuUnFJVllnVmlBUE5nSUFJQTlCQUVZaFdDQllCRUFNQkFzTElBOUJHR29oV1NCWklESTJBZ0FnOXdGQkVHb2hXaUJhS0FJQUlWc2dXMEVBUmlGY0lGeEZCRUFnRDBFUWFpRmRJRjBnV3pZQ0FDQmJRUmhxSVY0Z1hpQVBOZ0lBQ3lCYVFRUnFJVjhnWHlnQ0FDRmdJR0JCQUVZaFlTQmhSUVJBSUE5QkZHb2hZeUJqSUdBMkFnQWdZRUVZYWlGa0lHUWdEellDQUFzTEN3c2dJa0VCY2lGbElBZEJCR29oWmlCbUlHVTJBZ0FnaXdJZ0ltb2haeUJuSUNJMkFnQkIwRFlvQWdBaGFDQUhJR2hHSVdrZ2FRUkFRY1EySUNJMkFnQVBCU0FpSVEwTEJTQ09Ba0YrY1NGcUlJd0NJR28yQWdBZ0NFRUJjaUZySUFkQkJHb2hiQ0JzSUdzMkFnQWdpd0lnQ0dvaGJpQnVJQWcyQWdBZ0NDRU5DeUFOUVFOMklXOGdEVUdBQWtraGNDQndCRUFnYjBFQmRDRnhRZVEySUhGQkFuUnFJWEpCdkRZb0FnQWhjMEVCSUc5MElYUWdjeUIwY1NGMUlIVkJBRVloZGlCMkJFQWdjeUIwY2lGM1FidzJJSGMyQWdBZ2NrRUlhaUVRSUhJaEJpQVFJUkVGSUhKQkNHb2hlU0I1S0FJQUlYb2dlaUVHSUhraEVRc2dFU0FITmdJQUlBWkJER29oZXlCN0lBYzJBZ0FnQjBFSWFpRjhJSHdnQmpZQ0FDQUhRUXhxSVgwZ2ZTQnlOZ0lBRHdzZ0RVRUlkaUYrSUg1QkFFWWhmeUIvQkVCQkFDRUZCU0FOUWYvLy93ZExJWUFCSUlBQkJFQkJIeUVGQlNCK1FZRCtQMm9oZ1FFZ2dRRkJFSFloZ2dFZ2dnRkJDSEVoaFFFZ2ZpQ0ZBWFFoaGdFZ2hnRkJnT0FmYWlHSEFTQ0hBVUVRZGlHSUFTQ0lBVUVFY1NHSkFTQ0pBU0NGQVhJaGlnRWdoZ0VnaVFGMElZc0JJSXNCUVlDQUQyb2hqQUVnakFGQkVIWWhqUUVnalFGQkFuRWhqZ0VnaWdFZ2pnRnlJWkFCUVE0Z2tBRnJJWkVCSUlzQklJNEJkQ0dTQVNDU0FVRVBkaUdUQVNDUkFTQ1RBV29obEFFZ2xBRkJBWFFobFFFZ2xBRkJCMm9obGdFZ0RTQ1dBWFlobHdFZ2x3RkJBWEVobUFFZ21BRWdsUUZ5SVprQklKa0JJUVVMQzBIc09DQUZRUUowYWlHYkFTQUhRUnhxSVp3QklKd0JJQVUyQWdBZ0IwRVFhaUdkQVNBSFFSUnFJWjRCSUo0QlFRQTJBZ0FnblFGQkFEWUNBRUhBTmlnQ0FDR2ZBVUVCSUFWMElhQUJJSjhCSUtBQmNTR2hBU0NoQVVFQVJpR2lBUUpBSUtJQkJFQWdud0Vnb0FGeUlhTUJRY0EySUtNQk5nSUFJSnNCSUFjMkFnQWdCMEVZYWlHa0FTQ2tBU0NiQVRZQ0FDQUhRUXhxSWFZQklLWUJJQWMyQWdBZ0IwRUlhaUduQVNDbkFTQUhOZ0lBQlNDYkFTZ0NBQ0dvQVNBRlFSOUdJYWtCSUFWQkFYWWhxZ0ZCR1NDcUFXc2hxd0VncVFFRWYwRUFCU0NyQVFzaHJBRWdEU0NzQVhRaHJRRWdyUUVoQXlDb0FTRUVBMEFDUUNBRVFRUnFJYTRCSUs0QktBSUFJYThCSUs4QlFYaHhJYkVCSUxFQklBMUdJYklCSUxJQkJFQkJ5UUFobWdJTUFRc2dBMEVmZGlHekFTQUVRUkJxSUxNQlFRSjBhaUcwQVNBRFFRRjBJYlVCSUxRQktBSUFJYllCSUxZQlFRQkdJYmNCSUxjQkJFQkJ5QUFobWdJTUFRVWd0UUVoQXlDMkFTRUVDd3dCQ3dzZ21nSkJ5QUJHQkVBZ3RBRWdCellDQUNBSFFSaHFJYmdCSUxnQklBUTJBZ0FnQjBFTWFpRzVBU0M1QVNBSE5nSUFJQWRCQ0dvaHVnRWd1Z0VnQnpZQ0FBd0NCU0NhQWtISkFFWUVRQ0FFUVFocUlid0JJTHdCS0FJQUliMEJJTDBCUVF4cUliNEJJTDRCSUFjMkFnQWd2QUVnQnpZQ0FDQUhRUWhxSWI4QklMOEJJTDBCTmdJQUlBZEJER29od0FFZ3dBRWdCRFlDQUNBSFFSaHFJY0VCSU1FQlFRQTJBZ0FNQXdzTEN3dEIzRFlvQWdBaHdnRWd3Z0ZCZjJvaHd3RkIzRFlnd3dFMkFnQWd3d0ZCQUVZaHhBRWd4QUVFUUVHRU9pRUNCUThMQTBBQ1FDQUNLQUlBSVFFZ0FVRUFSaUhGQVNBQlFRaHFJY2NCSU1VQkJFQU1BUVVneHdFaEFnc01BUXNMUWR3MlFYODJBZ0FQQzA4QkNIOGpEU0VJSXcxQkVHb2tEU01OSXc1T0JFQkJFQkFEQ3lBSUlRWWdBRUU4YWlFQklBRW9BZ0FoQWlBQ0VESWhBeUFHSUFNMkFnQkJCaUFHRUFzaEJDQUVFREFoQlNBSUpBMGdCUThMbXdVQlFIOGpEU0ZDSXcxQk1Hb2tEU01OSXc1T0JFQkJNQkFEQ3lCQ1FSQnFJVHdnUWlFN0lFSkJJR29oSGlBQVFSeHFJU2tnS1NnQ0FDRTBJQjRnTkRZQ0FDQWVRUVJxSVRjZ0FFRVVhaUU0SURnb0FnQWhPU0E1SURScklUb2dOeUE2TmdJQUlCNUJDR29oQ2lBS0lBRTJBZ0FnSGtFTWFpRUxJQXNnQWpZQ0FDQTZJQUpxSVF3Z0FFRThhaUVOSUEwb0FnQWhEaUFlSVE4Z095QU9OZ0lBSUR0QkJHb2hQU0E5SUE4MkFnQWdPMEVJYWlFK0lENUJBallDQUVHU0FTQTdFQWtoRUNBUUVEQWhFU0FNSUJGR0lSSUNRQ0FTQkVCQkF5RkJCVUVDSVFRZ0RDRUZJQjRoQmlBUklSc0RRQUpBSUJ0QkFFZ2hHaUFhQkVBTUFRc2dCU0FiYXlFa0lBWkJCR29oSlNBbEtBSUFJU1lnR3lBbVN5RW5JQVpCQ0dvaEtDQW5CSDhnS0FVZ0Jnc2hDU0FuUVI5MFFSOTFJU29nQkNBcWFpRUlJQ2NFZnlBbUJVRUFDeUVySUJzZ0syc2hBeUFKS0FJQUlTd2dMQ0FEYWlFdElBa2dMVFlDQUNBSlFRUnFJUzRnTGlnQ0FDRXZJQzhnQTJzaE1DQXVJREEyQWdBZ0RTZ0NBQ0V4SUFraE1pQThJREUyQWdBZ1BFRUVhaUUvSUQ4Z01qWUNBQ0E4UVFocUlVQWdRQ0FJTmdJQVFaSUJJRHdRQ1NFeklETVFNQ0UxSUNRZ05VWWhOaUEyQkVCQkF5RkJEQVFGSUFnaEJDQWtJUVVnQ1NFR0lEVWhHd3NNQVFzTElBQkJFR29oSENBY1FRQTJBZ0FnS1VFQU5nSUFJRGhCQURZQ0FDQUFLQUlBSVIwZ0hVRWdjaUVmSUFBZ0h6WUNBQ0FFUVFKR0lTQWdJQVJBUVFBaEJ3VWdCa0VFYWlFaElDRW9BZ0FoSWlBQ0lDSnJJU01nSXlFSEN3c0xJRUZCQTBZRVFDQUFRU3hxSVJNZ0V5Z0NBQ0VVSUFCQk1Hb2hGU0FWS0FJQUlSWWdGQ0FXYWlFWElBQkJFR29oR0NBWUlCYzJBZ0FnRkNFWklDa2dHVFlDQUNBNElCazJBZ0FnQWlFSEN5QkNKQTBnQnc4THNBRUJFSDhqRFNFU0l3MUJJR29rRFNNTkl3NU9CRUJCSUJBREN5QVNJUXdnRWtFVWFpRUZJQUJCUEdvaEJpQUdLQUlBSVFjZ0JTRUlJQXdnQnpZQ0FDQU1RUVJxSVEwZ0RVRUFOZ0lBSUF4QkNHb2hEaUFPSUFFMkFnQWdERUVNYWlFUElBOGdDRFlDQUNBTVFSQnFJUkFnRUNBQ05nSUFRWXdCSUF3UUNDRUpJQWtRTUNFS0lBcEJBRWdoQ3lBTEJFQWdCVUYvTmdJQVFYOGhCQVVnQlNnQ0FDRURJQU1oQkFzZ0VpUU5JQVFQQ3pNQkJuOGpEU0VHSUFCQmdHQkxJUUlnQWdSQVFRQWdBR3NoQXhBeElRUWdCQ0FETmdJQVFYOGhBUVVnQUNFQkN5QUJEd3NNQVFKL0l3MGhBVUhzT2c4TEN3RUNmeU1OSVFJZ0FBOEx1d0VCRVg4akRTRVRJdzFCSUdva0RTTU5JdzVPQkVCQklCQURDeUFUSVE4Z0UwRVFhaUVJSUFCQkpHb2hDU0FKUVFJMkFnQWdBQ2dDQUNFS0lBcEJ3QUJ4SVFzZ0MwRUFSaUVNSUF3RVFDQUFRVHhxSVEwZ0RTZ0NBQ0VPSUFnaEF5QVBJQTQyQWdBZ0QwRUVhaUVRSUJCQms2Z0JOZ0lBSUE5QkNHb2hFU0FSSUFNMkFnQkJOaUFQRUFvaEJDQUVRUUJHSVFVZ0JVVUVRQ0FBUWNzQWFpRUdJQVpCZnpvQUFBc0xJQUFnQVNBQ0VDNGhCeUFUSkEwZ0J3OEwwQUVCRlg4akRTRVdJQUFzQUFBaEN5QUJMQUFBSVF3Z0MwRVlkRUVZZFNBTVFSaDBRUmgxUnlFTklBdEJHSFJCR0hWQkFFWWhEaUFPSUExeUlSUWdGQVJBSUF3aEJDQUxJUVVGSUFFaEFpQUFJUU1EUUFKQUlBTkJBV29oRHlBQ1FRRnFJUkFnRHl3QUFDRVJJQkFzQUFBaEVpQVJRUmgwUVJoMUlCSkJHSFJCR0hWSElRWWdFVUVZZEVFWWRVRUFSaUVISUFjZ0JuSWhFeUFUQkVBZ0VpRUVJQkVoQlF3QkJTQVFJUUlnRHlFREN3d0JDd3NMSUFWQi93RnhJUWdnQkVIL0FYRWhDU0FJSUFscklRb2dDZzhMd3dRQkxYOGpEU0V2SXcxQjRBRnFKQTBqRFNNT1RnUkFRZUFCRUFNTElDOUIrQUJxSVJzZ0wwSFFBR29oSmlBdklTZ2dMMEdJQVdvaEtTQW1RZ0EzQWdBZ0prRUlha0lBTndJQUlDWkJFR3BDQURjQ0FDQW1RUmhxUWdBM0FnQWdKa0VnYWtJQU53SUFJQUlvQWdBaExTQWJJQzAyQWdCQkFDQUJJQnNnS0NBbUVEWWhLaUFxUVFCSUlTc2dLd1JBUVg4aEJBVWdBRUhNQUdvaExDQXNLQUlBSVFjZ0IwRi9TaUVJSUFnRVFDQUFFRGNoQ1NBSklTY0ZRUUFoSndzZ0FDZ0NBQ0VLSUFwQklIRWhDeUFBUWNvQWFpRU1JQXdzQUFBaERTQU5RUmgwUVJoMVFRRklJUTRnRGdSQUlBcEJYM0VoRHlBQUlBODJBZ0FMSUFCQk1Hb2hFQ0FRS0FJQUlSRWdFVUVBUmlFU0lCSUVRQ0FBUVN4cUlSUWdGQ2dDQUNFVklCUWdLVFlDQUNBQVFSeHFJUllnRmlBcE5nSUFJQUJCRkdvaEZ5QVhJQ2syQWdBZ0VFSFFBRFlDQUNBcFFkQUFhaUVZSUFCQkVHb2hHU0FaSUJnMkFnQWdBQ0FCSUJzZ0tDQW1FRFloR2lBVlFRQkdJUndnSEFSQUlCb2hCUVVnQUVFa2FpRWRJQjBvQWdBaEhpQUFRUUJCQUNBZVFRZHhRUWhxRVFBQUdpQVhLQUlBSVI4Z0gwRUFSaUVnSUNBRWYwRi9CU0FhQ3lFRElCUWdGVFlDQUNBUVFRQTJBZ0FnR1VFQU5nSUFJQlpCQURZQ0FDQVhRUUEyQWdBZ0F5RUZDd1VnQUNBQklCc2dLQ0FtRURZaEV5QVRJUVVMSUFBb0FnQWhJU0FoUVNCeElTSWdJa0VBUmlFaklDTUVmeUFGQlVGL0N5RUdJQ0VnQzNJaEpDQUFJQ1EyQWdBZ0owRUFSaUVsSUNWRkJFQWdBQkE0Q3lBR0lRUUxJQzhrRFNBRUR3dm9LZ1BuQW44T2ZnRjhJdzBoNndJakRVSEFBR29rRFNNTkl3NU9CRUJCd0FBUUF3c2c2d0pCRUdvaGtnSWc2d0loblFJZzZ3SkJHR29ocUFJZzZ3SkJDR29oc3dJZzZ3SkJGR29odlFJZ2tnSWdBVFlDQUNBQVFRQkhJVThncUFKQktHb2hXaUJhSVdRZ3FBSkJKMm9oYnlDekFrRUVhaUY2UVFBaEZrRUFJUmRCQUNFaElBRWh2UUVEUUFKQUlCZEJmMG9oaEFFQ1FDQ0VBUVJBUWYvLy8vOEhJQmRySVk0QklCWWdqZ0ZLSVpjQklKY0JCRUFRTVNHaEFTQ2hBVUhMQURZQ0FFRi9JU29NQWdVZ0ZpQVhhaUdxQVNDcUFTRXFEQUlMQUFVZ0Z5RXFDd3NndlFFc0FBQWhzd0Vnc3dGQkdIUkJHSFZCQUVZaHh3RWd4d0VFUUVIV0FDSHFBZ3dCQlNDekFTSFNBU0M5QVNIbkFRc0RRQUpBQWtBQ1FBSkFBa0FnMGdGQkdIUkJHSFZCQUdzT0pnRUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFBZ3NDUUNEbkFTRVpJT2NCSWZzQlFRa2g2Z0lNQkF3REFBc0FDd0pBSU9jQklSZ2c1d0VoaHdJTUF3d0NBQXNBQ3dFTElPY0JRUUZxSWQwQklKSUNJTjBCTmdJQUlOMEJMQUFBSVVvZ1NpSFNBU0RkQVNIbkFRd0JDd3NDUUNEcUFrRUpSZ1JBQTBBQ1FFRUFJZW9DSVBzQlFRRnFJZklCSVBJQkxBQUFJZndCSVB3QlFSaDBRUmgxUVNWR0lmMEJJUDBCUlFSQUlCa2hHQ0Q3QVNHSEFnd0VDeUFaUVFGcUlmNEJJUHNCUVFKcUlmOEJJSklDSVA4Qk5nSUFJUDhCTEFBQUlZQUNJSUFDUVJoMFFSaDFRU1ZHSVlFQ0lJRUNCRUFnL2dFaEdTRC9BU0g3QVVFSkllb0NCU0QrQVNFWUlQOEJJWWNDREFFTERBRUxDd3NMSUJnaGdnSWd2UUVoZ3dJZ2dnSWdnd0pySVlRQ0lFOEVRQ0FBSUwwQklJUUNFRGtMSUlRQ1FRQkdJWVVDSUlVQ1JRUkFJQ0VoSWlDRUFpRVdJQ29oRnlDSEFpRzlBU0FpSVNFTUFnc2dod0pCQVdvaGhnSWdoZ0lzQUFBaGlBSWdpQUpCR0hSQkdIVWhpUUlnaVFKQlVHb2gzd0lnM3dKQkNra2gzQUlnM0FJRVFDQ0hBa0VDYWlHS0FpQ0tBaXdBQUNHTEFpQ0xBa0VZZEVFWWRVRWtSaUdNQWlDSEFrRURhaUdOQWlDTUFnUi9JSTBDQlNDR0Fnc2hSQ0NNQWdSL1FRRUZJQ0VMSVFrZ2pBSUVmeURmQWdWQmZ3c2g0QUlnNEFJaEd5QUpJVEFnUkNIbkFnVkJmeUViSUNFaE1DQ0dBaUhuQWdzZ2tnSWc1d0kyQWdBZzV3SXNBQUFoamdJZ2pnSkJHSFJCR0hVaGp3SWdqd0pCWUdvaGtBSWdrQUpCSDBzaGtRSkJBU0NRQW5RaGt3SWdrd0pCaWRFRWNTR1VBaUNVQWtFQVJpR1ZBaUNSQWlDVkFuSWh6UUlnelFJRVFFRUFJUjhnamdJaFNTRG5BaUduQWdWQkFDRWdJSTRDSVpjQ0lPY0NJWndDQTBBQ1FDQ1hBa0VZZEVFWWRTR1dBaUNXQWtGZ2FpR1lBa0VCSUpnQ2RDR1pBaUNaQWlBZ2NpR2FBaUNjQWtFQmFpR2JBaUNTQWlDYkFqWUNBQ0NiQWl3QUFDR2VBaUNlQWtFWWRFRVlkU0dmQWlDZkFrRmdhaUdnQWlDZ0FrRWZTeUdoQWtFQklLQUNkQ0dpQWlDaUFrR0owUVJ4SWFNQ0lLTUNRUUJHSWFRQ0lLRUNJS1FDY2lITUFpRE1BZ1JBSUpvQ0lSOGduZ0loU1NDYkFpR25BZ3dCQlNDYUFpRWdJSjRDSVpjQ0lKc0NJWndDQ3d3QkN3c0xJRWxCR0hSQkdIVkJLa1locFFJZ3BRSUVRQ0NuQWtFQmFpR21BaUNtQWl3QUFDR3BBaUNwQWtFWWRFRVlkU0dxQWlDcUFrRlFhaUhpQWlEaUFrRUtTU0hlQWlEZUFnUkFJS2NDUVFKcUlhc0NJS3NDTEFBQUlhd0NJS3dDUVJoMFFSaDFRU1JHSWEwQ0lLMENCRUFnQkNEaUFrRUNkR29ocmdJZ3JnSkJDallDQUNDbUFpd0FBQ0d2QWlDdkFrRVlkRUVZZFNHd0FpQ3dBa0ZRYWlHeEFpQURJTEVDUVFOMGFpR3lBaUN5QWlrREFDSDVBaUQ1QXFjaHRBSWdwd0pCQTJvaHRRSWd0QUloSGtFQklUd2d0UUloNkFJRlFSWWg2Z0lMQlVFV0llb0NDeURxQWtFV1JnUkFRUUFoNmdJZ01FRUFSaUcyQWlDMkFrVUVRRUYvSVF3TUF3c2dUd1JBSUFJb0FnQWh5QUlneUFJaHR3SkJBRUVFYWlIWEFpRFhBaUhXQWlEV0FrRUJheUhPQWlDM0FpRE9BbW9odUFKQkFFRUVhaUhiQWlEYkFpSGFBaURhQWtFQmF5SFpBaURaQWtGL2N5SFlBaUM0QWlEWUFuRWh1UUlndVFJaHVnSWd1Z0lvQWdBaHV3SWd1Z0pCQkdvaHlnSWdBaURLQWpZQ0FDQzdBaUVlUVFBaFBDQ21BaUhvQWdWQkFDRWVRUUFoUENDbUFpSG9BZ3NMSUpJQ0lPZ0NOZ0lBSUI1QkFFZ2h2QUlnSDBHQXdBQnlJYjRDUVFBZ0htc2h2d0lndkFJRWZ5QytBZ1VnSHdzaENDQzhBZ1IvSUw4Q0JTQWVDeUVISUFjaExTQUlJUzRnUENGQ0lPZ0NJY01DQlNDU0FoQTZJY0FDSU1BQ1FRQklJY0VDSU1FQ0JFQkJmeUVNREFJTElKSUNLQUlBSVVzZ3dBSWhMU0FmSVM0Z01DRkNJRXNod3dJTElNTUNMQUFBSWNJQ0lNSUNRUmgwUVJoMVFTNUdJY1FDQWtBZ3hBSUVRQ0REQWtFQmFpSEZBaURGQWl3QUFDSEdBaURHQWtFWWRFRVlkVUVxUmlISEFpREhBa1VFUUNEREFrRUJhaUZsSUpJQ0lHVTJBZ0Fna2dJUU9pRm1JSklDS0FJQUlVMGdaaUVjSUUwaFRBd0NDeUREQWtFQ2FpRlFJRkFzQUFBaFVTQlJRUmgwUVJoMUlWSWdVa0ZRYWlIaEFpRGhBa0VLU1NIZEFpRGRBZ1JBSU1NQ1FRTnFJVk1nVXl3QUFDRlVJRlJCR0hSQkdIVkJKRVloVlNCVkJFQWdCQ0RoQWtFQ2RHb2hWaUJXUVFvMkFnQWdVQ3dBQUNGWElGZEJHSFJCR0hVaFdDQllRVkJxSVZrZ0F5QlpRUU4wYWlGYklGc3BBd0FoN1FJZzdRS25JVndnd3dKQkJHb2hYU0NTQWlCZE5nSUFJRndoSENCZElVd01Bd3NMSUVKQkFFWWhYaUJlUlFSQVFYOGhEQXdEQ3lCUEJFQWdBaWdDQUNISkFpREpBaUZmUVFCQkJHb2gwUUlnMFFJaDBBSWcwQUpCQVdzaHp3SWdYeURQQW1vaFlFRUFRUVJxSWRVQ0lOVUNJZFFDSU5RQ1FRRnJJZE1DSU5NQ1FYOXpJZElDSUdBZzBnSnhJV0VnWVNGaUlHSW9BZ0FoWXlCaVFRUnFJY3NDSUFJZ3l3STJBZ0FnWXlINUFRVkJBQ0g1QVFzZ2tnSWdVRFlDQUNENUFTRWNJRkFoVEFWQmZ5RWNJTU1DSVV3TEMwRUFJUm9nVENGb0EwQUNRQ0JvTEFBQUlXY2daMEVZZEVFWWRTRnBJR2xCdjM5cUlXb2dha0U1U3lGcklHc0VRRUYvSVF3TUF3c2dhRUVCYWlGc0lKSUNJR3cyQWdBZ2FDd0FBQ0Z0SUcxQkdIUkJHSFVoYmlCdVFiOS9haUZ3UWNJaklCcEJPbXhxSUhCcUlYRWdjU3dBQUNGeUlISkIvd0Z4SVhNZ2MwRi9haUYwSUhSQkNFa2hkU0IxQkVBZ2N5RWFJR3doYUFVTUFRc01BUXNMSUhKQkdIUkJHSFZCQUVZaGRpQjJCRUJCZnlFTURBRUxJSEpCR0hSQkdIVkJFMFloZHlBYlFYOUtJWGdDUUNCM0JFQWdlQVJBUVg4aERBd0RCVUV3SWVvQ0N3VWdlQVJBSUFRZ0cwRUNkR29oZVNCNUlITTJBZ0FnQXlBYlFRTjBhaUY3SUhzcEF3QWg3Z0lnblFJZzdnSTNBd0JCTUNIcUFnd0NDeUJQUlFSQVFRQWhEQXdEQ3lDZEFpQnpJQUlRT3dzTElPb0NRVEJHQkVCQkFDSHFBaUJQUlFSQVFRQWhGaUFxSVJjZ1FpRWhJR3dodlFFTUF3c0xJR2dzQUFBaGZDQjhRUmgwUVJoMUlYMGdHa0VBUnlGK0lIMUJEM0VoZnlCL1FRTkdJWUFCSUg0Z2dBRnhJZVFDSUgxQlgzRWhnUUVnNUFJRWZ5Q0JBUVVnZlFzaEVTQXVRWURBQUhFaGdnRWdnZ0ZCQUVZaGd3RWdMa0gvLzN0eElZVUJJSU1CQkg4Z0xnVWdoUUVMSVM4Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdFVUhCQUdzT09BMFZDeFVRRHc0VkZSVVZGUlVWRlJVVkZRd1ZGUlVWQWhVVkZSVVZGUlVWRVJVSUJoUVRFaFVGRlJVVkNRQUVBUlVWQ2hVSEZSVURGUXNDUUNBYVFmOEJjU0hwQWdKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNEcEFrRVlkRUVZZFVFQWF3NElBQUVDQXdRSEJRWUhDd0pBSUowQ0tBSUFJWVlCSUlZQklDbzJBZ0JCQUNFV0lDb2hGeUJDSVNFZ2JDRzlBUXdpREFnQUN3QUxBa0FnblFJb0FnQWhod0VnaHdFZ0tqWUNBRUVBSVJZZ0tpRVhJRUloSVNCc0liMEJEQ0VNQndBTEFBc0NRQ0FxckNIdkFpQ2RBaWdDQUNHSUFTQ0lBU0R2QWpjREFFRUFJUllnS2lFWElFSWhJU0JzSWIwQkRDQU1CZ0FMQUFzQ1FDQXFRZi8vQTNFaGlRRWduUUlvQWdBaGlnRWdpZ0VnaVFFN0FRQkJBQ0VXSUNvaEZ5QkNJU0VnYkNHOUFRd2ZEQVVBQ3dBTEFrQWdLa0gvQVhFaGl3RWduUUlvQWdBaGpBRWdqQUVnaXdFNkFBQkJBQ0VXSUNvaEZ5QkNJU0VnYkNHOUFRd2VEQVFBQ3dBTEFrQWduUUlvQWdBaGpRRWdqUUVnS2pZQ0FFRUFJUllnS2lFWElFSWhJU0JzSWIwQkRCME1Bd0FMQUFzQ1FDQXFyQ0h3QWlDZEFpZ0NBQ0dQQVNDUEFTRHdBamNEQUVFQUlSWWdLaUVYSUVJaElTQnNJYjBCREJ3TUFnQUxBQXNDUUVFQUlSWWdLaUVYSUVJaElTQnNJYjBCREJzQUN3QUxEQllBQ3dBTEFrQWdIRUVJU3lHUUFTQ1FBUVIvSUJ3RlFRZ0xJWkVCSUM5QkNISWhrZ0ZCK0FBaEppQ1JBU0VzSUpJQklVRkJQQ0hxQWd3VkFBc0FDd0VMQWtBZ0VTRW1JQndoTENBdklVRkJQQ0hxQWd3VEFBc0FDd0pBSUowQ0tRTUFJZklDSVBJQ0lGb1FQU0diQVNBdlFRaHhJWndCSUp3QlFRQkdJWjBCSUpzQklaNEJJR1FnbmdGcklaOEJJQndnbndGS0lhQUJJSjhCUVFGcUlhSUJJSjBCSUtBQmNpR2pBU0NqQVFSL0lCd0ZJS0lCQ3lFZElKc0JJUTFCQUNFbFFaSW5JU2NnSFNFNElDOGhSaUR5QWlIMkFrSENBQ0hxQWd3U0FBc0FDd0VMQWtBZ25RSXBBd0FoOHdJZzh3SkNBRk1ocEFFZ3BBRUVRRUlBSVBNQ2ZTSDBBaUNkQWlEMEFqY0RBRUVCSVJCQmtpY2hFaUQwQWlIMUFrSEJBQ0hxQWd3U0JTQXZRWUFRY1NHbEFTQ2xBVUVBUmlHbUFTQXZRUUZ4SWFjQklLY0JRUUJHSWFnQklLZ0JCSDlCa2ljRlFaUW5DeUVGSUtZQkJIOGdCUVZCa3ljTElRWWdMMEdCRUhFaHFRRWdxUUZCQUVjaHF3RWdxd0ZCQVhFaFBTQTlJUkFnQmlFU0lQTUNJZlVDUWNFQUllb0NEQklMQUF3UUFBc0FDd0pBSUowQ0tRTUFJZXdDUVFBaEVFR1NKeUVTSU93Q0lmVUNRY0VBSWVvQ0RBOEFDd0FMQWtBZ25RSXBBd0FoOXdJZzl3S25RZjhCY1NHNEFTQnZJTGdCT2dBQUlHOGhNVUVBSVRKQmtpY2hNeUJhSVRkQkFTRkhJSVVCSVVnTURnQUxBQXNDUUJBeElia0JJTGtCS0FJQUlib0JJTG9CRUQ4aHV3RWd1d0VoSTBIR0FDSHFBZ3dOQUFzQUN3SkFJSjBDS0FJQUlid0JJTHdCUVFCSEliNEJJTDRCQkg4Z3ZBRUZRWnduQ3lHL0FTQy9BU0VqUWNZQUllb0NEQXdBQ3dBTEFrQWduUUlwQXdBaCtBSWcrQUtuSWNZQklMTUNJTVlCTmdJQUlIcEJBRFlDQUNDZEFpQ3pBallDQUVGL0lVVWdzd0loK2dGQnlnQWg2Z0lNQ3dBTEFBc0NRQ0NkQWlnQ0FDRk9JQnhCQUVZaHlBRWd5QUVFUUNBQVFTQWdMVUVBSUM4UVFVRUFJUlJCMHdBaDZnSUZJQndoUlNCT0lmb0JRY29BSWVvQ0N3d0tBQXNBQ3dFTEFRc0JDd0VMQVFzQkN3RUxBa0FnblFJckF3QWgrZ0lnQUNENkFpQXRJQndnTHlBUkVFTWg0QUVnNEFFaEZpQXFJUmNnUWlFaElHd2h2UUVNQlF3Q0FBc0FDd0pBSUwwQklURkJBQ0V5UVpJbklUTWdXaUUzSUJ3aFJ5QXZJVWdMQ3dzQ1FDRHFBa0U4UmdSQVFRQWg2Z0lnblFJcEF3QWg4UUlnSmtFZ2NTR1RBU0R4QWlCYUlKTUJFRHdobEFFZzhRSkNBRkVobFFFZ1FVRUljU0dXQVNDV0FVRUFSaUdZQVNDWUFTQ1ZBWEloNVFJZ0prRUVkU0daQVVHU0p5Q1pBV29obWdFZzVRSUVmMEdTSndVZ21nRUxJVDRnNVFJRWYwRUFCVUVDQ3lFL0lKUUJJUTBnUHlFbElENGhKeUFzSVRnZ1FTRkdJUEVDSWZZQ1FjSUFJZW9DQlNEcUFrSEJBRVlFUUVFQUllb0NJUFVDSUZvUVBpR3NBU0NzQVNFTklCQWhKU0FTSVNjZ0hDRTRJQzhoUmlEMUFpSDJBa0hDQUNIcUFnVWc2Z0pCeGdCR0JFQkJBQ0hxQWlBalFRQWdIQkJBSWNBQklNQUJRUUJHSWNFQklNQUJJY0lCSUNNaHd3RWd3Z0Vnd3dGckljUUJJQ01nSEdvaHhRRWd3UUVFZnlBY0JTREVBUXNoUUNEQkFRUi9JTVVCQlNEQUFRc2hLeUFqSVRGQkFDRXlRWkluSVRNZ0t5RTNJRUFoUnlDRkFTRklCU0RxQWtIS0FFWUVRRUVBSWVvQ0lQb0JJUTlCQUNFVlFRQWhLUU5BQWtBZ0R5Z0NBQ0hKQVNESkFVRUFSaUhLQVNES0FRUkFJQlVoRXlBcElUWU1BUXNndlFJZ3lRRVFRaUhMQVNETEFVRUFTQ0hNQVNCRklCVnJJYzBCSU1zQklNMEJTeUhPQVNETUFTRE9BWEloNWdJZzVnSUVRQ0FWSVJNZ3l3RWhOZ3dCQ3lBUFFRUnFJYzhCSU1zQklCVnFJZEFCSUVVZzBBRkxJZEVCSU5FQkJFQWd6d0VoRHlEUUFTRVZJTXNCSVNrRklOQUJJUk1neXdFaE5nd0JDd3dCQ3dzZ05rRUFTQ0hUQVNEVEFRUkFRWDhoREF3R0N5QUFRU0FnTFNBVElDOFFRU0FUUVFCR0lkUUJJTlFCQkVCQkFDRVVRZE1BSWVvQ0JTRDZBU0VrUVFBaEtBTkFBa0FnSkNnQ0FDSFZBU0RWQVVFQVJpSFdBU0RXQVFSQUlCTWhGRUhUQUNIcUFnd0lDeUM5QWlEVkFSQkNJZGNCSU5jQklDaHFJZGdCSU5nQklCTktJZGtCSU5rQkJFQWdFeUVVUWRNQUllb0NEQWdMSUNSQkJHb2gyZ0VnQUNDOUFpRFhBUkE1SU5nQklCTkpJZHNCSU5zQkJFQWcyZ0VoSkNEWUFTRW9CU0FUSVJSQjB3QWg2Z0lNQVFzTUFRc0xDd3NMQ3dzTElPb0NRY0lBUmdSQVFRQWg2Z0lnT0VGL1NpR3RBU0JHUWYvL2UzRWhyZ0VnclFFRWZ5Q3VBUVVnUmdzaENpRDJBa0lBVWlHdkFTQTRRUUJISWJBQklMQUJJSzhCY2lIakFpQU5JYkVCSUdRZ3NRRnJJYklCSUs4QlFRRnpJYlFCSUxRQlFRRnhJYlVCSUxJQklMVUJhaUcyQVNBNElMWUJTaUczQVNDM0FRUi9JRGdGSUxZQkN5RTVJT01DQkg4Z09RVWdPQXNoT2lEakFnUi9JQTBGSUZvTElRNGdEaUV4SUNVaE1pQW5JVE1nV2lFM0lEb2hSeUFLSVVnRklPb0NRZE1BUmdSQVFRQWg2Z0lnTDBHQXdBQnpJZHdCSUFCQklDQXRJQlFnM0FFUVFTQXRJQlJLSWQ0QklONEJCSDhnTFFVZ0ZBc2gzd0VnM3dFaEZpQXFJUmNnUWlFaElHd2h2UUVNQXdzTElEY2g0UUVnTVNIaUFTRGhBU0RpQVdzaDR3RWdSeURqQVVnaDVBRWc1QUVFZnlEakFRVWdSd3NoQ3lBTElESnFJZVVCSUMwZzVRRklJZVlCSU9ZQkJIOGc1UUVGSUMwTElUc2dBRUVnSURzZzVRRWdTQkJCSUFBZ015QXlFRGtnU0VHQWdBUnpJZWdCSUFCQk1DQTdJT1VCSU9nQkVFRWdBRUV3SUFzZzR3RkJBQkJCSUFBZ01TRGpBUkE1SUVoQmdNQUFjeUhwQVNBQVFTQWdPeURsQVNEcEFSQkJJRHNoRmlBcUlSY2dRaUVoSUd3aHZRRU1BUXNMQWtBZzZnSkIxZ0JHQkVBZ0FFRUFSaUhxQVNEcUFRUkFJQ0ZCQUVZaDZ3RWc2d0VFUUVFQUlRd0ZRUUVoTlFOQUFrQWdCQ0ExUVFKMGFpSHNBU0RzQVNnQ0FDSHRBU0R0QVVFQVJpSHVBU0R1QVFSQUlEVWhOQXdCQ3lBRElEVkJBM1JxSWZBQklQQUJJTzBCSUFJUU95QTFRUUZxSWZFQklEVkJDVWdoOHdFZzh3RUVRQ0R4QVNFMUJTRHhBU0UwREFFTERBRUxDeUEwUVFwSUllOEJJTzhCQkVBZ05DRkRBMEFDUUNBRUlFTkJBblJxSWZZQklQWUJLQUlBSWZjQklQY0JRUUJHSWZnQklQZ0JSUVJBUVg4aERBd0hDeUJEUVFGcUlmUUJJRU5CQ1VnaDlRRWc5UUVFUUNEMEFTRkRCVUVCSVF3TUFRc01BUXNMQlVFQklRd0xDd1VnS2lFTUN3c0xJT3NDSkEwZ0RBOExDd0VDZnlNTklRSkJBQThMQ1FFQ2Z5TU5JUUlQQ3l3QkJYOGpEU0VISUFBb0FnQWhBeUFEUVNCeElRUWdCRUVBUmlFRklBVUVRQ0FCSUFJZ0FCQlFHZ3NQQzZJQkFSSi9JdzBoRWlBQUtBSUFJUU1nQXl3QUFDRUVJQVJCR0hSQkdIVWhCU0FGUVZCcUlROGdEMEVLU1NFTklBMEVRRUVBSVFJZ0F5RUpJQThoRUFOQUFrQWdBa0VLYkNFR0lCQWdCbW9oQnlBSlFRRnFJUWdnQUNBSU5nSUFJQWdzQUFBaENpQUtRUmgwUVJoMUlRc2dDMEZRYWlFT0lBNUJDa2toRENBTUJFQWdCeUVDSUFnaENTQU9JUkFGSUFjaEFRd0JDd3dCQ3dzRlFRQWhBUXNnQVE4TG1Rb0RrQUYvQjM0Q2ZDTU5JWklCSUFGQkZFc2hGZ0pBSUJaRkJFQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FVRUphdzRLQUFFQ0F3UUZCZ2NJQ1FvTEFrQWdBaWdDQUNFM0lEY2hIMEVBUVFScUlVMGdUU0ZNSUV4QkFXc2hTeUFmSUV0cUlTbEJBRUVFYWlGUklGRWhVQ0JRUVFGcklVOGdUMEYvY3lGT0lDa2dUbkVoTWlBeUlUUWdOQ2dDQUNFMUlEUkJCR29oUVNBQ0lFRTJBZ0FnQUNBMU5nSUFEQTBNQ3dBTEFBc0NRQ0FDS0FJQUlUc2dPeUUyUVFCQkJHb2hWQ0JVSVZNZ1UwRUJheUZTSURZZ1Vtb2hCVUVBUVFScUlWZ2dXQ0ZYSUZkQkFXc2hWaUJXUVg5eklWVWdCU0JWY1NFR0lBWWhCeUFIS0FJQUlRZ2dCMEVFYWlGSUlBSWdTRFlDQUNBSXJDR1RBU0FBSUpNQk53TUFEQXdNQ2dBTEFBc0NRQ0FDS0FJQUlUOGdQeUVKUVFCQkJHb2hXeUJiSVZvZ1drRUJheUZaSUFrZ1dXb2hDa0VBUVFScUlWOGdYeUZlSUY1QkFXc2hYU0JkUVg5eklWd2dDaUJjY1NFTElBc2hEQ0FNS0FJQUlRMGdERUVFYWlGSklBSWdTVFlDQUNBTnJTR1VBU0FBSUpRQk53TUFEQXNNQ1FBTEFBc0NRQ0FDS0FJQUlVQWdRQ0VPUVFCQkNHb2hZaUJpSVdFZ1lVRUJheUZnSUE0Z1lHb2hEMEVBUVFocUlXWWdaaUZsSUdWQkFXc2haQ0JrUVg5eklXTWdEeUJqY1NFUUlCQWhFU0FSS1FNQUlaVUJJQkZCQ0dvaFNpQUNJRW8yQWdBZ0FDQ1ZBVGNEQUF3S0RBZ0FDd0FMQWtBZ0FpZ0NBQ0U0SURnaEVrRUFRUVJxSVdrZ2FTRm9JR2hCQVdzaFp5QVNJR2RxSVJOQkFFRUVhaUZ0SUcwaGJDQnNRUUZySVdzZ2EwRi9jeUZxSUJNZ2FuRWhGQ0FVSVJVZ0ZTZ0NBQ0VYSUJWQkJHb2hRaUFDSUVJMkFnQWdGMEgvL3dOeElSZ2dHRUVRZEVFUWRhd2hsZ0VnQUNDV0FUY0RBQXdKREFjQUN3QUxBa0FnQWlnQ0FDRTVJRGtoR1VFQVFRUnFJWEFnY0NGdklHOUJBV3NoYmlBWklHNXFJUnBCQUVFRWFpRjBJSFFoY3lCelFRRnJJWElnY2tGL2N5RnhJQm9nY1hFaEd5QWJJUndnSENnQ0FDRWRJQnhCQkdvaFF5QUNJRU0yQWdBZ0hVSC8vd054SVFRZ0JLMGhsd0VnQUNDWEFUY0RBQXdJREFZQUN3QUxBa0FnQWlnQ0FDRTZJRG9oSGtFQVFRUnFJWGNnZHlGMklIWkJBV3NoZFNBZUlIVnFJU0JCQUVFRWFpRjdJSHNoZWlCNlFRRnJJWGtnZVVGL2N5RjRJQ0FnZUhFaElTQWhJU0lnSWlnQ0FDRWpJQ0pCQkdvaFJDQUNJRVEyQWdBZ0kwSC9BWEVoSkNBa1FSaDBRUmgxckNHWUFTQUFJSmdCTndNQURBY01CUUFMQUFzQ1FDQUNLQUlBSVR3Z1BDRWxRUUJCQkdvaGZpQitJWDBnZlVFQmF5RjhJQ1VnZkdvaEprRUFRUVJxSVlJQklJSUJJWUVCSUlFQlFRRnJJWUFCSUlBQlFYOXpJWDhnSmlCL2NTRW5JQ2NoS0NBb0tBSUFJU29nS0VFRWFpRkZJQUlnUlRZQ0FDQXFRZjhCY1NFRElBT3RJWmtCSUFBZ21RRTNBd0FNQmd3RUFBc0FDd0pBSUFJb0FnQWhQU0E5SVN0QkFFRUlhaUdGQVNDRkFTR0VBU0NFQVVFQmF5R0RBU0FySUlNQmFpRXNRUUJCQ0dvaGlRRWdpUUVoaUFFZ2lBRkJBV3NoaHdFZ2h3RkJmM01oaGdFZ0xDQ0dBWEVoTFNBdElTNGdMaXNEQUNHYUFTQXVRUWhxSVVZZ0FpQkdOZ0lBSUFBZ21nRTVBd0FNQlF3REFBc0FDd0pBSUFJb0FnQWhQaUErSVM5QkFFRUlhaUdNQVNDTUFTR0xBU0NMQVVFQmF5R0tBU0F2SUlvQmFpRXdRUUJCQ0dvaGtBRWdrQUVoandFZ2p3RkJBV3NoamdFZ2pnRkJmM01oalFFZ01DQ05BWEVoTVNBeElUTWdNeXNEQUNHYkFTQXpRUWhxSVVjZ0FpQkhOZ0lBSUFBZ213RTVBd0FNQkF3Q0FBc0FDd3dDQ3dzTER3dVFBUUlPZndKK0l3MGhFQ0FBUWdCUklRZ2dDQVJBSUFFaEF3VWdBU0VFSUFBaEVRTkFBa0FnRWFjaENTQUpRUTl4SVFwQnhpY2dDbW9oQ3lBTExBQUFJUXdnREVIL0FYRWhEU0FOSUFKeUlRNGdEa0gvQVhFaEJTQUVRWDlxSVFZZ0JpQUZPZ0FBSUJGQ0JJZ2hFaUFTUWdCUklRY2dCd1JBSUFZaEF3d0JCU0FHSVFRZ0VpRVJDd3dCQ3dzTElBTVBDM1VDQ244Q2ZpTU5JUXNnQUVJQVVTRUVJQVFFUUNBQklRSUZJQUFoRENBQklRTURRQUpBSUF5blFmOEJjU0VGSUFWQkIzRWhCaUFHUVRCeUlRY2dBMEYvYWlFSUlBZ2dCem9BQUNBTVFnT0lJUTBnRFVJQVVTRUpJQWtFUUNBSUlRSU1BUVVnRFNFTUlBZ2hBd3NNQVFzTEN5QUNEd3Y5QVFJV2Z3TitJdzBoRnlBQVF2Ly8vLzhQVmlFT0lBQ25JUlFnRGdSQUlBQWhHQ0FCSVFVRFFBSkFJQmhDQ29JaEdTQVpwMEgvQVhFaER5QVBRVEJ5SVJBZ0JVRi9haUVSSUJFZ0VEb0FBQ0FZUWdxQUlSb2dHRUwvLy8vL253RldJUklnRWdSQUlCb2hHQ0FSSVFVRkRBRUxEQUVMQ3lBYXB5RVZJQlVoQWlBUklRUUZJQlFoQWlBQklRUUxJQUpCQUVZaEV5QVRCRUFnQkNFR0JTQUNJUU1nQkNFSEEwQUNRQ0FEUVFwd1FYOXhJUWdnQ0VFd2NpRUpJQWxCL3dGeElRb2dCMEYvYWlFTElBc2dDam9BQUNBRFFRcHVRWDl4SVF3Z0EwRUtTU0VOSUEwRVFDQUxJUVlNQVFVZ0RDRURJQXNoQndzTUFRc0xDeUFHRHdzbUFRWi9JdzBoQmhCS0lRRWdBVUc4QVdvaEFpQUNLQUlBSVFNZ0FDQURFRXNoQkNBRUR3dUhCUUU0ZnlNTklUb2dBVUgvQVhFaEppQUFJVEVnTVVFRGNTRXlJREpCQUVjaE15QUNRUUJISVRRZ05DQXpjU0U0QWtBZ09BUkFJQUZCL3dGeElUVWdBQ0VHSUFJaENRTkFBa0FnQml3QUFDRTJJRFpCR0hSQkdIVWdOVUVZZEVFWWRVWWhFaUFTQkVBZ0JpRUZJQWtoQ0VFR0lUa01CQXNnQmtFQmFpRVRJQWxCZjJvaEZDQVRJUlVnRlVFRGNTRVdJQlpCQUVjaEZ5QVVRUUJISVJnZ0dDQVhjU0UzSURjRVFDQVRJUVlnRkNFSkJTQVRJUVFnRkNFSElCZ2hFVUVGSVRrTUFRc01BUXNMQlNBQUlRUWdBaUVISURRaEVVRUZJVGtMQ3lBNVFRVkdCRUFnRVFSQUlBUWhCU0FISVFoQkJpRTVCU0FFSVE1QkFDRVFDd3NDUUNBNVFRWkdCRUFnQlN3QUFDRVpJQUZCL3dGeElSb2dHVUVZZEVFWWRTQWFRUmgwUVJoMVJpRWJJQnNFUUNBRklRNGdDQ0VRQlNBbVFZR0NoQWhzSVJ3Z0NFRURTeUVkQWtBZ0hRUkFJQVVoQ2lBSUlRd0RRQUpBSUFvb0FnQWhIaUFlSUJ4eklSOGdIMEgvL2Z0M2FpRWdJQjlCZ0lHQ2hIaHhJU0VnSVVHQWdZS0VlSE1oSWlBaUlDQnhJU01nSTBFQVJpRWtJQ1JGQkVBTUFRc2dDa0VFYWlFbElBeEJmR29oSnlBblFRTkxJU2dnS0FSQUlDVWhDaUFuSVF3RklDVWhBeUFuSVF0QkN5RTVEQVFMREFFTEN5QUtJUTBnRENFUEJTQUZJUU1nQ0NFTFFRc2hPUXNMSURsQkMwWUVRQ0FMUVFCR0lTa2dLUVJBSUFNaERrRUFJUkFNQkFVZ0F5RU5JQXNoRHdzTEEwQUNRQ0FOTEFBQUlTb2dLa0VZZEVFWWRTQWFRUmgwUVJoMVJpRXJJQ3NFUUNBTklRNGdEeUVRREFVTElBMUJBV29oTENBUFFYOXFJUzBnTFVFQVJpRXVJQzRFUUNBc0lRNUJBQ0VRREFFRklDd2hEU0F0SVE4TERBRUxDd3NMQ3lBUVFRQkhJUzhnTHdSL0lBNEZRUUFMSVRBZ01BOEx6QUVCRVg4akRTRVZJdzFCZ0FKcUpBMGpEU01PVGdSQVFZQUNFQU1MSUJVaERpQUVRWURBQkhFaER5QVBRUUJHSVJBZ0FpQURTaUVSSUJFZ0VIRWhFeUFUQkVBZ0FpQURheUVTSUJKQmdBSkpJUWNnQndSL0lCSUZRWUFDQ3lFSUlBNGdBU0FJRUY0YUlCSkIvd0ZMSVFrZ0NRUkFJQUlnQTJzaENpQVNJUVlEUUFKQUlBQWdEa0dBQWhBNUlBWkJnSDVxSVFzZ0MwSC9BVXNoRENBTUJFQWdDeUVHQlF3QkN3d0JDd3NnQ2tIL0FYRWhEU0FOSVFVRklCSWhCUXNnQUNBT0lBVVFPUXNnRlNRTkR3c3FBUVYvSXcwaEJpQUFRUUJHSVFNZ0F3UkFRUUFoQWdVZ0FDQUJRUUFRUnlFRUlBUWhBZ3NnQWc4TDNEQUQwZ04vRDM0aGZDTU5JZGNESXcxQnNBUnFKQTBqRFNNT1RnUkFRYkFFRUFNTElOY0RRUWhxSWFVRElOY0RJYThESU5jRFFZd0VhaUc2QXlDNkF5SENBeURYQTBHQUJHb2hiaUN2QTBFQU5nSUFJRzVCREdvaGVDQUJFRVFoMkFNZzJBTkNBRk1oaFFFZ2hRRUVRQ0FCbWlINEF5RDRBeUhxQTBFQklSeEJveWNoSFFVZ0JFR0FFSEVobUFFZ21BRkJBRVlob3dFZ0JFRUJjU0d1QVNDdUFVRUFSaUc1QVNDNUFRUi9RYVFuQlVHcEp3c2hCaUNqQVFSL0lBWUZRYVluQ3lFSElBUkJnUkJ4SWNRQklNUUJRUUJISWM4QklNOEJRUUZ4SVVvZ0FTSHFBeUJLSVJ3Z0J5RWRDeURxQXhCRUllQURJT0FEUW9DQWdJQ0FnSUQ0L3dDREllRURJT0VEUW9DQWdJQ0FnSUQ0L3dCUkllMEJBa0FnN1FFRVFDQUZRU0J4SWZZQklQWUJRUUJISVlFQ0lJRUNCSDlCdGljRlFib25DeUdNQWlEcUF5RHFBMkpFQUFBQUFBQUFBQUJFQUFBQUFBQUFBQUJpY2lHWEFpQ0JBZ1IvUWI0bkJVSENKd3Nob2dJZ2x3SUVmeUNpQWdVZ2pBSUxJUmtnSEVFRGFpR3RBaUFFUWYvL2UzRWh0d0lnQUVFZ0lBSWdyUUlndHdJUVFTQUFJQjBnSEJBNUlBQWdHVUVERURrZ0JFR0F3QUJ6SWNJQ0lBQkJJQ0FDSUswQ0lNSUNFRUVnclFJaGJRVWc2Z01ncndNUVJTSDhBeUQ4QTBRQUFBQUFBQUFBUUtJaC9RTWcvUU5FQUFBQUFBQUFBQUJpSWVBQ0lPQUNCRUFncndNb0FnQWg2Z0lnNmdKQmYyb2g5UUlncndNZzlRSTJBZ0FMSUFWQklISWgvd0lnL3dKQjRRQkdJWW9ESUlvREJFQWdCVUVnY1NHVkF5Q1ZBMEVBUmlHWUF5QWRRUWxxSVprRElKZ0RCSDhnSFFVZ21RTUxJUjRnSEVFQ2NpR2FBeUFEUVF0TElac0RRUXdnQTJzaG5BTWduQU5CQUVZaG5RTWdtd01nblFOeUlaNERBa0FnbmdNRVFDRDlBeUh1QXdWRUFBQUFBQUFBSUVBaDZ3TWduQU1oS2dOQUFrQWdLa0YvYWlHZkF5RHJBMFFBQUFBQUFBQXdRS0loL2dNZ253TkJBRVlob0FNZ29BTUVRQXdCQlNEK0F5SHJBeUNmQXlFcUN3d0JDd3NnSGl3QUFDR2hBeUNoQTBFWWRFRVlkVUV0UmlHaUF5Q2lBd1JBSVAwRG1pSC9BeUQvQXlEK0E2RWhnQVFnL2dNZ2dBU2dJWUVFSUlFRW1pR0NCQ0NDQkNIdUF3d0NCU0Q5QXlEK0E2QWhnd1FnZ3dRZy9nT2hJWVFFSUlRRUllNEREQUlMQUFzTElLOERLQUlBSWFNRElLTURRUUJJSWFRRFFRQWdvd05ySWFZRElLUURCSDhncGdNRklLTURDeUduQXlDbkE2d2g1Z01nNWdNZ2VCQStJYWdESUtnRElIaEdJYWtESUtrREJFQWdia0VMYWlHcUF5Q3FBMEV3T2dBQUlLb0RJUm9GSUtnRElSb0xJS01EUVI5MUlhc0RJS3NEUVFKeElhd0RJS3dEUVN0cUlhMERJSzBEUWY4QmNTR3VBeUFhUVg5cUliQURJTEFESUs0RE9nQUFJQVZCRDJvaHNRTWdzUU5CL3dGeEliSURJQnBCZm1vaHN3TWdzd01nc2dNNkFBQWdBMEVCU0NHMEF5QUVRUWh4SWJVRElMVURRUUJHSWJZRElMb0RJUjhnN2dNaDd3TURRQUpBSU84RHFpRzNBMEhHSnlDM0Eyb2h1QU1ndUFNc0FBQWh1UU1ndVFOQi93RnhJYnNESUpVRElMc0RjaUc4QXlDOEEwSC9BWEVodlFNZ0gwRUJhaUcrQXlBZklMMERPZ0FBSUxjRHR5R0ZCQ0R2QXlDRkJLRWhoZ1FnaGdSRUFBQUFBQUFBTUVDaUlZY0VJTDRESWI4RElMOERJTUlEYXlIQUF5REFBMEVCUmlIQkF5REJBd1JBSUljRVJBQUFBQUFBQUFBQVlTSERBeUMwQXlEREEzRWh6d01ndGdNZ3p3TnhJYzRESU00REJFQWd2Z01oTGdVZ0gwRUNhaUhFQXlDK0EwRXVPZ0FBSU1RRElTNExCU0MrQXlFdUN5Q0hCRVFBQUFBQUFBQUFBR0loeFFNZ3hRTUVRQ0F1SVI4Z2h3UWg3d01GREFFTERBRUxDeUFEUVFCR0ljWURJQzRoYUNER0F3UkFRUmdoMWdNRlFYNGd3Z05ySWNjRElNY0RJR2hxSWNnRElNZ0RJQU5JSWNrRElNa0RCRUFnQTBFQ2FpSEtBeUJvSU1JRGF5Rm5JR2NoWlNES0F5RnFCVUVZSWRZREN3c2cxZ05CR0VZRVFDQm9JTUlEYXlITEF5RExBeUZsSU1zRElXb0xJSGdoekFNZ3N3TWhieURNQXlCdmF5RndJSEFnbWdOcUlYRWdjU0JxYWlGeUlBQkJJQ0FDSUhJZ0JCQkJJQUFnSGlDYUF4QTVJQVJCZ0lBRWN5RnpJQUJCTUNBQ0lISWdjeEJCSUFBZ3VnTWdaUkE1SUdvZ1pXc2hkQ0FBUVRBZ2RFRUFRUUFRUVNBQUlMTURJSEFRT1NBRVFZREFBSE1oZFNBQVFTQWdBaUJ5SUhVUVFTQnlJVzBNQWdzZ0EwRUFTQ0YySUhZRWYwRUdCU0FEQ3lGTElPQUNCRUFnL1FORUFBQUFBQUFBc0VHaUlmUURJSzhES0FJQUlYY2dkMEZrYWlGNUlLOERJSGsyQWdBZzlBTWg4QU1nZVNGaUJTQ3ZBeWdDQUNGa0lQMERJZkFESUdRaFlnc2dZa0VBU0NGNklLVURRYUFDYWlGN0lIb0VmeUNsQXdVZ2V3c2hWU0JWSVJnZzhBTWg4UU1EUUFKQUlQRURxeUY4SUJnZ2ZEWUNBQ0FZUVFScUlYMGdmTGdoOVFNZzhRTWc5UU9oSWZZRElQWURSQUFBQUFCbHpjMUJvaUgzQXlEM0EwUUFBQUFBQUFBQUFHSWhmaUIrQkVBZ2ZTRVlJUGNESWZFREJRd0JDd3dCQ3dzZ1lrRUFTaUYvSUg4RVFDQlZJU1lnZlNFcElHSWhnUUVEUUFKQUlJRUJRUjFJSVlBQklJQUJCSDhnZ1FFRlFSMExJWUlCSUNsQmZHb2hGQ0FVSUNaSklZTUJJSU1CQkVBZ0ppRTRCU0NDQWEwaDJRTWdGQ0VWUVFBaEZ3TkFBa0FnRlNnQ0FDR0VBU0NFQWEwaDJnTWcyZ01nMlFPR0lkc0RJQmV0SWR3RElOc0RJTndEZkNIZEF5RGRBMEtBbE92Y0E0SWgzZ01nM2dPbklZWUJJQlVnaGdFMkFnQWczUU5DZ0pUcjNBT0FJZDhESU44RHB5R0hBU0FWUVh4cUlSTWdFeUFtU1NHSUFTQ0lBUVJBREFFRklCTWhGU0NIQVNFWEN3d0JDd3NnaHdGQkFFWWhpUUVnaVFFRVFDQW1JVGdGSUNaQmZHb2hpZ0VnaWdFZ2h3RTJBZ0FnaWdFaE9Bc0xJQ2toT1FOQUFrQWdPU0E0U3lHTEFTQ0xBVVVFUUF3QkN5QTVRWHhxSVl3QklJd0JLQUlBSVkwQklJMEJRUUJHSVk0QklJNEJCRUFnakFFaE9RVU1BUXNNQVFzTElLOERLQUlBSVk4QklJOEJJSUlCYXlHUUFTQ3ZBeUNRQVRZQ0FDQ1FBVUVBU2lHUkFTQ1JBUVJBSURnaEppQTVJU2tna0FFaGdRRUZJRGdoSlNBNUlTZ2drQUVoWXd3QkN3d0JDd3NGSUZVaEpTQjlJU2dnWWlGakN5QmpRUUJJSVpJQklKSUJCRUFnUzBFWmFpR1RBU0NUQVVFSmJVRi9jU0dVQVNDVUFVRUJhaUdWQVNEL0FrSG1BRVlobGdFZ0pTRkFJQ2doUWlCaklaa0JBMEFDUUVFQUlKa0JheUdYQVNDWEFVRUpTQ0dhQVNDYUFRUi9JSmNCQlVFSkN5R2JBU0JBSUVKSklad0JJSndCQkVCQkFTQ2JBWFFob0FFZ29BRkJmMm9ob1FGQmdKVHIzQU1nbXdGMklhSUJRUUFoRWlCQUlTY0RRQUpBSUNjb0FnQWhwQUVncEFFZ29RRnhJYVVCSUtRQklKc0JkaUdtQVNDbUFTQVNhaUduQVNBbklLY0JOZ0lBSUtVQklLSUJiQ0dvQVNBblFRUnFJYWtCSUtrQklFSkpJYW9CSUtvQkJFQWdxQUVoRWlDcEFTRW5CUXdCQ3d3QkN3c2dRQ2dDQUNHckFTQ3JBVUVBUmlHc0FTQkFRUVJxSWEwQklLd0JCSDhnclFFRklFQUxJUWdncUFGQkFFWWhyd0VncndFRVFDQUlJUW9nUWlGSEJTQkNRUVJxSWJBQklFSWdxQUUyQWdBZ0NDRUtJTEFCSVVjTEJTQkFLQUlBSVowQklKMEJRUUJHSVo0QklFQkJCR29obndFZ25nRUVmeUNmQVFVZ1FBc2hDU0FKSVFvZ1FpRkhDeUNXQVFSL0lGVUZJQW9MSWJFQklFY2hzZ0Vnc1FFaHN3RWdzZ0Vnc3dGckliUUJJTFFCUVFKMUliVUJJTFVCSUpVQlNpRzJBU0N4QVNDVkFVRUNkR29odHdFZ3RnRUVmeUMzQVFVZ1J3c2hEQ0N2QXlnQ0FDRzRBU0M0QVNDYkFXb2h1Z0VncndNZ3VnRTJBZ0FndWdGQkFFZ2h1d0VndXdFRVFDQUtJVUFnRENGQ0lMb0JJWmtCQlNBS0lUOGdEQ0ZCREFFTERBRUxDd1VnSlNFL0lDZ2hRUXNnUHlCQlNTRzhBU0JWSWIwQklMd0JCRUFnUHlHK0FTQzlBU0MrQVdzaHZ3RWd2d0ZCQW5VaHdBRWd3QUZCQ1d3aHdRRWdQeWdDQUNIQ0FTRENBVUVLU1NIREFTRERBUVJBSU1FQklTMEZJTUVCSVJ0QkNpRWlBMEFDUUNBaVFRcHNJY1VCSUJ0QkFXb2h4Z0Vnd2dFZ3hRRkpJY2NCSU1jQkJFQWd4Z0VoTFF3QkJTREdBU0ViSU1VQklTSUxEQUVMQ3dzRlFRQWhMUXNnL3dKQjVnQkhJY2dCSU1nQkJIOGdMUVZCQUFzaHlRRWdTeURKQVdzaHlnRWcvd0pCNXdCR0ljc0JJRXRCQUVjaHpBRWd6QUVneXdGeEljMEJJTTBCUVI5MFFSOTFJVjhneWdFZ1gyb2h6Z0VnUVNIUUFTRFFBU0M5QVdzaDBRRWcwUUZCQW5VaDBnRWcwZ0ZCQ1d3aDB3RWcwd0ZCZDJvaDFBRWd6Z0VnMUFGSUlkVUJJTlVCQkVBZ1ZVRUVhaUhXQVNET0FVR0F5QUJxSWRjQklOY0JRUWx0UVg5eElkZ0JJTmdCUVlCNGFpSFpBU0RXQVNEWkFVRUNkR29oMmdFZzF3RkJDVzlCZjNFaDJ3RWcyd0ZCQ0VnaDNBRWczQUVFUUNEYkFTRWhRUW9oTWdOQUFrQWdJVUVCYWlFZ0lESkJDbXdoM1FFZ0lVRUhTQ0hlQVNEZUFRUkFJQ0FoSVNEZEFTRXlCU0RkQVNFeERBRUxEQUVMQ3dWQkNpRXhDeURhQVNnQ0FDSGZBU0RmQVNBeGNFRi9jU0hnQVNEZ0FVRUFSaUhoQVNEYUFVRUVhaUhpQVNEaUFTQkJSaUhqQVNEakFTRGhBWEVoMEFNZzBBTUVRQ0RhQVNGR0lDMGhTQ0EvSVZ3RklOOEJJREZ1UVg5eEllUUJJT1FCUVFGeEllVUJJT1VCUVFCR0llWUJJT1lCQkh4RUFBQUFBQUFBUUVNRlJBRUFBQUFBQUVCREN5SHlBeUF4UVFKdFFYOXhJZWNCSU9BQklPY0JTU0hvQVNEZ0FTRG5BVVloNlFFZzR3RWc2UUZ4SWRFRElORURCSHhFQUFBQUFBQUE4RDhGUkFBQUFBQUFBUGcvQ3lIekF5RG9BUVI4UkFBQUFBQUFBT0EvQlNEekF3c2g2UU1nSEVFQVJpSHFBU0RxQVFSQUlPa0RJZXdESVBJREllMERCU0FkTEFBQUllc0JJT3NCUVJoMFFSaDFRUzFHSWV3QklQSURtaUg1QXlEcEE1b2grZ01nN0FFRWZDRDVBd1VnOGdNTEllZ0RJT3dCQkh3ZytnTUZJT2tEQ3lIbkF5RG5BeUhzQXlEb0F5SHRBd3NnM3dFZzRBRnJJZTRCSU5vQklPNEJOZ0lBSU8wRElPd0RvQ0g3QXlEN0F5RHRBMkloN3dFZzd3RUVRQ0R1QVNBeGFpSHdBU0RhQVNEd0FUWUNBQ0R3QVVIL2srdmNBMHNoOFFFZzhRRUVRQ0EvSVU4ZzJnRWhiQU5BQWtBZ2JFRjhhaUh5QVNCc1FRQTJBZ0FnOGdFZ1Qwa2g4d0VnOHdFRVFDQlBRWHhxSWZRQklQUUJRUUEyQWdBZzlBRWhWZ1VnVHlGV0N5RHlBU2dDQUNIMUFTRDFBVUVCYWlIM0FTRHlBU0QzQVRZQ0FDRDNBVUgvayt2Y0Ewc2grQUVnK0FFRVFDQldJVThnOGdFaGJBVWdWaUZPSVBJQklXc01BUXNNQVFzTEJTQS9JVTRnMmdFaGF3c2dUaUg1QVNDOUFTRDVBV3NoK2dFZytnRkJBblVoK3dFZyt3RkJDV3doL0FFZ1RpZ0NBQ0g5QVNEOUFVRUtTU0grQVNEK0FRUkFJR3NoUmlEOEFTRklJRTRoWEFVZy9BRWhPMEVLSVQwRFFBSkFJRDFCQ213aC93RWdPMEVCYWlHQUFpRDlBU0QvQVVraGdnSWdnZ0lFUUNCcklVWWdnQUloU0NCT0lWd01BUVVnZ0FJaE95RC9BU0U5Q3d3QkN3c0xCU0RhQVNGR0lDMGhTQ0EvSVZ3TEN5QkdRUVJxSVlNQ0lFRWdnd0pMSVlRQ0lJUUNCSDhnZ3dJRklFRUxJUXNnU0NGU0lBc2hXeUJjSVYwRklDMGhVaUJCSVZzZ1B5RmRDeUJiSVZrRFFBSkFJRmtnWFVzaGhRSWdoUUpGQkVCQkFDRmVEQUVMSUZsQmZHb2hoZ0lnaGdJb0FnQWhod0lnaHdKQkFFWWhpQUlnaUFJRVFDQ0dBaUZaQlVFQklWNE1BUXNNQVFzTFFRQWdVbXNoaVFJQ1FDRExBUVJBSU13QlFRRnpJYzBESU0wRFFRRnhJWW9DSUVzZ2lnSnFJVXdnVENCU1NpR0xBaUJTUVh0S0lZMENJSXNDSUkwQ2NTSFRBeURUQXdSQUlBVkJmMm9oamdJZ1RFRi9haUZnSUdBZ1Vtc2hqd0lnamdJaEVTQ1BBaUUxQlNBRlFYNXFJWkFDSUV4QmYyb2hrUUlna0FJaEVTQ1JBaUUxQ3lBRVFRaHhJWklDSUpJQ1FRQkdJWk1DSUpNQ0JFQWdYZ1JBSUZsQmZHb2hsQUlnbEFJb0FnQWhsUUlnbFFKQkFFWWhsZ0lnbGdJRVFFRUpJVHdGSUpVQ1FRcHdRWDl4SVpnQ0lKZ0NRUUJHSVprQ0lKa0NCRUJCQUNFd1FRb2hRd05BQWtBZ1EwRUtiQ0dhQWlBd1FRRnFJWnNDSUpVQ0lKb0NjRUYvY1NHY0FpQ2NBa0VBUmlHZEFpQ2RBZ1JBSUpzQ0lUQWdtZ0loUXdVZ213SWhQQXdCQ3d3QkN3c0ZRUUFoUEFzTEJVRUpJVHdMSUJGQklISWhuZ0lnbmdKQjVnQkdJWjhDSUZraG9BSWdvQUlndlFGcklhRUNJS0VDUVFKMUlhTUNJS01DUVFsc0lhUUNJS1FDUVhkcUlhVUNJSjhDQkVBZ3BRSWdQR3NocGdJZ3BnSkJBRW9ocHdJZ3B3SUVmeUNtQWdWQkFBc2hUU0ExSUUxSUlhZ0NJS2dDQkg4Z05RVWdUUXNoTmlBUklTUWdOaUUrUVFBaFpnd0RCU0NsQWlCU2FpR3BBaUNwQWlBOGF5R3FBaUNxQWtFQVNpR3JBaUNyQWdSL0lLb0NCVUVBQ3lGUklEVWdVVWdockFJZ3JBSUVmeUExQlNCUkN5RTNJQkVoSkNBM0lUNUJBQ0ZtREFNTEFBVWdFU0VrSURVaFBpQ1NBaUZtQ3dVZ0JFRUljU0ZwSUFVaEpDQkxJVDRnYVNGbUN3c2dQaUJtY2lHdUFpQ3VBa0VBUnlHdkFpQ3ZBa0VCY1NHd0FpQWtRU0J5SWJFQ0lMRUNRZVlBUmlHeUFpQ3lBZ1JBSUZKQkFFb2hzd0lnc3dJRWZ5QlNCVUVBQ3lHMEFrRUFJVG9ndEFJaFlRVWdVa0VBU0NHMUFpQzFBZ1IvSUlrQ0JTQlNDeUcyQWlDMkFxd2g0Z01nNGdNZ2VCQStJYmdDSUhnaHVRSWd1QUlodWdJZ3VRSWd1Z0pySWJzQ0lMc0NRUUpJSWJ3Q0lMd0NCRUFndUFJaExBTkFBa0FnTEVGL2FpRzlBaUM5QWtFd09nQUFJTDBDSWI0Q0lMa0NJTDRDYXlHL0FpQy9Ba0VDU0NIQUFpREFBZ1JBSUwwQ0lTd0ZJTDBDSVNzTUFRc01BUXNMQlNDNEFpRXJDeUJTUVI5MUljRUNJTUVDUVFKeEljTUNJTU1DUVN0cUljUUNJTVFDUWY4QmNTSEZBaUFyUVg5cUljWUNJTVlDSU1VQ09nQUFJQ1JCL3dGeEljY0NJQ3RCZm1vaHlBSWd5QUlneHdJNkFBQWd5QUloeVFJZ3VRSWd5UUpySWNvQ0lNZ0NJVG9neWdJaFlRc2dIRUVCYWlITEFpRExBaUErYWlITUFpRE1BaUN3QW1vaEx5QXZJR0ZxSWMwQ0lBQkJJQ0FDSU0wQ0lBUVFRU0FBSUIwZ0hCQTVJQVJCZ0lBRWN5SE9BaUFBUVRBZ0FpRE5BaURPQWhCQklMSUNCRUFnWFNCVlN5SFBBaURQQWdSL0lGVUZJRjBMSVJZZ3VnTkJDV29oMEFJZzBBSWgwUUlndWdOQkNHb2gwZ0lnRmlGUUEwQUNRQ0JRS0FJQUlkTUNJTk1DclNIakF5RGpBeURRQWhBK0lkUUNJRkFnRmtZaDFRSWcxUUlFUUNEVUFpRFFBa1loMndJZzJ3SUVRQ0RTQWtFd09nQUFJTklDSVNNRklOUUNJU01MQlNEVUFpQzZBMHNoMWdJZzFnSUVRQ0RVQWlIWEFpRFhBaURDQTJzaDJBSWd1Z05CTUNEWUFoQmVHaURVQWlFUUEwQUNRQ0FRUVg5cUlka0NJTmtDSUxvRFN5SGFBaURhQWdSQUlOa0NJUkFGSU5rQ0lTTU1BUXNNQVFzTEJTRFVBaUVqQ3dzZ0l5SGNBaURSQWlEY0Ftc2gzUUlnQUNBaklOMENFRGtnVUVFRWFpSGVBaURlQWlCVlN5SGZBaURmQWdSQURBRUZJTjRDSVZBTERBRUxDeUN1QWtFQVJpSGhBaURoQWtVRVFDQUFRZFluUVFFUU9Rc2czZ0lnV1VraDRnSWdQa0VBU2lIakFpRGlBaURqQW5FaDVBSWc1QUlFUUNBK0lVVWczZ0loVndOQUFrQWdWeWdDQUNIbEFpRGxBcTBoNUFNZzVBTWcwQUlRUGlIbUFpRG1BaUM2QTBzaDV3SWc1d0lFUUNEbUFpSG9BaURvQWlEQ0Eyc2g2UUlndWdOQk1DRHBBaEJlR2lEbUFpRVBBMEFDUUNBUFFYOXFJZXNDSU9zQ0lMb0RTeUhzQWlEc0FnUkFJT3NDSVE4RklPc0NJUTRNQVFzTUFRc0xCU0RtQWlFT0N5QkZRUWxJSWUwQ0lPMENCSDhnUlFWQkNRc2g3Z0lnQUNBT0lPNENFRGtnVjBFRWFpSHZBaUJGUVhkcUlmQUNJTzhDSUZsSklmRUNJRVZCQ1VvaDhnSWc4UUlnOGdKeElmTUNJUE1DQkVBZzhBSWhSU0R2QWlGWEJTRHdBaUZFREFFTERBRUxDd1VnUGlGRUN5QkVRUWxxSWZRQ0lBQkJNQ0QwQWtFSlFRQVFRUVVnWFVFRWFpSDJBaUJlQkg4Z1dRVWc5Z0lMSVZvZ1BrRi9TaUgzQWlEM0FnUkFJTG9EUVFscUlmZ0NJR1pCQUVZaCtRSWcrQUloK2dKQkFDRENBMnNoK3dJZ3VnTkJDR29oL0FJZ1BpRlVJRjBoV0FOQUFrQWdXQ2dDQUNIOUFpRDlBcTBoNVFNZzVRTWcrQUlRUGlIK0FpRCtBaUQ0QWtZaGdBTWdnQU1FUUNEOEFrRXdPZ0FBSVB3Q0lRMEZJUDRDSVEwTElGZ2dYVVloZ1FNQ1FDQ0JBd1JBSUExQkFXb2hoUU1nQUNBTlFRRVFPU0JVUVFGSUlZWURJUGtDSUlZRGNTSFNBeURTQXdSQUlJVURJVFFNQWdzZ0FFSFdKMEVCRURrZ2hRTWhOQVVnRFNDNkEwc2hnZ01nZ2dORkJFQWdEU0UwREFJTElBMGcrd0pxSWRRRElOUURJZFVESUxvRFFUQWcxUU1RWGhvZ0RTRXpBMEFDUUNBelFYOXFJWU1ESUlNRElMb0RTeUdFQXlDRUF3UkFJSU1ESVRNRklJTURJVFFNQVFzTUFRc0xDd3NnTkNHSEF5RDZBaUNIQTJzaGlBTWdWQ0NJQTBvaGlRTWdpUU1FZnlDSUF3VWdWQXNoaXdNZ0FDQTBJSXNERURrZ1ZDQ0lBMnNoakFNZ1dFRUVhaUdOQXlDTkF5QmFTU0dPQXlDTUEwRi9TaUdQQXlDT0F5Q1BBM0Voa0FNZ2tBTUVRQ0NNQXlGVUlJMERJVmdGSUl3RElVa01BUXNNQVFzTEJTQStJVWtMSUVsQkVtb2hrUU1nQUVFd0lKRURRUkpCQUJCQklIZ2hrZ01nT2lHVEF5Q1NBeUNUQTJzaGxBTWdBQ0E2SUpRREVEa0xJQVJCZ01BQWN5R1dBeUFBUVNBZ0FpRE5BaUNXQXhCQklNMENJVzBMQ3lCdElBSklJWmNESUpjREJIOGdBZ1VnYlFzaFV5RFhBeVFOSUZNUEN4SUNBbjhCZmlNTklRSWdBTDBoQXlBRER3c1ZBZ0ovQVh3akRTRURJQUFnQVJCR0lRUWdCQThMOUJFREMzOEVmZ1Y4SXcwaERDQUF2U0VQSUE5Q05JZ2hFQ0FRcDBILy93TnhJUWtnQ1VIL0QzRWhDZ0pBQWtBQ1FBSkFJQXBCRUhSQkVIVkJBR3NPZ0JBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBUUlMQWtBZ0FFUUFBQUFBQUFBQUFHSWhCQ0FFQkVBZ0FFUUFBQUFBQUFEd1E2SWhGQ0FVSUFFUVJpRVZJQUVvQWdBaEJTQUZRVUJxSVFZZ0ZTRVNJQVloQ0FVZ0FDRVNRUUFoQ0FzZ0FTQUlOZ0lBSUJJaEVRd0RBQXNBQ3dKQUlBQWhFUXdDQUFzQUN3SkFJQkNuSVFjZ0IwSC9EM0VoQWlBQ1FZSjRhaUVESUFFZ0F6WUNBQ0FQUXYvLy8vLy8vLytIZ0grRElRMGdEVUtBZ0lDQWdJQ0E4RCtFSVE0Z0RyOGhFeUFUSVJFTEN5QVJEd3ZrQkFFN2Z5TU5JVDBnQUVFQVJpRVlBa0FnR0FSQVFRRWhBd1VnQVVHQUFVa2hJeUFqQkVBZ0FVSC9BWEVoTGlBQUlDNDZBQUJCQVNFRERBSUxFRWdoTnlBM1Fid0JhaUU0SURnb0FnQWhPU0E1S0FJQUlUb2dPa0VBUmlFRUlBUUVRQ0FCUVlCL2NTRUZJQVZCZ0w4RFJpRUdJQVlFUUNBQlFmOEJjU0VJSUFBZ0NEb0FBRUVCSVFNTUF3VVFNU0VISUFkQjFBQTJBZ0JCZnlFRERBTUxBQXNnQVVHQUVFa2hDU0FKQkVBZ0FVRUdkaUVLSUFwQndBRnlJUXNnQzBIL0FYRWhEQ0FBUVFGcUlRMGdBQ0FNT2dBQUlBRkJQM0VoRGlBT1FZQUJjaUVQSUE5Qi93RnhJUkFnRFNBUU9nQUFRUUloQXd3Q0N5QUJRWUN3QTBraEVTQUJRWUJBY1NFU0lCSkJnTUFEUmlFVElCRWdFM0loT3lBN0JFQWdBVUVNZGlFVUlCUkI0QUZ5SVJVZ0ZVSC9BWEVoRmlBQVFRRnFJUmNnQUNBV09nQUFJQUZCQm5ZaEdTQVpRVDl4SVJvZ0drR0FBWEloR3lBYlFmOEJjU0VjSUFCQkFtb2hIU0FYSUJ3NkFBQWdBVUUvY1NFZUlCNUJnQUZ5SVI4Z0gwSC9BWEVoSUNBZElDQTZBQUJCQXlFRERBSUxJQUZCZ0lCOGFpRWhJQ0ZCZ0lEQUFFa2hJaUFpQkVBZ0FVRVNkaUVrSUNSQjhBRnlJU1VnSlVIL0FYRWhKaUFBUVFGcUlTY2dBQ0FtT2dBQUlBRkJESFloS0NBb1FUOXhJU2tnS1VHQUFYSWhLaUFxUWY4QmNTRXJJQUJCQW1vaExDQW5JQ3M2QUFBZ0FVRUdkaUV0SUMxQlAzRWhMeUF2UVlBQmNpRXdJREJCL3dGeElURWdBRUVEYWlFeUlDd2dNVG9BQUNBQlFUOXhJVE1nTTBHQUFYSWhOQ0EwUWY4QmNTRTFJRElnTlRvQUFFRUVJUU1NQWdVUU1TRTJJRFpCMUFBMkFnQkJmeUVEREFJTEFBc0xJQU1QQ3c4QkEzOGpEU0VDRUVraEFDQUFEd3NNQVFKL0l3MGhBVUdVSVE4TER3RURmeU1OSVFJUVNTRUFJQUFQQzVNQ0FSWi9JdzBoRjBFQUlRUURRQUpBUWRnbklBUnFJUThnRHl3QUFDRVFJQkJCL3dGeElSRWdFU0FBUmlFU0lCSUVRRUVDSVJZTUFRc2dCRUVCYWlFVElCTkIxd0JHSVJRZ0ZBUkFRYkFvSVFOQjF3QWhCa0VGSVJZTUFRVWdFeUVFQ3d3QkN3c2dGa0VDUmdSQUlBUkJBRVloRGlBT0JFQkJzQ2doQWdWQnNDZ2hBeUFFSVFaQkJTRVdDd3NnRmtFRlJnUkFBMEFDUUVFQUlSWWdBeUVGQTBBQ1FDQUZMQUFBSVJVZ0ZVRVlkRUVZZFVFQVJpRUhJQVZCQVdvaENDQUhCRUFNQVFVZ0NDRUZDd3dCQ3dzZ0JrRi9haUVKSUFsQkFFWWhDaUFLQkVBZ0NDRUNEQUVGSUFnaEF5QUpJUVpCQlNFV0N3d0JDd3NMSUFGQkZHb2hDeUFMS0FJQUlRd2dBaUFNRUV3aERTQU5Ed3NUQVFOL0l3MGhCQ0FBSUFFUVRTRUNJQUlQQzFJQkNuOGpEU0VMSUFGQkFFWWhBeUFEQkVCQkFDRUNCU0FCS0FJQUlRUWdBVUVFYWlFRklBVW9BZ0FoQmlBRUlBWWdBQkJPSVFjZ0J5RUNDeUFDUVFCSElRZ2dDQVIvSUFJRklBQUxJUWtnQ1E4TGpBVUJTWDhqRFNGTElBQW9BZ0FoSFNBZFFhTGE3OWNHYWlFb0lBQkJDR29oTXlBektBSUFJVDRnUGlBb0VFOGhSQ0FBUVF4cUlVVWdSU2dDQUNGR0lFWWdLQkJQSVFrZ0FFRVFhaUVLSUFvb0FnQWhDeUFMSUNnUVR5RU1JQUZCQW5ZaERTQkVJQTFKSVE0Q1FDQU9CRUFnUkVFQ2RDRVBJQUVnRDJzaEVDQUpJQkJKSVJFZ0RDQVFTU0VTSUJFZ0VuRWhSeUJIQkVBZ0RDQUpjaUVUSUJOQkEzRWhGQ0FVUVFCR0lSVWdGUVJBSUFsQkFuWWhGaUFNUVFKMklSZEJBQ0VFSUVRaEJRTkFBa0FnQlVFQmRpRVlJQVFnR0dvaEdTQVpRUUYwSVJvZ0dpQVdhaUViSUFBZ0cwRUNkR29oSENBY0tBSUFJUjRnSGlBb0VFOGhIeUFiUVFGcUlTQWdBQ0FnUVFKMGFpRWhJQ0VvQWdBaElpQWlJQ2dRVHlFaklDTWdBVWtoSkNBQklDTnJJU1VnSHlBbFNTRW1JQ1FnSm5FaFNDQklSUVJBUVFBaENBd0dDeUFqSUI5cUlTY2dBQ0FuYWlFcElDa3NBQUFoS2lBcVFSaDBRUmgxUVFCR0lTc2dLMFVFUUVFQUlRZ01CZ3NnQUNBamFpRXNJQUlnTEJBMElTMGdMVUVBUmlFdUlDNEVRQXdCQ3lBRlFRRkdJVUVnTFVFQVNDRkNJQVVnR0dzaFF5QkNCSDhnR0FVZ1F3c2hCeUJDQkg4Z0JBVWdHUXNoQmlCQkJFQkJBQ0VJREFZRklBWWhCQ0FISVFVTERBRUxDeUFhSUJkcUlTOGdBQ0F2UVFKMGFpRXdJREFvQWdBaE1TQXhJQ2dRVHlFeUlDOUJBV29oTkNBQUlEUkJBblJxSVRVZ05TZ0NBQ0UySURZZ0tCQlBJVGNnTnlBQlNTRTRJQUVnTjJzaE9TQXlJRGxKSVRvZ09DQTZjU0ZKSUVrRVFDQUFJRGRxSVRzZ055QXlhaUU4SUFBZ1BHb2hQU0E5TEFBQUlUOGdQMEVZZEVFWWRVRUFSaUZBSUVBRWZ5QTdCVUVBQ3lFRElBTWhDQVZCQUNFSUN3VkJBQ0VJQ3dWQkFDRUlDd1ZCQUNFSUN3c2dDQThMSkFFRmZ5TU5JUVlnQVVFQVJpRURJQUFRWENFRUlBTUVmeUFBQlNBRUN5RUNJQUlQQzcwREFTcC9JdzBoTENBQ1FSQnFJUjhnSHlnQ0FDRWxJQ1ZCQUVZaEppQW1CRUFnQWhCUklTZ2dLRUVBUmlFcElDa0VRQ0FmS0FJQUlRa2dDU0VOUVFVaEt3VkJBQ0VGQ3dVZ0pTRW5JQ2NoRFVFRklTc0xBa0FnSzBFRlJnUkFJQUpCRkdvaEtpQXFLQUlBSVFzZ0RTQUxheUVNSUF3Z0FVa2hEaUFMSVE4Z0RnUkFJQUpCSkdvaEVDQVFLQUlBSVJFZ0FpQUFJQUVnRVVFSGNVRUlhaEVBQUNFU0lCSWhCUXdDQ3lBQ1Fjc0FhaUVUSUJNc0FBQWhGQ0FVUVJoMFFSaDFRWDlLSVJVQ1FDQVZCRUFnQVNFREEwQUNRQ0FEUVFCR0lSWWdGZ1JBUVFBaEJpQUFJUWNnQVNFSUlBOGhJUXdFQ3lBRFFYOXFJUmNnQUNBWGFpRVlJQmdzQUFBaEdTQVpRUmgwUVJoMVFRcEdJUm9nR2dSQURBRUZJQmNoQXdzTUFRc0xJQUpCSkdvaEd5QWJLQUlBSVJ3Z0FpQUFJQU1nSEVFSGNVRUlhaEVBQUNFZElCMGdBMGtoSGlBZUJFQWdIU0VGREFRTElBQWdBMm9oSUNBQklBTnJJUVFnS2lnQ0FDRUtJQU1oQmlBZ0lRY2dCQ0VJSUFvaElRVkJBQ0VHSUFBaEJ5QUJJUWdnRHlFaEN3c2dJU0FISUFnUVhSb2dLaWdDQUNFaUlDSWdDR29oSXlBcUlDTTJBZ0FnQmlBSWFpRWtJQ1FoQlFzTElBVVBDK0FCQVJoL0l3MGhHQ0FBUWNvQWFpRUNJQUlzQUFBaERTQU5RUmgwUVJoMUlSQWdFRUgvQVdvaEVTQVJJQkJ5SVJJZ0VrSC9BWEVoRXlBQ0lCTTZBQUFnQUNnQ0FDRVVJQlJCQ0hFaEZTQVZRUUJHSVJZZ0ZnUkFJQUJCQ0dvaEJDQUVRUUEyQWdBZ0FFRUVhaUVGSUFWQkFEWUNBQ0FBUVN4cUlRWWdCaWdDQUNFSElBQkJIR29oQ0NBSUlBYzJBZ0FnQUVFVWFpRUpJQWtnQnpZQ0FDQUhJUW9nQUVFd2FpRUxJQXNvQWdBaERDQUtJQXhxSVE0Z0FFRVFhaUVQSUE4Z0RqWUNBRUVBSVFFRklCUkJJSEloQXlBQUlBTTJBZ0JCZnlFQkN5QUJEd3MzQVFoL0l3MGhDU0FBUVFBZ0FSQkFJUUlnQWtFQVJpRURJQUloQkNBQUlRVWdCQ0FGYXlFR0lBTUVmeUFCQlNBR0N5RUhJQWNQQzg4Q0FTQi9JdzBoSUNBQUlRZ2dDRUVEY1NFVElCTkJBRVloR0FKQUlCZ0VRQ0FBSVFKQkJDRWZCU0FBSVFNZ0NDRVhBMEFDUUNBRExBQUFJUmtnR1VFWWRFRVlkVUVBUmlFYUlCb0VRQ0FYSVFjTUJBc2dBMEVCYWlFYklCc2hIQ0FjUVFOeElSMGdIVUVBUmlFZUlCNEVRQ0FiSVFKQkJDRWZEQUVGSUJzaEF5QWNJUmNMREFFTEN3c0xJQjlCQkVZRVFDQUNJUUVEUUFKQUlBRW9BZ0FoQ1NBSlFmLzkrM2RxSVFvZ0NVR0FnWUtFZUhFaEN5QUxRWUNCZ29SNGN5RU1JQXdnQ25FaERTQU5RUUJHSVE0Z0FVRUVhaUVQSUE0RVFDQVBJUUVGREFFTERBRUxDeUFKUWY4QmNTRVFJQkJCR0hSQkdIVkJBRVloRVNBUkJFQWdBU0VFQlNBQklRVURRQUpBSUFWQkFXb2hFaUFTTEFBQUlRWWdCa0VZZEVFWWRVRUFSaUVVSUJRRVFDQVNJUVFNQVFVZ0VpRUZDd3dCQ3dzTElBUWhGU0FWSVFjTElBY2dDR3NoRmlBV0R3dEJBUWQvSXcwaENDQUFJQUVRVlNFQ0lBSXNBQUFoQXlBQlFmOEJjU0VFSUFOQkdIUkJHSFVnQkVFWWRFRVlkVVloQlNBRkJIOGdBZ1ZCQUFzaEJpQUdEd3VNQkFFemZ5TU5JVFFnQVVIL0FYRWhFaUFTUVFCR0lSMENRQ0FkQkVBZ0FCQlRJUzhnQUNBdmFpRXdJREFoQWdVZ0FDRW9JQ2hCQTNFaExDQXNRUUJHSVMwZ0xRUkFJQUFoQlFVZ0FVSC9BWEVoTGlBQUlRWURRQUpBSUFZc0FBQWhDQ0FJUVJoMFFSaDFRUUJHSVFrZ0NFRVlkRUVZZFNBdVFSaDBRUmgxUmlFS0lBa2dDbkloTVNBeEJFQWdCaUVDREFVTElBWkJBV29oQ3lBTElRd2dERUVEY1NFTklBMUJBRVloRGlBT0JFQWdDeUVGREFFRklBc2hCZ3NNQVFzTEN5QVNRWUdDaEFoc0lROGdCU2dDQUNFUUlCQkIvLzM3ZDJvaEVTQVFRWUNCZ29SNGNTRVRJQk5CZ0lHQ2hIaHpJUlFnRkNBUmNTRVZJQlZCQUVZaEZnSkFJQllFUUNBRklRUWdFQ0VZQTBBQ1FDQVlJQTl6SVJjZ0YwSC8vZnQzYWlFWklCZEJnSUdDaEhoeElSb2dHa0dBZ1lLRWVITWhHeUFiSUJseElSd2dIRUVBUmlFZUlCNUZCRUFnQkNFRERBUUxJQVJCQkdvaEh5QWZLQUlBSVNBZ0lFSC8vZnQzYWlFaElDQkJnSUdDaEhoeElTSWdJa0dBZ1lLRWVITWhJeUFqSUNGeElTUWdKRUVBUmlFbElDVUVRQ0FmSVFRZ0lDRVlCU0FmSVFNTUFRc01BUXNMQlNBRklRTUxDeUFCUWY4QmNTRW1JQU1oQndOQUFrQWdCeXdBQUNFbklDZEJHSFJCR0hWQkFFWWhLU0FuUVJoMFFSaDFJQ1pCR0hSQkdIVkdJU29nS1NBcWNpRXlJQWRCQVdvaEt5QXlCRUFnQnlFQ0RBRUZJQ3NoQndzTUFRc0xDd3NnQWc4TEVRRUNmeU1OSVFGQjhEb1FCa0g0T2c4TERnRUNmeU1OSVFGQjhEb1FEQThMNXdJQkozOGpEU0VuSUFCQkFFWWhDQUpBSUFnRVFFR1FJU2dDQUNFaklDTkJBRVloSkNBa0JFQkJBQ0VkQlVHUUlTZ0NBQ0VKSUFrUVdDRUtJQW9oSFFzUVZpRUxJQXNvQWdBaEF5QURRUUJHSVF3Z0RBUkFJQjBoQlFVZ0F5RUVJQjBoQmdOQUFrQWdCRUhNQUdvaERTQU5LQUlBSVE0Z0RrRi9TaUVQSUE4RVFDQUVFRGNoRUNBUUlSb0ZRUUFoR2dzZ0JFRVVhaUVSSUJFb0FnQWhFaUFFUVJ4cUlSUWdGQ2dDQUNFVklCSWdGVXNoRmlBV0JFQWdCQkJaSVJjZ0Z5QUdjaUVZSUJnaEJ3VWdCaUVIQ3lBYVFRQkdJUmtnR1VVRVFDQUVFRGdMSUFSQk9Hb2hHeUFiS0FJQUlRSWdBa0VBUmlFY0lCd0VRQ0FISVFVTUFRVWdBaUVFSUFjaEJnc01BUXNMQ3hCWElBVWhBUVVnQUVITUFHb2hFeUFUS0FJQUlSNGdIa0YvU2lFZklCOUZCRUFnQUJCWklTQWdJQ0VCREFJTElBQVFOeUVoSUNGQkFFWWhKU0FBRUZraElpQWxCRUFnSWlFQkJTQUFFRGdnSWlFQkN3c0xJQUVQQzRFQ0FSZC9JdzBoRnlBQVFSUnFJUUlnQWlnQ0FDRU5JQUJCSEdvaER5QVBLQUlBSVJBZ0RTQVFTeUVSSUJFRVFDQUFRU1JxSVJJZ0VpZ0NBQ0VUSUFCQkFFRUFJQk5CQjNGQkNHb1JBQUFhSUFJb0FnQWhGQ0FVUVFCR0lSVWdGUVJBUVg4aEFRVkJBeUVXQ3dWQkF5RVdDeUFXUVFOR0JFQWdBRUVFYWlFRElBTW9BZ0FoQkNBQVFRaHFJUVVnQlNnQ0FDRUdJQVFnQmtraEJ5QUhCRUFnQkNFSUlBWWhDU0FJSUFscklRb2dBRUVvYWlFTElBc29BZ0FoRENBQUlBcEJBU0FNUVFkeFFRaHFFUUFBR2dzZ0FFRVFhaUVPSUE1QkFEWUNBQ0FQUVFBMkFnQWdBa0VBTmdJQUlBVkJBRFlDQUNBRFFRQTJBZ0JCQUNFQkN5QUJEd3MzQVFSL0l3MGhCaU1OUVJCcUpBMGpEU01PVGdSQVFSQVFBd3NnQmlFRElBTWdBallDQUNBQUlBRWdBeEExSVFRZ0JpUU5JQVFQQ3dNQUFRc3NBQ0FBUWY4QmNVRVlkQ0FBUVFoMVFmOEJjVUVRZEhJZ0FFRVFkVUgvQVhGQkNIUnlJQUJCR0haeUR3dmtCQUVFZnlBQ1FZREFBRTRFUUNBQUlBRWdBaEFPRHdzZ0FDRURJQUFnQW1vaEJpQUFRUU54SUFGQkEzRkdCRUFEUUFKQUlBQkJBM0ZGQkVBTUFRc0NRQ0FDUVFCR0JFQWdBdzhMSUFBZ0FTd0FBRG9BQUNBQVFRRnFJUUFnQVVFQmFpRUJJQUpCQVdzaEFnc01BUXNMSUFaQmZIRWhCQ0FFUWNBQWF5RUZBMEFDUUNBQUlBVk1SUVJBREFFTEFrQWdBQ0FCS0FJQU5nSUFJQUJCQkdvZ0FVRUVhaWdDQURZQ0FDQUFRUWhxSUFGQkNHb29BZ0EyQWdBZ0FFRU1haUFCUVF4cUtBSUFOZ0lBSUFCQkVHb2dBVUVRYWlnQ0FEWUNBQ0FBUVJScUlBRkJGR29vQWdBMkFnQWdBRUVZYWlBQlFSaHFLQUlBTmdJQUlBQkJIR29nQVVFY2FpZ0NBRFlDQUNBQVFTQnFJQUZCSUdvb0FnQTJBZ0FnQUVFa2FpQUJRU1JxS0FJQU5nSUFJQUJCS0dvZ0FVRW9haWdDQURZQ0FDQUFRU3hxSUFGQkxHb29BZ0EyQWdBZ0FFRXdhaUFCUVRCcUtBSUFOZ0lBSUFCQk5Hb2dBVUUwYWlnQ0FEWUNBQ0FBUVRocUlBRkJPR29vQWdBMkFnQWdBRUU4YWlBQlFUeHFLQUlBTmdJQUlBQkJ3QUJxSVFBZ0FVSEFBR29oQVFzTUFRc0xBMEFDUUNBQUlBUklSUVJBREFFTEFrQWdBQ0FCS0FJQU5nSUFJQUJCQkdvaEFDQUJRUVJxSVFFTERBRUxDd1VnQmtFRWF5RUVBMEFDUUNBQUlBUklSUVJBREFFTEFrQWdBQ0FCTEFBQU9nQUFJQUJCQVdvZ0FVRUJhaXdBQURvQUFDQUFRUUpxSUFGQkFtb3NBQUE2QUFBZ0FFRURhaUFCUVFOcUxBQUFPZ0FBSUFCQkJHb2hBQ0FCUVFScUlRRUxEQUVMQ3dzRFFBSkFJQUFnQmtoRkJFQU1BUXNDUUNBQUlBRXNBQUE2QUFBZ0FFRUJhaUVBSUFGQkFXb2hBUXNNQVFzTElBTVBDL0VDQVFSL0lBQWdBbW9oQXlBQlFmOEJjU0VCSUFKQnd3Qk9CRUFEUUFKQUlBQkJBM0ZCQUVkRkJFQU1BUXNDUUNBQUlBRTZBQUFnQUVFQmFpRUFDd3dCQ3dzZ0EwRjhjU0VFSUFSQndBQnJJUVVnQVNBQlFRaDBjaUFCUVJCMGNpQUJRUmgwY2lFR0EwQUNRQ0FBSUFWTVJRUkFEQUVMQWtBZ0FDQUdOZ0lBSUFCQkJHb2dCallDQUNBQVFRaHFJQVkyQWdBZ0FFRU1haUFHTmdJQUlBQkJFR29nQmpZQ0FDQUFRUlJxSUFZMkFnQWdBRUVZYWlBR05nSUFJQUJCSEdvZ0JqWUNBQ0FBUVNCcUlBWTJBZ0FnQUVFa2FpQUdOZ0lBSUFCQktHb2dCallDQUNBQVFTeHFJQVkyQWdBZ0FFRXdhaUFHTmdJQUlBQkJOR29nQmpZQ0FDQUFRVGhxSUFZMkFnQWdBRUU4YWlBR05nSUFJQUJCd0FCcUlRQUxEQUVMQ3dOQUFrQWdBQ0FFU0VVRVFBd0JDd0pBSUFBZ0JqWUNBQ0FBUVFScUlRQUxEQUVMQ3dzRFFBSkFJQUFnQTBoRkJFQU1BUXNDUUNBQUlBRTZBQUFnQUVFQmFpRUFDd3dCQ3dzZ0F5QUNhdzhMQlFCQkFBOExCUUJCQUE4TFpnRUVmeUFBUVE5cVFYQnhJUUFqQ2lnQ0FDRUJJQUVnQUdvaEF5QUFRUUJLSUFNZ0FVaHhJQU5CQUVoeUJFQVFBaHBCREJBSFFYOFBDeU1LSUFNMkFnQVFBU0VFSUFNZ0JFb0VRQkFBUVFCR0JFQWpDaUFCTmdJQVFRd1FCMEYvRHdzTElBRVBDeEFBSUFFZ0FFRUhjVUVBYWhFQkFBOExGQUFnQVNBQ0lBTWdBRUVIY1VFSWFoRUFBQThMQ1FCQkFCQUVRUUFQQ3drQVFRRVFCVUVBRHdzTHdpNEJBRUdBQ0F1NkxnQUFBQUJzQVFBQTJBSUFBR3NCQUFEWEFnQUFhZ0VBQU5ZQ0FBQnBBUUFBMVFJQUFHZ0JBQURVQWdBQVp3RUFBTk1DQUFCbUFRQUEwZ0lBQUdVQkFBRFJBZ0FBWkFFQUFOQUNBQUJqQVFBQXp3SUFBR0lCQUFET0FnQUFZUUVBQU0wQ0FBQmdBUUFBekFJQUFGOEJBQURMQWdBQVhnRUFBTW9DQUFCZEFRQUF5UUlBQUZ3QkFBRElBZ0FBV3dFQUFNY0NBQUJhQVFBQXhnSUFBRmtCQUFERkFnQUFXQUVBQU1RQ0FBQlhBUUFBd3dJQUFGWUJBQURDQWdBQVZRRUFBTUVDQUFCVUFRQUF3QUlBQUZNQkFBQy9BZ0FBVWdFQUFMNENBQUJSQVFBQXZRSUFBRkFCQUFDOEFnQUFUd0VBQUxzQ0FBQk9BUUFBdWdJQUFFMEJBQUM1QWdBQVRBRUFBTGdDQUFCTEFRQUF0d0lBQUVvQkFBQzJBZ0FBU1FFQUFMVUNBQUJJQVFBQXRBSUFBRWNCQUFDekFnQUFSZ0VBQUxJQ0FBQkZBUUFBc1FJQUFFUUJBQUN3QWdBQVF3RUFBSzhDQUFCQ0FRQUFyZ0lBQUVFQkFBQ3RBZ0FBUUFFQUFLd0NBQUEvQVFBQXF3SUFBRDRCQUFDcUFnQUFQUUVBQUtrQ0FBQThBUUFBcUFJQUFEc0JBQUNuQWdBQU9nRUFBS1lDQUFBNUFRQUFwUUlBQURnQkFBQ2tBZ0FBTndFQUFLTUNBQUEyQVFBQW9nSUFBRFVCQUFDaEFnQUFOQUVBQUtBQ0FBQXpBUUFBbndJQUFESUJBQUNlQWdBQU1RRUFBSjBDQUFBd0FRQUFuQUlBQUM4QkFBQ2JBZ0FBTGdFQUFKb0NBQUF0QVFBQW1RSUFBQ3dCQUFDWUFnQUFLd0VBQUpjQ0FBQXFBUUFBbGdJQUFDa0JBQUNWQWdBQUtBRUFBSlFDQUFBbkFRQUFrd0lBQUNZQkFBQ1NBZ0FBSlFFQUFKRUNBQUFrQVFBQWtBSUFBQ01CQUFDUEFnQUFJZ0VBQUk0Q0FBQWhBUUFBalFJQUFDQUJBQUNNQWdBQUh3RUFBSXNDQUFBZUFRQUFpZ0lBQUIwQkFBQ0pBZ0FBSEFFQUFJZ0NBQUFiQVFBQWh3SUFBQm9CQUFDR0FnQUFHUUVBQUlVQ0FBQVlBUUFBaEFJQUFCY0JBQUNEQWdBQUZnRUFBSUlDQUFBVkFRQUFnUUlBQUJRQkFBQ0FBZ0FBRXdFQUFIOENBQUFTQVFBQWZnSUFBQkVCQUFCOUFnQUFFQUVBQUh3Q0FBQVBBUUFBZXdJQUFBNEJBQUI2QWdBQURRRUFBSGtDQUFBTUFRQUFlQUlBQUFzQkFBQjNBZ0FBQ2dFQUFIWUNBQUFKQVFBQWRRSUFBQWdCQUFCMEFnQUFCd0VBQUhNQ0FBQUdBUUFBY2dJQUFBVUJBQUJ4QWdBQUJBRUFBSEFDQUFBREFRQUFid0lBQUFJQkFBQnVBZ0FBQVFFQUFHMENBQUFBQVFBQWJBSUFBUDhBQUFCckFnQUEvZ0FBQUdvQ0FBRDlBQUFBYVFJQUFQd0FBQUJvQWdBQSt3QUFBR2NDQUFENkFBQUFaZ0lBQVBrQUFBQmxBZ0FBK0FBQUFHUUNBQUQzQUFBQVl3SUFBUFlBQUFCaUFnQUE5UUFBQUdFQ0FBRDBBQUFBWUFJQUFQTUFBQUJmQWdBQThnQUFBRjRDQUFEeEFBQUFYUUlBQVBBQUFBQmNBZ0FBN3dBQUFGc0NBQUR1QUFBQVdnSUFBTzBBQUFCWkFnQUE3QUFBQUZnQ0FBRHJBQUFBVndJQUFPb0FBQUJXQWdBQTZRQUFBRlVDQUFEb0FBQUFWQUlBQU9jQUFBQlRBZ0FBNWdBQUFGSUNBQURsQUFBQVVRSUFBT1FBQUFCUUFnQUE0d0FBQUU4Q0FBRGlBQUFBVGdJQUFPRUFBQUJOQWdBQTRBQUFBRXdDQUFEZkFBQUFTd0lBQU40QUFBQktBZ0FBM1FBQUFFa0NBQURjQUFBQVNBSUFBTnNBQUFCSEFnQUEyZ0FBQUVZQ0FBRFpBQUFBUlFJQUFOZ0FBQUJFQWdBQTF3QUFBRU1DQUFEV0FBQUFRZ0lBQU5VQUFBQkJBZ0FBMUFBQUFFQUNBQURUQUFBQVB3SUFBTklBQUFBK0FnQUEwUUFBQUQwQ0FBRFFBQUFBUEFJQUFNOEFBQUE3QWdBQXpnQUFBRG9DQUFETkFBQUFPUUlBQU13QUFBQTRBZ0FBeXdBQUFEY0NBQURLQUFBQU5nSUFBTWtBQUFBMUFnQUF5QUFBQURRQ0FBREhBQUFBTXdJQUFNWUFBQUF5QWdBQXhRQUFBREVDQUFERUFBQUFNQUlBQU1NQUFBQXZBZ0FBd2dBQUFDNENBQURCQUFBQUxRSUFBTUFBQUFBc0FnQUF2d0FBQUNzQ0FBQytBQUFBS2dJQUFMMEFBQUFwQWdBQXZBQUFBQ2dDQUFDN0FBQUFKd0lBQUxvQUFBQW1BZ0FBdVFBQUFDVUNBQUM0QUFBQUpBSUFBTGNBQUFBakFnQUF0Z0FBQUNJQ0FBQzFBQUFBSVFJQUFMUUFBQUFnQWdBQXN3QUFBQjhDQUFDeUFBQUFIZ0lBQUxFQUFBQWRBZ0FBc0FBQUFCd0NBQUN2QUFBQUd3SUFBSzRBQUFBYUFnQUFyUUFBQUJrQ0FBQ3NBQUFBR0FJQUFLc0FBQUFYQWdBQXFnQUFBQllDQUFDcEFBQUFGUUlBQUtnQUFBQVVBZ0FBcHdBQUFCTUNBQUNtQUFBQUVnSUFBS1VBQUFBUkFnQUFwQUFBQUJBQ0FBQ2pBQUFBRHdJQUFLSUFBQUFPQWdBQW9RQUFBQTBDQUFDZ0FBQUFEQUlBQUo4QUFBQUxBZ0FBbmdBQUFBb0NBQUNkQUFBQUNRSUFBSndBQUFBSUFnQUFtd0FBQUFjQ0FBQ2FBQUFBQmdJQUFKa0FBQUFGQWdBQW1BQUFBQVFDQUFDWEFBQUFBd0lBQUpZQUFBQUNBZ0FBbFFBQUFBRUNBQUNVQUFBQUFBSUFBSk1BQUFEL0FRQUFrZ0FBQVA0QkFBQ1JBQUFBL1FFQUFKQUFBQUQ4QVFBQWp3QUFBUHNCQUFDT0FBQUErZ0VBQUkwQUFBRDVBUUFBakFBQUFQZ0JBQUNMQUFBQTl3RUFBSW9BQUFEMkFRQUFpUUFBQVBVQkFBQ0lBQUFBOUFFQUFJY0FBQUR6QVFBQWhnQUFBUElCQUFDRkFBQUE4UUVBQUlRQUFBRHdBUUFBZ3dBQUFPOEJBQUNDQUFBQTdnRUFBSUVBQUFEdEFRQUFnQUFBQU93QkFBQi9BQUFBNndFQUFINEFBQURxQVFBQWZRQUFBT2tCQUFCOEFBQUE2QUVBQUhzQUFBRG5BUUFBZWdBQUFPWUJBQUI1QUFBQTVRRUFBSGdBQUFEa0FRQUFkd0FBQU9NQkFBQjJBQUFBNGdFQUFIVUFBQURoQVFBQWRBQUFBT0FCQUFCekFBQUEzd0VBQUhJQUFBRGVBUUFBY1FBQUFOMEJBQUJ3QUFBQTNBRUFBRzhBQUFEYkFRQUFiZ0FBQU5vQkFBQnRBQUFBMlFFQUFHd0FBQURZQVFBQWF3QUFBTmNCQUFCcUFBQUExZ0VBQUdrQUFBRFZBUUFBYUFBQUFOUUJBQUJuQUFBQTB3RUFBR1lBQUFEU0FRQUFaUUFBQU5FQkFBQmtBQUFBMEFFQUFHTUFBQURQQVFBQVlnQUFBTTRCQUFCaEFBQUF6UUVBQUdBQUFBRE1BUUFBWHdBQUFNc0JBQUJlQUFBQXlnRUFBRjBBQUFESkFRQUFYQUFBQU1nQkFBQmJBQUFBeHdFQUFGb0FBQURHQVFBQVdRQUFBTVVCQUFCWUFBQUF4QUVBQUZjQUFBRERBUUFBVmdBQUFNSUJBQUJWQUFBQXdRRUFBRlFBQUFEQUFRQUFVd0FBQUw4QkFBQlNBQUFBdmdFQUFGRUFBQUM5QVFBQVVBQUFBTHdCQUFCUEFBQUF1d0VBQUU0QUFBQzZBUUFBVFFBQUFMa0JBQUJNQUFBQXVBRUFBRXNBQUFDM0FRQUFTZ0FBQUxZQkFBQkpBQUFBdFFFQUFFZ0FBQUMwQVFBQVJ3QUFBTE1CQUFCR0FBQUFzZ0VBQUVVQUFBQ3hBUUFBUkFBQUFMQUJBQUJEQUFBQXJ3RUFBRUlBQUFDdUFRQUFRUUFBQUswQkFBQkFBQUFBckFFQUFEOEFBQUNyQVFBQVBnQUFBS29CQUFBOUFBQUFxUUVBQUR3QUFBQ29BUUFBT3dBQUFLY0JBQUE2QUFBQXBnRUFBRGtBQUFDbEFRQUFPQUFBQUtRQkFBQTNBQUFBb3dFQUFEWUFBQUNpQVFBQU5RQUFBS0VCQUFBMEFBQUFvQUVBQURNQUFBQ2ZBUUFBTWdBQUFKNEJBQUF4QUFBQW5RRUFBREFBQUFDY0FRQUFMd0FBQUpzQkFBQXVBQUFBbWdFQUFDMEFBQUNaQVFBQUxBQUFBSmdCQUFBckFBQUFsd0VBQUNvQUFBQ1dBUUFBS1FBQUFKVUJBQUFvQUFBQWxBRUFBQ2NBQUFDVEFRQUFKZ0FBQUpJQkFBQWxBQUFBa1FFQUFDUUFBQUNRQVFBQUl3QUFBSThCQUFBaUFBQUFqZ0VBQUNFQUFBQ05BUUFBSUFBQUFJd0JBQUFmQUFBQWl3RUFBQjRBQUFDS0FRQUFIUUFBQUlrQkFBQWNBQUFBaUFFQUFCc0FBQUNIQVFBQUdnQUFBSVlCQUFBWkFBQUFoUUVBQUJnQUFBQ0VBUUFBRndBQUFJTUJBQUFXQUFBQWdnRUFBQlVBQUFDQkFRQUFGQUFBQUlBQkFBQVRBQUFBZndFQUFCSUFBQUIrQVFBQUVRQUFBSDBCQUFBUUFBQUFmQUVBQUE4QUFBQjdBUUFBRGdBQUFIb0JBQUFOQUFBQWVRRUFBQXdBQUFCNEFRQUFDd0FBQUhjQkFBQUtBQUFBZGdFQUFBa0FBQUIxQVFBQUNBQUFBSFFCQUFBSEFBQUFjd0VBQUFZQUFBQnlBUUFBQlFBQUFIRUJBQUFFQUFBQWNBRUFBQU1BQUFCdkFRQUFBZ0FBQUc0QkFBQUJBQUFBYlFFQUFBQUFBQUFCQUFBQUFBQUFBUC8vLy84Q0FBQUFBUUFBQVAvLy8vOEFBQUFBQWdBQUFQLy8vLzhCQUFBQUFBQUFBSmdQQUFBRkFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ0FBQUFBd0FBQUpRaUFBQUFBQUFBQUFBQUFBQUFBQUFDQUFBQUFBQUFBQUFBQUFBQUFBRC8vLy8vL3dBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQkFBQUFBTUFBQUNjSWdBQUFBUUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUN2Ly8vLzhBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUZRZEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVNXNTJZV3hwWkNCdGFXNVhaV2xuYUhSTllXZHVhWFIxWkdVZ0pXUUFPVUZDUTBSRlJrZElTVXBMVEUxT1QxQlJVbE5VVlZaWFdGbGFBQkVBQ2dBUkVSRUFBQUFBQlFBQUFBQUFBQWtBQUFBQUN3QUFBQUFBQUFBQUVRQVBDaEVSRVFNS0J3QUJFd2tMQ3dBQUNRWUxBQUFMQUFZUkFBQUFFUkVSQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXNBQUFBQUFBQUFBQkVBQ2dvUkVSRUFDZ0FBQWdBSkN3QUFBQWtBQ3dBQUN3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFBQUFBQUFBQU1BQUFBQUF3QUFBQUFDUXdBQUFBQUFBd0FBQXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0FBQUFBQUFBQUFBQUFBRFFBQUFBUU5BQUFBQUFrT0FBQUFBQUFPQUFBT0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQUFBQUFBQUFBQUFBOEFBQUFBRHdBQUFBQUpFQUFBQUFBQUVBQUFFQUFBRWdBQUFCSVNFZ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVNBQUFBRWhJU0FBQUFBQUFBQ1FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQ3dBQUFBQUFBQUFBQUFBQUNnQUFBQUFLQUFBQUFBa0xBQUFBQUFBTEFBQUxBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBd0FBQUFBQUFBQUFBQUFBQXdBQUFBQURBQUFBQUFKREFBQUFBQUFEQUFBREFBQUxTc2dJQ0F3V0RCNEFDaHVkV3hzS1FBdE1GZ3JNRmdnTUZndE1IZ3JNSGdnTUhnQWFXNW1BRWxPUmdCdVlXNEFUa0ZPQURBeE1qTTBOVFkzT0RsQlFrTkVSVVl1QUZRaEloa05BUUlERVVzY0RCQUVDeDBTSGlkb2JtOXdjV0lnQlFZUEV4UVZHZ2dXQnlna0Z4Z0pDZzRiSHlVamc0SjlKaW9yUEQwK1AwTkhTazFZV1ZwYlhGMWVYMkJoWTJSbFptZHBhbXRzY25OMGVYcDdmQUJKYkd4bFoyRnNJR0o1ZEdVZ2MyVnhkV1Z1WTJVQVJHOXRZV2x1SUdWeWNtOXlBRkpsYzNWc2RDQnViM1FnY21Wd2NtVnpaVzUwWVdKc1pRQk9iM1FnWVNCMGRIa0FVR1Z5YldsemMybHZiaUJrWlc1cFpXUUFUM0JsY21GMGFXOXVJRzV2ZENCd1pYSnRhWFIwWldRQVRtOGdjM1ZqYUNCbWFXeGxJRzl5SUdScGNtVmpkRzl5ZVFCT2J5QnpkV05vSUhCeWIyTmxjM01BUm1sc1pTQmxlR2x6ZEhNQVZtRnNkV1VnZEc5dklHeGhjbWRsSUdadmNpQmtZWFJoSUhSNWNHVUFUbThnYzNCaFkyVWdiR1ZtZENCdmJpQmtaWFpwWTJVQVQzVjBJRzltSUcxbGJXOXllUUJTWlhOdmRYSmpaU0JpZFhONUFFbHVkR1Z5Y25Wd2RHVmtJSE41YzNSbGJTQmpZV3hzQUZKbGMyOTFjbU5sSUhSbGJYQnZjbUZ5YVd4NUlIVnVZWFpoYVd4aFlteGxBRWx1ZG1Gc2FXUWdjMlZsYXdCRGNtOXpjeTFrWlhacFkyVWdiR2x1YXdCU1pXRmtMVzl1YkhrZ1ptbHNaU0J6ZVhOMFpXMEFSR2x5WldOMGIzSjVJRzV2ZENCbGJYQjBlUUJEYjI1dVpXTjBhVzl1SUhKbGMyVjBJR0o1SUhCbFpYSUFUM0JsY21GMGFXOXVJSFJwYldWa0lHOTFkQUJEYjI1dVpXTjBhVzl1SUhKbFpuVnpaV1FBU0c5emRDQnBjeUJrYjNkdUFFaHZjM1FnYVhNZ2RXNXlaV0ZqYUdGaWJHVUFRV1JrY21WemN5QnBiaUIxYzJVQVFuSnZhMlZ1SUhCcGNHVUFTUzlQSUdWeWNtOXlBRTV2SUhOMVkyZ2daR1YyYVdObElHOXlJR0ZrWkhKbGMzTUFRbXh2WTJzZ1pHVjJhV05sSUhKbGNYVnBjbVZrQUU1dklITjFZMmdnWkdWMmFXTmxBRTV2ZENCaElHUnBjbVZqZEc5eWVRQkpjeUJoSUdScGNtVmpkRzl5ZVFCVVpYaDBJR1pwYkdVZ1luVnplUUJGZUdWaklHWnZjbTFoZENCbGNuSnZjZ0JKYm5aaGJHbGtJR0Z5WjNWdFpXNTBBRUZ5WjNWdFpXNTBJR3hwYzNRZ2RHOXZJR3h2Ym1jQVUzbHRZbTlzYVdNZ2JHbHVheUJzYjI5d0FFWnBiR1Z1WVcxbElIUnZieUJzYjI1bkFGUnZieUJ0WVc1NUlHOXdaVzRnWm1sc1pYTWdhVzRnYzNsemRHVnRBRTV2SUdacGJHVWdaR1Z6WTNKcGNIUnZjbk1nWVhaaGFXeGhZbXhsQUVKaFpDQm1hV3hsSUdSbGMyTnlhWEIwYjNJQVRtOGdZMmhwYkdRZ2NISnZZMlZ6Y3dCQ1lXUWdZV1JrY21WemN3QkdhV3hsSUhSdmJ5QnNZWEpuWlFCVWIyOGdiV0Z1ZVNCc2FXNXJjd0JPYnlCc2IyTnJjeUJoZG1GcGJHRmliR1VBVW1WemIzVnlZMlVnWkdWaFpHeHZZMnNnZDI5MWJHUWdiMk5qZFhJQVUzUmhkR1VnYm05MElISmxZMjkyWlhKaFlteGxBRkJ5WlhacGIzVnpJRzkzYm1WeUlHUnBaV1FBVDNCbGNtRjBhVzl1SUdOaGJtTmxiR1ZrQUVaMWJtTjBhVzl1SUc1dmRDQnBiWEJzWlcxbGJuUmxaQUJPYnlCdFpYTnpZV2RsSUc5bUlHUmxjMmx5WldRZ2RIbHdaUUJKWkdWdWRHbG1hV1Z5SUhKbGJXOTJaV1FBUkdWMmFXTmxJRzV2ZENCaElITjBjbVZoYlFCT2J5QmtZWFJoSUdGMllXbHNZV0pzWlFCRVpYWnBZMlVnZEdsdFpXOTFkQUJQZFhRZ2IyWWdjM1J5WldGdGN5QnlaWE52ZFhKalpYTUFUR2x1YXlCb1lYTWdZbVZsYmlCelpYWmxjbVZrQUZCeWIzUnZZMjlzSUdWeWNtOXlBRUpoWkNCdFpYTnpZV2RsQUVacGJHVWdaR1Z6WTNKcGNIUnZjaUJwYmlCaVlXUWdjM1JoZEdVQVRtOTBJR0VnYzI5amEyVjBBRVJsYzNScGJtRjBhVzl1SUdGa1pISmxjM01nY21WeGRXbHlaV1FBVFdWemMyRm5aU0IwYjI4Z2JHRnlaMlVBVUhKdmRHOWpiMndnZDNKdmJtY2dkSGx3WlNCbWIzSWdjMjlqYTJWMEFGQnliM1J2WTI5c0lHNXZkQ0JoZG1GcGJHRmliR1VBVUhKdmRHOWpiMndnYm05MElITjFjSEJ2Y25SbFpBQlRiMk5yWlhRZ2RIbHdaU0J1YjNRZ2MzVndjRzl5ZEdWa0FFNXZkQ0J6ZFhCd2IzSjBaV1FBVUhKdmRHOWpiMndnWm1GdGFXeDVJRzV2ZENCemRYQndiM0owWldRQVFXUmtjbVZ6Y3lCbVlXMXBiSGtnYm05MElITjFjSEJ2Y25SbFpDQmllU0J3Y205MGIyTnZiQUJCWkdSeVpYTnpJRzV2ZENCaGRtRnBiR0ZpYkdVQVRtVjBkMjl5YXlCcGN5QmtiM2R1QUU1bGRIZHZjbXNnZFc1eVpXRmphR0ZpYkdVQVEyOXVibVZqZEdsdmJpQnlaWE5sZENCaWVTQnVaWFIzYjNKckFFTnZibTVsWTNScGIyNGdZV0p2Y25SbFpBQk9ieUJpZFdabVpYSWdjM0JoWTJVZ1lYWmhhV3hoWW14bEFGTnZZMnRsZENCcGN5QmpiMjV1WldOMFpXUUFVMjlqYTJWMElHNXZkQ0JqYjI1dVpXTjBaV1FBUTJGdWJtOTBJSE5sYm1RZ1lXWjBaWElnYzI5amEyVjBJSE5vZFhSa2IzZHVBRTl3WlhKaGRHbHZiaUJoYkhKbFlXUjVJR2x1SUhCeWIyZHlaWE56QUU5d1pYSmhkR2x2YmlCcGJpQndjbTluY21WemN3QlRkR0ZzWlNCbWFXeGxJR2hoYm1Sc1pRQlNaVzF2ZEdVZ1NTOVBJR1Z5Y205eUFGRjFiM1JoSUdWNFkyVmxaR1ZrQUU1dklHMWxaR2wxYlNCbWIzVnVaQUJYY205dVp5QnRaV1JwZFcwZ2RIbHdaUUJPYnlCbGNuSnZjaUJwYm1admNtMWhkR2x2Ymc9PSc7XFxuICAgIHZhciBhc21qc0NvZGVGaWxlID0gJyc7XFxuXFxuICAgIGlmICh0eXBlb2YgX01vZHVsZVsnbG9jYXRlRmlsZSddID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgaWYgKCFpc0RhdGFVUkkod2FzbVRleHRGaWxlKSkge1xcbiAgICAgICAgd2FzbVRleHRGaWxlID0gX01vZHVsZVsnbG9jYXRlRmlsZSddKHdhc21UZXh0RmlsZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSkge1xcbiAgICAgICAgd2FzbUJpbmFyeUZpbGUgPSBfTW9kdWxlWydsb2NhdGVGaWxlJ10od2FzbUJpbmFyeUZpbGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzRGF0YVVSSShhc21qc0NvZGVGaWxlKSkge1xcbiAgICAgICAgYXNtanNDb2RlRmlsZSA9IF9Nb2R1bGVbJ2xvY2F0ZUZpbGUnXShhc21qc0NvZGVGaWxlKTtcXG4gICAgICB9XFxuICAgIH0gLy8gdXRpbGl0aWVzXFxuXFxuXFxuICAgIHZhciB3YXNtUGFnZVNpemUgPSA2NCAqIDEwMjQ7XFxuICAgIHZhciBpbmZvID0ge1xcbiAgICAgICdnbG9iYWwnOiBudWxsLFxcbiAgICAgICdlbnYnOiBudWxsLFxcbiAgICAgICdhc20yd2FzbSc6IHtcXG4gICAgICAgIC8vIHNwZWNpYWwgYXNtMndhc20gaW1wb3J0c1xcbiAgICAgICAgXFxcImY2NC1yZW1cXFwiOiBmdW5jdGlvbiBmNjRSZW0oeCwgeSkge1xcbiAgICAgICAgICByZXR1cm4geCAlIHk7XFxuICAgICAgICB9LFxcbiAgICAgICAgXFxcImRlYnVnZ2VyXFxcIjogZnVuY3Rpb24gX2RlYnVnZ2VyKCkge1xcbiAgICAgICAgICBkZWJ1Z2dlcjtcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgICdwYXJlbnQnOiBfTW9kdWxlIC8vIE1vZHVsZSBpbnNpZGUgd2FzbS1qcy5jcHAgcmVmZXJzIHRvIHdhc20tanMuY3BwOyB0aGlzIGFsbG93cyBhY2Nlc3MgdG8gdGhlIG91dHNpZGUgcHJvZ3JhbS5cXG5cXG4gICAgfTtcXG4gICAgdmFyIGV4cG9ydHMgPSBudWxsO1xcblxcbiAgICBmdW5jdGlvbiBtZXJnZU1lbW9yeShuZXdCdWZmZXIpIHtcXG4gICAgICAvLyBUaGUgd2FzbSBpbnN0YW5jZSBjcmVhdGVzIGl0cyBtZW1vcnkuIEJ1dCBzdGF0aWMgaW5pdCBjb2RlIG1pZ2h0IGhhdmUgd3JpdHRlbiB0b1xcbiAgICAgIC8vIGJ1ZmZlciBhbHJlYWR5LCBpbmNsdWRpbmcgdGhlIG1lbSBpbml0IGZpbGUsIGFuZCB3ZSBtdXN0IGNvcHkgaXQgb3ZlciBpbiBhIHByb3BlciBtZXJnZS5cXG4gICAgICAvLyBUT0RPOiBhdm9pZCB0aGlzIGNvcHksIGJ5IGF2b2lkaW5nIHN1Y2ggc3RhdGljIGluaXQgd3JpdGVzXFxuICAgICAgLy8gVE9ETzogaW4gc2hvcnRlciB0ZXJtLCBqdXN0IGNvcHkgdXAgdG8gdGhlIGxhc3Qgc3RhdGljIGluaXQgd3JpdGVcXG4gICAgICB2YXIgb2xkQnVmZmVyID0gX01vZHVsZVsnYnVmZmVyJ107XFxuXFxuICAgICAgaWYgKG5ld0J1ZmZlci5ieXRlTGVuZ3RoIDwgb2xkQnVmZmVyLmJ5dGVMZW5ndGgpIHtcXG4gICAgICAgIF9Nb2R1bGVbJ3ByaW50RXJyJ10oJ3RoZSBuZXcgYnVmZmVyIGluIG1lcmdlTWVtb3J5IGlzIHNtYWxsZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lLiBpbiBuYXRpdmUgd2FzbSwgd2Ugc2hvdWxkIGdyb3cgbWVtb3J5IGhlcmUnKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG9sZFZpZXcgPSBuZXcgSW50OEFycmF5KG9sZEJ1ZmZlcik7XFxuICAgICAgdmFyIG5ld1ZpZXcgPSBuZXcgSW50OEFycmF5KG5ld0J1ZmZlcik7XFxuICAgICAgbmV3Vmlldy5zZXQob2xkVmlldyk7XFxuICAgICAgdXBkYXRlR2xvYmFsQnVmZmVyKG5ld0J1ZmZlcik7XFxuICAgICAgdXBkYXRlR2xvYmFsQnVmZmVyVmlld3MoKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBmaXhJbXBvcnRzKGltcG9ydHMpIHtcXG4gICAgICByZXR1cm4gaW1wb3J0cztcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBnZXRCaW5hcnkoKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGlmIChfTW9kdWxlWyd3YXNtQmluYXJ5J10pIHtcXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KF9Nb2R1bGVbJ3dhc21CaW5hcnknXSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgYmluYXJ5ID0gdHJ5UGFyc2VBc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpO1xcblxcbiAgICAgICAgaWYgKGJpbmFyeSkge1xcbiAgICAgICAgICByZXR1cm4gYmluYXJ5O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKF9Nb2R1bGVbJ3JlYWRCaW5hcnknXSkge1xcbiAgICAgICAgICByZXR1cm4gX01vZHVsZVsncmVhZEJpbmFyeSddKHdhc21CaW5hcnlGaWxlKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRocm93IFxcXCJvbiB0aGUgd2ViLCB3ZSBuZWVkIHRoZSB3YXNtIGJpbmFyeSB0byBiZSBwcmVsb2FkZWQgYW5kIHNldCBvbiBNb2R1bGVbJ3dhc21CaW5hcnknXS4gZW1jYy5weSB3aWxsIGRvIHRoYXQgZm9yIHlvdSB3aGVuIGdlbmVyYXRpbmcgSFRNTCAoYnV0IG5vdCBKUylcXFwiO1xcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgICAgYWJvcnQoZXJyKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZSgpIHtcXG4gICAgICAvLyBpZiB3ZSBkb24ndCBoYXZlIHRoZSBiaW5hcnkgeWV0LCBhbmQgaGF2ZSB0aGUgRmV0Y2ggYXBpLCB1c2UgdGhhdFxcbiAgICAgIC8vIGluIHNvbWUgZW52aXJvbm1lbnRzLCBsaWtlIEVsZWN0cm9uJ3MgcmVuZGVyIHByb2Nlc3MsIEZldGNoIGFwaSBtYXkgYmUgcHJlc2VudCwgYnV0IGhhdmUgYSBkaWZmZXJlbnQgY29udGV4dCB0aGFuIGV4cGVjdGVkLCBsZXQncyBvbmx5IHVzZSBpdCBvbiB0aGUgV2ViXFxuICAgICAgaWYgKCFfTW9kdWxlWyd3YXNtQmluYXJ5J10gJiYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpICYmIHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7XFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXFxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlWydvayddKSB7XFxuICAgICAgICAgICAgdGhyb3cgXFxcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1xcXCIgKyB3YXNtQmluYXJ5RmlsZSArIFxcXCInXFxcIjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VbJ2FycmF5QnVmZmVyJ10oKTtcXG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIGdldEJpbmFyeSgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSAvLyBPdGhlcndpc2UsIGdldEJpbmFyeSBzaG91bGQgYmUgYWJsZSB0byBnZXQgaXQgc3luY2hyb25vdXNseVxcblxcblxcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgICByZXNvbHZlKGdldEJpbmFyeSgpKTtcXG4gICAgICB9KTtcXG4gICAgfSAvLyBkby1tZXRob2QgZnVuY3Rpb25zXFxuXFxuXFxuICAgIGZ1bmN0aW9uIGRvTmF0aXZlV2FzbShnbG9iYWwsIGVudiwgcHJvdmlkZWRCdWZmZXIpIHtcXG4gICAgICBpZiAoKHR5cGVvZiBXZWJBc3NlbWJseSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoV2ViQXNzZW1ibHkpKSAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIF9Nb2R1bGVbJ3ByaW50RXJyJ10oJ25vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQnKTtcXG5cXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9IC8vIHByZXBhcmUgbWVtb3J5IGltcG9ydFxcblxcblxcbiAgICAgIGlmICghKF9Nb2R1bGVbJ3dhc21NZW1vcnknXSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSkpIHtcXG4gICAgICAgIF9Nb2R1bGVbJ3ByaW50RXJyJ10oJ25vIG5hdGl2ZSB3YXNtIE1lbW9yeSBpbiB1c2UnKTtcXG5cXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgZW52WydtZW1vcnknXSA9IF9Nb2R1bGVbJ3dhc21NZW1vcnknXTsgLy8gTG9hZCB0aGUgd2FzbSBtb2R1bGUgYW5kIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiB1c2luZyBuYXRpdmUgc3VwcG9ydCBpbiB0aGUgSlMgZW5naW5lLlxcblxcbiAgICAgIGluZm9bJ2dsb2JhbCddID0ge1xcbiAgICAgICAgJ05hTic6IE5hTixcXG4gICAgICAgICdJbmZpbml0eSc6IEluZmluaXR5XFxuICAgICAgfTtcXG4gICAgICBpbmZvWydnbG9iYWwuTWF0aCddID0gTWF0aDtcXG4gICAgICBpbmZvWydlbnYnXSA9IGVudjsgLy8gaGFuZGxlIGEgZ2VuZXJhdGVkIHdhc20gaW5zdGFuY2UsIHJlY2VpdmluZyBpdHMgZXhwb3J0cyBhbmRcXG4gICAgICAvLyBwZXJmb3JtaW5nIG90aGVyIG5lY2Vzc2FyeSBzZXR1cFxcblxcbiAgICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XFxuICAgICAgICBleHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcXG4gICAgICAgIGlmIChleHBvcnRzLm1lbW9yeSkgbWVyZ2VNZW1vcnkoZXhwb3J0cy5tZW1vcnkpO1xcbiAgICAgICAgX01vZHVsZVsnYXNtJ10gPSBleHBvcnRzO1xcbiAgICAgICAgX01vZHVsZVtcXFwidXNpbmdXYXNtXFxcIl0gPSB0cnVlO1xcbiAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgnd2FzbS1pbnN0YW50aWF0ZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBhZGRSdW5EZXBlbmRlbmN5KCd3YXNtLWluc3RhbnRpYXRlJyk7IC8vIFVzZXIgc2hlbGwgcGFnZXMgY2FuIHdyaXRlIHRoZWlyIG93biBNb2R1bGUuaW5zdGFudGlhdGVXYXNtID0gZnVuY3Rpb24oaW1wb3J0cywgc3VjY2Vzc0NhbGxiYWNrKSBjYWxsYmFja1xcbiAgICAgIC8vIHRvIG1hbnVhbGx5IGluc3RhbnRpYXRlIHRoZSBXYXNtIG1vZHVsZSB0aGVtc2VsdmVzLiBUaGlzIGFsbG93cyBwYWdlcyB0byBydW4gdGhlIGluc3RhbnRpYXRpb24gcGFyYWxsZWxcXG4gICAgICAvLyB0byBhbnkgb3RoZXIgYXN5bmMgc3RhcnR1cCBhY3Rpb25zIHRoZXkgYXJlIHBlcmZvcm1pbmcuXFxuXFxuICAgICAgaWYgKF9Nb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICByZXR1cm4gX01vZHVsZVsnaW5zdGFudGlhdGVXYXNtJ10oaW5mbywgcmVjZWl2ZUluc3RhbmNlKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgX01vZHVsZVsncHJpbnRFcnInXSgnTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGUpO1xcblxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgfSAvLyBBc3luYyBjb21waWxhdGlvbiBjYW4gYmUgY29uZnVzaW5nIHdoZW4gYW4gZXJyb3Igb24gdGhlIHBhZ2Ugb3ZlcndyaXRlcyBNb2R1bGVcXG4gICAgICAvLyAoZm9yIGV4YW1wbGUsIGlmIHRoZSBvcmRlciBvZiBlbGVtZW50cyBpcyB3cm9uZywgYW5kIHRoZSBvbmUgZGVmaW5pbmcgTW9kdWxlIGlzXFxuICAgICAgLy8gbGF0ZXIpLCBzbyB3ZSBzYXZlIE1vZHVsZSBhbmQgY2hlY2sgaXQgbGF0ZXIuXFxuXFxuXFxuICAgICAgdmFyIHRydWVNb2R1bGUgPSBfTW9kdWxlO1xcblxcbiAgICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2Uob3V0cHV0KSB7XFxuICAgICAgICAvLyAnb3V0cHV0JyBpcyBhIFdlYkFzc2VtYmx5SW5zdGFudGlhdGVkU291cmNlIG9iamVjdCB3aGljaCBoYXMgYm90aCB0aGUgbW9kdWxlIGFuZCBpbnN0YW5jZS5cXG4gICAgICAgIC8vIHJlY2VpdmVJbnN0YW5jZSgpIHdpbGwgc3dhcCBpbiB0aGUgZXhwb3J0cyAodG8gTW9kdWxlLmFzbSkgc28gdGhleSBjYW4gYmUgY2FsbGVkXFxuICAgICAgICBhc3NlcnQoX01vZHVsZSA9PT0gdHJ1ZU1vZHVsZSwgJ3RoZSBNb2R1bGUgb2JqZWN0IHNob3VsZCBub3QgYmUgcmVwbGFjZWQgZHVyaW5nIGFzeW5jIGNvbXBpbGF0aW9uIC0gcGVyaGFwcyB0aGUgb3JkZXIgb2YgSFRNTCBlbGVtZW50cyBpcyB3cm9uZz8nKTtcXG4gICAgICAgIHRydWVNb2R1bGUgPSBudWxsO1xcbiAgICAgICAgcmVjZWl2ZUluc3RhbmNlKG91dHB1dFsnaW5zdGFuY2UnXSwgb3V0cHV0Wydtb2R1bGUnXSk7XFxuICAgICAgfVxcblxcbiAgICAgIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZXIpIHtcXG4gICAgICAgIGdldEJpbmFyeVByb21pc2UoKS50aGVuKGZ1bmN0aW9uIChiaW5hcnkpIHtcXG4gICAgICAgICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSwgaW5mbyk7XFxuICAgICAgICB9KS50aGVuKHJlY2VpdmVyKS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XFxuICAgICAgICAgIF9Nb2R1bGVbJ3ByaW50RXJyJ10oJ2ZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICcgKyByZWFzb24pO1xcblxcbiAgICAgICAgICBhYm9ydChyZWFzb24pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSAvLyBQcmVmZXIgc3RyZWFtaW5nIGluc3RhbnRpYXRpb24gaWYgYXZhaWxhYmxlLlxcblxcblxcbiAgICAgIGlmICghX01vZHVsZVsnd2FzbUJpbmFyeSddICYmIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSAmJiB0eXBlb2YgZmV0Y2ggPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGZldGNoKHdhc21CaW5hcnlGaWxlLCB7XFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXFxuICAgICAgICB9KSwgaW5mbykudGhlbihyZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XFxuICAgICAgICAgIC8vIFdlIGV4cGVjdCB0aGUgbW9zdCBjb21tb24gZmFpbHVyZSBjYXVzZSB0byBiZSBhIGJhZCBNSU1FIHR5cGUgZm9yIHRoZSBiaW5hcnksXFxuICAgICAgICAgIC8vIGluIHdoaWNoIGNhc2UgZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24gc2hvdWxkIHdvcmsuXFxuICAgICAgICAgIF9Nb2R1bGVbJ3ByaW50RXJyJ10oJ3dhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAnICsgcmVhc29uKTtcXG5cXG4gICAgICAgICAgX01vZHVsZVsncHJpbnRFcnInXSgnZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24nKTtcXG5cXG4gICAgICAgICAgaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVJbnN0YW50aWF0ZWRTb3VyY2UpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4ge307IC8vIG5vIGV4cG9ydHMgeWV0OyB3ZSdsbCBmaWxsIHRoZW0gaW4gbGF0ZXJcXG4gICAgfSAvLyBXZSBtYXkgaGF2ZSBhIHByZWxvYWRlZCB2YWx1ZSBpbiBNb2R1bGUuYXNtLCBzYXZlIGl0XFxuXFxuXFxuICAgIF9Nb2R1bGVbJ2FzbVByZWxvYWQnXSA9IF9Nb2R1bGVbJ2FzbSddOyAvLyBNZW1vcnkgZ3Jvd3RoIGludGVncmF0aW9uIGNvZGVcXG5cXG4gICAgdmFyIGFzbWpzUmVhbGxvY0J1ZmZlciA9IF9Nb2R1bGVbJ3JlYWxsb2NCdWZmZXInXTtcXG5cXG4gICAgdmFyIHdhc21SZWFsbG9jQnVmZmVyID0gZnVuY3Rpb24gd2FzbVJlYWxsb2NCdWZmZXIoc2l6ZSkge1xcbiAgICAgIHZhciBQQUdFX01VTFRJUExFID0gX01vZHVsZVtcXFwidXNpbmdXYXNtXFxcIl0gPyBXQVNNX1BBR0VfU0laRSA6IEFTTUpTX1BBR0VfU0laRTsgLy8gSW4gd2FzbSwgaGVhcCBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NEtCLiBJbiBhc20uanMsIHRoZXkgbmVlZCB0byBiZSBtdWx0aXBsZXMgb2YgMTZNQi5cXG5cXG4gICAgICBzaXplID0gYWxpZ25VcChzaXplLCBQQUdFX01VTFRJUExFKTsgLy8gcm91bmQgdXAgdG8gd2FzbSBwYWdlIHNpemVcXG5cXG4gICAgICB2YXIgb2xkID0gX01vZHVsZVsnYnVmZmVyJ107XFxuICAgICAgdmFyIG9sZFNpemUgPSBvbGQuYnl0ZUxlbmd0aDtcXG5cXG4gICAgICBpZiAoX01vZHVsZVtcXFwidXNpbmdXYXNtXFxcIl0pIHtcXG4gICAgICAgIC8vIG5hdGl2ZSB3YXNtIHN1cHBvcnRcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgIHZhciByZXN1bHQgPSBfTW9kdWxlWyd3YXNtTWVtb3J5J10uZ3Jvdygoc2l6ZSAtIG9sZFNpemUpIC8gd2FzbVBhZ2VTaXplKTsgLy8gLmdyb3coKSB0YWtlcyBhIGRlbHRhIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyBzaXplXFxuXFxuXFxuICAgICAgICAgIGlmIChyZXN1bHQgIT09ICgtMSB8IDApKSB7XFxuICAgICAgICAgICAgLy8gc3VjY2VzcyBpbiBuYXRpdmUgd2FzbSBtZW1vcnkgZ3Jvd3RoLCBnZXQgdGhlIGJ1ZmZlciBmcm9tIHRoZSBtZW1vcnlcXG4gICAgICAgICAgICByZXR1cm4gX01vZHVsZVsnYnVmZmVyJ10gPSBfTW9kdWxlWyd3YXNtTWVtb3J5J10uYnVmZmVyO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01vZHVsZS5yZWFsbG9jQnVmZmVyOiBBdHRlbXB0ZWQgdG8gZ3JvdyBmcm9tICcgKyBvbGRTaXplICsgJyBieXRlcyB0byAnICsgc2l6ZSArICcgYnl0ZXMsIGJ1dCBnb3QgZXJyb3I6ICcgKyBlKTtcXG4gICAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBfTW9kdWxlWydyZWFsbG9jQnVmZmVyJ10gPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgICAgIGlmIChmaW5hbE1ldGhvZCA9PT0gJ2FzbWpzJykge1xcbiAgICAgICAgcmV0dXJuIGFzbWpzUmVhbGxvY0J1ZmZlcihzaXplKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHdhc21SZWFsbG9jQnVmZmVyKHNpemUpO1xcbiAgICAgIH1cXG4gICAgfTsgLy8gd2UgbWF5IHRyeSBtb3JlIHRoYW4gb25lOyB0aGlzIGlzIHRoZSBmaW5hbCBvbmUsIHRoYXQgd29ya2VkIGFuZCB3ZSBhcmUgdXNpbmdcXG5cXG5cXG4gICAgdmFyIGZpbmFsTWV0aG9kID0gJyc7IC8vIFByb3ZpZGUgYW4gXFxcImFzbS5qcyBmdW5jdGlvblxcXCIgZm9yIHRoZSBhcHBsaWNhdGlvbiwgY2FsbGVkIHRvIFxcXCJsaW5rXFxcIiB0aGUgYXNtLmpzIG1vZHVsZS4gV2UgaW5zdGFudGlhdGVcXG4gICAgLy8gdGhlIHdhc20gbW9kdWxlIGF0IHRoYXQgdGltZSwgYW5kIGl0IHJlY2VpdmVzIGltcG9ydHMgYW5kIHByb3ZpZGVzIGV4cG9ydHMgYW5kIHNvIGZvcnRoLCB0aGUgYXBwXFxuICAgIC8vIGRvZXNuJ3QgbmVlZCB0byBjYXJlIHRoYXQgaXQgaXMgd2FzbSBvciBvbHlmaWxsZWQgd2FzbSBvciBhc20uanMuXFxuXFxuICAgIF9Nb2R1bGVbJ2FzbSddID0gZnVuY3Rpb24gKGdsb2JhbCwgZW52LCBwcm92aWRlZEJ1ZmZlcikge1xcbiAgICAgIGVudiA9IGZpeEltcG9ydHMoZW52KTsgLy8gaW1wb3J0IHRhYmxlXFxuXFxuICAgICAgaWYgKCFlbnZbJ3RhYmxlJ10pIHtcXG4gICAgICAgIHZhciBUQUJMRV9TSVpFID0gX01vZHVsZVsnd2FzbVRhYmxlU2l6ZSddO1xcbiAgICAgICAgaWYgKFRBQkxFX1NJWkUgPT09IHVuZGVmaW5lZCkgVEFCTEVfU0laRSA9IDEwMjQ7IC8vIHdvcmtzIGluIGJpbmFyeWVuIGludGVycHJldGVyIGF0IGxlYXN0XFxuXFxuICAgICAgICB2YXIgTUFYX1RBQkxFX1NJWkUgPSBfTW9kdWxlWyd3YXNtTWF4VGFibGVTaXplJ107XFxuXFxuICAgICAgICBpZiAoKHR5cGVvZiBXZWJBc3NlbWJseSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoV2ViQXNzZW1ibHkpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIFdlYkFzc2VtYmx5LlRhYmxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIGlmIChNQVhfVEFCTEVfU0laRSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgZW52Wyd0YWJsZSddID0gbmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtcXG4gICAgICAgICAgICAgICdpbml0aWFsJzogVEFCTEVfU0laRSxcXG4gICAgICAgICAgICAgICdtYXhpbXVtJzogTUFYX1RBQkxFX1NJWkUsXFxuICAgICAgICAgICAgICAnZWxlbWVudCc6ICdhbnlmdW5jJ1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGVudlsndGFibGUnXSA9IG5ldyBXZWJBc3NlbWJseS5UYWJsZSh7XFxuICAgICAgICAgICAgICAnaW5pdGlhbCc6IFRBQkxFX1NJWkUsXFxuICAgICAgICAgICAgICBlbGVtZW50OiAnYW55ZnVuYydcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgZW52Wyd0YWJsZSddID0gbmV3IEFycmF5KFRBQkxFX1NJWkUpOyAvLyB3b3JrcyBpbiBiaW5hcnllbiBpbnRlcnByZXRlciBhdCBsZWFzdFxcbiAgICAgICAgfVxcblxcbiAgICAgICAgX01vZHVsZVsnd2FzbVRhYmxlJ10gPSBlbnZbJ3RhYmxlJ107XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghZW52WydtZW1vcnlCYXNlJ10pIHtcXG4gICAgICAgIGVudlsnbWVtb3J5QmFzZSddID0gX01vZHVsZVsnU1RBVElDX0JBU0UnXTsgLy8gdGVsbCB0aGUgbWVtb3J5IHNlZ21lbnRzIHdoZXJlIHRvIHBsYWNlIHRoZW1zZWx2ZXNcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFlbnZbJ3RhYmxlQmFzZSddKSB7XFxuICAgICAgICBlbnZbJ3RhYmxlQmFzZSddID0gMDsgLy8gdGFibGUgc3RhcnRzIGF0IDAgYnkgZGVmYXVsdCwgaW4gZHluYW1pYyBsaW5raW5nIHRoaXMgd2lsbCBjaGFuZ2VcXG4gICAgICB9IC8vIHRyeSB0aGUgbWV0aG9kcy4gZWFjaCBzaG91bGQgcmV0dXJuIHRoZSBleHBvcnRzIGlmIGl0IHN1Y2NlZWRlZFxcblxcblxcbiAgICAgIHZhciBleHBvcnRzO1xcbiAgICAgIGV4cG9ydHMgPSBkb05hdGl2ZVdhc20oZ2xvYmFsLCBlbnYsIHByb3ZpZGVkQnVmZmVyKTtcXG4gICAgICBpZiAoIWV4cG9ydHMpIGFib3J0KCdubyBiaW5hcnllbiBtZXRob2Qgc3VjY2VlZGVkLiBjb25zaWRlciBlbmFibGluZyBtb3JlIG9wdGlvbnMsIGxpa2UgaW50ZXJwcmV0aW5nLCBpZiB5b3Ugd2FudCB0aGF0OiBodHRwczovL2dpdGh1Yi5jb20va3JpcGtlbi9lbXNjcmlwdGVuL3dpa2kvV2ViQXNzZW1ibHkjYmluYXJ5ZW4tbWV0aG9kcycpO1xcbiAgICAgIHJldHVybiBleHBvcnRzO1xcbiAgICB9O1xcblxcbiAgICB2YXIgbWV0aG9kSGFuZGxlciA9IF9Nb2R1bGVbJ2FzbSddOyAvLyBub3RlIG91ciBtZXRob2QgaGFuZGxlciwgYXMgd2UgbWF5IG1vZGlmeSBNb2R1bGVbJ2FzbSddIGxhdGVyXFxuICB9XFxuXFxuICBpbnRlZ3JhdGVXYXNtSlMoKTsgLy8gPT09IEJvZHkgPT09XFxuXFxuICB2YXIgQVNNX0NPTlNUUyA9IFtdO1xcbiAgU1RBVElDX0JBU0UgPSBHTE9CQUxfQkFTRTtcXG4gIFNUQVRJQ1RPUCA9IFNUQVRJQ19CQVNFICsgOTg4ODtcXG4gIC8qIGdsb2JhbCBpbml0aWFsaXplcnMgKi9cXG5cXG4gIF9fQVRJTklUX18ucHVzaCgpO1xcblxcbiAgdmFyIFNUQVRJQ19CVU1QID0gOTg4ODtcXG4gIF9Nb2R1bGVbXFxcIlNUQVRJQ19CQVNFXFxcIl0gPSBTVEFUSUNfQkFTRTtcXG4gIF9Nb2R1bGVbXFxcIlNUQVRJQ19CVU1QXFxcIl0gPSBTVEFUSUNfQlVNUDtcXG4gIC8qIG5vIG1lbW9yeSBpbml0aWFsaXplciAqL1xcblxcbiAgdmFyIHRlbXBEb3VibGVQdHIgPSBTVEFUSUNUT1A7XFxuICBTVEFUSUNUT1AgKz0gMTY7XFxuICBhc3NlcnQodGVtcERvdWJsZVB0ciAlIDggPT0gMCk7XFxuXFxuICBmdW5jdGlvbiBjb3B5VGVtcEZsb2F0KHB0cikge1xcbiAgICAvLyBmdW5jdGlvbnMsIGJlY2F1c2UgaW5saW5pbmcgdGhpcyBjb2RlIGluY3JlYXNlcyBjb2RlIHNpemUgdG9vIG11Y2hcXG4gICAgSEVBUDhbdGVtcERvdWJsZVB0cl0gPSBIRUFQOFtwdHJdO1xcbiAgICBIRUFQOFt0ZW1wRG91YmxlUHRyICsgMV0gPSBIRUFQOFtwdHIgKyAxXTtcXG4gICAgSEVBUDhbdGVtcERvdWJsZVB0ciArIDJdID0gSEVBUDhbcHRyICsgMl07XFxuICAgIEhFQVA4W3RlbXBEb3VibGVQdHIgKyAzXSA9IEhFQVA4W3B0ciArIDNdO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gY29weVRlbXBEb3VibGUocHRyKSB7XFxuICAgIEhFQVA4W3RlbXBEb3VibGVQdHJdID0gSEVBUDhbcHRyXTtcXG4gICAgSEVBUDhbdGVtcERvdWJsZVB0ciArIDFdID0gSEVBUDhbcHRyICsgMV07XFxuICAgIEhFQVA4W3RlbXBEb3VibGVQdHIgKyAyXSA9IEhFQVA4W3B0ciArIDJdO1xcbiAgICBIRUFQOFt0ZW1wRG91YmxlUHRyICsgM10gPSBIRUFQOFtwdHIgKyAzXTtcXG4gICAgSEVBUDhbdGVtcERvdWJsZVB0ciArIDRdID0gSEVBUDhbcHRyICsgNF07XFxuICAgIEhFQVA4W3RlbXBEb3VibGVQdHIgKyA1XSA9IEhFQVA4W3B0ciArIDVdO1xcbiAgICBIRUFQOFt0ZW1wRG91YmxlUHRyICsgNl0gPSBIRUFQOFtwdHIgKyA2XTtcXG4gICAgSEVBUDhbdGVtcERvdWJsZVB0ciArIDddID0gSEVBUDhbcHRyICsgN107XFxuICB9IC8vIHt7UFJFX0xJQlJBUll9fVxcblxcblxcbiAgZnVuY3Rpb24gX19fbG9jaygpIHt9XFxuXFxuICB2YXIgU1lTQ0FMTFMgPSB7XFxuICAgIHZhcmFyZ3M6IDAsXFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KHZhcmFyZ3MpIHtcXG4gICAgICBTWVNDQUxMUy52YXJhcmdzICs9IDQ7XFxuICAgICAgdmFyIHJldCA9IEhFQVAzMltTWVNDQUxMUy52YXJhcmdzIC0gNCA+PiAyXTtcXG4gICAgICByZXR1cm4gcmV0O1xcbiAgICB9LFxcbiAgICBnZXRTdHI6IGZ1bmN0aW9uIGdldFN0cigpIHtcXG4gICAgICB2YXIgcmV0ID0gUG9pbnRlcl9zdHJpbmdpZnkoU1lTQ0FMTFMuZ2V0KCkpO1xcbiAgICAgIHJldHVybiByZXQ7XFxuICAgIH0sXFxuICAgIGdldDY0OiBmdW5jdGlvbiBnZXQ2NCgpIHtcXG4gICAgICB2YXIgbG93ID0gU1lTQ0FMTFMuZ2V0KCksXFxuICAgICAgICAgIGhpZ2ggPSBTWVNDQUxMUy5nZXQoKTtcXG4gICAgICBpZiAobG93ID49IDApIGFzc2VydChoaWdoID09PSAwKTtlbHNlIGFzc2VydChoaWdoID09PSAtMSk7XFxuICAgICAgcmV0dXJuIGxvdztcXG4gICAgfSxcXG4gICAgZ2V0WmVybzogZnVuY3Rpb24gZ2V0WmVybygpIHtcXG4gICAgICBhc3NlcnQoU1lTQ0FMTFMuZ2V0KCkgPT09IDApO1xcbiAgICB9XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gX19fc3lzY2FsbDE0MCh3aGljaCwgdmFyYXJncykge1xcbiAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcXG5cXG4gICAgdHJ5IHtcXG4gICAgICAvLyBsbHNlZWtcXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKCksXFxuICAgICAgICAgIG9mZnNldF9oaWdoID0gU1lTQ0FMTFMuZ2V0KCksXFxuICAgICAgICAgIG9mZnNldF9sb3cgPSBTWVNDQUxMUy5nZXQoKSxcXG4gICAgICAgICAgcmVzdWx0ID0gU1lTQ0FMTFMuZ2V0KCksXFxuICAgICAgICAgIHdoZW5jZSA9IFNZU0NBTExTLmdldCgpOyAvLyBOT1RFOiBvZmZzZXRfaGlnaCBpcyB1bnVzZWQgLSBFbXNjcmlwdGVuJ3Mgb2ZmX3QgaXMgMzItYml0XFxuXFxuICAgICAgdmFyIG9mZnNldCA9IG9mZnNldF9sb3c7XFxuICAgICAgRlMubGxzZWVrKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpO1xcbiAgICAgIEhFQVAzMltyZXN1bHQgPj4gMl0gPSBzdHJlYW0ucG9zaXRpb247XFxuICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cyAmJiBvZmZzZXQgPT09IDAgJiYgd2hlbmNlID09PSAwKSBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsOyAvLyByZXNldCByZWFkZGlyIHN0YXRlXFxuXFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7XFxuICAgICAgcmV0dXJuIC1lLmVycm5vO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBmbHVzaF9OT19GSUxFU1lTVEVNKCkge1xcbiAgICAvLyBmbHVzaCBhbnl0aGluZyByZW1haW5pbmcgaW4gdGhlIGJ1ZmZlcnMgZHVyaW5nIHNodXRkb3duXFxuICAgIHZhciBmZmx1c2ggPSBfTW9kdWxlW1xcXCJfZmZsdXNoXFxcIl07XFxuICAgIGlmIChmZmx1c2gpIGZmbHVzaCgwKTtcXG4gICAgdmFyIHByaW50Q2hhciA9IF9fX3N5c2NhbGwxNDYucHJpbnRDaGFyO1xcbiAgICBpZiAoIXByaW50Q2hhcikgcmV0dXJuO1xcbiAgICB2YXIgYnVmZmVycyA9IF9fX3N5c2NhbGwxNDYuYnVmZmVycztcXG4gICAgaWYgKGJ1ZmZlcnNbMV0ubGVuZ3RoKSBwcmludENoYXIoMSwgMTApO1xcbiAgICBpZiAoYnVmZmVyc1syXS5sZW5ndGgpIHByaW50Q2hhcigyLCAxMCk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBfX19zeXNjYWxsMTQ2KHdoaWNoLCB2YXJhcmdzKSB7XFxuICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xcblxcbiAgICB0cnkge1xcbiAgICAgIC8vIHdyaXRldlxcbiAgICAgIC8vIGhhY2sgdG8gc3VwcG9ydCBwcmludGYgaW4gTk9fRklMRVNZU1RFTVxcbiAgICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXQoKSxcXG4gICAgICAgICAgaW92ID0gU1lTQ0FMTFMuZ2V0KCksXFxuICAgICAgICAgIGlvdmNudCA9IFNZU0NBTExTLmdldCgpO1xcbiAgICAgIHZhciByZXQgPSAwO1xcblxcbiAgICAgIGlmICghX19fc3lzY2FsbDE0Ni5idWZmZXJzKSB7XFxuICAgICAgICBfX19zeXNjYWxsMTQ2LmJ1ZmZlcnMgPSBbbnVsbCwgW10sIFtdXTsgLy8gMSA9PiBzdGRvdXQsIDIgPT4gc3RkZXJyXFxuXFxuICAgICAgICBfX19zeXNjYWxsMTQ2LnByaW50Q2hhciA9IGZ1bmN0aW9uIChzdHJlYW0sIGN1cnIpIHtcXG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IF9fX3N5c2NhbGwxNDYuYnVmZmVyc1tzdHJlYW1dO1xcbiAgICAgICAgICBhc3NlcnQoYnVmZmVyKTtcXG5cXG4gICAgICAgICAgaWYgKGN1cnIgPT09IDAgfHwgY3VyciA9PT0gMTApIHtcXG4gICAgICAgICAgICAoc3RyZWFtID09PSAxID8gX01vZHVsZVsncHJpbnQnXSA6IF9Nb2R1bGVbJ3ByaW50RXJyJ10pKFVURjhBcnJheVRvU3RyaW5nKGJ1ZmZlciwgMCkpO1xcbiAgICAgICAgICAgIGJ1ZmZlci5sZW5ndGggPSAwO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XFxuICAgICAgICB2YXIgcHRyID0gSEVBUDMyW2lvdiArIGkgKiA4ID4+IDJdO1xcbiAgICAgICAgdmFyIGxlbiA9IEhFQVAzMltpb3YgKyAoaSAqIDggKyA0KSA+PiAyXTtcXG5cXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcXG4gICAgICAgICAgX19fc3lzY2FsbDE0Ni5wcmludENoYXIoc3RyZWFtLCBIRUFQVThbcHRyICsgal0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0ICs9IGxlbjtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTtcXG4gICAgICByZXR1cm4gLWUuZXJybm87XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIF9fX3N5c2NhbGw1NCh3aGljaCwgdmFyYXJncykge1xcbiAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcXG5cXG4gICAgdHJ5IHtcXG4gICAgICAvLyBpb2N0bFxcbiAgICAgIHJldHVybiAwO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIGFib3J0KGUpO1xcbiAgICAgIHJldHVybiAtZS5lcnJubztcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gX19fc3lzY2FsbDYod2hpY2gsIHZhcmFyZ3MpIHtcXG4gICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XFxuXFxuICAgIHRyeSB7XFxuICAgICAgLy8gY2xvc2VcXG4gICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKCk7XFxuICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTtcXG4gICAgICByZXR1cm4gLWUuZXJybm87XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIF9fX3VubG9jaygpIHt9XFxuXFxuICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9oYXNfdGhyZWFkaW5nX3N1cHBvcnQoKSB7XFxuICAgIHJldHVybiAwO1xcbiAgfVxcblxcbiAgdmFyIGN0dHpfaTggPSBhbGxvY2F0ZShbOCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNSwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNiwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNSwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNSwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNiwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNSwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMCwgNCwgMCwgMSwgMCwgMiwgMCwgMSwgMCwgMywgMCwgMSwgMCwgMiwgMCwgMSwgMF0sIFxcXCJpOFxcXCIsIEFMTE9DX1NUQVRJQyk7XFxuXFxuICBmdW5jdGlvbiBfbGx2bV9jdHR6X2kzMih4KSB7XFxuICAgIHggPSB4IHwgMDtcXG4gICAgdmFyIHJldCA9IDA7XFxuICAgIHJldCA9IEhFQVA4W2N0dHpfaTggKyAoeCAmIDB4ZmYpID4+IDBdIHwgMDtcXG4gICAgaWYgKChyZXQgfCAwKSA8IDgpIHJldHVybiByZXQgfCAwO1xcbiAgICByZXQgPSBIRUFQOFtjdHR6X2k4ICsgKHggPj4gOCAmIDB4ZmYpID4+IDBdIHwgMDtcXG4gICAgaWYgKChyZXQgfCAwKSA8IDgpIHJldHVybiByZXQgKyA4IHwgMDtcXG4gICAgcmV0ID0gSEVBUDhbY3R0el9pOCArICh4ID4+IDE2ICYgMHhmZikgPj4gMF0gfCAwO1xcbiAgICBpZiAoKHJldCB8IDApIDwgOCkgcmV0dXJuIHJldCArIDE2IHwgMDtcXG4gICAgcmV0dXJuIChIRUFQOFtjdHR6X2k4ICsgKHggPj4+IDI0KSA+PiAwXSB8IDApICsgMjQgfCAwO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gX2xsdm1fY3R0el9pNjQobCwgaCkge1xcbiAgICB2YXIgcmV0ID0gX2xsdm1fY3R0el9pMzIobCk7XFxuXFxuICAgIGlmIChyZXQgPT0gMzIpIHJldCArPSBfbGx2bV9jdHR6X2kzMihoKTtcXG4gICAgcmV0dXJuIChzZXRUZW1wUmV0MCgwKSwgcmV0KSB8IDA7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBfbGx2bV9zdGFja3Jlc3RvcmUocCkge1xcbiAgICB2YXIgc2VsZiA9IF9sbHZtX3N0YWNrc2F2ZTtcXG4gICAgdmFyIHJldCA9IHNlbGYuTExWTV9TQVZFRFNUQUNLU1twXTtcXG4gICAgc2VsZi5MTFZNX1NBVkVEU1RBQ0tTLnNwbGljZShwLCAxKTtcXG5cXG4gICAgX3N0YWNrUmVzdG9yZShyZXQpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gX2xsdm1fc3RhY2tzYXZlKCkge1xcbiAgICB2YXIgc2VsZiA9IF9sbHZtX3N0YWNrc2F2ZTtcXG5cXG4gICAgaWYgKCFzZWxmLkxMVk1fU0FWRURTVEFDS1MpIHtcXG4gICAgICBzZWxmLkxMVk1fU0FWRURTVEFDS1MgPSBbXTtcXG4gICAgfVxcblxcbiAgICBzZWxmLkxMVk1fU0FWRURTVEFDS1MucHVzaChfc3RhY2tTYXZlKCkpO1xcbiAgICByZXR1cm4gc2VsZi5MTFZNX1NBVkVEU1RBQ0tTLmxlbmd0aCAtIDE7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3QsIHNyYywgbnVtKSB7XFxuICAgIEhFQVBVOC5zZXQoSEVBUFU4LnN1YmFycmF5KHNyYywgc3JjICsgbnVtKSwgZGVzdCk7XFxuICAgIHJldHVybiBkZXN0O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gX3B0aHJlYWRfY3JlYXRlKCkge1xcbiAgICByZXR1cm4gMTE7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBfcHRocmVhZF9qb2luKCkge31cXG5cXG4gIGZ1bmN0aW9uIF9wdGhyZWFkX211dGV4X2luaXQoKSB7fVxcblxcbiAgZnVuY3Rpb24gX19fc2V0RXJyTm8odmFsdWUpIHtcXG4gICAgaWYgKF9Nb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10pIEhFQVAzMltfTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddKCkgPj4gMl0gPSB2YWx1ZTtlbHNlIF9Nb2R1bGUucHJpbnRFcnIoJ2ZhaWxlZCB0byBzZXQgZXJybm8gZnJvbSBKUycpO1xcbiAgICByZXR1cm4gdmFsdWU7XFxuICB9XFxuXFxuICB2YXIgRVJSTk9fQ09ERVMgPSB7XFxuICAgIEVQRVJNOiAxLFxcbiAgICBFTk9FTlQ6IDIsXFxuICAgIEVTUkNIOiAzLFxcbiAgICBFSU5UUjogNCxcXG4gICAgRUlPOiA1LFxcbiAgICBFTlhJTzogNixcXG4gICAgRTJCSUc6IDcsXFxuICAgIEVOT0VYRUM6IDgsXFxuICAgIEVCQURGOiA5LFxcbiAgICBFQ0hJTEQ6IDEwLFxcbiAgICBFQUdBSU46IDExLFxcbiAgICBFV09VTERCTE9DSzogMTEsXFxuICAgIEVOT01FTTogMTIsXFxuICAgIEVBQ0NFUzogMTMsXFxuICAgIEVGQVVMVDogMTQsXFxuICAgIEVOT1RCTEs6IDE1LFxcbiAgICBFQlVTWTogMTYsXFxuICAgIEVFWElTVDogMTcsXFxuICAgIEVYREVWOiAxOCxcXG4gICAgRU5PREVWOiAxOSxcXG4gICAgRU5PVERJUjogMjAsXFxuICAgIEVJU0RJUjogMjEsXFxuICAgIEVJTlZBTDogMjIsXFxuICAgIEVORklMRTogMjMsXFxuICAgIEVNRklMRTogMjQsXFxuICAgIEVOT1RUWTogMjUsXFxuICAgIEVUWFRCU1k6IDI2LFxcbiAgICBFRkJJRzogMjcsXFxuICAgIEVOT1NQQzogMjgsXFxuICAgIEVTUElQRTogMjksXFxuICAgIEVST0ZTOiAzMCxcXG4gICAgRU1MSU5LOiAzMSxcXG4gICAgRVBJUEU6IDMyLFxcbiAgICBFRE9NOiAzMyxcXG4gICAgRVJBTkdFOiAzNCxcXG4gICAgRU5PTVNHOiA0MixcXG4gICAgRUlEUk06IDQzLFxcbiAgICBFQ0hSTkc6IDQ0LFxcbiAgICBFTDJOU1lOQzogNDUsXFxuICAgIEVMM0hMVDogNDYsXFxuICAgIEVMM1JTVDogNDcsXFxuICAgIEVMTlJORzogNDgsXFxuICAgIEVVTkFUQ0g6IDQ5LFxcbiAgICBFTk9DU0k6IDUwLFxcbiAgICBFTDJITFQ6IDUxLFxcbiAgICBFREVBRExLOiAzNSxcXG4gICAgRU5PTENLOiAzNyxcXG4gICAgRUJBREU6IDUyLFxcbiAgICBFQkFEUjogNTMsXFxuICAgIEVYRlVMTDogNTQsXFxuICAgIEVOT0FOTzogNTUsXFxuICAgIEVCQURSUUM6IDU2LFxcbiAgICBFQkFEU0xUOiA1NyxcXG4gICAgRURFQURMT0NLOiAzNSxcXG4gICAgRUJGT05UOiA1OSxcXG4gICAgRU5PU1RSOiA2MCxcXG4gICAgRU5PREFUQTogNjEsXFxuICAgIEVUSU1FOiA2MixcXG4gICAgRU5PU1I6IDYzLFxcbiAgICBFTk9ORVQ6IDY0LFxcbiAgICBFTk9QS0c6IDY1LFxcbiAgICBFUkVNT1RFOiA2NixcXG4gICAgRU5PTElOSzogNjcsXFxuICAgIEVBRFY6IDY4LFxcbiAgICBFU1JNTlQ6IDY5LFxcbiAgICBFQ09NTTogNzAsXFxuICAgIEVQUk9UTzogNzEsXFxuICAgIEVNVUxUSUhPUDogNzIsXFxuICAgIEVET1RET1Q6IDczLFxcbiAgICBFQkFETVNHOiA3NCxcXG4gICAgRU5PVFVOSVE6IDc2LFxcbiAgICBFQkFERkQ6IDc3LFxcbiAgICBFUkVNQ0hHOiA3OCxcXG4gICAgRUxJQkFDQzogNzksXFxuICAgIEVMSUJCQUQ6IDgwLFxcbiAgICBFTElCU0NOOiA4MSxcXG4gICAgRUxJQk1BWDogODIsXFxuICAgIEVMSUJFWEVDOiA4MyxcXG4gICAgRU5PU1lTOiAzOCxcXG4gICAgRU5PVEVNUFRZOiAzOSxcXG4gICAgRU5BTUVUT09MT05HOiAzNixcXG4gICAgRUxPT1A6IDQwLFxcbiAgICBFT1BOT1RTVVBQOiA5NSxcXG4gICAgRVBGTk9TVVBQT1JUOiA5NixcXG4gICAgRUNPTk5SRVNFVDogMTA0LFxcbiAgICBFTk9CVUZTOiAxMDUsXFxuICAgIEVBRk5PU1VQUE9SVDogOTcsXFxuICAgIEVQUk9UT1RZUEU6IDkxLFxcbiAgICBFTk9UU09DSzogODgsXFxuICAgIEVOT1BST1RPT1BUOiA5MixcXG4gICAgRVNIVVRET1dOOiAxMDgsXFxuICAgIEVDT05OUkVGVVNFRDogMTExLFxcbiAgICBFQUREUklOVVNFOiA5OCxcXG4gICAgRUNPTk5BQk9SVEVEOiAxMDMsXFxuICAgIEVORVRVTlJFQUNIOiAxMDEsXFxuICAgIEVORVRET1dOOiAxMDAsXFxuICAgIEVUSU1FRE9VVDogMTEwLFxcbiAgICBFSE9TVERPV046IDExMixcXG4gICAgRUhPU1RVTlJFQUNIOiAxMTMsXFxuICAgIEVJTlBST0dSRVNTOiAxMTUsXFxuICAgIEVBTFJFQURZOiAxMTQsXFxuICAgIEVERVNUQUREUlJFUTogODksXFxuICAgIEVNU0dTSVpFOiA5MCxcXG4gICAgRVBST1RPTk9TVVBQT1JUOiA5MyxcXG4gICAgRVNPQ0tUTk9TVVBQT1JUOiA5NCxcXG4gICAgRUFERFJOT1RBVkFJTDogOTksXFxuICAgIEVORVRSRVNFVDogMTAyLFxcbiAgICBFSVNDT05OOiAxMDYsXFxuICAgIEVOT1RDT05OOiAxMDcsXFxuICAgIEVUT09NQU5ZUkVGUzogMTA5LFxcbiAgICBFVVNFUlM6IDg3LFxcbiAgICBFRFFVT1Q6IDEyMixcXG4gICAgRVNUQUxFOiAxMTYsXFxuICAgIEVOT1RTVVA6IDk1LFxcbiAgICBFTk9NRURJVU06IDEyMyxcXG4gICAgRUlMU0VROiA4NCxcXG4gICAgRU9WRVJGTE9XOiA3NSxcXG4gICAgRUNBTkNFTEVEOiAxMjUsXFxuICAgIEVOT1RSRUNPVkVSQUJMRTogMTMxLFxcbiAgICBFT1dORVJERUFEOiAxMzAsXFxuICAgIEVTVFJQSVBFOiA4NlxcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIF9zeXNjb25mKG5hbWUpIHtcXG4gICAgLy8gbG9uZyBzeXNjb25mKGludCBuYW1lKTtcXG4gICAgLy8gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzAwOTY5NTM5OS9mdW5jdGlvbnMvc3lzY29uZi5odG1sXFxuICAgIHN3aXRjaCAobmFtZSkge1xcbiAgICAgIGNhc2UgMzA6XFxuICAgICAgICByZXR1cm4gUEFHRV9TSVpFO1xcblxcbiAgICAgIGNhc2UgODU6XFxuICAgICAgICB2YXIgbWF4SGVhcFNpemUgPSAyICogMTAyNCAqIDEwMjQgKiAxMDI0IC0gNjU1MzY7XFxuICAgICAgICBtYXhIZWFwU2l6ZSA9IEhFQVBVOC5sZW5ndGg7XFxuICAgICAgICByZXR1cm4gbWF4SGVhcFNpemUgLyBQQUdFX1NJWkU7XFxuXFxuICAgICAgY2FzZSAxMzI6XFxuICAgICAgY2FzZSAxMzM6XFxuICAgICAgY2FzZSAxMjpcXG4gICAgICBjYXNlIDEzNzpcXG4gICAgICBjYXNlIDEzODpcXG4gICAgICBjYXNlIDE1OlxcbiAgICAgIGNhc2UgMjM1OlxcbiAgICAgIGNhc2UgMTY6XFxuICAgICAgY2FzZSAxNzpcXG4gICAgICBjYXNlIDE4OlxcbiAgICAgIGNhc2UgMTk6XFxuICAgICAgY2FzZSAyMDpcXG4gICAgICBjYXNlIDE0OTpcXG4gICAgICBjYXNlIDEzOlxcbiAgICAgIGNhc2UgMTA6XFxuICAgICAgY2FzZSAyMzY6XFxuICAgICAgY2FzZSAxNTM6XFxuICAgICAgY2FzZSA5OlxcbiAgICAgIGNhc2UgMjE6XFxuICAgICAgY2FzZSAyMjpcXG4gICAgICBjYXNlIDE1OTpcXG4gICAgICBjYXNlIDE1NDpcXG4gICAgICBjYXNlIDE0OlxcbiAgICAgIGNhc2UgNzc6XFxuICAgICAgY2FzZSA3ODpcXG4gICAgICBjYXNlIDEzOTpcXG4gICAgICBjYXNlIDgwOlxcbiAgICAgIGNhc2UgODE6XFxuICAgICAgY2FzZSA4MjpcXG4gICAgICBjYXNlIDY4OlxcbiAgICAgIGNhc2UgNjc6XFxuICAgICAgY2FzZSAxNjQ6XFxuICAgICAgY2FzZSAxMTpcXG4gICAgICBjYXNlIDI5OlxcbiAgICAgIGNhc2UgNDc6XFxuICAgICAgY2FzZSA0ODpcXG4gICAgICBjYXNlIDk1OlxcbiAgICAgIGNhc2UgNTI6XFxuICAgICAgY2FzZSA1MTpcXG4gICAgICBjYXNlIDQ2OlxcbiAgICAgICAgcmV0dXJuIDIwMDgwOTtcXG5cXG4gICAgICBjYXNlIDc5OlxcbiAgICAgICAgcmV0dXJuIDA7XFxuXFxuICAgICAgY2FzZSAyNzpcXG4gICAgICBjYXNlIDI0NjpcXG4gICAgICBjYXNlIDEyNzpcXG4gICAgICBjYXNlIDEyODpcXG4gICAgICBjYXNlIDIzOlxcbiAgICAgIGNhc2UgMjQ6XFxuICAgICAgY2FzZSAxNjA6XFxuICAgICAgY2FzZSAxNjE6XFxuICAgICAgY2FzZSAxODE6XFxuICAgICAgY2FzZSAxODI6XFxuICAgICAgY2FzZSAyNDI6XFxuICAgICAgY2FzZSAxODM6XFxuICAgICAgY2FzZSAxODQ6XFxuICAgICAgY2FzZSAyNDM6XFxuICAgICAgY2FzZSAyNDQ6XFxuICAgICAgY2FzZSAyNDU6XFxuICAgICAgY2FzZSAxNjU6XFxuICAgICAgY2FzZSAxNzg6XFxuICAgICAgY2FzZSAxNzk6XFxuICAgICAgY2FzZSA0OTpcXG4gICAgICBjYXNlIDUwOlxcbiAgICAgIGNhc2UgMTY4OlxcbiAgICAgIGNhc2UgMTY5OlxcbiAgICAgIGNhc2UgMTc1OlxcbiAgICAgIGNhc2UgMTcwOlxcbiAgICAgIGNhc2UgMTcxOlxcbiAgICAgIGNhc2UgMTcyOlxcbiAgICAgIGNhc2UgOTc6XFxuICAgICAgY2FzZSA3NjpcXG4gICAgICBjYXNlIDMyOlxcbiAgICAgIGNhc2UgMTczOlxcbiAgICAgIGNhc2UgMzU6XFxuICAgICAgICByZXR1cm4gLTE7XFxuXFxuICAgICAgY2FzZSAxNzY6XFxuICAgICAgY2FzZSAxNzc6XFxuICAgICAgY2FzZSA3OlxcbiAgICAgIGNhc2UgMTU1OlxcbiAgICAgIGNhc2UgODpcXG4gICAgICBjYXNlIDE1NzpcXG4gICAgICBjYXNlIDEyNTpcXG4gICAgICBjYXNlIDEyNjpcXG4gICAgICBjYXNlIDkyOlxcbiAgICAgIGNhc2UgOTM6XFxuICAgICAgY2FzZSAxMjk6XFxuICAgICAgY2FzZSAxMzA6XFxuICAgICAgY2FzZSAxMzE6XFxuICAgICAgY2FzZSA5NDpcXG4gICAgICBjYXNlIDkxOlxcbiAgICAgICAgcmV0dXJuIDE7XFxuXFxuICAgICAgY2FzZSA3NDpcXG4gICAgICBjYXNlIDYwOlxcbiAgICAgIGNhc2UgNjk6XFxuICAgICAgY2FzZSA3MDpcXG4gICAgICBjYXNlIDQ6XFxuICAgICAgICByZXR1cm4gMTAyNDtcXG5cXG4gICAgICBjYXNlIDMxOlxcbiAgICAgIGNhc2UgNDI6XFxuICAgICAgY2FzZSA3MjpcXG4gICAgICAgIHJldHVybiAzMjtcXG5cXG4gICAgICBjYXNlIDg3OlxcbiAgICAgIGNhc2UgMjY6XFxuICAgICAgY2FzZSAzMzpcXG4gICAgICAgIHJldHVybiAyMTQ3NDgzNjQ3O1xcblxcbiAgICAgIGNhc2UgMzQ6XFxuICAgICAgY2FzZSAxOlxcbiAgICAgICAgcmV0dXJuIDQ3ODM5O1xcblxcbiAgICAgIGNhc2UgMzg6XFxuICAgICAgY2FzZSAzNjpcXG4gICAgICAgIHJldHVybiA5OTtcXG5cXG4gICAgICBjYXNlIDQzOlxcbiAgICAgIGNhc2UgMzc6XFxuICAgICAgICByZXR1cm4gMjA0ODtcXG5cXG4gICAgICBjYXNlIDA6XFxuICAgICAgICByZXR1cm4gMjA5NzE1MjtcXG5cXG4gICAgICBjYXNlIDM6XFxuICAgICAgICByZXR1cm4gNjU1MzY7XFxuXFxuICAgICAgY2FzZSAyODpcXG4gICAgICAgIHJldHVybiAzMjc2ODtcXG5cXG4gICAgICBjYXNlIDQ0OlxcbiAgICAgICAgcmV0dXJuIDMyNzY3O1xcblxcbiAgICAgIGNhc2UgNzU6XFxuICAgICAgICByZXR1cm4gMTYzODQ7XFxuXFxuICAgICAgY2FzZSAzOTpcXG4gICAgICAgIHJldHVybiAxMDAwO1xcblxcbiAgICAgIGNhc2UgODk6XFxuICAgICAgICByZXR1cm4gNzAwO1xcblxcbiAgICAgIGNhc2UgNzE6XFxuICAgICAgICByZXR1cm4gMjU2O1xcblxcbiAgICAgIGNhc2UgNDA6XFxuICAgICAgICByZXR1cm4gMjU1O1xcblxcbiAgICAgIGNhc2UgMjpcXG4gICAgICAgIHJldHVybiAxMDA7XFxuXFxuICAgICAgY2FzZSAxODA6XFxuICAgICAgICByZXR1cm4gNjQ7XFxuXFxuICAgICAgY2FzZSAyNTpcXG4gICAgICAgIHJldHVybiAyMDtcXG5cXG4gICAgICBjYXNlIDU6XFxuICAgICAgICByZXR1cm4gMTY7XFxuXFxuICAgICAgY2FzZSA2OlxcbiAgICAgICAgcmV0dXJuIDY7XFxuXFxuICAgICAgY2FzZSA3MzpcXG4gICAgICAgIHJldHVybiA0O1xcblxcbiAgICAgIGNhc2UgODQ6XFxuICAgICAgICB7XFxuICAgICAgICAgIGlmICgodHlwZW9mIG5hdmlnYXRvciA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YobmF2aWdhdG9yKSkgPT09ICdvYmplY3QnKSByZXR1cm4gbmF2aWdhdG9yWydoYXJkd2FyZUNvbmN1cnJlbmN5J10gfHwgMTtcXG4gICAgICAgICAgcmV0dXJuIDE7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgX19fc2V0RXJyTm8oRVJSTk9fQ09ERVMuRUlOVkFMKTtcXG5cXG4gICAgcmV0dXJuIC0xO1xcbiAgfVxcblxcbiAgRFlOQU1JQ1RPUF9QVFIgPSBzdGF0aWNBbGxvYyg0KTtcXG4gIFNUQUNLX0JBU0UgPSBTVEFDS1RPUCA9IGFsaWduTWVtb3J5KFNUQVRJQ1RPUCk7XFxuICBTVEFDS19NQVggPSBTVEFDS19CQVNFICsgVE9UQUxfU1RBQ0s7XFxuICBEWU5BTUlDX0JBU0UgPSBhbGlnbk1lbW9yeShTVEFDS19NQVgpO1xcbiAgSEVBUDMyW0RZTkFNSUNUT1BfUFRSID4+IDJdID0gRFlOQU1JQ19CQVNFO1xcbiAgc3RhdGljU2VhbGVkID0gdHJ1ZTsgLy8gc2VhbCB0aGUgc3RhdGljIHBvcnRpb24gb2YgbWVtb3J5XFxuXFxuICBhc3NlcnQoRFlOQU1JQ19CQVNFIDwgVE9UQUxfTUVNT1JZLCBcXFwiVE9UQUxfTUVNT1JZIG5vdCBiaWcgZW5vdWdoIGZvciBzdGFja1xcXCIpO1xcbiAgdmFyIEFTU0VSVElPTlMgPSB0cnVlO1xcbiAgLyoqIEB0eXBlIHtmdW5jdGlvbihzdHJpbmcsIGJvb2xlYW49LCBudW1iZXI9KX0gKi9cXG5cXG4gIGZ1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LCBkb250QWRkTnVsbCwgbGVuZ3RoKSB7XFxuICAgIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpICsgMTtcXG4gICAgdmFyIHU4YXJyYXkgPSBuZXcgQXJyYXkobGVuKTtcXG4gICAgdmFyIG51bUJ5dGVzV3JpdHRlbiA9IHN0cmluZ1RvVVRGOEFycmF5KHN0cmluZ3ksIHU4YXJyYXksIDAsIHU4YXJyYXkubGVuZ3RoKTtcXG4gICAgaWYgKGRvbnRBZGROdWxsKSB1OGFycmF5Lmxlbmd0aCA9IG51bUJ5dGVzV3JpdHRlbjtcXG4gICAgcmV0dXJuIHU4YXJyYXk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbnRBcnJheVRvU3RyaW5nKGFycmF5KSB7XFxuICAgIHZhciByZXQgPSBbXTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBjaHIgPSBhcnJheVtpXTtcXG5cXG4gICAgICBpZiAoY2hyID4gMHhGRikge1xcbiAgICAgICAgaWYgKEFTU0VSVElPTlMpIHtcXG4gICAgICAgICAgYXNzZXJ0KGZhbHNlLCAnQ2hhcmFjdGVyIGNvZGUgJyArIGNociArICcgKCcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyAnKSAgYXQgb2Zmc2V0ICcgKyBpICsgJyBub3QgaW4gMHgwMC0weEZGLicpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY2hyICY9IDB4RkY7XFxuICAgICAgfVxcblxcbiAgICAgIHJldC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcXG4gIH0gLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3N0cm9waGUvc3Ryb3BoZWpzL2Jsb2IvZTA2ZDAyNy9zcmMvcG9seWZpbGxzLmpzI0wxNDlcXG4gIC8vIFRoaXMgY29kZSB3YXMgd3JpdHRlbiBieSBUeWxlciBBa2lucyBhbmQgaGFzIGJlZW4gcGxhY2VkIGluIHRoZVxcbiAgLy8gcHVibGljIGRvbWFpbi4gIEl0IHdvdWxkIGJlIG5pY2UgaWYgeW91IGxlZnQgdGhpcyBoZWFkZXIgaW50YWN0LlxcbiAgLy8gQmFzZTY0IGNvZGUgZnJvbSBUeWxlciBBa2lucyAtLSBodHRwOi8vcnVta2luLmNvbVxcblxcbiAgLyoqXFxyXFxuICAgKiBEZWNvZGVzIGEgYmFzZTY0IHN0cmluZy5cXHJcXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIHRvIGRlY29kZS5cXHJcXG4gICAqL1xcblxcblxcbiAgdmFyIGRlY29kZUJhc2U2NCA9IHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nID8gYXRvYiA6IGZ1bmN0aW9uIChpbnB1dCkge1xcbiAgICB2YXIga2V5U3RyID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcXG4gICAgdmFyIG91dHB1dCA9ICcnO1xcbiAgICB2YXIgY2hyMSwgY2hyMiwgY2hyMztcXG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XFxuICAgIHZhciBpID0gMDsgLy8gcmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBBLVosIGEteiwgMC05LCArLCAvLCBvciA9XFxuXFxuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW15BLVphLXowLTlcXFxcK1xcXFwvXFxcXD1dL2csICcnKTtcXG5cXG4gICAgZG8ge1xcbiAgICAgIGVuYzEgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XFxuICAgICAgZW5jMiA9IGtleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcXG4gICAgICBlbmMzID0ga2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xcbiAgICAgIGVuYzQgPSBrZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XFxuICAgICAgY2hyMSA9IGVuYzEgPDwgMiB8IGVuYzIgPj4gNDtcXG4gICAgICBjaHIyID0gKGVuYzIgJiAxNSkgPDwgNCB8IGVuYzMgPj4gMjtcXG4gICAgICBjaHIzID0gKGVuYzMgJiAzKSA8PCA2IHwgZW5jNDtcXG4gICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpO1xcblxcbiAgICAgIGlmIChlbmMzICE9PSA2NCkge1xcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XFxuICAgICAgICBvdXRwdXQgPSBvdXRwdXQgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjMpO1xcbiAgICAgIH1cXG4gICAgfSB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCk7XFxuXFxuICAgIHJldHVybiBvdXRwdXQ7XFxuICB9OyAvLyBDb252ZXJ0cyBhIHN0cmluZyBvZiBiYXNlNjQgaW50byBhIGJ5dGUgYXJyYXkuXFxuICAvLyBUaHJvd3MgZXJyb3Igb24gaW52YWxpZCBpbnB1dC5cXG5cXG4gIGZ1bmN0aW9uIGludEFycmF5RnJvbUJhc2U2NChzKSB7XFxuICAgIGlmICh0eXBlb2YgRU5WSVJPTk1FTlRfSVNfTk9ERSA9PT0gJ2Jvb2xlYW4nICYmIEVOVklST05NRU5UX0lTX05PREUpIHtcXG4gICAgICB2YXIgYnVmO1xcblxcbiAgICAgIHRyeSB7XFxuICAgICAgICBidWYgPSBCdWZmZXIuZnJvbShzLCAnYmFzZTY0Jyk7XFxuICAgICAgfSBjYXRjaCAoXykge1xcbiAgICAgICAgYnVmID0gbmV3IEJ1ZmZlcihzLCAnYmFzZTY0Jyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xcbiAgICB9XFxuXFxuICAgIHRyeSB7XFxuICAgICAgdmFyIGRlY29kZWQgPSBkZWNvZGVCYXNlNjQocyk7XFxuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlZC5sZW5ndGgpO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgYnl0ZXNbaV0gPSBkZWNvZGVkLmNoYXJDb2RlQXQoaSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBieXRlcztcXG4gICAgfSBjYXRjaCAoXykge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29udmVydGluZyBiYXNlNjQgc3RyaW5nIHRvIGJ5dGVzIGZhaWxlZC4nKTtcXG4gICAgfVxcbiAgfSAvLyBJZiBmaWxlbmFtZSBpcyBhIGJhc2U2NCBkYXRhIFVSSSwgcGFyc2VzIGFuZCByZXR1cm5zIGRhdGEgKEJ1ZmZlciBvbiBub2RlLFxcbiAgLy8gVWludDhBcnJheSBvdGhlcndpc2UpLiBJZiBmaWxlbmFtZSBpcyBub3QgYSBiYXNlNjQgZGF0YSBVUkksIHJldHVybnMgdW5kZWZpbmVkLlxcblxcblxcbiAgZnVuY3Rpb24gdHJ5UGFyc2VBc0RhdGFVUkkoZmlsZW5hbWUpIHtcXG4gICAgaWYgKCFpc0RhdGFVUkkoZmlsZW5hbWUpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBpbnRBcnJheUZyb21CYXNlNjQoZmlsZW5hbWUuc2xpY2UoZGF0YVVSSVByZWZpeC5sZW5ndGgpKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG51bGxGdW5jX2lpKHgpIHtcXG4gICAgX01vZHVsZVtcXFwicHJpbnRFcnJcXFwiXShcXFwiSW52YWxpZCBmdW5jdGlvbiBwb2ludGVyIGNhbGxlZCB3aXRoIHNpZ25hdHVyZSAnaWknLiBQZXJoYXBzIHRoaXMgaXMgYW4gaW52YWxpZCB2YWx1ZSAoZS5nLiBjYXVzZWQgYnkgY2FsbGluZyBhIHZpcnR1YWwgbWV0aG9kIG9uIGEgTlVMTCBwb2ludGVyKT8gT3IgY2FsbGluZyBhIGZ1bmN0aW9uIHdpdGggYW4gaW5jb3JyZWN0IHR5cGUsIHdoaWNoIHdpbGwgZmFpbD8gKGl0IGlzIHdvcnRoIGJ1aWxkaW5nIHlvdXIgc291cmNlIGZpbGVzIHdpdGggLVdlcnJvciAod2FybmluZ3MgYXJlIGVycm9ycyksIGFzIHdhcm5pbmdzIGNhbiBpbmRpY2F0ZSB1bmRlZmluZWQgYmVoYXZpb3Igd2hpY2ggY2FuIGNhdXNlIHRoaXMpXFxcIik7XFxuXFxuICAgIF9Nb2R1bGVbXFxcInByaW50RXJyXFxcIl0oXFxcIkJ1aWxkIHdpdGggQVNTRVJUSU9OUz0yIGZvciBtb3JlIGluZm8uXFxcIik7XFxuXFxuICAgIGFib3J0KHgpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gbnVsbEZ1bmNfaWlpaSh4KSB7XFxuICAgIF9Nb2R1bGVbXFxcInByaW50RXJyXFxcIl0oXFxcIkludmFsaWQgZnVuY3Rpb24gcG9pbnRlciBjYWxsZWQgd2l0aCBzaWduYXR1cmUgJ2lpaWknLiBQZXJoYXBzIHRoaXMgaXMgYW4gaW52YWxpZCB2YWx1ZSAoZS5nLiBjYXVzZWQgYnkgY2FsbGluZyBhIHZpcnR1YWwgbWV0aG9kIG9uIGEgTlVMTCBwb2ludGVyKT8gT3IgY2FsbGluZyBhIGZ1bmN0aW9uIHdpdGggYW4gaW5jb3JyZWN0IHR5cGUsIHdoaWNoIHdpbGwgZmFpbD8gKGl0IGlzIHdvcnRoIGJ1aWxkaW5nIHlvdXIgc291cmNlIGZpbGVzIHdpdGggLVdlcnJvciAod2FybmluZ3MgYXJlIGVycm9ycyksIGFzIHdhcm5pbmdzIGNhbiBpbmRpY2F0ZSB1bmRlZmluZWQgYmVoYXZpb3Igd2hpY2ggY2FuIGNhdXNlIHRoaXMpXFxcIik7XFxuXFxuICAgIF9Nb2R1bGVbXFxcInByaW50RXJyXFxcIl0oXFxcIkJ1aWxkIHdpdGggQVNTRVJUSU9OUz0yIGZvciBtb3JlIGluZm8uXFxcIik7XFxuXFxuICAgIGFib3J0KHgpO1xcbiAgfVxcblxcbiAgX01vZHVsZVsnd2FzbVRhYmxlU2l6ZSddID0gMTY7XFxuICBfTW9kdWxlWyd3YXNtTWF4VGFibGVTaXplJ10gPSAxNjtcXG5cXG4gIGZ1bmN0aW9uIGludm9rZV9paShpbmRleCwgYTEpIHtcXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4gX01vZHVsZVtcXFwiZHluQ2FsbF9paVxcXCJdKGluZGV4LCBhMSk7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZTtcXG5cXG4gICAgICBfTW9kdWxlW1xcXCJzZXRUaHJld1xcXCJdKDEsIDApO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBpbnZva2VfaWlpaShpbmRleCwgYTEsIGEyLCBhMykge1xcbiAgICB0cnkge1xcbiAgICAgIHJldHVybiBfTW9kdWxlW1xcXCJkeW5DYWxsX2lpaWlcXFwiXShpbmRleCwgYTEsIGEyLCBhMyk7XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZTtcXG5cXG4gICAgICBfTW9kdWxlW1xcXCJzZXRUaHJld1xcXCJdKDEsIDApO1xcbiAgICB9XFxuICB9XFxuXFxuICBfTW9kdWxlLmFzbUdsb2JhbEFyZyA9IHt9O1xcbiAgX01vZHVsZS5hc21MaWJyYXJ5QXJnID0ge1xcbiAgICBcXFwiYWJvcnRcXFwiOiBhYm9ydCxcXG4gICAgXFxcImFzc2VydFxcXCI6IGFzc2VydCxcXG4gICAgXFxcImVubGFyZ2VNZW1vcnlcXFwiOiBlbmxhcmdlTWVtb3J5LFxcbiAgICBcXFwiZ2V0VG90YWxNZW1vcnlcXFwiOiBnZXRUb3RhbE1lbW9yeSxcXG4gICAgXFxcImFib3J0T25DYW5ub3RHcm93TWVtb3J5XFxcIjogYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnksXFxuICAgIFxcXCJhYm9ydFN0YWNrT3ZlcmZsb3dcXFwiOiBhYm9ydFN0YWNrT3ZlcmZsb3csXFxuICAgIFxcXCJudWxsRnVuY19paVxcXCI6IG51bGxGdW5jX2lpLFxcbiAgICBcXFwibnVsbEZ1bmNfaWlpaVxcXCI6IG51bGxGdW5jX2lpaWksXFxuICAgIFxcXCJpbnZva2VfaWlcXFwiOiBpbnZva2VfaWksXFxuICAgIFxcXCJpbnZva2VfaWlpaVxcXCI6IGludm9rZV9paWlpLFxcbiAgICBcXFwiX19fbG9ja1xcXCI6IF9fX2xvY2ssXFxuICAgIFxcXCJfX19zZXRFcnJOb1xcXCI6IF9fX3NldEVyck5vLFxcbiAgICBcXFwiX19fc3lzY2FsbDE0MFxcXCI6IF9fX3N5c2NhbGwxNDAsXFxuICAgIFxcXCJfX19zeXNjYWxsMTQ2XFxcIjogX19fc3lzY2FsbDE0NixcXG4gICAgXFxcIl9fX3N5c2NhbGw1NFxcXCI6IF9fX3N5c2NhbGw1NCxcXG4gICAgXFxcIl9fX3N5c2NhbGw2XFxcIjogX19fc3lzY2FsbDYsXFxuICAgIFxcXCJfX191bmxvY2tcXFwiOiBfX191bmxvY2ssXFxuICAgIFxcXCJfZW1zY3JpcHRlbl9oYXNfdGhyZWFkaW5nX3N1cHBvcnRcXFwiOiBfZW1zY3JpcHRlbl9oYXNfdGhyZWFkaW5nX3N1cHBvcnQsXFxuICAgIFxcXCJfZW1zY3JpcHRlbl9tZW1jcHlfYmlnXFxcIjogX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyxcXG4gICAgXFxcIl9sbHZtX2N0dHpfaTMyXFxcIjogX2xsdm1fY3R0el9pMzIsXFxuICAgIFxcXCJfbGx2bV9jdHR6X2k2NFxcXCI6IF9sbHZtX2N0dHpfaTY0LFxcbiAgICBcXFwiX2xsdm1fc3RhY2tyZXN0b3JlXFxcIjogX2xsdm1fc3RhY2tyZXN0b3JlLFxcbiAgICBcXFwiX2xsdm1fc3RhY2tzYXZlXFxcIjogX2xsdm1fc3RhY2tzYXZlLFxcbiAgICBcXFwiX3B0aHJlYWRfY3JlYXRlXFxcIjogX3B0aHJlYWRfY3JlYXRlLFxcbiAgICBcXFwiX3B0aHJlYWRfam9pblxcXCI6IF9wdGhyZWFkX2pvaW4sXFxuICAgIFxcXCJfcHRocmVhZF9tdXRleF9pbml0XFxcIjogX3B0aHJlYWRfbXV0ZXhfaW5pdCxcXG4gICAgXFxcIl9zeXNjb25mXFxcIjogX3N5c2NvbmYsXFxuICAgIFxcXCJmbHVzaF9OT19GSUxFU1lTVEVNXFxcIjogZmx1c2hfTk9fRklMRVNZU1RFTSxcXG4gICAgXFxcIkRZTkFNSUNUT1BfUFRSXFxcIjogRFlOQU1JQ1RPUF9QVFIsXFxuICAgIFxcXCJ0ZW1wRG91YmxlUHRyXFxcIjogdGVtcERvdWJsZVB0cixcXG4gICAgXFxcIkFCT1JUXFxcIjogQUJPUlQsXFxuICAgIFxcXCJTVEFDS1RPUFxcXCI6IFNUQUNLVE9QLFxcbiAgICBcXFwiU1RBQ0tfTUFYXFxcIjogU1RBQ0tfTUFYLFxcbiAgICBcXFwiY3R0el9pOFxcXCI6IGN0dHpfaThcXG4gIH07IC8vIEVNU0NSSVBURU5fU1RBUlRfQVNNXFxuXFxuICB2YXIgYXNtID0gX01vZHVsZVtcXFwiYXNtXFxcIl0gLy8gRU1TQ1JJUFRFTl9FTkRfQVNNXFxuICAoX01vZHVsZS5hc21HbG9iYWxBcmcsIF9Nb2R1bGUuYXNtTGlicmFyeUFyZywgYnVmZmVyKTtcXG5cXG4gIHZhciByZWFsX19fX2Vycm5vX2xvY2F0aW9uID0gYXNtW1xcXCJfX19lcnJub19sb2NhdGlvblxcXCJdO1xcblxcbiAgYXNtW1xcXCJfX19lcnJub19sb2NhdGlvblxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIHJlYWxfX19fZXJybm9fbG9jYXRpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9fY2N1cmxfcG93ID0gYXNtW1xcXCJfY2N1cmxfcG93XFxcIl07XFxuXFxuICBhc21bXFxcIl9jY3VybF9wb3dcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX19jY3VybF9wb3cuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9fZmZsdXNoID0gYXNtW1xcXCJfZmZsdXNoXFxcIl07XFxuXFxuICBhc21bXFxcIl9mZmx1c2hcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX19mZmx1c2guYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9fZnJlZSA9IGFzbVtcXFwiX2ZyZWVcXFwiXTtcXG5cXG4gIGFzbVtcXFwiX2ZyZWVcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX19mcmVlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIHJlYWxfX2xsdm1fYnN3YXBfaTMyID0gYXNtW1xcXCJfbGx2bV9ic3dhcF9pMzJcXFwiXTtcXG5cXG4gIGFzbVtcXFwiX2xsdm1fYnN3YXBfaTMyXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xcbiAgICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xcbiAgICByZXR1cm4gcmVhbF9fbGx2bV9ic3dhcF9pMzIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9fbWFsbG9jID0gYXNtW1xcXCJfbWFsbG9jXFxcIl07XFxuXFxuICBhc21bXFxcIl9tYWxsb2NcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX19tYWxsb2MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9fcHRocmVhZF9tdXRleF9sb2NrID0gYXNtW1xcXCJfcHRocmVhZF9tdXRleF9sb2NrXFxcIl07XFxuXFxuICBhc21bXFxcIl9wdGhyZWFkX211dGV4X2xvY2tcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX19wdGhyZWFkX211dGV4X2xvY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9fcHRocmVhZF9tdXRleF91bmxvY2sgPSBhc21bXFxcIl9wdGhyZWFkX211dGV4X3VubG9ja1xcXCJdO1xcblxcbiAgYXNtW1xcXCJfcHRocmVhZF9tdXRleF91bmxvY2tcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX19wdGhyZWFkX211dGV4X3VubG9jay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIHZhciByZWFsX19zYnJrID0gYXNtW1xcXCJfc2Jya1xcXCJdO1xcblxcbiAgYXNtW1xcXCJfc2Jya1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIHJlYWxfX3NicmsuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9lc3RhYmxpc2hTdGFja1NwYWNlID0gYXNtW1xcXCJlc3RhYmxpc2hTdGFja1NwYWNlXFxcIl07XFxuXFxuICBhc21bXFxcImVzdGFibGlzaFN0YWNrU3BhY2VcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX2VzdGFibGlzaFN0YWNrU3BhY2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9nZXRUZW1wUmV0MCA9IGFzbVtcXFwiZ2V0VGVtcFJldDBcXFwiXTtcXG5cXG4gIGFzbVtcXFwiZ2V0VGVtcFJldDBcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX2dldFRlbXBSZXQwLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIHJlYWxfc2V0VGVtcFJldDAgPSBhc21bXFxcInNldFRlbXBSZXQwXFxcIl07XFxuXFxuICBhc21bXFxcInNldFRlbXBSZXQwXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xcbiAgICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xcbiAgICByZXR1cm4gcmVhbF9zZXRUZW1wUmV0MC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIHZhciByZWFsX3NldFRocmV3ID0gYXNtW1xcXCJzZXRUaHJld1xcXCJdO1xcblxcbiAgYXNtW1xcXCJzZXRUaHJld1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIHJlYWxfc2V0VGhyZXcuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9zdGFja0FsbG9jID0gYXNtW1xcXCJzdGFja0FsbG9jXFxcIl07XFxuXFxuICBhc21bXFxcInN0YWNrQWxsb2NcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX3N0YWNrQWxsb2MuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgcmVhbF9zdGFja1Jlc3RvcmUgPSBhc21bXFxcInN0YWNrUmVzdG9yZVxcXCJdO1xcblxcbiAgYXNtW1xcXCJzdGFja1Jlc3RvcmVcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiByZWFsX3N0YWNrUmVzdG9yZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIHZhciByZWFsX3N0YWNrU2F2ZSA9IGFzbVtcXFwic3RhY2tTYXZlXFxcIl07XFxuXFxuICBhc21bXFxcInN0YWNrU2F2ZVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIHJlYWxfc3RhY2tTYXZlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgX01vZHVsZVtcXFwiYXNtXFxcIl0gPSBhc207XFxuXFxuICB2YXIgX19fZXJybm9fbG9jYXRpb24gPSBfTW9kdWxlW1xcXCJfX19lcnJub19sb2NhdGlvblxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJfX19lcnJub19sb2NhdGlvblxcXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIF9jY3VybF9wb3cgPSBfTW9kdWxlW1xcXCJfY2N1cmxfcG93XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xcbiAgICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xcbiAgICByZXR1cm4gX01vZHVsZVtcXFwiYXNtXFxcIl1bXFxcIl9jY3VybF9wb3dcXFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIHZhciBfZmZsdXNoID0gX01vZHVsZVtcXFwiX2ZmbHVzaFxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJfZmZsdXNoXFxcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgX2ZyZWUgPSBfTW9kdWxlW1xcXCJfZnJlZVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJfZnJlZVxcXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIF9sbHZtX2Jzd2FwX2kzMiA9IF9Nb2R1bGVbXFxcIl9sbHZtX2Jzd2FwX2kzMlxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJfbGx2bV9ic3dhcF9pMzJcXFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIHZhciBfbWFsbG9jID0gX01vZHVsZVtcXFwiX21hbGxvY1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJfbWFsbG9jXFxcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgX21lbWNweSA9IF9Nb2R1bGVbXFxcIl9tZW1jcHlcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiBfTW9kdWxlW1xcXCJhc21cXFwiXVtcXFwiX21lbWNweVxcXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIF9tZW1zZXQgPSBfTW9kdWxlW1xcXCJfbWVtc2V0XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xcbiAgICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xcbiAgICByZXR1cm4gX01vZHVsZVtcXFwiYXNtXFxcIl1bXFxcIl9tZW1zZXRcXFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIHZhciBfcHRocmVhZF9tdXRleF9sb2NrID0gX01vZHVsZVtcXFwiX3B0aHJlYWRfbXV0ZXhfbG9ja1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJfcHRocmVhZF9tdXRleF9sb2NrXFxcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgX3B0aHJlYWRfbXV0ZXhfdW5sb2NrID0gX01vZHVsZVtcXFwiX3B0aHJlYWRfbXV0ZXhfdW5sb2NrXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xcbiAgICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xcbiAgICByZXR1cm4gX01vZHVsZVtcXFwiYXNtXFxcIl1bXFxcIl9wdGhyZWFkX211dGV4X3VubG9ja1xcXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIF9zYnJrID0gX01vZHVsZVtcXFwiX3NicmtcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiBfTW9kdWxlW1xcXCJhc21cXFwiXVtcXFwiX3NicmtcXFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIHZhciBlc3RhYmxpc2hTdGFja1NwYWNlID0gX01vZHVsZVtcXFwiZXN0YWJsaXNoU3RhY2tTcGFjZVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJlc3RhYmxpc2hTdGFja1NwYWNlXFxcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgZ2V0VGVtcFJldDAgPSBfTW9kdWxlW1xcXCJnZXRUZW1wUmV0MFxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJnZXRUZW1wUmV0MFxcXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIHJ1blBvc3RTZXRzID0gX01vZHVsZVtcXFwicnVuUG9zdFNldHNcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiBfTW9kdWxlW1xcXCJhc21cXFwiXVtcXFwicnVuUG9zdFNldHNcXFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIHZhciBzZXRUZW1wUmV0MCA9IF9Nb2R1bGVbXFxcInNldFRlbXBSZXQwXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xcbiAgICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xcbiAgICByZXR1cm4gX01vZHVsZVtcXFwiYXNtXFxcIl1bXFxcInNldFRlbXBSZXQwXFxcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgc2V0VGhyZXcgPSBfTW9kdWxlW1xcXCJzZXRUaHJld1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJzZXRUaHJld1xcXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIHN0YWNrQWxsb2MgPSBfTW9kdWxlW1xcXCJzdGFja0FsbG9jXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xcbiAgICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xcbiAgICByZXR1cm4gX01vZHVsZVtcXFwiYXNtXFxcIl1bXFxcInN0YWNrQWxsb2NcXFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIHZhciBfc3RhY2tSZXN0b3JlID0gX01vZHVsZVtcXFwic3RhY2tSZXN0b3JlXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsICd5b3UgbmVlZCB0byB3YWl0IGZvciB0aGUgcnVudGltZSB0byBiZSByZWFkeSAoZS5nLiB3YWl0IGZvciBtYWluKCkgdG8gYmUgY2FsbGVkKScpO1xcbiAgICBhc3NlcnQoIXJ1bnRpbWVFeGl0ZWQsICd0aGUgcnVudGltZSB3YXMgZXhpdGVkICh1c2UgTk9fRVhJVF9SVU5USU1FIHRvIGtlZXAgaXQgYWxpdmUgYWZ0ZXIgbWFpbigpIGV4aXRzKScpO1xcbiAgICByZXR1cm4gX01vZHVsZVtcXFwiYXNtXFxcIl1bXFxcInN0YWNrUmVzdG9yZVxcXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIF9zdGFja1NhdmUgPSBfTW9kdWxlW1xcXCJzdGFja1NhdmVcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiBfTW9kdWxlW1xcXCJhc21cXFwiXVtcXFwic3RhY2tTYXZlXFxcIl0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcXG4gIH07XFxuXFxuICB2YXIgZHluQ2FsbF9paSA9IF9Nb2R1bGVbXFxcImR5bkNhbGxfaWlcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgJ3lvdSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBydW50aW1lIHRvIGJlIHJlYWR5IChlLmcuIHdhaXQgZm9yIG1haW4oKSB0byBiZSBjYWxsZWQpJyk7XFxuICAgIGFzc2VydCghcnVudGltZUV4aXRlZCwgJ3RoZSBydW50aW1lIHdhcyBleGl0ZWQgKHVzZSBOT19FWElUX1JVTlRJTUUgdG8ga2VlcCBpdCBhbGl2ZSBhZnRlciBtYWluKCkgZXhpdHMpJyk7XFxuICAgIHJldHVybiBfTW9kdWxlW1xcXCJhc21cXFwiXVtcXFwiZHluQ2FsbF9paVxcXCJdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XFxuICB9O1xcblxcbiAgdmFyIGR5bkNhbGxfaWlpaSA9IF9Nb2R1bGVbXFxcImR5bkNhbGxfaWlpaVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCAneW91IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHJ1bnRpbWUgdG8gYmUgcmVhZHkgKGUuZy4gd2FpdCBmb3IgbWFpbigpIHRvIGJlIGNhbGxlZCknKTtcXG4gICAgYXNzZXJ0KCFydW50aW1lRXhpdGVkLCAndGhlIHJ1bnRpbWUgd2FzIGV4aXRlZCAodXNlIE5PX0VYSVRfUlVOVElNRSB0byBrZWVwIGl0IGFsaXZlIGFmdGVyIG1haW4oKSBleGl0cyknKTtcXG4gICAgcmV0dXJuIF9Nb2R1bGVbXFxcImFzbVxcXCJdW1xcXCJkeW5DYWxsX2lpaWlcXFwiXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xcbiAgfTtcXG5cXG4gIDsgLy8gPT09IEF1dG8tZ2VuZXJhdGVkIHBvc3RhbWJsZSBzZXR1cCBlbnRyeSBzdHVmZiA9PT1cXG5cXG4gIF9Nb2R1bGVbJ2FzbSddID0gYXNtO1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJpbnRBcnJheUZyb21TdHJpbmdcXFwiXSkgX01vZHVsZVtcXFwiaW50QXJyYXlGcm9tU3RyaW5nXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInaW50QXJyYXlGcm9tU3RyaW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcImludEFycmF5VG9TdHJpbmdcXFwiXSkgX01vZHVsZVtcXFwiaW50QXJyYXlUb1N0cmluZ1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ2ludEFycmF5VG9TdHJpbmcnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIF9Nb2R1bGVbXFxcImNjYWxsXFxcIl0gPSBjY2FsbDtcXG4gIF9Nb2R1bGVbXFxcImN3cmFwXFxcIl0gPSBjd3JhcDtcXG4gIGlmICghX01vZHVsZVtcXFwic2V0VmFsdWVcXFwiXSkgX01vZHVsZVtcXFwic2V0VmFsdWVcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidzZXRWYWx1ZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJnZXRWYWx1ZVxcXCJdKSBfTW9kdWxlW1xcXCJnZXRWYWx1ZVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ2dldFZhbHVlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcImFsbG9jYXRlXFxcIl0pIF9Nb2R1bGVbXFxcImFsbG9jYXRlXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInYWxsb2NhdGUnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwiZ2V0TWVtb3J5XFxcIl0pIF9Nb2R1bGVbXFxcImdldE1lbW9yeVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ2dldE1lbW9yeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwiUG9pbnRlcl9zdHJpbmdpZnlcXFwiXSkgX01vZHVsZVtcXFwiUG9pbnRlcl9zdHJpbmdpZnlcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidQb2ludGVyX3N0cmluZ2lmeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJBc2NpaVRvU3RyaW5nXFxcIl0pIF9Nb2R1bGVbXFxcIkFzY2lpVG9TdHJpbmdcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidBc2NpaVRvU3RyaW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcInN0cmluZ1RvQXNjaWlcXFwiXSkgX01vZHVsZVtcXFwic3RyaW5nVG9Bc2NpaVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ3N0cmluZ1RvQXNjaWknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwiVVRGOEFycmF5VG9TdHJpbmdcXFwiXSkgX01vZHVsZVtcXFwiVVRGOEFycmF5VG9TdHJpbmdcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidVVEY4QXJyYXlUb1N0cmluZycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJVVEY4VG9TdHJpbmdcXFwiXSkgX01vZHVsZVtcXFwiVVRGOFRvU3RyaW5nXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInVVRGOFRvU3RyaW5nJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcInN0cmluZ1RvVVRGOEFycmF5XFxcIl0pIF9Nb2R1bGVbXFxcInN0cmluZ1RvVVRGOEFycmF5XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInc3RyaW5nVG9VVEY4QXJyYXknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwic3RyaW5nVG9VVEY4XFxcIl0pIF9Nb2R1bGVbXFxcInN0cmluZ1RvVVRGOFxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ3N0cmluZ1RvVVRGOCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJsZW5ndGhCeXRlc1VURjhcXFwiXSkgX01vZHVsZVtcXFwibGVuZ3RoQnl0ZXNVVEY4XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInbGVuZ3RoQnl0ZXNVVEY4JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcIlVURjE2VG9TdHJpbmdcXFwiXSkgX01vZHVsZVtcXFwiVVRGMTZUb1N0cmluZ1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ1VURjE2VG9TdHJpbmcnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwic3RyaW5nVG9VVEYxNlxcXCJdKSBfTW9kdWxlW1xcXCJzdHJpbmdUb1VURjE2XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInc3RyaW5nVG9VVEYxNicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJsZW5ndGhCeXRlc1VURjE2XFxcIl0pIF9Nb2R1bGVbXFxcImxlbmd0aEJ5dGVzVVRGMTZcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidsZW5ndGhCeXRlc1VURjE2JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcIlVURjMyVG9TdHJpbmdcXFwiXSkgX01vZHVsZVtcXFwiVVRGMzJUb1N0cmluZ1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ1VURjMyVG9TdHJpbmcnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwic3RyaW5nVG9VVEYzMlxcXCJdKSBfTW9kdWxlW1xcXCJzdHJpbmdUb1VURjMyXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInc3RyaW5nVG9VVEYzMicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJsZW5ndGhCeXRlc1VURjMyXFxcIl0pIF9Nb2R1bGVbXFxcImxlbmd0aEJ5dGVzVVRGMzJcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidsZW5ndGhCeXRlc1VURjMyJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcImFsbG9jYXRlVVRGOFxcXCJdKSBfTW9kdWxlW1xcXCJhbGxvY2F0ZVVURjhcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidhbGxvY2F0ZVVURjgnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwic3RhY2tUcmFjZVxcXCJdKSBfTW9kdWxlW1xcXCJzdGFja1RyYWNlXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInc3RhY2tUcmFjZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJhZGRPblByZVJ1blxcXCJdKSBfTW9kdWxlW1xcXCJhZGRPblByZVJ1blxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ2FkZE9uUHJlUnVuJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcImFkZE9uSW5pdFxcXCJdKSBfTW9kdWxlW1xcXCJhZGRPbkluaXRcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidhZGRPbkluaXQnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwiYWRkT25QcmVNYWluXFxcIl0pIF9Nb2R1bGVbXFxcImFkZE9uUHJlTWFpblxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ2FkZE9uUHJlTWFpbicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJhZGRPbkV4aXRcXFwiXSkgX01vZHVsZVtcXFwiYWRkT25FeGl0XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInYWRkT25FeGl0JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcImFkZE9uUG9zdFJ1blxcXCJdKSBfTW9kdWxlW1xcXCJhZGRPblBvc3RSdW5cXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidhZGRPblBvc3RSdW4nIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwid3JpdGVTdHJpbmdUb01lbW9yeVxcXCJdKSBfTW9kdWxlW1xcXCJ3cml0ZVN0cmluZ1RvTWVtb3J5XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInd3JpdGVTdHJpbmdUb01lbW9yeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJ3cml0ZUFycmF5VG9NZW1vcnlcXFwiXSkgX01vZHVsZVtcXFwid3JpdGVBcnJheVRvTWVtb3J5XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInd3JpdGVBcnJheVRvTWVtb3J5JyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcIndyaXRlQXNjaWlUb01lbW9yeVxcXCJdKSBfTW9kdWxlW1xcXCJ3cml0ZUFzY2lpVG9NZW1vcnlcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIid3cml0ZUFzY2lpVG9NZW1vcnknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwiYWRkUnVuRGVwZW5kZW5jeVxcXCJdKSBfTW9kdWxlW1xcXCJhZGRSdW5EZXBlbmRlbmN5XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInYWRkUnVuRGVwZW5kZW5jeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwicmVtb3ZlUnVuRGVwZW5kZW5jeVxcXCJdKSBfTW9kdWxlW1xcXCJyZW1vdmVSdW5EZXBlbmRlbmN5XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCIncmVtb3ZlUnVuRGVwZW5kZW5jeScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXMgRk9SQ0VfRklMRVNZU1RFTT0xKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwiRlNcXFwiXSkgX01vZHVsZVtcXFwiRlNcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidGUycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJGU19jcmVhdGVGb2xkZXJcXFwiXSkgX01vZHVsZVtcXFwiRlNfY3JlYXRlRm9sZGVyXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInRlNfY3JlYXRlRm9sZGVyJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJGU19jcmVhdGVQYXRoXFxcIl0pIF9Nb2R1bGVbXFxcIkZTX2NyZWF0ZVBhdGhcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidGU19jcmVhdGVQYXRoJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJGU19jcmVhdGVEYXRhRmlsZVxcXCJdKSBfTW9kdWxlW1xcXCJGU19jcmVhdGVEYXRhRmlsZVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ0ZTX2NyZWF0ZURhdGFGaWxlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJGU19jcmVhdGVQcmVsb2FkZWRGaWxlXFxcIl0pIF9Nb2R1bGVbXFxcIkZTX2NyZWF0ZVByZWxvYWRlZEZpbGVcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidGU19jcmVhdGVQcmVsb2FkZWRGaWxlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJGU19jcmVhdGVMYXp5RmlsZVxcXCJdKSBfTW9kdWxlW1xcXCJGU19jcmVhdGVMYXp5RmlsZVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ0ZTX2NyZWF0ZUxhenlGaWxlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJGU19jcmVhdGVMaW5rXFxcIl0pIF9Nb2R1bGVbXFxcIkZTX2NyZWF0ZUxpbmtcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidGU19jcmVhdGVMaW5rJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJGU19jcmVhdGVEZXZpY2VcXFwiXSkgX01vZHVsZVtcXFwiRlNfY3JlYXRlRGV2aWNlXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInRlNfY3JlYXRlRGV2aWNlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJGU191bmxpbmtcXFwiXSkgX01vZHVsZVtcXFwiRlNfdW5saW5rXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInRlNfdW5saW5rJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSkuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtcyBGT1JDRV9GSUxFU1lTVEVNPTEpIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJHTFxcXCJdKSBfTW9kdWxlW1xcXCJHTFxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ0dMJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcInN0YXRpY0FsbG9jXFxcIl0pIF9Nb2R1bGVbXFxcInN0YXRpY0FsbG9jXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInc3RhdGljQWxsb2MnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwiZHluYW1pY0FsbG9jXFxcIl0pIF9Nb2R1bGVbXFxcImR5bmFtaWNBbGxvY1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ2R5bmFtaWNBbGxvYycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJ3YXJuT25jZVxcXCJdKSBfTW9kdWxlW1xcXCJ3YXJuT25jZVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ3dhcm5PbmNlJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcImxvYWREeW5hbWljTGlicmFyeVxcXCJdKSBfTW9kdWxlW1xcXCJsb2FkRHluYW1pY0xpYnJhcnlcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidsb2FkRHluYW1pY0xpYnJhcnknIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwibG9hZFdlYkFzc2VtYmx5TW9kdWxlXFxcIl0pIF9Nb2R1bGVbXFxcImxvYWRXZWJBc3NlbWJseU1vZHVsZVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ2xvYWRXZWJBc3NlbWJseU1vZHVsZScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJnZXRMRUJcXFwiXSkgX01vZHVsZVtcXFwiZ2V0TEVCXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInZ2V0TEVCJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcImdldEZ1bmN0aW9uVGFibGVzXFxcIl0pIF9Nb2R1bGVbXFxcImdldEZ1bmN0aW9uVGFibGVzXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInZ2V0RnVuY3Rpb25UYWJsZXMnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwiYWxpZ25GdW5jdGlvblRhYmxlc1xcXCJdKSBfTW9kdWxlW1xcXCJhbGlnbkZ1bmN0aW9uVGFibGVzXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInYWxpZ25GdW5jdGlvblRhYmxlcycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJyZWdpc3RlckZ1bmN0aW9uc1xcXCJdKSBfTW9kdWxlW1xcXCJyZWdpc3RlckZ1bmN0aW9uc1xcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ3JlZ2lzdGVyRnVuY3Rpb25zJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcImFkZEZ1bmN0aW9uXFxcIl0pIF9Nb2R1bGVbXFxcImFkZEZ1bmN0aW9uXFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInYWRkRnVuY3Rpb24nIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwicmVtb3ZlRnVuY3Rpb25cXFwiXSkgX01vZHVsZVtcXFwicmVtb3ZlRnVuY3Rpb25cXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidyZW1vdmVGdW5jdGlvbicgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJnZXRGdW5jV3JhcHBlclxcXCJdKSBfTW9kdWxlW1xcXCJnZXRGdW5jV3JhcHBlclxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ2dldEZ1bmNXcmFwcGVyJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcInByZXR0eVByaW50XFxcIl0pIF9Nb2R1bGVbXFxcInByZXR0eVByaW50XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCIncHJldHR5UHJpbnQnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwibWFrZUJpZ0ludFxcXCJdKSBfTW9kdWxlW1xcXCJtYWtlQmlnSW50XFxcIl0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGFib3J0KFxcXCInbWFrZUJpZ0ludCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJkeW5DYWxsXFxcIl0pIF9Nb2R1bGVbXFxcImR5bkNhbGxcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidkeW5DYWxsJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcImdldENvbXBpbGVyU2V0dGluZ1xcXCJdKSBfTW9kdWxlW1xcXCJnZXRDb21waWxlclNldHRpbmdcXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgYWJvcnQoXFxcIidnZXRDb21waWxlclNldHRpbmcnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgfTtcXG4gIGlmICghX01vZHVsZVtcXFwiaW50QXJyYXlGcm9tQmFzZTY0XFxcIl0pIF9Nb2R1bGVbXFxcImludEFycmF5RnJvbUJhc2U2NFxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ2ludEFycmF5RnJvbUJhc2U2NCcgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICB9O1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJ0cnlQYXJzZUFzRGF0YVVSSVxcXCJdKSBfTW9kdWxlW1xcXCJ0cnlQYXJzZUFzRGF0YVVSSVxcXCJdID0gZnVuY3Rpb24gKCkge1xcbiAgICBhYm9ydChcXFwiJ3RyeVBhcnNlQXNEYXRhVVJJJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gIH07XFxuICBpZiAoIV9Nb2R1bGVbXFxcIkFMTE9DX05PUk1BTFxcXCJdKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoX01vZHVsZSwgXFxcIkFMTE9DX05PUk1BTFxcXCIsIHtcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgYWJvcnQoXFxcIidBTExPQ19OT1JNQUwnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgICB9XFxuICB9KTtcXG4gIGlmICghX01vZHVsZVtcXFwiQUxMT0NfU1RBQ0tcXFwiXSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9Nb2R1bGUsIFxcXCJBTExPQ19TVEFDS1xcXCIsIHtcXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgYWJvcnQoXFxcIidBTExPQ19TVEFDSycgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICAgIH1cXG4gIH0pO1xcbiAgaWYgKCFfTW9kdWxlW1xcXCJBTExPQ19TVEFUSUNcXFwiXSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9Nb2R1bGUsIFxcXCJBTExPQ19TVEFUSUNcXFwiLCB7XFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIGFib3J0KFxcXCInQUxMT0NfU1RBVElDJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhUUkFfRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcXFwiKTtcXG4gICAgfVxcbiAgfSk7XFxuICBpZiAoIV9Nb2R1bGVbXFxcIkFMTE9DX0RZTkFNSUNcXFwiXSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9Nb2R1bGUsIFxcXCJBTExPQ19EWU5BTUlDXFxcIiwge1xcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcXG4gICAgICBhYm9ydChcXFwiJ0FMTE9DX0RZTkFNSUMnIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFRSQV9FWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVxcXCIpO1xcbiAgICB9XFxuICB9KTtcXG4gIGlmICghX01vZHVsZVtcXFwiQUxMT0NfTk9ORVxcXCJdKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoX01vZHVsZSwgXFxcIkFMTE9DX05PTkVcXFwiLCB7XFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xcbiAgICAgIGFib3J0KFxcXCInQUxMT0NfTk9ORScgd2FzIG5vdCBleHBvcnRlZC4gYWRkIGl0IHRvIEVYVFJBX0VYUE9SVEVEX1JVTlRJTUVfTUVUSE9EUyAoc2VlIHRoZSBGQVEpXFxcIik7XFxuICAgIH1cXG4gIH0pOyAvLyBNb2R1bGFyaXplIG1vZGUgcmV0dXJucyBhIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgY2FsbGVkIHRvXFxuICAvLyBjcmVhdGUgaW5zdGFuY2VzLiBUaGUgaW5zdGFuY2VzIHByb3ZpZGUgYSB0aGVuKCkgbWV0aG9kLFxcbiAgLy8gbXVzdCBsaWtlIGEgUHJvbWlzZSwgdGhhdCByZWNlaXZlcyBhIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2tcXG4gIC8vIGlzIGNhbGxlZCB3aGVuIHRoZSBtb2R1bGUgaXMgcmVhZHkgdG8gcnVuLCB3aXRoIHRoZSBtb2R1bGVcXG4gIC8vIGFzIGEgcGFyYW1ldGVyLiAoTGlrZSBhIFByb21pc2UsIGl0IGFsc28gcmV0dXJucyB0aGUgbW9kdWxlXFxuICAvLyBzbyB5b3UgY2FuIHVzZSB0aGUgb3V0cHV0IG9mIC50aGVuKC4uKSkuXFxuXFxuICBfTW9kdWxlWyd0aGVuJ10gPSBmdW5jdGlvbiAoZnVuYykge1xcbiAgICAvLyBXZSBtYXkgYWxyZWFkeSBiZSByZWFkeSB0byBydW4gY29kZSBhdCB0aGlzIHRpbWUuIGlmXFxuICAgIC8vIHNvLCBqdXN0IHF1ZXVlIGEgY2FsbCB0byB0aGUgY2FsbGJhY2suXFxuICAgIGlmIChfTW9kdWxlWydjYWxsZWRSdW4nXSkge1xcbiAgICAgIGZ1bmMoX01vZHVsZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gd2UgYXJlIG5vdCByZWFkeSB0byBjYWxsIHRoZW4oKSB5ZXQuIHdlIG11c3QgY2FsbCBpdFxcbiAgICAgIC8vIGF0IHRoZSBzYW1lIHRpbWUgd2Ugd291bGQgY2FsbCBvblJ1bnRpbWVJbml0aWFsaXplZC5cXG4gICAgICB2YXIgb2xkID0gX01vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXTtcXG5cXG4gICAgICBfTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKG9sZCkgb2xkKCk7XFxuICAgICAgICBmdW5jKF9Nb2R1bGUpO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIF9Nb2R1bGU7XFxuICB9O1xcbiAgLyoqXFxyXFxuICAgKiBAY29uc3RydWN0b3JcXHJcXG4gICAqIEBleHRlbmRzIHtFcnJvcn1cXHJcXG4gICAqIEB0aGlzIHtFeGl0U3RhdHVzfVxcclxcbiAgICovXFxuXFxuXFxuICBmdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cykge1xcbiAgICB0aGlzLm5hbWUgPSBcXFwiRXhpdFN0YXR1c1xcXCI7XFxuICAgIHRoaXMubWVzc2FnZSA9IFxcXCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFxcXCIgKyBzdGF0dXMgKyBcXFwiKVxcXCI7XFxuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xcbiAgfVxcblxcbiAgO1xcbiAgRXhpdFN0YXR1cy5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcXG4gIEV4aXRTdGF0dXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhpdFN0YXR1cztcXG4gIHZhciBpbml0aWFsU3RhY2tUb3A7XFxuICB2YXIgY2FsbGVkTWFpbiA9IGZhbHNlO1xcblxcbiAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkge1xcbiAgICAvLyBJZiBydW4gaGFzIG5ldmVyIGJlZW4gY2FsbGVkLCBhbmQgd2Ugc2hvdWxkIGNhbGwgcnVuIChJTlZPS0VfUlVOIGlzIHRydWUsIGFuZCBNb2R1bGUubm9Jbml0aWFsUnVuIGlzIG5vdCBmYWxzZSlcXG4gICAgaWYgKCFfTW9kdWxlWydjYWxsZWRSdW4nXSkgcnVuKCk7XFxuICAgIGlmICghX01vZHVsZVsnY2FsbGVkUnVuJ10pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjsgLy8gdHJ5IHRoaXMgYWdhaW4gbGF0ZXIsIGFmdGVyIG5ldyBkZXBzIGFyZSBmdWxmaWxsZWRcXG4gIH07XFxuICAvKiogQHR5cGUge2Z1bmN0aW9uKEFycmF5PSl9ICovXFxuXFxuXFxuICBmdW5jdGlvbiBydW4oYXJncykge1xcbiAgICBhcmdzID0gYXJncyB8fCBfTW9kdWxlWydhcmd1bWVudHMnXTtcXG5cXG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgd3JpdGVTdGFja0Nvb2tpZSgpO1xcbiAgICBwcmVSdW4oKTtcXG4gICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHJldHVybjsgLy8gYSBwcmVSdW4gYWRkZWQgYSBkZXBlbmRlbmN5LCBydW4gd2lsbCBiZSBjYWxsZWQgbGF0ZXJcXG5cXG4gICAgaWYgKF9Nb2R1bGVbJ2NhbGxlZFJ1biddKSByZXR1cm47IC8vIHJ1biBtYXkgaGF2ZSBqdXN0IGJlZW4gY2FsbGVkIHRocm91Z2ggZGVwZW5kZW5jaWVzIGJlaW5nIGZ1bGZpbGxlZCBqdXN0IGluIHRoaXMgdmVyeSBmcmFtZVxcblxcbiAgICBmdW5jdGlvbiBkb1J1bigpIHtcXG4gICAgICBpZiAoX01vZHVsZVsnY2FsbGVkUnVuJ10pIHJldHVybjsgLy8gcnVuIG1heSBoYXZlIGp1c3QgYmVlbiBjYWxsZWQgd2hpbGUgdGhlIGFzeW5jIHNldFN0YXR1cyB0aW1lIGJlbG93IHdhcyBoYXBwZW5pbmdcXG5cXG4gICAgICBfTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XFxuICAgICAgaWYgKEFCT1JUKSByZXR1cm47XFxuICAgICAgZW5zdXJlSW5pdFJ1bnRpbWUoKTtcXG4gICAgICBwcmVNYWluKCk7XFxuICAgICAgaWYgKF9Nb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10pIF9Nb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10oKTtcXG4gICAgICBhc3NlcnQoIV9Nb2R1bGVbJ19tYWluJ10sICdjb21waWxlZCB3aXRob3V0IGEgbWFpbiwgYnV0IG9uZSBpcyBwcmVzZW50LiBpZiB5b3UgYWRkZWQgaXQgZnJvbSBKUywgdXNlIE1vZHVsZVtcXFwib25SdW50aW1lSW5pdGlhbGl6ZWRcXFwiXScpO1xcbiAgICAgIHBvc3RSdW4oKTtcXG4gICAgfVxcblxcbiAgICBpZiAoX01vZHVsZVsnc2V0U3RhdHVzJ10pIHtcXG4gICAgICBfTW9kdWxlWydzZXRTdGF0dXMnXSgnUnVubmluZy4uLicpO1xcblxcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF9Nb2R1bGVbJ3NldFN0YXR1cyddKCcnKTtcXG4gICAgICAgIH0sIDEpO1xcbiAgICAgICAgZG9SdW4oKTtcXG4gICAgICB9LCAxKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBkb1J1bigpO1xcbiAgICB9XFxuXFxuICAgIGNoZWNrU3RhY2tDb29raWUoKTtcXG4gIH1cXG5cXG4gIF9Nb2R1bGVbJ3J1biddID0gcnVuO1xcblxcbiAgZnVuY3Rpb24gY2hlY2tVbmZsdXNoZWRDb250ZW50KCkge1xcbiAgICAvLyBDb21waWxlciBzZXR0aW5ncyBkbyBub3QgYWxsb3cgZXhpdGluZyB0aGUgcnVudGltZSwgc28gZmx1c2hpbmdcXG4gICAgLy8gdGhlIHN0cmVhbXMgaXMgbm90IHBvc3NpYmxlLiBidXQgaW4gQVNTRVJUSU9OUyBtb2RlIHdlIGNoZWNrXFxuICAgIC8vIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgdG8gZmx1c2gsIGFuZCBpZiBzbyB0ZWxsIHRoZSB1c2VyIHRoZXlcXG4gICAgLy8gc2hvdWxkIHJlcXVlc3QgdGhhdCB0aGUgcnVudGltZSBiZSBleGl0YWJsZS5cXG4gICAgLy8gTm9ybWFsbHkgd2Ugd291bGQgbm90IGV2ZW4gaW5jbHVkZSBmbHVzaCgpIGF0IGFsbCwgYnV0IGluIEFTU0VSVElPTlNcXG4gICAgLy8gYnVpbGRzIHdlIGRvIHNvIGp1c3QgZm9yIHRoaXMgY2hlY2ssIGFuZCBoZXJlIHdlIHNlZSBpZiB0aGVyZSBpcyBhbnlcXG4gICAgLy8gY29udGVudCB0byBmbHVzaCwgdGhhdCBpcywgd2UgY2hlY2sgaWYgdGhlcmUgd291bGQgaGF2ZSBiZWVuXFxuICAgIC8vIHNvbWV0aGluZyBhIG5vbi1BU1NFUlRJT05TIGJ1aWxkIHdvdWxkIGhhdmUgbm90IHNlZW4uXFxuICAgIC8vIEhvdyB3ZSBmbHVzaCB0aGUgc3RyZWFtcyBkZXBlbmRzIG9uIHdoZXRoZXIgd2UgYXJlIGluIE5PX0ZJTEVTWVNURU1cXG4gICAgLy8gbW9kZSAod2hpY2ggaGFzIGl0cyBvd24gc3BlY2lhbCBmdW5jdGlvbiBmb3IgdGhpczsgb3RoZXJ3aXNlLCBhbGxcXG4gICAgLy8gdGhlIGNvZGUgaXMgaW5zaWRlIGxpYmMpXFxuICAgIHZhciBwcmludCA9IF9Nb2R1bGVbJ3ByaW50J107XFxuICAgIHZhciBwcmludEVyciA9IF9Nb2R1bGVbJ3ByaW50RXJyJ107XFxuICAgIHZhciBoYXMgPSBmYWxzZTtcXG5cXG4gICAgX01vZHVsZVsncHJpbnQnXSA9IF9Nb2R1bGVbJ3ByaW50RXJyJ10gPSBmdW5jdGlvbiAoeCkge1xcbiAgICAgIGhhcyA9IHRydWU7XFxuICAgIH07XFxuXFxuICAgIHRyeSB7XFxuICAgICAgLy8gaXQgZG9lc24ndCBtYXR0ZXIgaWYgaXQgZmFpbHNcXG4gICAgICB2YXIgZmx1c2ggPSBmbHVzaF9OT19GSUxFU1lTVEVNO1xcbiAgICAgIGlmIChmbHVzaCkgZmx1c2goMCk7XFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxuXFxuICAgIF9Nb2R1bGVbJ3ByaW50J10gPSBwcmludDtcXG4gICAgX01vZHVsZVsncHJpbnRFcnInXSA9IHByaW50RXJyO1xcblxcbiAgICBpZiAoaGFzKSB7XFxuICAgICAgd2Fybk9uY2UoJ3N0ZGlvIHN0cmVhbXMgaGFkIGNvbnRlbnQgaW4gdGhlbSB0aGF0IHdhcyBub3QgZmx1c2hlZC4geW91IHNob3VsZCBzZXQgTk9fRVhJVF9SVU5USU1FIHRvIDAgKHNlZSB0aGUgRkFRKSwgb3IgbWFrZSBzdXJlIHRvIGVtaXQgYSBuZXdsaW5lIHdoZW4geW91IHByaW50ZiBldGMuJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGV4aXQoc3RhdHVzLCBpbXBsaWNpdCkge1xcbiAgICBjaGVja1VuZmx1c2hlZENvbnRlbnQoKTsgLy8gaWYgdGhpcyBpcyBqdXN0IG1haW4gZXhpdC1pbmcgaW1wbGljaXRseSwgYW5kIHRoZSBzdGF0dXMgaXMgMCwgdGhlbiB3ZVxcbiAgICAvLyBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGhlcmUgYW5kIGNhbiBqdXN0IGxlYXZlLiBpZiB0aGUgc3RhdHVzIGlzXFxuICAgIC8vIG5vbi16ZXJvLCB0aG91Z2gsIHRoZW4gd2UgbmVlZCB0byByZXBvcnQgaXQuXFxuICAgIC8vICh3ZSBtYXkgaGF2ZSB3YXJuZWQgYWJvdXQgdGhpcyBlYXJsaWVyLCBpZiBhIHNpdHVhdGlvbiBqdXN0aWZpZXMgZG9pbmcgc28pXFxuXFxuICAgIGlmIChpbXBsaWNpdCAmJiBfTW9kdWxlWydub0V4aXRSdW50aW1lJ10gJiYgc3RhdHVzID09PSAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChfTW9kdWxlWydub0V4aXRSdW50aW1lJ10pIHtcXG4gICAgICAvLyBpZiBleGl0KCkgd2FzIGNhbGxlZCwgd2UgbWF5IHdhcm4gdGhlIHVzZXIgaWYgdGhlIHJ1bnRpbWUgaXNuJ3QgYWN0dWFsbHkgYmVpbmcgc2h1dCBkb3duXFxuICAgICAgaWYgKCFpbXBsaWNpdCkge1xcbiAgICAgICAgX01vZHVsZS5wcmludEVycignZXhpdCgnICsgc3RhdHVzICsgJykgY2FsbGVkLCBidXQgTk9fRVhJVF9SVU5USU1FIGlzIHNldCwgc28gaGFsdGluZyBleGVjdXRpb24gYnV0IG5vdCBleGl0aW5nIHRoZSBydW50aW1lIG9yIHByZXZlbnRpbmcgZnVydGhlciBhc3luYyBleGVjdXRpb24gKGJ1aWxkIHdpdGggTk9fRVhJVF9SVU5USU1FPTAsIGlmIHlvdSB3YW50IGEgdHJ1ZSBzaHV0ZG93biknKTtcXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgQUJPUlQgPSB0cnVlO1xcbiAgICAgIEVYSVRTVEFUVVMgPSBzdGF0dXM7XFxuICAgICAgU1RBQ0tUT1AgPSBpbml0aWFsU3RhY2tUb3A7XFxuICAgICAgZXhpdFJ1bnRpbWUoKTtcXG4gICAgICBpZiAoX01vZHVsZVsnb25FeGl0J10pIF9Nb2R1bGVbJ29uRXhpdCddKHN0YXR1cyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKEVOVklST05NRU5UX0lTX05PREUpIHtcXG4gICAgICBwcm9jZXNzWydleGl0J10oc3RhdHVzKTtcXG4gICAgfVxcblxcbiAgICBfTW9kdWxlWydxdWl0J10oc3RhdHVzLCBuZXcgRXhpdFN0YXR1cyhzdGF0dXMpKTtcXG4gIH1cXG5cXG4gIF9Nb2R1bGVbJ2V4aXQnXSA9IGV4aXQ7XFxuICB2YXIgYWJvcnREZWNvcmF0b3JzID0gW107XFxuXFxuICBmdW5jdGlvbiBhYm9ydCh3aGF0KSB7XFxuICAgIGlmIChfTW9kdWxlWydvbkFib3J0J10pIHtcXG4gICAgICBfTW9kdWxlWydvbkFib3J0J10od2hhdCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHdoYXQgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIF9Nb2R1bGUucHJpbnQod2hhdCk7XFxuXFxuICAgICAgX01vZHVsZS5wcmludEVycih3aGF0KTtcXG5cXG4gICAgICB3aGF0ID0gSlNPTi5zdHJpbmdpZnkod2hhdCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgd2hhdCA9ICcnO1xcbiAgICB9XFxuXFxuICAgIEFCT1JUID0gdHJ1ZTtcXG4gICAgRVhJVFNUQVRVUyA9IDE7XFxuICAgIHZhciBleHRyYSA9ICcnO1xcbiAgICB2YXIgb3V0cHV0ID0gJ2Fib3J0KCcgKyB3aGF0ICsgJykgYXQgJyArIHN0YWNrVHJhY2UoKSArIGV4dHJhO1xcblxcbiAgICBpZiAoYWJvcnREZWNvcmF0b3JzKSB7XFxuICAgICAgYWJvcnREZWNvcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGRlY29yYXRvcikge1xcbiAgICAgICAgb3V0cHV0ID0gZGVjb3JhdG9yKG91dHB1dCwgd2hhdCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgdGhyb3cgb3V0cHV0O1xcbiAgfVxcblxcbiAgX01vZHVsZVsnYWJvcnQnXSA9IGFib3J0OyAvLyB7e1BSRV9SVU5fQURESVRJT05TfX1cXG5cXG4gIGlmIChfTW9kdWxlWydwcmVJbml0J10pIHtcXG4gICAgaWYgKHR5cGVvZiBfTW9kdWxlWydwcmVJbml0J10gPT0gJ2Z1bmN0aW9uJykgX01vZHVsZVsncHJlSW5pdCddID0gW19Nb2R1bGVbJ3ByZUluaXQnXV07XFxuXFxuICAgIHdoaWxlIChfTW9kdWxlWydwcmVJbml0J10ubGVuZ3RoID4gMCkge1xcbiAgICAgIF9Nb2R1bGVbJ3ByZUluaXQnXS5wb3AoKSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBfTW9kdWxlW1xcXCJub0V4aXRSdW50aW1lXFxcIl0gPSB0cnVlO1xcbiAgcnVuKCk7IC8vIHt7UE9TVF9SVU5fQURESVRJT05TfX1cXG4gIC8vIHt7TU9EVUxFX0FERElUSU9OU319XFxuXFxuICByZXR1cm4gX01vZHVsZTtcXG59O1xcblxcbmlmICgoIGZhbHNlID8gdW5kZWZpbmVkIDogX3R5cGVvZihleHBvcnRzKSkgPT09ICdvYmplY3QnICYmICggZmFsc2UgPyB1bmRlZmluZWQgOiBfdHlwZW9mKG1vZHVsZSkpID09PSAnb2JqZWN0JykgbW9kdWxlLmV4cG9ydHMgPSBNb2R1bGU7ZWxzZSBpZiAodHJ1ZSkgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gW10sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBNb2R1bGU7XFxufSkuYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyksXFxuXFx0XFx0XFx0XFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO2Vsc2Uge31cXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi8uLi9pb3RhLXBpY28tbGliLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanMgKi8gXFxcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcXFwiKShtb2R1bGUpKSlcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2FzbS93YXNtL2lvdGEtcGljby1wb3ctd2FzbS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX19leHBvcnQobSkge1xcbiAgZm9yICh2YXIgcCBpbiBtKSB7XFxuICAgIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XFxuICB9XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogQ29tYmluZWQgaW5kZXggb2YgYWxsIHRoZSBtb2R1bGVzLlxcclxcbiAqL1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcHJvb2ZPZldvcmtXZWJHbCAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3Byb29mT2ZXb3JrV2ViR2wuanNcXFwiKSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3QvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3QvcGVhcmxEaXZlci9wZWFybERpdmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3BlYXJsRGl2ZXIvcGVhcmxEaXZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX3JlZ2VuZXJhdG9yUnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IHN0ZXAoXFxcIm5leHRcXFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBzdGVwKFxcXCJ0aHJvd1xcXCIsIGVycik7IH0gX25leHQoKTsgfSk7IH07IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcXG4gICAgXFxcImRlZmF1bHRcXFwiOiBtb2RcXG4gIH07XFxufTtcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcblxcbnZhciBvYmplY3RIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvb2JqZWN0SGVscGVyLmpzXFxcIik7XFxuXFxudmFyIHNwb25nZUZhY3RvcnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZmFjdG9yaWVzL3Nwb25nZUZhY3RvcnkgKi8gXFxcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9mYWN0b3JpZXMvc3BvbmdlRmFjdG9yeS5qc1xcXCIpO1xcblxcbnZhciB0cml0c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9kYXRhL2Rpc3QvZGF0YS90cml0cyAqLyBcXFwiLi4vaW90YS1waWNvLWRhdGEvZGlzdC9kYXRhL3RyaXRzLmpzXFxcIik7XFxuXFxudmFyIGFkZF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NoYWRlcnMvYWRkICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9hZGQuanNcXFwiKSk7XFxuXFxudmFyIGNoZWNrQ29sXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2hhZGVycy9jaGVja0NvbCAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3NoYWRlcnMvY2hlY2tDb2wuanNcXFwiKSk7XFxuXFxudmFyIGNoZWNrRG9fMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zaGFkZXJzL2NoZWNrRG8gKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2NoZWNrRG8uanNcXFwiKSk7XFxuXFxudmFyIGNoZWNrS18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NoYWRlcnMvY2hlY2tLICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9jaGVja0suanNcXFwiKSk7XFxuXFxudmFyIGZpbmFsaXplXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vc2hhZGVycy9maW5hbGl6ZSAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3NoYWRlcnMvZmluYWxpemUuanNcXFwiKSk7XFxuXFxudmFyIGhlYWRlcnNfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zaGFkZXJzL2hlYWRlcnMgKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2hlYWRlcnMuanNcXFwiKSk7XFxuXFxudmFyIGluY3JlbWVudF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NoYWRlcnMvaW5jcmVtZW50ICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9pbmNyZW1lbnQuanNcXFwiKSk7XFxuXFxudmFyIGluaXRfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9zaGFkZXJzL2luaXQgKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2luaXQuanNcXFwiKSk7XFxuXFxudmFyIHRyYW5zZm9ybV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3NoYWRlcnMvdHJhbnNmb3JtICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy90cmFuc2Zvcm0uanNcXFwiKSk7XFxuXFxudmFyIHdlYkdMV29ya2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi93ZWJHTC93ZWJHTFdvcmtlciAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3dlYkdML3dlYkdMV29ya2VyLmpzXFxcIik7XFxuXFxudmFyIHBlYXJsRGl2ZXJTdGF0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wZWFybERpdmVyU3RhdGUgKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9wZWFybERpdmVyL3BlYXJsRGl2ZXJTdGF0ZS5qc1xcXCIpO1xcbi8qKlxcclxcbiAqIFBlYXJsRGl2ZXIuXFxyXFxuICogQ29udmVydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2lvdGFsZWRnZXIvY3VybC5saWIuanMvYmxvYi9tYXN0ZXIvc3JjL3BlYXJsZGl2ZXIuanNcXHJcXG4gKi9cXG5cXG5cXG52YXIgUGVhcmxEaXZlciA9XFxuLyojX19QVVJFX18qL1xcbmZ1bmN0aW9uICgpIHtcXG4gIC8qIEBpbnRlcm5hbCAqL1xcbiAgZnVuY3Rpb24gUGVhcmxEaXZlcih3ZWJHTFBsYXRmb3JtKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQZWFybERpdmVyKTtcXG5cXG4gICAgdGhpcy5fd2ViR0xXb3JrZXIgPSBuZXcgd2ViR0xXb3JrZXJfMS5XZWJHTFdvcmtlcigpO1xcbiAgICB2YXIgY3VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFxcXCJjdXJsXFxcIik7XFxuICAgIHZhciBjdXJsQ29uc3RhbnRzID0gY3VybC5nZXRDb25zdGFudHMoKTtcXG4gICAgdGhpcy5faGFzaExlbmd0aCA9IGN1cmxDb25zdGFudHMuSEFTSF9MRU5HVEg7XFxuICAgIHRoaXMuX3N0YXRlTGVuZ3RoID0gY3VybENvbnN0YW50cy5TVEFURV9MRU5HVEg7XFxuICAgIHRoaXMuX251bWJlclJvdW5kcyA9IGN1cmxDb25zdGFudHMuTlVNQkVSX09GX1JPVU5EUztcXG4gICAgdGhpcy5fdHJhbnNhY3Rpb25MZW5ndGggPSB0aGlzLl9oYXNoTGVuZ3RoICogMzM7XFxuICAgIHRoaXMuX25vbmNlTGVuZ3RoID0gdGhpcy5faGFzaExlbmd0aCAvIDM7XFxuICAgIHRoaXMuX25vbmNlU3RhcnQgPSB0aGlzLl9oYXNoTGVuZ3RoIC0gdGhpcy5fbm9uY2VMZW5ndGg7XFxuXFxuICAgIHRoaXMuX3dlYkdMV29ya2VyLmluaXRpYWxpemUod2ViR0xQbGF0Zm9ybSwgdGhpcy5fc3RhdGVMZW5ndGggKyAxLCBQZWFybERpdmVyLlRFWEVMX1NJWkUpO1xcblxcbiAgICB0aGlzLl9jdXJyZW50QnVmZmVyID0gdGhpcy5fd2ViR0xXb3JrZXIuZ2V0SXB0KCkuZGF0YTtcXG5cXG4gICAgdGhpcy5fd2ViR0xXb3JrZXIuYWRkUHJvZ3JhbShcXFwiaW5pdFxcXCIsIGhlYWRlcnNfMS5kZWZhdWx0ICsgYWRkXzEuZGVmYXVsdCArIGluaXRfMS5kZWZhdWx0LCBcXFwiZ3Jfb2Zmc2V0XFxcIik7XFxuXFxuICAgIHRoaXMuX3dlYkdMV29ya2VyLmFkZFByb2dyYW0oXFxcImluY3JlbWVudFxcXCIsIGhlYWRlcnNfMS5kZWZhdWx0ICsgYWRkXzEuZGVmYXVsdCArIGluY3JlbWVudF8xLmRlZmF1bHQpO1xcblxcbiAgICB0aGlzLl93ZWJHTFdvcmtlci5hZGRQcm9ncmFtKFxcXCJ0d2lzdFxcXCIsIGhlYWRlcnNfMS5kZWZhdWx0ICsgdHJhbnNmb3JtXzEuZGVmYXVsdCk7XFxuXFxuICAgIHRoaXMuX3dlYkdMV29ya2VyLmFkZFByb2dyYW0oXFxcImNoZWNrXFxcIiwgaGVhZGVyc18xLmRlZmF1bHQgKyBjaGVja0RvXzEuZGVmYXVsdCArIGNoZWNrS18xLmRlZmF1bHQsIFxcXCJtaW5XZWlnaHRNYWduaXR1ZGVcXFwiKTtcXG5cXG4gICAgdGhpcy5fd2ViR0xXb3JrZXIuYWRkUHJvZ3JhbShcXFwiY29sX2NoZWNrXFxcIiwgaGVhZGVyc18xLmRlZmF1bHQgKyBjaGVja0NvbF8xLmRlZmF1bHQpO1xcblxcbiAgICB0aGlzLl93ZWJHTFdvcmtlci5hZGRQcm9ncmFtKFxcXCJmaW5hbGl6ZVxcXCIsIGhlYWRlcnNfMS5kZWZhdWx0ICsgY2hlY2tEb18xLmRlZmF1bHQgKyBmaW5hbGl6ZV8xLmRlZmF1bHQpO1xcblxcbiAgICB0aGlzLl9zdGF0ZSA9IHBlYXJsRGl2ZXJTdGF0ZV8xLlBlYXJsRGl2ZXJTdGF0ZS5yZWFkeTtcXG4gICAgdGhpcy5fcXVldWUgPSBbXTtcXG4gIH1cXG4gIC8qKlxcclxcbiAgICogSW5pdGlhbGl6ZSB0aGUgUGVhcmxEaXZlciBtYWluIGluc3RhbmNlLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoUGVhcmxEaXZlciwgW3tcXG4gICAga2V5OiBcXFwic2VhcmNoV2l0aFRyeXRlc1xcXCIsXFxuXFxuICAgIC8qKlxcclxcbiAgICAgKiBQZXJmb3JtIGEgc2VhcmNoIHVzaW5nIHRyeXRlcy5cXHJcXG4gICAgICogQHBhcmFtIHRyeXRlcyBUaGUgdHJ5dGVzIHRvIHBlcmZvcm0gdGhlIHNlYXJjaCBvbi5cXHJcXG4gICAgICogQHBhcmFtIG1pbldlaWdodE1hZ25pdHVkZSBUaGUgbWluaW11bSB3ZWlnaHQgbWFnbml0dWRlLlxcclxcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSB0cnl0ZXMgZnJvbSB0aGUgc2VhcmNoLlxcclxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3NlYXJjaFdpdGhUcnl0ZXMgPSBfYXN5bmNUb0dlbmVyYXRvcihcXG4gICAgICAvKiNfX1BVUkVfXyovXFxuICAgICAgX3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodHJ5dGVzLCBtaW5XZWlnaHRNYWduaXR1ZGUpIHtcXG4gICAgICAgIHZhciBzZWFyY2hTdGF0ZXM7XFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XFxuICAgICAgICAgIHdoaWxlICgxKSB7XFxuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBzZWFyY2hTdGF0ZXMgPSB0aGlzLnByZXBhcmUodHJ5dGVzKTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgdGhpcy5zZWFyY2goc2VhcmNoU3RhdGVzLCBtaW5XZWlnaHRNYWduaXR1ZGUpKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMjpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNlYXJjaFdpdGhUcnl0ZXMoX3gsIF94Mikge1xcbiAgICAgICAgcmV0dXJuIF9zZWFyY2hXaXRoVHJ5dGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwcmVwYXJlXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmUodHJhbnNhY3Rpb25Ucnl0ZXMpIHtcXG4gICAgICB2YXIgY3VybCA9IHNwb25nZUZhY3RvcnlfMS5TcG9uZ2VGYWN0b3J5Lmluc3RhbmNlKCkuY3JlYXRlKFxcXCJjdXJsXFxcIik7XFxuICAgICAgY3VybC5pbml0aWFsaXplKCk7XFxuICAgICAgdmFyIHRyYW5zYWN0aW9uVHJpdHMgPSB0cml0c18xLlRyaXRzLmZyb21Ucnl0ZXModHJhbnNhY3Rpb25Ucnl0ZXMpLnRvQXJyYXkoKTtcXG4gICAgICBjdXJsLmFic29yYih0cmFuc2FjdGlvblRyaXRzLCAwLCB0aGlzLl90cmFuc2FjdGlvbkxlbmd0aCAtIHRoaXMuX2hhc2hMZW5ndGgpO1xcbiAgICAgIHZhciBjdXJsU3RhdGUgPSBjdXJsLmdldFN0YXRlKCk7XFxuICAgICAgdHJhbnNhY3Rpb25Ucml0cy5zbGljZSh0aGlzLl90cmFuc2FjdGlvbkxlbmd0aCAtIHRoaXMuX2hhc2hMZW5ndGgsIHRoaXMuX3RyYW5zYWN0aW9uTGVuZ3RoKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcXG4gICAgICAgIGN1cmxTdGF0ZVtpbmRleF0gPSB2YWx1ZTtcXG4gICAgICB9KTtcXG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hUb1BhaXIoY3VybFN0YXRlKTtcXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwic2VhcmNoXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgX3NlYXJjaCA9IF9hc3luY1RvR2VuZXJhdG9yKFxcbiAgICAgIC8qI19fUFVSRV9fKi9cXG4gICAgICBfcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoc3RhdGVzLCBtaW5XZWlnaHQpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcXG4gICAgICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXFxcInJldHVyblxcXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICAgICAgICAgICAgICBfdGhpcy5fcXVldWUucHVzaCh7XFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZXM6IHN0YXRlcyxcXG4gICAgICAgICAgICAgICAgICAgIG1pbldlaWdodE1hZ25pdHVkZTogbWluV2VpZ2h0LFxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHJlc29sdmVcXG4gICAgICAgICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXRlID09PSBwZWFybERpdmVyU3RhdGVfMS5QZWFybERpdmVyU3RhdGUucmVhZHkpIHtcXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlYXJjaERvTmV4dCgpO1xcbiAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSkpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICAgICAgY2FzZSBcXFwiZW5kXFxcIjpcXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XFxuICAgICAgfSkpO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZWFyY2goX3gzLCBfeDQpIHtcXG4gICAgICAgIHJldHVybiBfc2VhcmNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfSgpXFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZWFyY2hUb1BhaXJcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoVG9QYWlyKHN0YXRlKSB7XFxuICAgICAgdmFyIHN0YXRlcyA9IHtcXG4gICAgICAgIGxvdzogbmV3IEludDMyQXJyYXkodGhpcy5fc3RhdGVMZW5ndGgpLFxcbiAgICAgICAgaGlnaDogbmV3IEludDMyQXJyYXkodGhpcy5fc3RhdGVMZW5ndGgpXFxuICAgICAgfTtcXG4gICAgICBzdGF0ZS5mb3JFYWNoKGZ1bmN0aW9uICh0cml0LCBpbmRleCkge1xcbiAgICAgICAgc3dpdGNoICh0cml0KSB7XFxuICAgICAgICAgIGNhc2UgMDpcXG4gICAgICAgICAgICBzdGF0ZXMubG93W2luZGV4XSA9IFBlYXJsRGl2ZXIuSElHSF9CSVRTO1xcbiAgICAgICAgICAgIHN0YXRlcy5oaWdoW2luZGV4XSA9IFBlYXJsRGl2ZXIuSElHSF9CSVRTO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlIDE6XFxuICAgICAgICAgICAgc3RhdGVzLmxvd1tpbmRleF0gPSBQZWFybERpdmVyLkxPV19CSVRTO1xcbiAgICAgICAgICAgIHN0YXRlcy5oaWdoW2luZGV4XSA9IFBlYXJsRGl2ZXIuSElHSF9CSVRTO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgIHN0YXRlcy5sb3dbaW5kZXhdID0gUGVhcmxEaXZlci5ISUdIX0JJVFM7XFxuICAgICAgICAgICAgc3RhdGVzLmhpZ2hbaW5kZXhdID0gUGVhcmxEaXZlci5MT1dfQklUUztcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICB0aGlzLnNlYXJjaE9mZnNldChzdGF0ZXMsIHRoaXMuX25vbmNlU3RhcnQpO1xcbiAgICAgIHJldHVybiBzdGF0ZXM7XFxuICAgIH1cXG4gICAgLyogQGludGVybmFsICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcInNlYXJjaE9mZnNldFxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWFyY2hPZmZzZXQoc3RhdGVzLCBvZmZzZXQpIHtcXG4gICAgICBzdGF0ZXMubG93W29mZnNldCArIDBdID0gUGVhcmxEaXZlci5MT1dfMDtcXG4gICAgICBzdGF0ZXMubG93W29mZnNldCArIDFdID0gUGVhcmxEaXZlci5MT1dfMTtcXG4gICAgICBzdGF0ZXMubG93W29mZnNldCArIDJdID0gUGVhcmxEaXZlci5MT1dfMjtcXG4gICAgICBzdGF0ZXMubG93W29mZnNldCArIDNdID0gUGVhcmxEaXZlci5MT1dfMztcXG4gICAgICBzdGF0ZXMuaGlnaFtvZmZzZXQgKyAwXSA9IFBlYXJsRGl2ZXIuSElHSF8wO1xcbiAgICAgIHN0YXRlcy5oaWdoW29mZnNldCArIDFdID0gUGVhcmxEaXZlci5ISUdIXzE7XFxuICAgICAgc3RhdGVzLmhpZ2hbb2Zmc2V0ICsgMl0gPSBQZWFybERpdmVyLkhJR0hfMjtcXG4gICAgICBzdGF0ZXMuaGlnaFtvZmZzZXQgKyAzXSA9IFBlYXJsRGl2ZXIuSElHSF8zO1xcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJzZWFyY2hEb05leHRcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoRG9OZXh0KCkge1xcbiAgICAgIHZhciBuZXh0ID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcXG5cXG4gICAgICBpZiAob2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkobmV4dCkpIHtcXG4gICAgICAgIHRoaXMuX3N0YXRlID0gcGVhcmxEaXZlclN0YXRlXzEuUGVhcmxEaXZlclN0YXRlLnJlYWR5O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9zdGF0ZSA9IHBlYXJsRGl2ZXJTdGF0ZV8xLlBlYXJsRGl2ZXJTdGF0ZS5zZWFyY2hpbmc7XFxuICAgICAgICB0aGlzLndlYkdMRmluZE5vbmNlKG5leHQpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwid2ViR0xGaW5kTm9uY2VcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2ViR0xGaW5kTm9uY2Uoc2VhcmNoT2JqZWN0KSB7XFxuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy53ZWJHTFdyaXRlQnVmZmVycyhzZWFyY2hPYmplY3Quc3RhdGVzKTtcXG5cXG4gICAgICB0aGlzLl93ZWJHTFdvcmtlci53cml0ZURhdGEodGhpcy5fY3VycmVudEJ1ZmZlcik7XFxuXFxuICAgICAgdGhpcy5fd2ViR0xXb3JrZXIucnVuUHJvZ3JhbShcXFwiaW5pdFxcXCIsIDEsIHtcXG4gICAgICAgIG5hbWU6IFxcXCJncl9vZmZzZXRcXFwiLFxcbiAgICAgICAgdmFsdWU6IDBcXG4gICAgICB9KTtcXG5cXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiBfdGhpczIud2ViR0xTZWFyY2goc2VhcmNoT2JqZWN0KTtcXG4gICAgICB9LCAxKTtcXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwid2ViR0xXcml0ZUJ1ZmZlcnNcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2ViR0xXcml0ZUJ1ZmZlcnMoc3RhdGVzKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zdGF0ZUxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB0aGlzLl9jdXJyZW50QnVmZmVyW2kgKiBQZWFybERpdmVyLlRFWEVMX1NJWkVdID0gc3RhdGVzLmxvd1tpXTtcXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCdWZmZXJbaSAqIFBlYXJsRGl2ZXIuVEVYRUxfU0laRSArIDFdID0gc3RhdGVzLmhpZ2hbaV07XFxuICAgICAgICB0aGlzLl9jdXJyZW50QnVmZmVyW2kgKiBQZWFybERpdmVyLlRFWEVMX1NJWkUgKyAyXSA9IHN0YXRlcy5sb3dbaV07XFxuICAgICAgICB0aGlzLl9jdXJyZW50QnVmZmVyW2kgKiBQZWFybERpdmVyLlRFWEVMX1NJWkUgKyAzXSA9IHN0YXRlcy5oaWdoW2ldO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwid2ViR0xTZWFyY2hcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2ViR0xTZWFyY2goc2VhcmNoT2JqZWN0KSB7XFxuICAgICAgdGhpcy5fd2ViR0xXb3JrZXIucnVuUHJvZ3JhbShcXFwiaW5jcmVtZW50XFxcIiwgMSk7XFxuXFxuICAgICAgdGhpcy5fd2ViR0xXb3JrZXIucnVuUHJvZ3JhbShcXFwidHdpc3RcXFwiLCB0aGlzLl9udW1iZXJSb3VuZHMpO1xcblxcbiAgICAgIHRoaXMuX3dlYkdMV29ya2VyLnJ1blByb2dyYW0oXFxcImNoZWNrXFxcIiwgMSwge1xcbiAgICAgICAgbmFtZTogXFxcIm1pbldlaWdodE1hZ25pdHVkZVxcXCIsXFxuICAgICAgICB2YWx1ZTogc2VhcmNoT2JqZWN0Lm1pbldlaWdodE1hZ25pdHVkZVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHRoaXMuX3dlYkdMV29ya2VyLnJ1blByb2dyYW0oXFxcImNvbF9jaGVja1xcXCIsIDEpO1xcblxcbiAgICAgIHRoaXMuX3dlYkdMV29ya2VyLnJ1blByb2dyYW0oXFxcImZpbmFsaXplXFxcIiwgMSk7XFxuXFxuICAgICAgdmFyIG5vbmNlID0gdGhpcy5fd2ViR0xXb3JrZXIucmVhZERhdGEoMCwgMCwgdGhpcy5fd2ViR0xXb3JrZXIuZ2V0RGltZW5zaW9ucygpLngsIDEpLnJlZHVjZSh0aGlzLnBhY2soNCksIFtdKS5zbGljZSgwLCB0aGlzLl9oYXNoTGVuZ3RoKS5tYXAoZnVuY3Rpb24gKHgpIHtcXG4gICAgICAgIHJldHVybiB4WzNdO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHNlYXJjaE9iamVjdC5jYWxsYmFjayh0cml0c18xLlRyaXRzLmZyb21OdW1iZXJBcnJheShub25jZSkudG9Ucnl0ZXMoKSk7XFxuICAgICAgdGhpcy5zZWFyY2hEb05leHQoKTtcXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicGFja1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWNrKGwpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHIsIGN1cnJlbnRWYWx1ZSwgY3VycmVudEluZGV4KSB7XFxuICAgICAgICByZXR1cm4gKGN1cnJlbnRJbmRleCAlIGwgPT09IDAgPyByLnB1c2goW2N1cnJlbnRWYWx1ZV0pIDogcltyLmxlbmd0aCAtIDFdLnB1c2goY3VycmVudFZhbHVlKSkgJiYgcjtcXG4gICAgICB9O1xcbiAgICB9XFxuICB9XSwgW3tcXG4gICAga2V5OiBcXFwiaW5pdGlhbGl6ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKHdlYkdMUGxhdGZvcm0pIHtcXG4gICAgICBpZiAoIVBlYXJsRGl2ZXIuaW5zdGFuY2UpIHtcXG4gICAgICAgIFBlYXJsRGl2ZXIuaW5zdGFuY2UgPSBuZXcgUGVhcmxEaXZlcih3ZWJHTFBsYXRmb3JtKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIENsb3NlZG93biB0aGUgUGVhcmxEaXZlciBtYWluIGluc3RhbmNlLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY2xvc2Vkb3duXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlZG93bigpIHtcXG4gICAgICBpZiAoUGVhcmxEaXZlci5pbnN0YW5jZSkge1xcbiAgICAgICAgUGVhcmxEaXZlci5pbnN0YW5jZSA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBQZWFybERpdmVyO1xcbn0oKTtcXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5cXG5QZWFybERpdmVyLlRFWEVMX1NJWkUgPSA0O1xcbi8qIEBpbnRlcm5hbCAqL1xcblxcblBlYXJsRGl2ZXIuTE9XX0JJVFMgPSAwOyAvLyAwMDAwMDAwMFxcblxcbi8qIEBpbnRlcm5hbCAqL1xcblxcblBlYXJsRGl2ZXIuSElHSF9CSVRTID0gLTE7IC8vIDB4RkZGRkZGRkYsRkZGRkZGRkYsNDI5NDk2NzI5NVxcblxcbi8qIEBpbnRlcm5hbCAqL1xcblxcblBlYXJsRGl2ZXIuTE9XXzAgPSAweERCNkRCNkRCOyAvLyA2REI2REI2RCxcXG5cXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5QZWFybERpdmVyLkxPV18xID0gMHhGMUY4RkM3RTsgLy8gM0YxRjhGQzcsXFxuXFxuLyogQGludGVybmFsICovXFxuXFxuUGVhcmxEaXZlci5MT1dfMiA9IDB4N0ZGRkUwMEY7IC8vIEZGRkMwMUZGLFxcblxcbi8qIEBpbnRlcm5hbCAqL1xcblxcblBlYXJsRGl2ZXIuTE9XXzMgPSAweEZGQzAwMDAwOyAvLyAwN0ZGRkZGRixcXG5cXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5QZWFybERpdmVyLkhJR0hfMCA9IDB4QjZEQjZEQjY7IC8vIERCNkRCNkRCLFxcblxcbi8qIEBpbnRlcm5hbCAqL1xcblxcblBlYXJsRGl2ZXIuSElHSF8xID0gMHg4RkM3RTNGMTsgLy8gRjhGQzdFM0YsXFxuXFxuLyogQGludGVybmFsICovXFxuXFxuUGVhcmxEaXZlci5ISUdIXzIgPSAweEZGQzAxRkZGOyAvLyBGODAzRkZGRixcXG5cXG4vKiBAaW50ZXJuYWwgKi9cXG5cXG5QZWFybERpdmVyLkhJR0hfMyA9IDB4MDAzRkZGRkY7IC8vRkZGRkZGRkYsXFxuXFxuZXhwb3J0cy5QZWFybERpdmVyID0gUGVhcmxEaXZlcjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9wZWFybERpdmVyL3BlYXJsRGl2ZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3QvcGVhcmxEaXZlci9wZWFybERpdmVyU3RhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9wZWFybERpdmVyL3BlYXJsRGl2ZXJTdGF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogUGVhcmxEaXZlciBTdGF0ZS5cXHJcXG4gKi9cXG5cXG52YXIgUGVhcmxEaXZlclN0YXRlO1xcblxcbihmdW5jdGlvbiAoUGVhcmxEaXZlclN0YXRlKSB7XFxuICBQZWFybERpdmVyU3RhdGVbUGVhcmxEaXZlclN0YXRlW1xcXCJyZWFkeVxcXCJdID0gMF0gPSBcXFwicmVhZHlcXFwiO1xcbiAgUGVhcmxEaXZlclN0YXRlW1BlYXJsRGl2ZXJTdGF0ZVtcXFwic2VhcmNoaW5nXFxcIl0gPSAxXSA9IFxcXCJzZWFyY2hpbmdcXFwiO1xcbiAgUGVhcmxEaXZlclN0YXRlW1BlYXJsRGl2ZXJTdGF0ZVtcXFwiaW50ZXJydXB0ZWRcXFwiXSA9IC0xXSA9IFxcXCJpbnRlcnJ1cHRlZFxcXCI7XFxufSkoUGVhcmxEaXZlclN0YXRlID0gZXhwb3J0cy5QZWFybERpdmVyU3RhdGUgfHwgKGV4cG9ydHMuUGVhcmxEaXZlclN0YXRlID0ge30pKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9wZWFybERpdmVyL3BlYXJsRGl2ZXJTdGF0ZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9wcm9vZk9mV29ya1dlYkdsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9wcm9vZk9mV29ya1dlYkdsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJ2YXIgX3JlZ2VuZXJhdG9yUnVudGltZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBzdGVwKGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IHN0ZXAoXFxcIm5leHRcXFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBzdGVwKFxcXCJ0aHJvd1xcXCIsIGVycik7IH0gX25leHQoKTsgfSk7IH07IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgYXJyYXlIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvYXJyYXlIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9hcnJheUhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBudW1iZXJIZWxwZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyICovIFxcXCIuLi9pb3RhLXBpY28tY29yZS9kaXN0L2hlbHBlcnMvbnVtYmVySGVscGVyLmpzXFxcIik7XFxuXFxudmFyIG9iamVjdEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIgKi8gXFxcIi4uL2lvdGEtcGljby1jb3JlL2Rpc3QvaGVscGVycy9vYmplY3RIZWxwZXIuanNcXFwiKTtcXG5cXG52YXIgY3J5cHRvRXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3IgKi8gXFxcIi4uL2lvdGEtcGljby1jcnlwdG8vZGlzdC9lcnJvci9jcnlwdG9FcnJvci5qc1xcXCIpO1xcblxcbnZhciB0cnl0ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vZGF0YS9kaXN0L2RhdGEvdHJ5dGVzICovIFxcXCIuLi9pb3RhLXBpY28tZGF0YS9kaXN0L2RhdGEvdHJ5dGVzLmpzXFxcIik7XFxuXFxudmFyIHBlYXJsRGl2ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGVhcmxEaXZlci9wZWFybERpdmVyICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3QvcGVhcmxEaXZlci9wZWFybERpdmVyLmpzXFxcIik7XFxuLyoqXFxyXFxuICogUHJvb2ZPZldvcmsgaW1wbGVtZW50YXRpb24gdXNpbmcgV2ViR0wuXFxyXFxuICovXFxuXFxuXFxudmFyIFByb29mT2ZXb3JrV2ViR2wgPVxcbi8qI19fUFVSRV9fKi9cXG5mdW5jdGlvbiAoKSB7XFxuICAvKipcXHJcXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBQcm9vZk9mV29yay5cXHJcXG4gICAqIEBwYXJhbSB3ZWJHTFBsYXRmb3JtIFByb3ZpZGVzIHBsYXRmb3JtIHNwZWNpZmljIGZ1bmN0aW9ucywgb3B0aW9uYWwgbW9zdGx5IHVzZWQgZm9yIHRlc3RpbmcuXFxyXFxuICAgKi9cXG4gIGZ1bmN0aW9uIFByb29mT2ZXb3JrV2ViR2wod2ViR0xQbGF0Zm9ybSkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvb2ZPZldvcmtXZWJHbCk7XFxuXFxuICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eSh3ZWJHTFBsYXRmb3JtKSkge1xcbiAgICAgIHRoaXMuX3dlYkdMUGxhdGZvcm0gPSB7XFxuICAgICAgICBnZXRXaW5kb3c6IGZ1bmN0aW9uIGdldFdpbmRvdygpIHtcXG4gICAgICAgICAgcmV0dXJuIHdpbmRvdztcXG4gICAgICAgIH0sXFxuICAgICAgICBnZXREb2N1bWVudDogZnVuY3Rpb24gZ2V0RG9jdW1lbnQod2luZG93KSB7XFxuICAgICAgICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XFxuICAgICAgICB9LFxcbiAgICAgICAgZ2V0Q2FudmFzOiBmdW5jdGlvbiBnZXRDYW52YXMoZG9jdW1lbnQpIHtcXG4gICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImNhbnZhc1xcXCIpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGdldFdlYkdMOiBmdW5jdGlvbiBnZXRXZWJHTChjYW52YXMpIHtcXG4gICAgICAgICAgdmFyIGF0dHIgPSB7XFxuICAgICAgICAgICAgYWxwaGE6IGZhbHNlLFxcbiAgICAgICAgICAgIGFudGlhbGlhczogZmFsc2VcXG4gICAgICAgICAgfTtcXG4gICAgICAgICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoXFxcIndlYmdsMlxcXCIsIGF0dHIpO1xcbiAgICAgICAgICByZXR1cm4gZ2w7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLl93ZWJHTFBsYXRmb3JtID0gd2ViR0xQbGF0Zm9ybTtcXG4gICAgfVxcbiAgfVxcbiAgLyoqXFxyXFxuICAgKiBBbGxvdyB0aGUgcHJvb2Ygb2Ygd29yayB0byBwZXJmb3JtIGFueSBpbml0aWFsaXphdGlvbi5cXHJcXG4gICAqIFdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxcclxcbiAgICovXFxuXFxuXFxuICBfY3JlYXRlQ2xhc3MoUHJvb2ZPZldvcmtXZWJHbCwgW3tcXG4gICAga2V5OiBcXFwiaW5pdGlhbGl6ZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIF9pbml0aWFsaXplID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcXG4gICAgICAgICAgd2hpbGUgKDEpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XFxuICAgICAgICAgICAgICBjYXNlIDA6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXFxcInJldHVyblxcXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcXG4gICAgICAgICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgICAgICAgcGVhcmxEaXZlcl8xLlBlYXJsRGl2ZXIuaW5pdGlhbGl6ZShfdGhpcy5fd2ViR0xQbGF0Zm9ybSk7XFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XFxuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0pKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTpcXG4gICAgICAgICAgICAgIGNhc2UgXFxcImVuZFxcXCI6XFxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XFxuICAgICAgICByZXR1cm4gX2luaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gICAgLyoqXFxyXFxuICAgICAqIFBlcmZvcm1zIHNpbmdsZSBjb252ZXJzaW9uIHBlciBwb3cgY2FsbC5cXHJcXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBwb3cgb25seSBkb2VzIG9uZSBjb252ZXJzaW9uLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwicGVyZm9ybXNTaW5nbGVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGVyZm9ybXNTaW5nbGUoKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIFBlcmZvcm0gYSBwcm9vZiBvZiB3b3JrIG9uIHRoZSBkYXRhLlxcclxcbiAgICAgKiBAcGFyYW0gdHJ1bmtUcmFuc2FjdGlvbiBUaGUgdHJ1bmtUcmFuc2FjdGlvbiB0byB1c2UgZm9yIHRoZSBwb3cuXFxyXFxuICAgICAqIEBwYXJhbSBicmFuY2hUcmFuc2FjdGlvbiBUaGUgYnJhbmNoVHJhbnNhY3Rpb24gdG8gdXNlIGZvciB0aGUgcG93LlxcclxcbiAgICAgKiBAcGFyYW0gdHJ5dGVzIFRoZSB0cnl0ZXMgdG8gcGVyZm9ybSB0aGUgcG93IG9uLlxcclxcbiAgICAgKiBAcGFyYW0gbWluV2VpZ2h0TWFnbml0dWRlIFRoZSBtaW5pbXVtIHdlaWdodCBtYWduaXR1ZGUuXFxyXFxuICAgICAqIEByZXR1cm5zIFRoZSB0cnl0ZXMgcHJvZHVjZWQgYnkgdGhlIHByb29mIG9mIHdvcmsuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJwb3dcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfcG93ID0gX2FzeW5jVG9HZW5lcmF0b3IoXFxuICAgICAgLyojX19QVVJFX18qL1xcbiAgICAgIF9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMih0cnVua1RyYW5zYWN0aW9uLCBicmFuY2hUcmFuc2FjdGlvbiwgdHJ5dGVzLCBtaW5XZWlnaHRNYWduaXR1ZGUpIHtcXG4gICAgICAgIHZhciBub25jZSwgdHJ5dGVzU3RyaW5nLCBub25jZVN0cmluZztcXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xcbiAgICAgICAgICB3aGlsZSAoMSkge1xcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xcbiAgICAgICAgICAgICAgY2FzZSAwOlxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiV2ViR0wgaXMgbm90IGluaXRpYWxpemVkLCBoYXZlIHlvdSBjYWxsZWQgaW5pdGlhbGl6ZVxcXCIpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSAyOlxcbiAgICAgICAgICAgICAgICBpZiAoYXJyYXlIZWxwZXJfMS5BcnJheUhlbHBlci5pc1R5cGVkKHRyeXRlcywgdHJ5dGVzXzEuVHJ5dGVzKSkge1xcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcXG4gICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIHRyeXRlcyBtdXN0IGJlIGFuIGFycmF5IG9mIHR5cGUgVHJ5dGVzXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDQ6XFxuICAgICAgICAgICAgICAgIGlmICghKCFudW1iZXJIZWxwZXJfMS5OdW1iZXJIZWxwZXIuaXNJbnRlZ2VyKG1pbldlaWdodE1hZ25pdHVkZSkgfHwgbWluV2VpZ2h0TWFnbml0dWRlIDw9IDApKSB7XFxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJUaGUgbWluV2VpZ2h0TWFnbml0dWRlIG11c3QgYmUgPiAwXFxcIik7XFxuXFxuICAgICAgICAgICAgICBjYXNlIDY6XFxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gODtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlYXJsRGl2ZXJfMS5QZWFybERpdmVyLmluc3RhbmNlLnNlYXJjaFdpdGhUcnl0ZXModHJ5dGVzWzBdLCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xcblxcbiAgICAgICAgICAgICAgY2FzZSA4OlxcbiAgICAgICAgICAgICAgICBub25jZSA9IF9jb250ZXh0Mi5zZW50O1xcbiAgICAgICAgICAgICAgICB0cnl0ZXNTdHJpbmcgPSB0cnl0ZXMudG9TdHJpbmcoKTtcXG4gICAgICAgICAgICAgICAgbm9uY2VTdHJpbmcgPSBub25jZS50b1N0cmluZygpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcXFwicmV0dXJuXFxcIiwgW3RyeXRlc18xLlRyeXRlcy5mcm9tU3RyaW5nKHRyeXRlc1N0cmluZy5zdWJzdHIoMCwgdHJ5dGVzU3RyaW5nLmxlbmd0aCAtIG5vbmNlU3RyaW5nLmxlbmd0aCkuY29uY2F0KG5vbmNlU3RyaW5nKSldKTtcXG5cXG4gICAgICAgICAgICAgIGNhc2UgMTI6XFxuICAgICAgICAgICAgICBjYXNlIFxcXCJlbmRcXFwiOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcXG4gICAgICB9KSk7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBvdyhfeCwgX3gyLCBfeDMsIF94NCkge1xcbiAgICAgICAgcmV0dXJuIF9wb3cuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgICB9O1xcbiAgICB9KClcXG4gIH1dKTtcXG5cXG4gIHJldHVybiBQcm9vZk9mV29ya1dlYkdsO1xcbn0oKTtcXG5cXG5leHBvcnRzLlByb29mT2ZXb3JrV2ViR2wgPSBQcm9vZk9mV29ya1dlYkdsO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3Byb29mT2ZXb3JrV2ViR2wuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9hZGQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2FkZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogU2hhZGVycyBhZGQuXFxyXFxuICovXFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gXFxcIlxcXFxuaW50IHN1bSAoaW50IGEsIGludCBiKSB7XFxcXG4gIGludCBteV9zdW0gPSBhICsgYjtcXFxcbiAgcmV0dXJuIG15X3N1bSA9PSAyID8gLTEgOiAobXlfc3VtID09IC0yKSA/IDEgOiBteV9zdW07XFxcXG59XFxcXG5pbnQgY29ucyAoaW50IGEsIGludCBiKSB7XFxcXG4gIHJldHVybiAoYSA9PSAxICYmIGIgPT0gMSk/IDEgOiAoYSA9PSAtMSAmJiBiID09IC0xKSA/IC0xIDogMDtcXFxcbn1cXFxcbmludCBhbnlfdCAoaW50IGEsIGludCBiKSB7XFxcXG4gIGludCBteV9hbnkgPSBhICsgYjtcXFxcbiAgcmV0dXJuIG15X2FueSA9PSAwID8gMCA6IChteV9hbnkgPiAwKSA/IDEgOiAtMTtcXFxcbn1cXFxcbml2ZWMyIGZ1bGxfYWRkZXIoaW50IGEsIGludCBiLCBpbnQgYykge1xcXFxuICBpbnQgY19hLCBjX2IsIHN1bV9hYiwgY19zO1xcXFxuXFxcXG4gIGNfYSAgICA9IGNvbnMoYSxiKTtcXFxcbiAgc3VtX2FiID0gc3VtKGEsYik7XFxcXG4gIGNfYiAgICA9IGNvbnMoc3VtX2FiLGMpO1xcXFxuICBjX3MgICAgPSBhbnlfdChjX2EsIGNfYik7XFxcXG5cXFxcbiAgcmV0dXJuIGl2ZWMyKHN1bShzdW1fYWIsIGMpLCBjX3MpO1xcXFxufVxcXFxuaXZlYzIgZ2V0X3N1bV90b19pbmRleChpbnQgZnJvbSwgaW50IHRvLCBpbnQgbnVtYmVyX3RvX2FkZCwgaW50IHJvdykge1xcXFxuICBpbnQgdHJpdF90b19hZGQsIHRyaXRfYXRfaW5kZXgsIHBvdywgY2FycnksIG51bV9jYXJyeTtcXFxcbiAgaXZlYzIgcmVhZF9pbiwgc3VtX291dCwgb3V0X3RyaXQ7XFxcXG4gIHBvdyA9IDE7XFxcXG4gIGNhcnJ5ID0gMDtcXFxcbiAgbnVtX2NhcnJ5ID0gMDtcXFxcblxcXFxuICBmb3IoaW50IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xcXFxuICAgIC8vaWYodHJpdF90b19hZGQgPT0gMCAmJiBzdW1fb3V0LnQgPT0gMCkgY29udGludWU7XFxcXG5cXFxcbiAgICByZWFkX2luID0gcmVhZF9hdCAoIGl2ZWMyIChpLCByb3cpKS5yZztcXFxcblxcXFxuICAgIHRyaXRfdG9fYWRkID0gKChudW1iZXJfdG9fYWRkIC8gcG93KSAlIDMpICsgbnVtX2NhcnJ5O1xcXFxuICAgIG51bV9jYXJyeSA9IHRyaXRfdG9fYWRkID4gMSA/IDEgOiAwO1xcXFxuICAgIHRyaXRfdG9fYWRkID0gKHRyaXRfdG9fYWRkID09IDIgPyAtMSA6ICh0cml0X3RvX2FkZCA9PSAzID8gMCA6IHRyaXRfdG9fYWRkKSk7XFxcXG5cXFxcbiAgICBzdW1fb3V0ID0gZnVsbF9hZGRlcihcXFxcbiAgICAgIChyZWFkX2luLnMgPT0gTE9XX0JJVFMgPyAxIDogcmVhZF9pbi50ID09IExPV19CSVRTPyAtMSA6IDApLFxcXFxuICAgICAgdHJpdF90b19hZGQsXFxcXG4gICAgICBjYXJyeVxcXFxuICAgICk7XFxcXG5cXFxcbiAgICBpZihteV9jb29yZC54ID09IGkpIGJyZWFrO1xcXFxuICAgIGNhcnJ5ID0gc3VtX291dC50O1xcXFxuICAgIHBvdyAqPTM7XFxcXG4gIH1cXFxcbiAgaWYoc3VtX291dC5zID09IDApIHtcXFxcbiAgICByZXR1cm4gaXZlYzIoSElHSF9CSVRTKTtcXFxcbiAgfSBlbHNlIGlmIChzdW1fb3V0LnMgPT0gMSkge1xcXFxuICAgIHJldHVybiBpdmVjMihMT1dfQklUUywgSElHSF9CSVRTKTtcXFxcbiAgfSBlbHNlIHtcXFxcbiAgICByZXR1cm4gaXZlYzIoSElHSF9CSVRTLCBMT1dfQklUUyk7XFxcXG4gIH1cXFxcbn1cXFxcblxcXCI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9hZGQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9jaGVja0NvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9jaGVja0NvbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG4vKipcXHJcXG4gKiBTaGFkZXJzIGNoZWNrX2NvbC5cXHJcXG4gKi9cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBcXFwiXFxcXG52b2lkIG1haW4oKSB7XFxcXG4gIGluaXQoKTtcXFxcbiAgaXZlYzQgbXlfdmVjID0gcmVhZCgpO1xcXFxuICBpbnQgaTtcXFxcbiAgaWYobXlfY29vcmQueCA9PSBTVEFURV9MRU5HVEggJiYgbXlfY29vcmQueSA9PSAwKSB7XFxcXG4gICAgbXlfdmVjLmIgPSAwO1xcXFxuICAgIGlmKG15X3ZlYy5hID09IDApIHtcXFxcbiAgICAgIGl2ZWM0IHJlYWRfdmVjO1xcXFxuICAgICAgbXlfdmVjLmIgPSAtMTtcXFxcbiAgICAgIGZvcihpID0gMTsgaSA8IGludChzaXplLnkpOyBpKyspIHtcXFxcbiAgICAgICAgcmVhZF92ZWMgPSByZWFkX2F0KCBpdmVjMiggU1RBVEVfTEVOR1RILCBpKSk7XFxcXG4gICAgICAgIGlmKHJlYWRfdmVjLmEgIT0gMCkge1xcXFxuICAgICAgICAgIG15X3ZlYy5hID0gcmVhZF92ZWMuYTtcXFxcbiAgICAgICAgICBteV92ZWMuYiA9IGk7XFxcXG4gICAgICAgICAgYnJlYWs7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgIH1cXFxcbiAgICB9XFxcXG4gIH1cXFxcbiAgY29tbWl0KG15X3ZlYyk7XFxcXG59XFxcXG5cXFwiO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3NoYWRlcnMvY2hlY2tDb2wuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9jaGVja0RvLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3NoYWRlcnMvY2hlY2tEby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIFNoYWRlcnMgY2hlY2tfZG8uXFxyXFxuICovXFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gXFxcIlxcXFxuaW50IGNoZWNrKGludCByb3csIGludCBtaW5fd2VpZ2h0X21hZ25pdHVkZSkge1xcXFxuICBpbnQgbm9uY2VfcHJvYmUsIGk7XFxcXG4gIGl2ZWMyIHJfdGV4ZWw7XFxcXG4gIG5vbmNlX3Byb2JlID0gSElHSF9CSVRTO1xcXFxuICBmb3IoaSA9IG1pbl93ZWlnaHRfbWFnbml0dWRlOyBpLS0gPiAwOyApIHtcXFxcbiAgICByX3RleGVsID0gcmVhZF9hdChpdmVjMihIQVNIX0xFTkdUSCAtIDEgLSBpLCByb3cpKS5iYTtcXFxcbiAgICBub25jZV9wcm9iZSAmPSB+KHJfdGV4ZWwucyBeIHJfdGV4ZWwudCk7XFxcXG4gICAgaWYobm9uY2VfcHJvYmUgPT0gMCkgYnJlYWs7XFxcXG4gIH1cXFxcbiAgcmV0dXJuIG5vbmNlX3Byb2JlO1xcXFxufVxcXFxuXFxcIjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2NoZWNrRG8uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9jaGVja0suanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2NoZWNrSy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogU2hhZGVycyBjaGVja19rLlxcclxcbiAqL1xcblxcbmV4cG9ydHMuZGVmYXVsdCA9IFxcXCJcXFxcbnVuaWZvcm0gaW50IG1pbldlaWdodE1hZ25pdHVkZTtcXFxcbnZvaWQgbWFpbigpIHtcXFxcbiAgaW5pdCgpO1xcXFxuICBpdmVjNCBteV92ZWMgPSByZWFkKCk7XFxcXG4gIGlmKG15X2Nvb3JkLnggPT0gU1RBVEVfTEVOR1RIKSB7XFxcXG4gICAgbXlfdmVjLnIgPSBtaW5XZWlnaHRNYWduaXR1ZGU7XFxcXG4gICAgbXlfdmVjLmEgPSBjaGVjayhteV9jb29yZC55LCBtaW5XZWlnaHRNYWduaXR1ZGUpO1xcXFxuICB9XFxcXG4gIGNvbW1pdChteV92ZWMpO1xcXFxufVxcXFxuXFxcIjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2NoZWNrSy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2ZpbmFsaXplLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2ZpbmFsaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIFNoYWRlcnMgZmluYWxpemUuXFxyXFxuICovXFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gXFxcIlxcXFxudm9pZCBtYWluKCkge1xcXFxuICBpbml0KCk7XFxcXG4gIGl2ZWM0IG15X3ZlYyA9IHJlYWQoKTtcXFxcbiAgaWYobXlfY29vcmQueSA9PSAwICYmIG15X2Nvb3JkLnggPT0gU1RBVEVfTEVOR1RIKSB7XFxcXG4gICAgbXlfdmVjLmcgPSBjaGVjayhteV92ZWMuYiwgbXlfdmVjLnIpO1xcXFxuICB9XFxcXG4gIGlmKG15X2Nvb3JkLnkgPT0gMCAmJiBteV9jb29yZC54IDwgSEFTSF9MRU5HVEgpIHtcXFxcbiAgICBpdmVjNCBpbmZvX3ZlYyA9IHJlYWRfYXQoaXZlYzIoU1RBVEVfTEVOR1RILCAwKSk7XFxcXG4gICAgaW50IG5vbmNlX3Byb2JlID0gaW5mb192ZWMuYTtcXFxcbiAgICBpbnQgcm93ID0gaW5mb192ZWMuYjtcXFxcbiAgICBpdmVjNCBoYXNoX3ZlYyA9IHJlYWRfYXQoaXZlYzIobXlfY29vcmQueCwgcm93KSk7XFxcXG4gICAgbXlfdmVjLmEgPSAoaGFzaF92ZWMuciAmIG5vbmNlX3Byb2JlKSA9PSAwPyAxIDogKChoYXNoX3ZlYy5nICYgbm9uY2VfcHJvYmUpID09IDA/IC0xIDogMCk7XFxcXG4gIH1cXFxcbiAgY29tbWl0KG15X3ZlYyk7XFxcXG59XFxcXG5cXFwiO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3NoYWRlcnMvZmluYWxpemUuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9oZWFkZXJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3NoYWRlcnMvaGVhZGVycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIFNoYWRlcnMgYWRkLlxcclxcbiAqL1xcblxcbmV4cG9ydHMuZGVmYXVsdCA9IFxcXCJcXFxcbiNkZWZpbmUgSEFTSF9MRU5HVEggMjQzXFxcXG4jZGVmaW5lIE5VTUJFUl9PRl9ST1VORFMgODFcXFxcbiNkZWZpbmUgSU5DUkVNRU5UX1NUQVJUIEhBU0hfTEVOR1RIIC0gNjRcXFxcbiNkZWZpbmUgU1RBVEVfTEVOR1RIIDMgKiBIQVNIX0xFTkdUSFxcXFxuI2RlZmluZSBIQUxGX0xFTkdUSCAzNjRcXFxcbiNkZWZpbmUgSElHSF9CSVRTIDB4RkZGRkZGRkZcXFxcbiNkZWZpbmUgTE9XX0JJVFMgMHgwMDAwMDAwMFxcXFxuXFxcIjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2hlYWRlcnMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9pbmNyZW1lbnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL2luY3JlbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXZhbChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogU2hhZGVycyBpbmNyZW1lbnQuXFxyXFxuICovXFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gXFxcIlxcXFxudm9pZCBtYWluKCkge1xcXFxuICBpbml0KCk7XFxcXG4gIGl2ZWM0IG15X3ZlYyA9IHJlYWQoKTtcXFxcbiAgaWYobXlfY29vcmQueCA+PSBJTkNSRU1FTlRfU1RBUlQgJiYgbXlfY29vcmQueCA8IEhBU0hfTEVOR1RIICkge1xcXFxuICAgIG15X3ZlYy5yZyA9IGdldF9zdW1fdG9faW5kZXgoSU5DUkVNRU5UX1NUQVJULCBIQVNIX0xFTkdUSCwgMSwgbXlfY29vcmQueSk7XFxcXG4gIH1cXFxcbiAgaWYobXlfY29vcmQueCA9PSBTVEFURV9MRU5HVEggKSB7XFxcXG4gICAgbXlfdmVjLnJnID0gaXZlYzIoMCk7XFxcXG4gIH1cXFxcbiAgbXlfdmVjLmJhID0gbXlfdmVjLnJnO1xcXFxuICBjb21taXQobXlfdmVjKTtcXFxcbn1cXFxcblxcXCI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9pbmNyZW1lbnQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy9pbml0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3NoYWRlcnMvaW5pdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIFNoYWRlcnMgaW5pdC5cXHJcXG4gKi9cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBcXFwiXFxcXG51bmlmb3JtIGludCBncl9vZmZzZXQ7XFxcXG5pdmVjNCBvZmZzZXQoKSB7XFxcXG4gIGlmKG15X2Nvb3JkLnggPj0gSEFTSF9MRU5HVEggLyAzICYmIG15X2Nvb3JkLnggPCBIQVNIX0xFTkdUSCAvIDMgKiAyICkge1xcXFxuICAgIGl2ZWM0IG15X3ZlYztcXFxcbiAgICBteV92ZWMucmcgPSBnZXRfc3VtX3RvX2luZGV4KEhBU0hfTEVOR1RIIC8gMywgSEFTSF9MRU5HVEggLyAzICogMiwgbXlfY29vcmQueSArIGdyX29mZnNldCwgMCk7XFxcXG4gICAgcmV0dXJuIG15X3ZlYztcXFxcbiAgfSBlbHNlIHtcXFxcbiAgICByZXR1cm4gcmVhZF9hdChpdmVjMihteV9jb29yZC54LDApKTtcXFxcbiAgfVxcXFxufVxcXFxudm9pZCBtYWluKCkge1xcXFxuICBpbml0KCk7XFxcXG4gIGNvbW1pdChvZmZzZXQoKSk7XFxcXG59XFxcXG5cXFwiO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3NoYWRlcnMvaW5pdC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC9zaGFkZXJzL3RyYW5zZm9ybS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3NoYWRlcnMvdHJhbnNmb3JtLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG4vKipcXHJcXG4gKiBTaGFkZXJzIHRyYW5zZm9ybS5cXHJcXG4gKi9cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBcXFwiXFxcXG5pdmVjMiB0d2lzdCgpIHtcXFxcbiAgaW50IGFscGhhLCBiZXRhLCBnYW1tYSwgZGVsdGE7XFxcXG4gIGl2ZWM0IHYxLCB2MjtcXFxcbiAgaW50IGogPSBteV9jb29yZC54O1xcXFxuXFxcXG4gIHYxID0gcmVhZF9hdChpdmVjMihqID09IDA/IDA6KCgoaiAtIDEpJTIpKzEpKkhBTEZfTEVOR1RIIC0gKChqLTEpPj4xKSwgbXlfY29vcmQueSkpO1xcXFxuICB2MiA9IHJlYWRfYXQoaXZlYzIoKChqJTIpKzEpKkhBTEZfTEVOR1RIIC0gKChqKT4+MSksIG15X2Nvb3JkLnkpKTtcXFxcbiAgYWxwaGEgPSB2MS5iO1xcXFxuICBiZXRhID0gdjEuYTtcXFxcbiAgZ2FtbWEgPSB2Mi5hO1xcXFxuICBkZWx0YSA9IChhbHBoYSB8ICh+Z2FtbWEpKSAmICh2Mi5iIF4gYmV0YSk7Ly92Mi5iID09PSBzdGF0ZV9sb3dbdDJdXFxcXG5cXFxcbiAgcmV0dXJuIGl2ZWMyKH5kZWx0YSwgKGFscGhhIF4gZ2FtbWEpIHwgZGVsdGEpO1xcXFxufVxcXFxudm9pZCBtYWluKCkge1xcXFxuICBpbml0KCk7XFxcXG4gIGl2ZWM0IG15X3ZlYyA9IHJlYWQoKTtcXFxcbiAgaWYobXlfY29vcmQueCA8IFNUQVRFX0xFTkdUSClcXFxcbiAgICBteV92ZWMuYmEgPSB0d2lzdCgpO1xcXFxuICBjb21taXQobXlfdmVjKTtcXFxcbn1cXFxcblxcXCI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvc2hhZGVycy90cmFuc2Zvcm0uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvd2ViR0wvc3RkbGliLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3dlYkdML3N0ZGxpYi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuICB2YWx1ZTogdHJ1ZVxcbn0pO1xcbi8qKlxcclxcbiAqIFN0ZGxpYi5cXHJcXG4gKi9cXG5cXG5leHBvcnRzLmRlZmF1bHQgPSBcXFwiI3ZlcnNpb24gMzAwIGVzXFxcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxcXG5wcmVjaXNpb24gaGlnaHAgaW50O1xcXFxucHJlY2lzaW9uIGhpZ2hwIGlzYW1wbGVyMkQ7XFxcXG51bmlmb3JtIGlzYW1wbGVyMkQgdV90ZXh0dXJlO1xcXFxuaW4gdmVjMiBwb3M7XFxcXG5vdXQgaXZlYzQgY29sb3I7XFxcXG4vL291dCBpbnQgaXNGaW5pc2hlZDtcXFxcblxcXFxudmVjMiBzaXplO1xcXFxuaXZlYzIgbXlfY29vcmQ7XFxcXG5cXFxcbnZvaWQgaW5pdCh2b2lkKSB7XFxcXG4gIC8vc2l6ZSA9IHZlYzIodGV4dHVyZVNpemUodV90ZXh0dXJlLCAwKSAtIDEpO1xcXFxuICBzaXplID0gdmVjMih0ZXh0dXJlU2l6ZSh1X3RleHR1cmUsIDApKTtcXFxcbiAgbXlfY29vcmQgPSBpdmVjMihwb3MgKiBzaXplKTtcXFxcbn1cXFxcblxcXFxuaXZlYzQgcmVhZCh2b2lkKSB7XFxcXG4gIHJldHVybiB0ZXh0dXJlKHVfdGV4dHVyZSwgcG9zKTtcXFxcbn1cXFxcblxcXFxuaXZlYzQgcmVhZF9hdChpdmVjMiBjb29yZCkge1xcXFxuICByZXR1cm4gdGV4ZWxGZXRjaCh1X3RleHR1cmUsIGNvb3JkLCAwKTtcXFxcbn1cXFxcblxcXFxudm9pZCBjb21taXQoaXZlYzQgdmFsKSB7XFxcXG4gIGNvbG9yID0gdmFsO1xcXFxufVxcXFxuXFxcIjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC93ZWJHTC9zdGRsaWIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvd2ViR0wvdmVydGV4U2hhZGVyQ29kZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvd2ViR0wvdmVydGV4U2hhZGVyQ29kZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG4vKipcXHJcXG4gKiBWZXJ0ZXggU2hhZGVyIGNvZGUuXFxyXFxuICovXFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gXFxcIiN2ZXJzaW9uIDMwMCBlc1xcXFxubGF5b3V0KGxvY2F0aW9uID0gMCkgaW4gdmVjMiBwb3NpdGlvbjtcXFxcbmxheW91dChsb2NhdGlvbiA9IDEpIGluIHZlYzIgdGV4dHVyZTtcXFxcbm91dCB2ZWMyIHBvcztcXFxcblxcXFxudm9pZCBtYWluKHZvaWQpIHtcXFxcbiAgcG9zID0gdGV4dHVyZTtcXFxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLnh5LCAwLjAsIDEuMCk7XFxcXG59XFxcIjtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC93ZWJHTC92ZXJ0ZXhTaGFkZXJDb2RlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3dlYkdML3dlYkdMSGVscGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvd2ViR0wvd2ViR0xIZWxwZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxcblxcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcbiAgdmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgb2JqZWN0SGVscGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9oZWxwZXJzL29iamVjdEhlbHBlci5qc1xcXCIpO1xcblxcbnZhciBjcnlwdG9FcnJvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9jcnlwdG8vZGlzdC9lcnJvci9jcnlwdG9FcnJvciAqLyBcXFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yLmpzXFxcIik7XFxuLyoqXFxyXFxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgdXNlIHdpdGggV2ViR0wuXFxyXFxuICovXFxuXFxuXFxudmFyIFdlYkdMSGVscGVyID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gV2ViR0xIZWxwZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTEhlbHBlcik7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoV2ViR0xIZWxwZXIsIG51bGwsIFt7XFxuICAgIGtleTogXFxcImNyZWF0ZUNvbnRleHRcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogQ3JlYXRlIGEgV2ViR0wgQ29udGV4dC5cXHJcXG4gICAgICogQHJldHVybnMgVGhlIGNvbnRleHQgaWYgc3VjY2Vzc2Z1bHkgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGl0IGNhbm5vdCBiZSBjcmVhdGVkLlxcclxcbiAgICAgKi9cXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQod2ViR0xQbGF0Zm9ybSkge1xcbiAgICAgIHZhciB3aW5kb3cgPSB3ZWJHTFBsYXRmb3JtLmdldFdpbmRvdygpO1xcblxcbiAgICAgIGlmICghb2JqZWN0SGVscGVyXzEuT2JqZWN0SGVscGVyLmlzRW1wdHkod2luZG93KSAmJiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIikge1xcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gd2ViR0xQbGF0Zm9ybS5nZXREb2N1bWVudCh3aW5kb3cpO1xcblxcbiAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShkb2N1bWVudCkpIHtcXG4gICAgICAgICAgdmFyIGNhbnZhcyA9IHdlYkdMUGxhdGZvcm0uZ2V0Q2FudmFzKGRvY3VtZW50KTtcXG5cXG4gICAgICAgICAgaWYgKCFvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShjYW52YXMpKSB7XFxuICAgICAgICAgICAgdmFyIGdsID0gd2ViR0xQbGF0Zm9ybS5nZXRXZWJHTChjYW52YXMpO1xcblxcbiAgICAgICAgICAgIGlmIChvYmplY3RIZWxwZXJfMS5PYmplY3RIZWxwZXIuaXNFbXB0eShnbCkpIHtcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJDYW4gbm90IGNyZWF0ZSBhIFdlYkdMIGNvbnRleHQgb24gYSA8Y2FudmFzPiBlbGVtZW50LlxcXCIsIHtcXG4gICAgICAgICAgICAgICAgdXNlckFnZW50OiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiBnbDtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwiVGhlIEhUTUw1IDxjYW52YXM+IGVsZW1lbnQgaXMgbm90IGF2YWlsYWJsZSBpbiB5b3VyIGJyb3dzZXIuXFxcIiwge1xcbiAgICAgICAgICAgICAgdXNlckFnZW50OiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aHJvdyBuZXcgY3J5cHRvRXJyb3JfMS5DcnlwdG9FcnJvcihcXFwid2luZG93LmRvY3VtZW50IGlzIG5vdCBhdmFpbGFibGUsIHlvdSBtdXN0IGJlIHJ1bm5pbmcgaW4gYW4gZW52aXJvbm1lbnQgd2l0aCBXZWJHTC5cXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIndpbmRvdyBpcyBub3QgYXZhaWxhYmxlLCB5b3UgbXVzdCBiZSBydW5uaW5nIGluIGFuIGVudmlyb25tZW50IHdpdGggV2ViR0wuXFxcIik7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBDcmVhdGUgYSBuZXcgV2ViR0wgYnVmZmVyLlxcclxcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIFdlYkdMIHJlbmRlcmluZyBjb250ZXh0LlxcclxcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBhZGQgdG8gdGhlIGJ1ZmZlci5cXHJcXG4gICAgICogQHBhcmFtIGFycmF5VHlwZSBUaGUgZGF0YSB0eXBlIGZvciB0aGUgYnVmZmVyLlxcclxcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IEEgR0wgRW51bSBzcGVjaWZ5aW5nIHRoZSBiaW5kaW5nIHBvaW50ICh0YXJnZXQpLlxcclxcbiAgICAgKiBAcmV0dXJucyBUaGUgV2ViR0wgYnVmZmVyLlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY3JlYXRlQnVmZmVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihnbCwgZGF0YSwgYXJyYXlUeXBlLCB0YXJnZXQpIHtcXG4gICAgICB2YXIgYnVmID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxuICAgICAgZ2wuYmluZEJ1ZmZlcih0YXJnZXQgfHwgZ2wuQVJSQVlfQlVGRkVSLCBidWYpO1xcbiAgICAgIGdsLmJ1ZmZlckRhdGEodGFyZ2V0IHx8IGdsLkFSUkFZX0JVRkZFUiwgbmV3IChhcnJheVR5cGUgfHwgRmxvYXQzMkFycmF5KShkYXRhKSwgZ2wuU1RBVElDX0RSQVcpO1xcbiAgICAgIHJldHVybiBidWY7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIFRyYW5zZmVyIGRhdGEgb250byBjbGFtcGVkIHRleHR1cmUgYW5kIHR1cm4gb2ZmIGFueSBmaWx0ZXJpbmdcXHJcXG4gICAgICogQHBhcmFtIGdsIFRoZSBXZWJHTCByZW5kZXJpbmcgY29udGV4dC5cXHJcXG4gICAgICogQHBhcmFtIHBpeGVsRGF0YSBUaGUgcGl4ZWwgZGF0YSB0byBjcmVhdGUgdGhlIHZpZXcgZnJvbS5cXHJcXG4gICAgICogQHBhcmFtIGRpbWVuc2lvbnMgVGhlIGRpbWVuc2lvbnMgdG8gY3JlYXRlIHRoZSB0ZXh0dXJlLlxcclxcbiAgICAgKiBAcmV0dXJucyBUaGUgdGV4dHVyZS5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImNyZWF0ZVRleHR1cmVcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGV4dHVyZShnbCwgcGl4ZWxEYXRhLCBkaW1lbnNpb25zKSB7XFxuICAgICAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XFxuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XFxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XFxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XFxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcXG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEzMkksIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55LCAwLCBnbC5SR0JBX0lOVEVHRVIsIGdsLklOVCwgcGl4ZWxEYXRhKTtcXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcXG4gICAgICByZXR1cm4gdGV4dHVyZTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogU2V0IHRoZSB0ZXh1cmUgaW50byB0aGUgZnJhbWVidWZmZXIuXFxyXFxuICAgICAqIEBwYXJhbSBnbCBUaGUgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQuXFxyXFxuICAgICAqIEBwYXJhbSBmcmFtZUJ1ZmZlciBUaGUgZnJhbWUgYnVmZmVyIHRvIHNldCB0aGUgdGV4dCBpbiB0by5cXHJcXG4gICAgICogQHBhcmFtIHRleHR1cmUgVGhlIHRleHR1cmUgdG8gc2V0IGluIHRvIHRoZSBmcmFtZWJ1ZmZlci5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImZyYW1lQnVmZmVyU2V0VGV4dHVyZVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcmFtZUJ1ZmZlclNldFRleHR1cmUoZ2wsIGZyYW1lQnVmZmVyLCB0ZXh0dXJlKSB7XFxuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XFxuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTsgLy8gVGVzdCBmb3IgbW9iaWxlIGJ1ZyBNRE4tPldlYkdMX2Jlc3RfcHJhY3RpY2VzLCBidWxsZXQgN1xcblxcbiAgICAgIHZhciBmcmFtZUJ1ZmZlclN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpO1xcblxcbiAgICAgIGlmIChmcmFtZUJ1ZmZlclN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJFcnJvciBhdHRhY2hpbmcgZmxvYXQgdGV4dHVyZSB0byBmcmFtZWJ1ZmZlci4gWW91ciBkZXZpY2UgaXMgcHJvYmFibHkgaW5jb21wYXRpYmxlLlxcXCIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfV0pO1xcblxcbiAgcmV0dXJuIFdlYkdMSGVscGVyO1xcbn0oKTtcXG5cXG5leHBvcnRzLldlYkdMSGVscGVyID0gV2ViR0xIZWxwZXI7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvd2ViR0wvd2ViR0xIZWxwZXIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3Qvd2ViR0wvd2ViR0xXb3JrZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC93ZWJHTC93ZWJHTFdvcmtlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XFxuXFxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cXG5cXG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XFxuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xcbiAgICBcXFwiZGVmYXVsdFxcXCI6IG1vZFxcbiAgfTtcXG59O1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIGNyeXB0b0Vycm9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NyeXB0by9kaXN0L2Vycm9yL2NyeXB0b0Vycm9yICovIFxcXCIuLi9pb3RhLXBpY28tY3J5cHRvL2Rpc3QvZXJyb3IvY3J5cHRvRXJyb3IuanNcXFwiKTtcXG5cXG52YXIgc3RkbGliXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdGRsaWIgKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC93ZWJHTC9zdGRsaWIuanNcXFwiKSk7XFxuXFxudmFyIHZlcnRleFNoYWRlckNvZGVfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZlcnRleFNoYWRlckNvZGUgKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctd2ViZ2wvZGlzdC93ZWJHTC92ZXJ0ZXhTaGFkZXJDb2RlLmpzXFxcIikpO1xcblxcbnZhciB3ZWJHTEhlbHBlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi93ZWJHTEhlbHBlciAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3dlYkdML3dlYkdMSGVscGVyLmpzXFxcIik7XFxuLyoqXFxyXFxuICogV2ViR0xXb3JrZXIuXFxyXFxuICovXFxuXFxuXFxudmFyIFdlYkdMV29ya2VyID1cXG4vKiNfX1BVUkVfXyovXFxuZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gV2ViR0xXb3JrZXIoKSB7XFxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTFdvcmtlcik7XFxuICB9XFxuXFxuICBfY3JlYXRlQ2xhc3MoV2ViR0xXb3JrZXIsIFt7XFxuICAgIGtleTogXFxcImluaXRpYWxpemVcXFwiLFxcblxcbiAgICAvKipcXHJcXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgd2ViIEdMIFdvcmtlci5cXHJcXG4gICAgICogQHBhcmFtIHdlYkdMUGxhdGZvcm0gVGhlIHdlYkdMIHBsYXRmb3JtLlxcclxcbiAgICAgKiBAcGFyYW0gc3RhdGVMZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgc3RhdGUuXFxyXFxuICAgICAqIEBwYXJhbSB0ZXhlbFNpemUgVGhlIHRleGVsIHNpemUuXFxyXFxuICAgICAqL1xcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSh3ZWJHTFBsYXRmb3JtLCBzdGF0ZUxlbmd0aCwgdGV4ZWxTaXplKSB7XFxuICAgICAgdGhpcy5fY29udGV4dCA9IHdlYkdMSGVscGVyXzEuV2ViR0xIZWxwZXIuY3JlYXRlQ29udGV4dCh3ZWJHTFBsYXRmb3JtKTtcXG4gICAgICB0aGlzLl9kaW1lbnNpb25zID0ge1xcbiAgICAgICAgeDogc3RhdGVMZW5ndGgsXFxuICAgICAgICB5OiAwXFxuICAgICAgfTtcXG4gICAgICB2YXIgbWF4SW1hZ2VTaXplID0gTWF0aC5wb3codGhpcy5fY29udGV4dC5NQVhfVEVYVFVSRV9TSVpFLCAyKSAqIDAuNTtcXG4gICAgICB2YXIgaW1hZ2VTaXplID0gTWF0aC5mbG9vcihtYXhJbWFnZVNpemUgLyB0aGlzLl9kaW1lbnNpb25zLnggLyB0ZXhlbFNpemUpICogdGhpcy5fZGltZW5zaW9ucy54ICogdGV4ZWxTaXplO1xcbiAgICAgIHRoaXMuX2RpbWVuc2lvbnMueSA9IGltYWdlU2l6ZSAvIHRoaXMuX2RpbWVuc2lvbnMueCAvIHRleGVsU2l6ZTtcXG4gICAgICB0aGlzLl9wcm9ncmFtcyA9IG5ldyBNYXAoKTtcXG4gICAgICB0aGlzLl9pcHQgPSB7XFxuICAgICAgICBkYXRhOiBuZXcgSW50MzJBcnJheShpbWFnZVNpemUpLFxcbiAgICAgICAgbGVuZ3RoOiBpbWFnZVNpemVcXG4gICAgICB9OyAvLyBHUFUgdGV4dHVyZSBidWZmZXIgPSBmcm9tIEpTIHR5cGVkIGFycmF5XFxuXFxuICAgICAgdGhpcy5fYnVmZmVycyA9IHtcXG4gICAgICAgIHBvc2l0aW9uOiB3ZWJHTEhlbHBlcl8xLldlYkdMSGVscGVyLmNyZWF0ZUJ1ZmZlcih0aGlzLl9jb250ZXh0LCBbLTEsIC0xLCAxLCAtMSwgMSwgMSwgLTEsIDFdKSxcXG4gICAgICAgIHRleHR1cmU6IHdlYkdMSGVscGVyXzEuV2ViR0xIZWxwZXIuY3JlYXRlQnVmZmVyKHRoaXMuX2NvbnRleHQsIFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSksXFxuICAgICAgICBpbmRleDogd2ViR0xIZWxwZXJfMS5XZWJHTEhlbHBlci5jcmVhdGVCdWZmZXIodGhpcy5fY29udGV4dCwgWzEsIDIsIDAsIDMsIDAsIDJdLCBVaW50MTZBcnJheSwgdGhpcy5fY29udGV4dC5FTEVNRU5UX0FSUkFZX0JVRkZFUilcXG4gICAgICB9O1xcbiAgICAgIHRoaXMuX2F0dHJpYiA9IHtcXG4gICAgICAgIHBvc2l0aW9uOiAwLFxcbiAgICAgICAgdGV4dHVyZTogMVxcbiAgICAgIH07XFxuICAgICAgdGhpcy5fdmVydGV4QXJyYXkgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZVZlcnRleEFycmF5KCk7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmVydGV4QXJyYXkodGhpcy5fdmVydGV4QXJyYXkpO1xcblxcbiAgICAgIHRoaXMuYmluZEJ1ZmZlcnMoKTtcXG5cXG4gICAgICB0aGlzLl9jb250ZXh0LmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcXG5cXG4gICAgICB0aGlzLmNyZWF0ZVZlcnRleFNoYWRlcigpO1xcbiAgICAgIHRoaXMuX2ZyYW1lQnVmZmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xcbiAgICAgIHRoaXMuX3RleHR1cmUwID0gd2ViR0xIZWxwZXJfMS5XZWJHTEhlbHBlci5jcmVhdGVUZXh0dXJlKHRoaXMuX2NvbnRleHQsIHRoaXMuX2lwdC5kYXRhLCB0aGlzLl9kaW1lbnNpb25zKTtcXG4gICAgICB0aGlzLl90ZXh0dXJlMSA9IHdlYkdMSGVscGVyXzEuV2ViR0xIZWxwZXIuY3JlYXRlVGV4dHVyZSh0aGlzLl9jb250ZXh0LCBuZXcgSW50MzJBcnJheShpbWFnZVNpemUpLCB0aGlzLl9kaW1lbnNpb25zKTtcXG4gICAgfVxcbiAgICAvKipcXHJcXG4gICAgICogR2V0IHRoZSBkaW1lbnNpb25zIGZyb20gdGhlIHdvcmtlci5cXHJcXG4gICAgICogQHJldHVybnMgVGhlIGRpbWVuc2lvbnMuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJnZXREaW1lbnNpb25zXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2RpbWVuc2lvbnM7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIEdldCB0aGUgSVBUIGZyb20gdGhlIHdvcmtlci5cXHJcXG4gICAgICogQHJldHVybiBUaGUgaXB0LlxcclxcbiAgICAgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZ2V0SXB0XFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldElwdCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5faXB0O1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBBZGQgYSBwcm9ncmFtIHRvIHRoZSB3b3JrZXIuXFxyXFxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtIHRvIGFkZC5cXHJcXG4gICAgICogQHBhcmFtIGNvZGUgVGhlIGNvZGUgZm9yIHRoZSBwcm9ncmFtLlxcclxcbiAgICAgKiBAcGFyYW0gdW5pZm9ybXMgQWRkaXRpb25hbCB1bmlmb3JtIGxvY2F0aW9ucy5cXHJcXG4gICAgICovXFxuXFxuICB9LCB7XFxuICAgIGtleTogXFxcImFkZFByb2dyYW1cXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUHJvZ3JhbShuYW1lLCBjb2RlKSB7XFxuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gdGhpcy5jcmVhdGVGcmFnbWVudFNoYWRlcihjb2RlKTtcXG5cXG4gICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlUHJvZ3JhbSgpO1xcblxcbiAgICAgIHRoaXMuX2NvbnRleHQuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHRoaXMuX3ZlcnRleFNoYWRlcik7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xcblxcbiAgICAgIHRoaXMuX2NvbnRleHQuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIHRoaXMuX2F0dHJpYi5wb3NpdGlvbiwgXFxcInBvc2l0aW9uXFxcIik7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgdGhpcy5fYXR0cmliLnRleHR1cmUsIFxcXCJ0ZXh0dXJlXFxcIik7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcXG5cXG4gICAgICB2YXIgdW5pZm9ybVZhcnMgPSBuZXcgTWFwKCk7XFxuXFxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHVuaWZvcm1zID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcXG4gICAgICAgIHVuaWZvcm1zW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHVuaWZvcm1zLmxlbmd0aDsgX2krKykge1xcbiAgICAgICAgdmFyIHZhcmlhYmxlID0gdW5pZm9ybXNbX2ldO1xcbiAgICAgICAgdW5pZm9ybVZhcnMuc2V0KHZhcmlhYmxlLCB0aGlzLl9jb250ZXh0LmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB2YXJpYWJsZSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9wcm9ncmFtcy5zZXQobmFtZSwge1xcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcXG4gICAgICAgIHVuaWZvcm1WYXJzOiB1bmlmb3JtVmFyc1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBSdW4gdGhlIHByb2dyYW0gaW4gdGhlIHdlYiB3b3JrZXIuXFxyXFxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtIHRvIHJ1bi5cXHJcXG4gICAgICogQHBhcmFtIGNvdW50IFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIGl0LlxcclxcbiAgICAgKiBAcGFyYW0gdW5pZm9ybXMgQWRkaXRpb25hbCB1bmlmb3JtIGxvY2F0aW9ucyB0byB1c2UuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJydW5Qcm9ncmFtXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1blByb2dyYW0obmFtZSwgY291bnQpIHtcXG4gICAgICB2YXIgaW5mbyA9IHRoaXMuX3Byb2dyYW1zLmdldChuYW1lKTtcXG5cXG4gICAgICB2YXIgcHJvZ3JhbSA9IGluZm8ucHJvZ3JhbTtcXG5cXG4gICAgICBpZiAoIXRoaXMuX2NvbnRleHQuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCB0aGlzLl9jb250ZXh0LkxJTktfU1RBVFVTKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IGNyeXB0b0Vycm9yXzEuQ3J5cHRvRXJyb3IoXFxcIkZhaWxlZCB0byBsaW5rIEdMU0wgcHJvZ3JhbSBjb2RlXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB1bmlmb3JtVmFycyA9IGluZm8udW5pZm9ybVZhcnM7XFxuXFxuICAgICAgdmFyIHVUZXh0dXJlID0gdGhpcy5fY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXFxcInVfdGV4dHVyZVxcXCIpO1xcblxcbiAgICAgIHRoaXMuX2NvbnRleHQudXNlUHJvZ3JhbShwcm9ncmFtKTtcXG5cXG4gICAgICB2YXIgbG9jYWxDb3VudCA9IGNvdW50O1xcblxcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdW5pZm9ybXMgPSBuZXcgQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xcbiAgICAgICAgdW5pZm9ybXNbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XFxuICAgICAgfVxcblxcbiAgICAgIHdoaWxlIChsb2NhbENvdW50LS0gPiAwKSB7XFxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHRoaXMuX2NvbnRleHQuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZTApO1xcblxcbiAgICAgICAgdGhpcy5fY29udGV4dC5hY3RpdmVUZXh0dXJlKHRoaXMuX2NvbnRleHQuVEVYVFVSRTApO1xcblxcbiAgICAgICAgdGhpcy5fY29udGV4dC51bmlmb3JtMWkodVRleHR1cmUsIDApO1xcblxcbiAgICAgICAgdGhpcy5fY29udGV4dC52aWV3cG9ydCgwLCAwLCB0aGlzLl9kaW1lbnNpb25zLngsIHRoaXMuX2RpbWVuc2lvbnMueSk7XFxuXFxuICAgICAgICB3ZWJHTEhlbHBlcl8xLldlYkdMSGVscGVyLmZyYW1lQnVmZmVyU2V0VGV4dHVyZSh0aGlzLl9jb250ZXh0LCB0aGlzLl9mcmFtZUJ1ZmZlciwgdGhpcy5fdGV4dHVyZTEpO1xcblxcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmVydGV4QXJyYXkodGhpcy5fdmVydGV4QXJyYXkpO1xcblxcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdW5pZm9ybXMubGVuZ3RoOyBfaTIrKykge1xcbiAgICAgICAgICB2YXIgdVZhcnMgPSB1bmlmb3Jtc1tfaTJdO1xcblxcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LnVuaWZvcm0xaSh1bmlmb3JtVmFycy5nZXQodVZhcnMubmFtZSksIHVWYXJzLnZhbHVlKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd0VsZW1lbnRzKHRoaXMuX2NvbnRleHQuVFJJQU5HTEVTLCA2LCB0aGlzLl9jb250ZXh0LlVOU0lHTkVEX1NIT1JULCAwKTtcXG5cXG4gICAgICAgIHZhciB0ZXgwID0gdGhpcy5fdGV4dHVyZTA7XFxuICAgICAgICB0aGlzLl90ZXh0dXJlMCA9IHRoaXMuX3RleHR1cmUxO1xcbiAgICAgICAgdGhpcy5fdGV4dHVyZTEgPSB0ZXgwO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmZpbmlzaFJ1bigpO1xcbiAgICB9XFxuICAgIC8qKlxcclxcbiAgICAgKiBSZWFkIGRhdGEgZnJvbSB0aGUgd29ya2VyLlxcclxcbiAgICAgKiBAcGFyYW0geCBUaGUgeCBwb3NpdGlvbiB0byByZWFkIGZyb20uXFxyXFxuICAgICAqIEBwYXJhbSB5IFRoZSB5IHBvc2l0aW9uIHRvIHJlYWQgZnJvbS5cXHJcXG4gICAgICogQHBhcmFtIG4gVGhlIHdpZHRoIHBvc2l0aW9uIHRvIHJlYWQgZnJvbS5cXHJcXG4gICAgICogQHBhcmFtIG0gVGhlIGhlaWdodCBwb3NpdGlvbiB0byByZWFkIGZyb20uXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJyZWFkRGF0YVxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkRGF0YSh4LCB5LCBuLCBtKSB7XFxuICAgICAgdGhpcy5fY29udGV4dC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY29udGV4dC5GUkFNRUJVRkZFUiwgdGhpcy5fZnJhbWVCdWZmZXIpO1xcblxcbiAgICAgIHRoaXMuX2NvbnRleHQucmVhZFBpeGVscyh4LCB5LCBuLCBtLCB0aGlzLl9jb250ZXh0LlJHQkFfSU5URUdFUiwgdGhpcy5fY29udGV4dC5JTlQsIHRoaXMuX2lwdC5kYXRhKTtcXG5cXG4gICAgICB0aGlzLl9jb250ZXh0LmJpbmRGcmFtZWJ1ZmZlcih0aGlzLl9jb250ZXh0LkZSQU1FQlVGRkVSLCBudWxsKTtcXG5cXG4gICAgICByZXR1cm4gdGhpcy5faXB0LmRhdGEuc3ViYXJyYXkoMCwgdGhpcy5faXB0Lmxlbmd0aCk7XFxuICAgIH1cXG4gICAgLyoqXFxyXFxuICAgICAqIFdyaXRlIGRhdGEgdG8gdGhlIHdvcmtlci5cXHJcXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gd3JpdGUuXFxyXFxuICAgICAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJ3cml0ZURhdGFcXFwiLFxcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGVEYXRhKGRhdGEpIHtcXG4gICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHRoaXMuX2NvbnRleHQuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZTApO1xcblxcbiAgICAgIHRoaXMuX2NvbnRleHQudGV4SW1hZ2UyRCh0aGlzLl9jb250ZXh0LlRFWFRVUkVfMkQsIDAsIHRoaXMuX2NvbnRleHQuUkdCQTMySSwgdGhpcy5fZGltZW5zaW9ucy54LCB0aGlzLl9kaW1lbnNpb25zLnksIDAsIHRoaXMuX2NvbnRleHQuUkdCQV9JTlRFR0VSLCB0aGlzLl9jb250ZXh0LklOVCwgZGF0YSk7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZSh0aGlzLl9jb250ZXh0LlRFWFRVUkVfMkQsIG51bGwpO1xcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJiaW5kQnVmZmVyc1xcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kQnVmZmVycygpIHtcXG4gICAgICB0aGlzLl9jb250ZXh0LmJpbmRCdWZmZXIodGhpcy5fY29udGV4dC5BUlJBWV9CVUZGRVIsIHRoaXMuX2J1ZmZlcnMudGV4dHVyZSk7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIudGV4dHVyZSk7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYi50ZXh0dXJlLCAyLCB0aGlzLl9jb250ZXh0LkZMT0FULCBmYWxzZSwgMCwgMCk7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC5iaW5kQnVmZmVyKHRoaXMuX2NvbnRleHQuQVJSQVlfQlVGRkVSLCB0aGlzLl9idWZmZXJzLnBvc2l0aW9uKTtcXG5cXG4gICAgICB0aGlzLl9jb250ZXh0LmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYi5wb3NpdGlvbik7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuX2F0dHJpYi5wb3NpdGlvbiwgMiwgdGhpcy5fY29udGV4dC5GTE9BVCwgZmFsc2UsIDAsIDApO1xcblxcbiAgICAgIHRoaXMuX2NvbnRleHQuYmluZEJ1ZmZlcih0aGlzLl9jb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9idWZmZXJzLmluZGV4KTtcXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiY3JlYXRlVmVydGV4U2hhZGVyXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcigpIHtcXG4gICAgICB0aGlzLl92ZXJ0ZXhTaGFkZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZVNoYWRlcih0aGlzLl9jb250ZXh0LlZFUlRFWF9TSEFERVIpO1xcblxcbiAgICAgIHRoaXMuX2NvbnRleHQuc2hhZGVyU291cmNlKHRoaXMuX3ZlcnRleFNoYWRlciwgdmVydGV4U2hhZGVyQ29kZV8xLmRlZmF1bHQpO1xcblxcbiAgICAgIHRoaXMuX2NvbnRleHQuY29tcGlsZVNoYWRlcih0aGlzLl92ZXJ0ZXhTaGFkZXIpOyAvLyBUaGlzIHNob3VsZCBub3QgZmFpbC5cXG5cXG5cXG4gICAgICBpZiAoIXRoaXMuX2NvbnRleHQuZ2V0U2hhZGVyUGFyYW1ldGVyKHRoaXMuX3ZlcnRleFNoYWRlciwgdGhpcy5fY29udGV4dC5DT01QSUxFX1NUQVRVUykpIHtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKFxcXCJDb3VsZCBub3QgYnVpbGQgdmVydGV4IHNoYWRlci5cXFxcblxcXFxuLS0tIENPREUgRFVNUCAtLS1cXFwiLmNvbmNhdCh2ZXJ0ZXhTaGFkZXJDb2RlXzEuZGVmYXVsdCwgXFxcIlxcXFxuXFxcXG4tLS0gRVJST1IgTE9HIC0tLVxcXFxuXFxcIikuY29uY2F0KHRoaXMuX2NvbnRleHQuZ2V0U2hhZGVySW5mb0xvZyh0aGlzLl92ZXJ0ZXhTaGFkZXIpKSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8qIEBpbnRlcm5hbCAqL1xcblxcbiAgfSwge1xcbiAgICBrZXk6IFxcXCJjcmVhdGVGcmFnbWVudFNoYWRlclxcXCIsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudFNoYWRlcihjb2RlKSB7XFxuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVTaGFkZXIodGhpcy5fY29udGV4dC5GUkFHTUVOVF9TSEFERVIpO1xcblxcbiAgICAgIHRoaXMuX2NvbnRleHQuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBzdGRsaWJfMS5kZWZhdWx0ICsgY29kZSk7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTsgLy8gVXNlIHRoaXMgb3V0cHV0IHRvIGRlYnVnIHRoZSBzaGFkZXJcXG4gICAgICAvLyBLZWVwIGluIG1pbmQgdGhhdCBXZWJHTCBHTFNMIGlzICoqbXVjaCoqIHN0cmljdGVyIHRoYW4gZS5nLiBPcGVuR0wgR0xTTFxcblxcblxcbiAgICAgIGlmICghdGhpcy5fY29udGV4dC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIHRoaXMuX2NvbnRleHQuQ09NUElMRV9TVEFUVVMpKSB7XFxuICAgICAgICB2YXIgY29kZUxpbmVzID0gY29kZS5zcGxpdChcXFwiXFxcXG5cXFwiKTtcXG4gICAgICAgIHZhciBkYmdNc2cgPSBcXFwiQ291bGQgbm90IGJ1aWxkIGZyYWdtZW50IHNoYWRlci5cXFxcblxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tIEtFUk5FTCBDT0RFIERVTVAgLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG5cXFwiO1xcblxcbiAgICAgICAgZm9yICh2YXIgbmwgPSAwOyBubCA8IGNvZGVMaW5lcy5sZW5ndGg7IG5sKyspIHtcXG4gICAgICAgICAgZGJnTXNnICs9IFxcXCJcXFwiLmNvbmNhdChzdGRsaWJfMS5kZWZhdWx0LnNwbGl0KFxcXCJcXFxcblxcXCIpLmxlbmd0aCArIG5sLCBcXFwiPiBcXFwiKS5jb25jYXQoY29kZUxpbmVzW25sXSwgXFxcIlxcXFxuXFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYmdNc2cgKz0gXFxcIlxcXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVSUk9SICBMT0cgLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXG5cXFwiLmNvbmNhdCh0aGlzLl9jb250ZXh0LmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpKTtcXG4gICAgICAgIHRocm93IG5ldyBjcnlwdG9FcnJvcl8xLkNyeXB0b0Vycm9yKGRiZ01zZyk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmcmFnbWVudFNoYWRlcjtcXG4gICAgfVxcbiAgICAvKiBAaW50ZXJuYWwgKi9cXG5cXG4gIH0sIHtcXG4gICAga2V5OiBcXFwiZmluaXNoUnVuXFxcIixcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmlzaFJ1bigpIHtcXG4gICAgICB0aGlzLl9jb250ZXh0LmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcXG5cXG4gICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHRoaXMuX2NvbnRleHQuVEVYVFVSRV8yRCwgbnVsbCk7XFxuXFxuICAgICAgdGhpcy5fY29udGV4dC5iaW5kRnJhbWVidWZmZXIodGhpcy5fY29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XFxuICAgIH1cXG4gIH1dKTtcXG5cXG4gIHJldHVybiBXZWJHTFdvcmtlcjtcXG59KCk7XFxuXFxuZXhwb3J0cy5XZWJHTFdvcmtlciA9IFdlYkdMV29ya2VyO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy13ZWJnbC9kaXN0L3dlYkdML3dlYkdMV29ya2VyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy13ZWJnbC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13ZWJnbC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXZhbChcIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy13ZWJnbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qc1xcXCIpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvLi4vaW90YS1waWNvLXBvdy13ZWJnbC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vaW90YS1waWNvLXBvdy13ZWJnbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCIvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKi9cXG5cXG4vLyBUaGlzIG1ldGhvZCBvZiBvYnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgbmVlZHMgdG8gYmVcXG4vLyBrZXB0IGlkZW50aWNhbCB0byB0aGUgd2F5IGl0IGlzIG9idGFpbmVkIGluIHJ1bnRpbWUuanNcXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcXFwicmV0dXJuIHRoaXNcXFwiKSgpO1xcblxcbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xcbi8vIGBoYXNPd25Qcm9wZXJ0eWAgb24gdGhlIGdsb2JhbCBgc2VsZmAgb2JqZWN0IGluIGEgd29ya2VyLiBTZWUgIzE4My5cXG52YXIgaGFkUnVudGltZSA9IGcucmVnZW5lcmF0b3JSdW50aW1lICYmXFxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFxcXCJyZWdlbmVyYXRvclJ1bnRpbWVcXFwiKSA+PSAwO1xcblxcbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cXG52YXIgb2xkUnVudGltZSA9IGhhZFJ1bnRpbWUgJiYgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XFxuXFxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxcbmcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xcblxcbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ydW50aW1lICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcXFwiKTtcXG5cXG5pZiAoaGFkUnVudGltZSkge1xcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cXG4gIGcucmVnZW5lcmF0b3JSdW50aW1lID0gb2xkUnVudGltZTtcXG59IGVsc2Uge1xcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cXG4gIHRyeSB7XFxuICAgIGRlbGV0ZSBnLnJlZ2VuZXJhdG9yUnVudGltZTtcXG4gIH0gY2F0Y2goZSkge1xcbiAgICBnLnJlZ2VuZXJhdG9yUnVudGltZSA9IHVuZGVmaW5lZDtcXG4gIH1cXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUtbW9kdWxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vaW90YS1waWNvLXBvdy13ZWJnbC9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9pb3RhLXBpY28tcG93LXdlYmdsL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCIvKipcXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cXG4gKlxcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cXG4gKi9cXG5cXG4hKGZ1bmN0aW9uKGdsb2JhbCkge1xcbiAgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcXG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcXG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxcbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiID8gU3ltYm9sIDoge307XFxuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFxcXCJAQGl0ZXJhdG9yXFxcIjtcXG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFxcXCJAQGFzeW5jSXRlcmF0b3JcXFwiO1xcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcXFwiQEB0b1N0cmluZ1RhZ1xcXCI7XFxuXFxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcXFwib2JqZWN0XFxcIjtcXG4gIHZhciBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZTtcXG4gIGlmIChydW50aW1lKSB7XFxuICAgIGlmIChpbk1vZHVsZSkge1xcbiAgICAgIC8vIElmIHJlZ2VuZXJhdG9yUnVudGltZSBpcyBkZWZpbmVkIGdsb2JhbGx5IGFuZCB3ZSdyZSBpbiBhIG1vZHVsZSxcXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcXG4gICAgfVxcbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXFxuICAgIC8vIGFscmVhZHkgZGVmaW5lZCBnbG9iYWxseS5cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgLy8gRGVmaW5lIHRoZSBydW50aW1lIGdsb2JhbGx5IChhcyBleHBlY3RlZCBieSBnZW5lcmF0ZWQgY29kZSkgYXMgZWl0aGVyXFxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXFxuICBydW50aW1lID0gZ2xvYmFsLnJlZ2VuZXJhdG9yUnVudGltZSA9IGluTW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgOiB7fTtcXG5cXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcXG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXFxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcXG5cXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXFxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcXG5cXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcXG4gIH1cXG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XFxuXFxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXFxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXFxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXFxuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXFxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXFxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4geyB0eXBlOiBcXFwibm9ybWFsXFxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICByZXR1cm4geyB0eXBlOiBcXFwidGhyb3dcXFwiLCBhcmc6IGVyciB9O1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFxcXCJzdXNwZW5kZWRTdGFydFxcXCI7XFxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFxcXCJzdXNwZW5kZWRZaWVsZFxcXCI7XFxuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcXFwiZXhlY3V0aW5nXFxcIjtcXG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFxcXCJjb21wbGV0ZWRcXFwiO1xcblxcbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcXG5cXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXFxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XFxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XFxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XFxuXFxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxcbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XFxuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfTtcXG5cXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcXG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcXG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcXG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xcbiAgfVxcblxcbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cXG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcXG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XFxuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxcbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFxcXCJHZW5lcmF0b3JGdW5jdGlvblxcXCI7XFxuXFxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcXG4gICAgW1xcXCJuZXh0XFxcIiwgXFxcInRocm93XFxcIiwgXFxcInJldHVyblxcXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XFxuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xcbiAgICAgIH07XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XFxuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XFxuICAgIHJldHVybiBjdG9yXFxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxcbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxcbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXFxcIkdlbmVyYXRvckZ1bmN0aW9uXFxcIlxcbiAgICAgIDogZmFsc2U7XFxuICB9O1xcblxcbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XFxuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcXG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcXG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcXFwiR2VuZXJhdG9yRnVuY3Rpb25cXFwiO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XFxuICAgIHJldHVybiBnZW5GdW47XFxuICB9O1xcblxcbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXFxuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcXFwiX19hd2FpdFxcXCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXFxuICBydW50aW1lLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XFxuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XFxuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XFxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xcbiAgICAgICAgaWYgKHZhbHVlICYmXFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcXFwib2JqZWN0XFxcIiAmJlxcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcXFwiX19hd2FpdFxcXCIpKSB7XFxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xcbiAgICAgICAgICAgIGludm9rZShcXFwibmV4dFxcXCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcXG4gICAgICAgICAgICBpbnZva2UoXFxcInRocm93XFxcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XFxuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXFxuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi4gSWYgdGhlIFByb21pc2UgaXMgcmVqZWN0ZWQsIGhvd2V2ZXIsIHRoZVxcbiAgICAgICAgICAvLyByZXN1bHQgZm9yIHRoaXMgaXRlcmF0aW9uIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCB0aGUgc2FtZVxcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxcbiAgICAgICAgICAvLyB0aHJvd24gYmFjayBpbnRvIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIGFzIGlzIHRoZSBjYXNlXFxuICAgICAgICAgIC8vIHdoZW4gYW4gYXdhaXRlZCBQcm9taXNlIGlzIHJlamVjdGVkLiBUaGlzIGRpZmZlcmVuY2UgaW5cXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XFxuICAgICAgICAgIC8vIGFsbG93cyB0aGUgY29uc3VtZXIgdG8gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGUgeWllbGRlZFxcbiAgICAgICAgICAvLyByZWplY3Rpb24gKHN3YWxsb3cgaXQgYW5kIGNvbnRpbnVlLCBtYW51YWxseSAudGhyb3cgaXQgYmFja1xcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcXG4gICAgICAgICAgLy8gYXdhaXQsIGJ5IGNvbnRyYXN0LCB0aGVyZSBpcyBubyBvcHBvcnR1bml0eSB0byBleGFtaW5lIHRoZVxcbiAgICAgICAgICAvLyByZWplY3Rpb24gcmVhc29uIG91dHNpZGUgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgc28gdGhlXFxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxcbiAgICAgICAgICAvLyBsZXQgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBoYW5kbGUgdGhlIGV4Y2VwdGlvbi5cXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XFxuICAgICAgICB9LCByZWplY3QpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xcblxcbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XFxuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XFxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XFxuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cXG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcXG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXFxuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XFxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXFxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXFxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xcbiAgICB9XFxuXFxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxcbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xcbiAgfVxcblxcbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcXG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuICBydW50aW1lLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xcblxcbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXFxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cXG4gIHJ1bnRpbWUuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXFxuICAgICk7XFxuXFxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxcbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XFxuICAgICAgICB9KTtcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcXG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcXG5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1xcXCIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XFxuICAgICAgICBpZiAobWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgIHRocm93IGFyZztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XFxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXFxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcXG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcXG5cXG4gICAgICB3aGlsZSAodHJ1ZSkge1xcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcXG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcXG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XFxuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcXG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXFxcIm5leHRcXFwiKSB7XFxuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxcbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XFxuXFxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XFxuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XFxuXFxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwicmV0dXJuXFxcIikge1xcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcXFwicmV0dXJuXFxcIiwgY29udGV4dC5hcmcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcXG5cXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcXG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcIm5vcm1hbFxcXCIpIHtcXG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxcbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXFxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXFxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcXG5cXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxcbiAgICAgICAgICB9O1xcblxcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXFxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXFxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcXG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcXG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XFxuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG5cXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvci5yZXR1cm4pIHtcXG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXFxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInJldHVyblxcXCI7XFxuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcXG5cXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cXG4gICAgICAgICAgICAvLyBcXFwicmV0dXJuXFxcIiB0byBcXFwidGhyb3dcXFwiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxcbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXFxuICAgICAgICAgIFxcXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXFxcIik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9XFxuXFxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XFxuXFxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInRocm93XFxcIikge1xcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXFxcInRocm93XFxcIjtcXG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XFxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG5cXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xcblxcbiAgICBpZiAoISBpbmZvKSB7XFxuICAgICAgY29udGV4dC5tZXRob2QgPSBcXFwidGhyb3dcXFwiO1xcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcXFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcXFwiKTtcXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcXG4gICAgfVxcblxcbiAgICBpZiAoaW5mby5kb25lKSB7XFxuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcXG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxcbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xcblxcbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xcblxcbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcXFwidGhyb3dcXFwiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXFxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFxcXCJuZXh0XFxcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXFxuICAgICAgLy8gXFxcImNvbnN1bWVkXFxcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xcbiAgICAgIC8vIFxcXCJyZXR1cm5cXFwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFxcXCJyZXR1cm5cXFwiKSB7XFxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xcbiAgICAgIH1cXG5cXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXFxuICAgICAgcmV0dXJuIGluZm87XFxuICAgIH1cXG5cXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XFxuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgfVxcblxcbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XFxuXFxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcXFwiR2VuZXJhdG9yXFxcIjtcXG5cXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXFxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXFxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcblxcbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcXG4gICAgcmV0dXJuIFxcXCJbb2JqZWN0IEdlbmVyYXRvcl1cXFwiO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XFxuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XFxuXFxuICAgIGlmICgxIGluIGxvY3MpIHtcXG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XFxuICAgIH1cXG5cXG4gICAgaWYgKDIgaW4gbG9jcykge1xcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcXG4gICAgfVxcblxcbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XFxuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xcbiAgICByZWNvcmQudHlwZSA9IFxcXCJub3JtYWxcXFwiO1xcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcXG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcXG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFxcXCJyb290XFxcIiB9XTtcXG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xcbiAgfVxcblxcbiAgcnVudGltZS5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XFxuICAgIHZhciBrZXlzID0gW107XFxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcXG4gICAgICBrZXlzLnB1c2goa2V5KTtcXG4gICAgfVxcbiAgICBrZXlzLnJldmVyc2UoKTtcXG5cXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XFxuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XFxuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcXG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XFxuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XFxuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xcbiAgICAgICAgICByZXR1cm4gbmV4dDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXFxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xcbiAgICAgIHJldHVybiBuZXh0O1xcbiAgICB9O1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xcbiAgICBpZiAoaXRlcmFibGUpIHtcXG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XFxuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XFxuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXFxcImZ1bmN0aW9uXFxcIikge1xcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcXG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XFxuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XFxuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xcbiAgfVxcbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XFxuXFxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XFxuICB9XFxuXFxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcXG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXFxuXFxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XFxuICAgICAgdGhpcy5wcmV2ID0gMDtcXG4gICAgICB0aGlzLm5leHQgPSAwO1xcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXFxuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xcblxcbiAgICAgIHRoaXMubWV0aG9kID0gXFxcIm5leHRcXFwiO1xcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xcblxcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xcblxcbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XFxuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XFxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXFxcInRcXFwiICYmXFxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XFxuXFxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcXG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xcbiAgICB9LFxcblxcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XFxuICAgICAgaWYgKHRoaXMuZG9uZSkge1xcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XFxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XFxuICAgICAgICByZWNvcmQudHlwZSA9IFxcXCJ0aHJvd1xcXCI7XFxuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xcblxcbiAgICAgICAgaWYgKGNhdWdodCkge1xcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcXG5cXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFxcXCJyb290XFxcIikge1xcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcXFwiZW5kXFxcIik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXFxcImNhdGNoTG9jXFxcIik7XFxuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFxcXCJmaW5hbGx5TG9jXFxcIik7XFxuXFxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XFxcIik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXFxcImZpbmFsbHlMb2NcXFwiKSAmJlxcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcXG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxcbiAgICAgICAgICAodHlwZSA9PT0gXFxcImJyZWFrXFxcIiB8fFxcbiAgICAgICAgICAgdHlwZSA9PT0gXFxcImNvbnRpbnVlXFxcIikgJiZcXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XFxuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXFxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXFxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcXG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XFxuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcXG5cXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XFxuICAgICAgICB0aGlzLm1ldGhvZCA9IFxcXCJuZXh0XFxcIjtcXG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XFxuICAgIH0sXFxuXFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XFxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcXFwidGhyb3dcXFwiKSB7XFxuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJicmVha1xcXCIgfHxcXG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFxcXCJjb250aW51ZVxcXCIpIHtcXG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XFxuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXFxcInJldHVyblxcXCIpIHtcXG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcXG4gICAgICAgIHRoaXMubWV0aG9kID0gXFxcInJldHVyblxcXCI7XFxuICAgICAgICB0aGlzLm5leHQgPSBcXFwiZW5kXFxcIjtcXG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcXFwibm9ybWFsXFxcIiAmJiBhZnRlckxvYykge1xcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICB9LFxcblxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XFxuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcXG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XFxuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgXFxcImNhdGNoXFxcIjogZnVuY3Rpb24odHJ5TG9jKSB7XFxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XFxuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFxcXCJ0aHJvd1xcXCIpIHtcXG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcXG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXFxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcXFwiKTtcXG4gICAgfSxcXG5cXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcXG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xcbiAgICAgIH07XFxuXFxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcXFwibmV4dFxcXCIpIHtcXG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXFxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XFxuICAgIH1cXG4gIH07XFxufSkoXFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xcbiAgLy8gRnVuY3Rpb24gY29uc3RydWN0b3IgaWYgd2UncmUgaW4gZ2xvYmFsIHN0cmljdCBtb2RlLiBUaGF0IGlzIHNhZGx5IGEgZm9ybVxcbiAgLy8gb2YgaW5kaXJlY3QgZXZhbCB3aGljaCB2aW9sYXRlcyBDb250ZW50IFNlY3VyaXR5IFBvbGljeS5cXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcXFwicmV0dXJuIHRoaXNcXFwiKSgpXFxuKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4uL2lvdGEtcGljby1wb3ctd2ViZ2wvbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vZGlzdC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9kaXN0L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiZnVuY3Rpb24gX19leHBvcnQobSkge1xcbiAgZm9yICh2YXIgcCBpbiBtKSB7XFxuICAgIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XFxuICB9XFxufVxcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcXFwiX19lc01vZHVsZVxcXCIsIHtcXG4gIHZhbHVlOiB0cnVlXFxufSk7XFxuLyoqXFxyXFxuICogQ29tYmluZWQgaW5kZXggb2YgYWxsIHRoZSBtb2R1bGVzLlxcclxcbiAqL1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vY29yZSAqLyBcXFwiLi4vaW90YS1waWNvLWNvcmUvZGlzdC9pbmRleC5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2RhdGEgKi8gXFxcIi4uL2lvdGEtcGljby1kYXRhL2Rpc3QvaW5kZXguanNcXFwiKSk7XFxuXFxuX19leHBvcnQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGlvdGEtcGljby9hcGkgKi8gXFxcIi4uL2lvdGEtcGljby1hcGkvZGlzdC9pbmRleC5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL2NyeXB0byAqLyBcXFwiLi4vaW90YS1waWNvLWNyeXB0by9kaXN0L2luZGV4LmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vYnVzaW5lc3MgKi8gXFxcIi4uL2lvdGEtcGljby1idXNpbmVzcy9kaXN0L2luZGV4LmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vcGFsLWJyb3dzZXIgKi8gXFxcIi4uL2lvdGEtcGljby1wYWwtYnJvd3Nlci9kaXN0L2luZGV4LmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vcG93LWJveCAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy1ib3gvZGlzdC9pbmRleC5qc1xcXCIpKTtcXG5cXG5fX2V4cG9ydChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAaW90YS1waWNvL3Bvdy1qcyAqLyBcXFwiLi4vaW90YS1waWNvLXBvdy1qcy9kaXN0L2luZGV4LmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vcG93LXdhc20gKi8gXFxcIi4uL2lvdGEtcGljby1wb3ctd2FzbS9kaXN0L2luZGV4LmpzXFxcIikpO1xcblxcbl9fZXhwb3J0KF9fd2VicGFja19yZXF1aXJlX18oLyohIEBpb3RhLXBpY28vcG93LXdlYmdsICovIFxcXCIuLi9pb3RhLXBpY28tcG93LXdlYmdsL2Rpc3QvaW5kZXguanNcXFwiKSk7XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC8uL2Rpc3QvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrL2VtcHR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbW9jay9lbXB0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL21vY2svZW1wdHkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xcclxcblxcdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xcclxcblxcdFxcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xcclxcblxcdFxcdG1vZHVsZS5wYXRocyA9IFtdO1xcclxcblxcdFxcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxcclxcblxcdFxcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcXHJcXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcXFwibG9hZGVkXFxcIiwge1xcclxcblxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxyXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbigpIHtcXHJcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbW9kdWxlLmw7XFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH0pO1xcclxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFxcXCJpZFxcXCIsIHtcXHJcXG5cXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcclxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24oKSB7XFxyXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1vZHVsZS5pO1xcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9KTtcXHJcXG5cXHRcXHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcXHJcXG5cXHR9XFxyXFxuXFx0cmV0dXJuIG1vZHVsZTtcXHJcXG59O1xcclxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLyU1Qm9iamVjdF9PYmplY3QlNUQvKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wa2cvYm9vdHN0cmFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BrZy9ib290c3RyYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV2YWwoXCJleHBvcnRzLmRlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kaXN0L2luZGV4ICovIFxcXCIuL2Rpc3QvaW5kZXguanNcXFwiKTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8lNUJvYmplY3RfT2JqZWN0JTVELy4vcGtnL2Jvb3RzdHJhcC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImJpZy1pbnRlZ2VyXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogZXh0ZXJuYWwge1wiYW1kXCI6XCJiaWctaW50ZWdlclwiLFwiY29tbW9uanNcIjpcImJpZy1pbnRlZ2VyXCIsXCJjb21tb25qczJcIjpcImJpZy1pbnRlZ2VyXCIsXCJyb290XCI6XCJiaWdJbnRcIn0gKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5ldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2JpZ19pbnRlZ2VyX187XFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vJTVCb2JqZWN0X09iamVjdCU1RC9leHRlcm5hbF8lN0IlMjJhbWQlMjI6JTIyYmlnLWludGVnZXIlMjIsJTIyY29tbW9uanMlMjI6JTIyYmlnLWludGVnZXIlMjIsJTIyY29tbW9uanMyJTIyOiUyMmJpZy1pbnRlZ2VyJTIyLCUyMnJvb3QlMjI6JTIyYmlnSW50JTIyJTdEP1wiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSlbXCJkZWZhdWx0XCJdO1xufSk7IiwidmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcclxuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gSW1wb3J0IHRoZSBhbGwtaW4tb25lIGxpYnJhcnlcclxuY29uc3QgSW90YVBpY28gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBpb3RhLXBpY28vbGliLWJyb3dzZXJcIikpO1xyXG4oYXN5bmMgZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gQ3JlYXRlIGFuIGVuZCBwb2ludCB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBub2RlXHJcbiAgICBjb25zdCBuZXR3b3JrRW5kcG9pbnQgPSBuZXcgSW90YVBpY28uTmV0d29ya0VuZFBvaW50KFwiaHR0cHNcIiwgXCJub2Rlcy50aGV0YW5nbGUub3JnXCIsIDQ0Myk7XHJcbiAgICAvLyBDcmVhdGUgYSBuZXR3b3JrIGNsaWVudCBmcm9tIHRoZSBQQUxcclxuICAgIGNvbnN0IG5ldHdvcmtDbGllbnQgPSBuZXcgSW90YVBpY28uTmV0d29ya0NsaWVudChuZXR3b3JrRW5kcG9pbnQpO1xyXG4gICAgLy8gQ3JlYXRlIGFuIEFQSSBjbGllbnQgdXNpbmcgdGhlIG5ldHdvcmsgY2xpZW50IGFuZCB0aGUgQVBJIHZlcnNpb25cclxuICAgIGNvbnN0IGFwaUNsaWVudCA9IG5ldyBJb3RhUGljby5BcGlDbGllbnQobmV0d29ya0NsaWVudCwgXCIxXCIpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyBNYWtlIHRoZSBjYWxsIHRvIHRoZSBBUElcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5nZXROb2RlSW5mbygpO1xyXG4gICAgICAgIC8vIEFuZCBsb2cgdGhlIHJlc3BvbnNlXHJcbiAgICAgICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UsIHVuZGVmaW5lZCwgXCJcXHRcIikpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgIC8vIE9yIGxvZyBhbiBlcnJvciBpZiBpdCBmYWlsZWRcclxuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICB9XHJcbn0pKCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVoyVjBUbTlrWlVsdVptOHVhbk1pTENKemIzVnlZMlZTYjI5MElqb2lJaXdpYzI5MWNtTmxjeUk2V3lKblpYUk9iMlJsU1c1bWJ5NTBjeUpkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096dEJRVUZCTEdkRFFVRm5RenRCUVVOb1F5eHBSVUZCYlVRN1FVRkZia1FzUTBGQlF5eExRVUZMTzBsQlEwWXNiVVJCUVcxRU8wbEJRMjVFTEUxQlFVMHNaVUZCWlN4SFFVRkhMRWxCUVVrc1VVRkJVU3hEUVVGRExHVkJRV1VzUTBGQlF5eFBRVUZQTEVWQlFVVXNjVUpCUVhGQ0xFVkJRVVVzUjBGQlJ5eERRVUZETEVOQlFVTTdTVUZGTVVZc2RVTkJRWFZETzBsQlEzWkRMRTFCUVUwc1lVRkJZU3hIUVVGSExFbEJRVWtzVVVGQlVTeERRVUZETEdGQlFXRXNRMEZCUXl4bFFVRmxMRU5CUVVNc1EwRkJRenRKUVVWc1JTeHZSVUZCYjBVN1NVRkRjRVVzVFVGQlRTeFRRVUZUTEVkQlFVY3NTVUZCU1N4UlFVRlJMRU5CUVVNc1UwRkJVeXhEUVVGRExHRkJRV0VzUlVGQlJTeEhRVUZITEVOQlFVTXNRMEZCUXp0SlFVVTNSQ3hKUVVGSkxFTkJRVU03VVVGRFJDd3lRa0ZCTWtJN1VVRkRNMElzVFVGQlRTeFJRVUZSTEVkQlFVY3NUVUZCVFN4VFFVRlRMRU5CUVVNc1YwRkJWeXhGUVVGRkxFTkJRVU03VVVGRkwwTXNkVUpCUVhWQ08xRkJRM1pDTEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1NVRkJTU3hEUVVGRExGTkJRVk1zUTBGQlF5eFJRVUZSTEVWQlFVVXNVMEZCVXl4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRExFTkJRVU03U1VGRE0wUXNRMEZCUXp0SlFVRkRMRXRCUVVzc1EwRkJRU3hEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETEVOQlFVTTdVVUZEVml3clFrRkJLMEk3VVVGREwwSXNUMEZCVHl4RFFVRkRMRXRCUVVzc1EwRkJReXhIUVVGSExFTkJRVU1zUTBGQlF6dEpRVU4yUWl4RFFVRkRPMEZCUTB3c1EwRkJReXhEUVVGRExFVkJRVVVzUTBGQlF5SjkiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=